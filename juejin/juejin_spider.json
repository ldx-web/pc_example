{"tag_name": "JVM", "concern_user_count": 24906, "user_id": "2119514117904295", "title": "给我1万字，也讲不清Java内存排查。1万不行来2万~.~", "mark_content": ">不羡鸳鸯不羡仙，一行代码调半天。原创：小姐姐味道（GZH ID：xjjdog），欢迎分享，转载请保留出处。\n\n本篇文章是[《Java内存故障？只是因为你不够帅！》](https://mp.weixin.qq.com/s/MAebo8x356IMlASocxPqRw) 这篇文章的续篇。上篇侧重于理论，本篇侧重于实践。对于内存问题排查来说，搞理论的痛苦，搞实践的也痛苦，没有一片清净之地。\n\nwhy？因为内存溢出是Java码农永远的伤。\n\n溢出有很多种解释，有精满自溢，有缓冲区溢出攻击，还有另外一种叫做领导的溢出。不知道什么叫作**溢出理论**，xjjdog在此普及一下。 \n\n[《领导看了会炸毛的溢出理论》](http://mp.weixin.qq.com/s?__biz=MzA4MTc4NTUxNQ==&mid=2650520353&idx=1&sn=2fd5f0eee8eaf5e2025f7b2e57609b49&chksm=8780bce5b0f735f314775b17895ebe3429c26b1197573450cdd8032bccab70428d3cca061120&scene=21#wechat_redirect)  \n\n## 内存溢出什么最重要？\n\n其实，内存溢出就像是一场交通事故。事故的发生方，就是具体的服务；事故的处理方，就是相关的程序员。其中有一个最重要的环节，就是在事故现场需要拍照取证。\n\n如果没有照片没有行车记录仪没有证据，就只能靠那张嘴，怎么说都是不可信的。\n\n**这句话很重要很重要：内存问题排查什么最重要？当然是信息收集，留下一些为我们的排查提供支持的依据。**千万不要舍本逐末，对内存问题排查本身感兴趣，那是自虐行为。\n\n有很多工具可以帮助我们定位问题，但前提是你得把它留下来。下面这篇文章是xjjdog很久之前留下来的，由于标题的缘故，你可能忽略了，但这些工具能够快速帮我们定位问题。\n\n[《将java进程转移到“解剖台”之前，法医都干了什么？》](http://mp.weixin.qq.com/s?__biz=MzA4MTc4NTUxNQ==&mid=2650520084&idx=1&sn=b2ca0a4355f83b304715f24113e155a1&chksm=8780bdd0b0f734c6cdf898f9c11e024d3c141e58fa45ddfb36aa3f320eb38b22674aabbe9432&scene=21#wechat_redirect)\n\n ![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/cc6e35f37c9643508358511f04654ef1~tplv-k3u1fbpfcp-zoom-1.image)\n```bash\nss -antp > $DUMP_DIR/ss.dump 2>&1\nnetstat -s > $DUMP_DIR/netstat-s.dump 2>&1\ntop -Hp $PID -b -n 1 -c >  $DUMP_DIR/top-$PID.dump 2>&1\nsar -n DEV 1 2 > $DUMP_DIR/sar-traffic.dump 2>&1\nlsof -p $PID > $DUMP_DIR/lsof-$PID.dump\niostat -x > $DUMP_DIR/iostat.dump 2>&1\nfree -h > $DUMP_DIR/free.dump 2>&1\njstat -gcutil $PID > $DUMP_DIR/jstat-gcutil.dump 2>&1\njstack $PID > $DUMP_DIR/jstack.dump 2>&1\njmap -histo $PID > $DUMP_DIR/jmap-histo.dump 2>&1\njmap -dump:format=b,file=$DUMP_DIR/heap.bin $PID > /dev/null  2>&1\n```\n\n## GC日志配置\n\n但并不是每次出现故障，你都在机器的身边。靠人工也不能保证实时性。所以，强烈建议你把GC日志输出的详细一些，那么出现问题的时候就舒坦一些。\n\n**实际上，这个要求在我看来是强制的。**\n\n很多同学上来就说，**我的内存溢出了**。但你和它要一些日志信息，要堆栈，要现场保存的快照。都没有。这就是纯粹来搞笑的。\n\n下面是JDK8或者以下的GC日志参数，可以看到还是很长的。\n```bash\n#!/bin/sh\nLOG_DIR=\"/tmp/logs\"\nJAVA_OPT_LOG=\" -verbose:gc\"\nJAVA_OPT_LOG=\"${JAVA_OPT_LOG} -XX:+PrintGCDetails\"\nJAVA_OPT_LOG=\"${JAVA_OPT_LOG} -XX:+PrintGCDateStamps\"\nJAVA_OPT_LOG=\"${JAVA_OPT_LOG} -XX:+PrintGCApplicationStoppedTime\"\nJAVA_OPT_LOG=\"${JAVA_OPT_LOG} -XX:+PrintTenuringDistribution\"\nJAVA_OPT_LOG=\"${JAVA_OPT_LOG} -Xloggc:${LOG_DIR}/gc_%p.log\"\n\nJAVA_OPT_OOM=\" -XX:+HeapDumpOnOutOfMemoryError -XX:HeapDumpPath=${LOG_DIR} -XX:ErrorFile=${LOG_DIR}/hs_error_pid%p.log \"\n\nJAVA_OPT=\"${JAVA_OPT_LOG} ${JAVA_OPT_OOM}\"\nJAVA_OPT=\"${JAVA_OPT} -XX:-OmitStackTraceInFastThrow\"\n```\n\n下面是JDK9及其以上的日志配置。可以看到它的配置方式全变了，而且不向下兼容。Java搞的这个变化还是挺蛋疼的。\n\n```bash\n#!/bin/sh\n\nLOG_DIR=\"/tmp/logs\"\nJAVA_OPT_LOG=\" -verbose:gc\"\nJAVA_OPT_LOG=\"${JAVA_OPT_LOG} -Xlog:gc,gc+ref=debug,gc+heap=debug,gc+age=trace:file=${LOG_DIR}/gc_%p.log:tags,uptime,time,level\"\nJAVA_OPT_LOG=\"${JAVA_OPT_LOG} -Xlog:safepoint:file=${LOG_DIR}/safepoint_%p.log:tags,uptime,time,level\"\n\nJAVA_OPT_OOM=\" -XX:+HeapDumpOnOutOfMemoryError -XX:HeapDumpPath=${LOG_DIR} -XX:ErrorFile=${LOG_DIR}/hs_error_pid%p.log \"\n\nJAVA_OPT=\"${JAVA_OPT_LOG} ${JAVA_OPT_OOM}\"\nJAVA_OPT=\"${JAVA_OPT} -XX:-OmitStackTraceInFastThrow\"\n\necho $JAVA_OPT\n```\n\n一旦发现了问题，就可以拿GC日志来快速定位堆内问题。但是并不是让你一行行去看，那太低效了。因为日志可能会很长很长，而且也不一定看得懂。这个时候，就可以使用一些在线工具辅助解决。我经常使用的是gceasy，下面是它的一张截图。\n\n```java\nhttp://gceasy.io\n```\n![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/bbcdde51705b45139ad798f2d9e6824a~tplv-k3u1fbpfcp-zoom-1.image)\n\n\n有了GC日志还不行，因为它仅仅是记录了堆空间的一些变化，至于操作系统的一些资源变动，它是无从知晓的。所以，如果你有一个监控系统的话，在寻找问题的时候也能帮到忙。从下图可以看到系统资源的一些变动。\n\n![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8db7dcb4956e4b459823309275471394~tplv-k3u1fbpfcp-zoom-1.image)\n\n## 溢出示例\n\n### 堆溢出\n代码。\n![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1b2f4b1c83064fa1b240453af9f9351a~tplv-k3u1fbpfcp-zoom-1.image)\n\n日志。\n```bash\njava -Xmx20m -Xmn4m -XX:+HeapDumpOnOutOfMemoryError - OOMTest\n[18.386s][info][gc] GC(10) Concurrent Mark 5.435ms\n[18.395s][info][gc] GC(12) Pause Full (Allocation Failure) 18M->18M(19M) 10.572ms\n[18.400s][info][gc] GC(13) Pause Full (Allocation Failure) 18M->18M(19M) 5.348ms\nException in thread \"main\" java.lang.OutOfMemoryError: Java heap space\n    at OldOOM.main(OldOOM.java:20)\n```\n\njvisualvm的反应。\n![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a6f3346b132c4303807e7147c697da78~tplv-k3u1fbpfcp-zoom-1.image)\n\n### 元空间溢出\n\n代码。\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7991e5859ee34c099b42bb443dc8fcdb~tplv-k3u1fbpfcp-zoom-1.image)\n\n日志。\n```bash\njava -Xmx20m -Xmn4m -XX:+HeapDumpOnOutOfMemoryError -XX:MetaspaceSize=16M -XX:MaxMetaspaceSize=16M MetaspaceOOMTest\n6.556s][info][gc] GC(30) Concurrent Cycle 46.668ms\njava.lang.OutOfMemoryError: Metaspace\nDumping heap to /tmp/logs/java_pid36723.hprof ..\n```\n\njvisualvm的反应。\n![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/fc8be3ced1484c1692ceba1c3046aad4~tplv-k3u1fbpfcp-zoom-1.image)\n\n### 直接内存溢出\n代码。\n![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/eb8aedb0537e4efd93dae55feca1932f~tplv-k3u1fbpfcp-zoom-1.image)\n\n日志。\n```bash\njava -XX:MaxDirectMemorySize=10M -Xmx10M OffHeapOOMTest\nException in thread \"Thread-2\" java.lang.OutOfMemoryError: Direct buffer memory\n    at java.nio.Bits.reserveMemory(Bits.java:694)\n    at java.nio.DirectByteBuffer.<init>(DirectByteBuffer.java:123)\n    at java.nio.ByteBuffer.allocateDirect(ByteBuffer.java:311)\n    at OffHeapOOMTest.oom(OffHeapOOMTest.java:27)...\n```\n\n### 栈溢出\n代码。\n![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3bc8ef7276004c59a874648cb39235ce~tplv-k3u1fbpfcp-zoom-1.image)\n\n日志。\n```bash\njava -Xss128K StackOverflowTest\nException in thread \"main\" java.lang.StackOverflowError\n    at java.io.PrintStream.write(PrintStream.java:526)\n    at java.io.PrintStream.print(PrintStream.java:597)\n    at java.io.PrintStream.println(PrintStream.java:736)\n    at StackOverflowTest.a(StackOverflowTest.java:5)\n```\n\n## 哪些代码容易出现问题\n\n### 忘记重写hashCode和equals\n看下面的代码。由于没有重写Key类的hashCode和equals方法。造成了放入HashMap的所有对象，都无法被取出来。它们和外界失联了。\n![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7881a878006941be999f420fca9b3fdc~tplv-k3u1fbpfcp-zoom-1.image)\n\n下面这篇文章详细的描述了它的原理。\n[架构师写的BUG，非比寻常](https://mp.weixin.qq.com/s/BBJKJXE7dFaGn5n7BAwHTQ)\n\n### 结果集失控\n\n![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7b60b4270f224181bf7ea3db3339a88c~tplv-k3u1fbpfcp-zoom-1.image)\n不要觉得这段代码可笑。在实际工作中的review中，xjjdog不止一次发现这种蛋疼的代码。这有可能是赶工期，也有可能是刚学会写Java。这行代码有很大的可能性踩坑。\n\n### 条件失控 \n\n代码。与之类似的就是条件失控，当某个条件不满足的时候，将会造成结果集的失控。大家可以看下面的代码，fullname 和 other为空的时候，会出现什么后果？\n![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/108c139ca5884e709dc7422b303cd2c1~tplv-k3u1fbpfcp-zoom-1.image)\n\n### 万能参数\n\n还有的同学使用各种Object和HashMap来进行信息交换。这种代码正常运行的时候没什么问题，但一旦出错，几乎无法排查。排查参数、排查堆栈、排查调用链，全部失效。\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6f51617854534cbea386a6e895fb2bdc~tplv-k3u1fbpfcp-zoom-1.image)\n\n\n### 一些预防的措施\n\n- 减少创建大对象的频率：比如byte数组的传递\n- 不要缓存太多的堆内数据：使用guava的weak引用模式\n- 查询的范围一定要可控：如分库分表中间件；ES等有同样问题\n- 用完的资源一定要close掉：可以使用新的 try-with-resources语法\n- 少用intern：字符串太长，且无法复用，就会造成内存泄漏\n- 合理的Session超时时间\n- 少用第三方本地代码，使用Java方案替代\n- 合理的池大小\n- XML（SAX/DOM）、JSON解析要注意对象大小\n \n## 案例分析一\n\n这是最常见的一种情况。了解了这种方式，能够应对大多数内存溢出和内存泄漏问题。\n\n### 现象\n\n- 环境：CentOS7，JDK1.8，SpringBoot\n- G1垃圾回收器\n- 刚启动没什么问题，慢慢放量后，发生了OOM\n- 系统自动生成了heapdump文件\n-  临时解决方式：重启，但问题依然发现\n\n### 信息收集\n\n- 日志：GC的日志信息： 内存突增突降，变动迅速\n-  堆栈：Thread Dump文件：大部分阻塞在某个方法上\n- 压测：使用wrk进行压测，发现20个用户并发，内存溢出\n\n```bash\nwrk -t20 -c20 -d300s http://127.0.0.1:8084/api/test\n```\n\n### MAT分析\n\n堆栈文件获取：\n\n```bash\njmap -dump:format=b,file=heap.bin 37340\njhsdb jmap  --binaryheap --pid  37340\n```\n\nMAT工具是基于eclipse平台开发的，本身是一个Java程序。分析Heap Dump文件：发现内存创建了大量的报表对象。\n![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7687b006508d4a3ca3991a87ed2fd00c~tplv-k3u1fbpfcp-zoom-1.image)\n\n通过菜单Find Leaks，一键找出黑李逵。\n\n![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4717bfa8b9df454bbc1a578df451446c~tplv-k3u1fbpfcp-zoom-1.image)\n根据提示向下挖就可以。\n\n### 解决\n\n分析结果：\n- 系统存在大数据量查询服务，并在内存做合并\n- 当并发量达到一定程度，会有大量数据堆积到内存进行运算\n\n解决方式：\n- 重构查询服务，减少查询的字段\n- 使用SQL查询代替内存拼接，避免对结果集的操作\n- 举例：查找两个列表的交集\n\n## 案例分析二\n\n### 现象\n\n- 环境：CentOS7，JDK1.8，JBoss\n- CMS垃圾回收器\n- 操作系统CPU资源耗尽\n- 访问任何接口，响应都非常的慢\n\n### 分析\n\n- 发现每次GC的效果都特别好，但是非常频繁\n- 了解到使用了堆内缓存，而且设置的容量比较大\n- 缓存填充的速度特别快！\n\n结论：\n- 开了非常大的缓存，GC之后迅速占满，造成GC频繁\n\n## 案例分析三\n\n### 现象\n\n- java进程异常退出\n- java进程直接消失\n- 没有留下dump文件\n- GC日志正常\n- 监控发现死亡时，堆内内存占用很少，堆内仍有大量剩余空间\n\n### 分析\n\n- XX:+HeapDumpOnOutOfMemoryError不起作用\n- 监控发现操作系统内存持续增加\n\n下面这些情况都会造成程序退出而没什么响应。\n\n- 被操作系统杀死 dmesg oom-killer\n- System.exit()\n- java  com.cn.AA & 后终端关闭\n- kill -9\n\n### 解决\n\n发现：\n- 在dmesg命令中发现确实被oom-kill\n\n解决：\n- 给JVM少分配一些内存，腾出空间给其他进程\n\n## 案例分析四\n\n请参见堆外内存排查这篇文章。\n[《Java堆外内存排查小结》](https://mp.weixin.qq.com/s/p0cQeDLm3A-C0gGQ3aBp1Q) \n\n\n## End\n\n![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5e98d5708e0d452dbf0d6ae757cc02e9~tplv-k3u1fbpfcp-zoom-1.image)\n\n最后，还是以下面这张图作为小结。实践知识永远逃不出理论的支持，没有了实践的巩固理论也就变成没有灵魂的躯体。Java内存问题永远都逃不出下面这张图，就像计算机永远都逃不出0和1。\n\n>作者简介：**小姐姐味道**  (xjjdog)，一个不允许程序员走弯路的gzh。聚焦基础架构和Linux。十年架构，日百亿流量，与你探讨高并发世界，给你不一样的味道。", "user_name": "小姐姐味道", "description": "不羡鸳鸯不羡仙，一行代码调半天", "got_view_count": 538098, "category_name": "后端", "ctime": 1457483880}
{"tag_name": "React.js", "concern_user_count": 199177, "user_id": "1714893872433928", "title": "（上）手摸手教你大厂都在用 React+TS+Antd 快速入门到NodeJS全栈项目实战（附源码）", "mark_content": "# 前言\n\n> 最近这段时间忙着公司项目和带娃，发表技术文章就被搁置了半个月之久。为了答谢读者和我的粉丝们，趁着周末完成了一个小Dome项目，前端技术用到 <span style=\"color:red\">React全家桶 + TypeScript + Antd</span>。恶补了一下相关知识点，就迫不及待的想着分享出来。其实自己很久都没用过的 React.js 前端框架，大厂必备面试必问，作为前端三大主流框架之一，也是最流行的，因为它的设计很优秀。之前作者一直都在用 Vue.js 框架，是最火的一门前端框架，它是中国人开发的，对我们来说，文档要友好一些，上手更快。💪\n\n基于 Vue.js 前端框架开发的开源项目如下：\n* [NodeJS全栈开发一个功能完善的Express项目(附完整源码)](https://juejin.im/post/6844904198551666701)\n* [Nodejs全栈进阶-Vue+Express+Webpack自建脚手架完善单页应用，档次瞬间提高（附完整源码）](https://juejin.im/post/6847902224073523208)\n* [Vue+Echarts构建大数据可视化酷炫展示公司品牌实战项目分享（附源码）](https://juejin.im/post/6845166890449371149)\n\n# React 是什么？\n\n## 介绍\n\n* React 是一个用于构建用户界面的 JAVASCRIPT 库；\n* React 主要用于构建UI，很多人认为 React 是 MVC 中的 V（视图）；\n* React 起源于 Facebook 的内部项目，用来架设 Instagram 的网站，并于2013年 5月开源；\n* React 拥有较高的性能，代码逻辑非常简单，越来越多的人已开始关注和使用它。\n\n## 特点\n\n1. <span style=\"color:red\">声明式设计</span> - React 采用声明范式，可以轻松描述应用；\n2. <span style=\"color:red\">高效</span> - React 通过对 DOM 的模拟，最大限度地减少与 DOM 的交互；\n3. <span style=\"color:red\">灵活</span> - React 可以与已知的库或框架很好地配合；\n4. <span style=\"color:red\">JSX</span> - JSX 是 JavaScript 语法的扩展，React 开发不一定使用 JSX ，但我们建议使用它；\n5. <span style=\"color:red\">组件化</span> - 通过 React 构建组件，使得代码更加容易得到复用，能够很好的应用在大项目的开发中；\n6. <span style=\"color:red\">单向响应的数据流</span> − React 实现了单向响应的数据流，从而减少了重复代码，这也是它为什么比传统数据绑定更简单。\n\n## 缺点\n\n* 对于一直使用 JS，jQuery 的传统前端，React 非常不友好；\n* React 强调组件和状态管理，其世界观是面向程序语言的；\n* Vue.js 强调视图的自动同步，其世界观是面向UI脚本的；\n* React 的学习成本较 Vue.js 高；\n* React 本身没有全家桶，只做UI界面。\n\n## 为什么要用 React ？\n\n* 和其他框架相比，React 设计很优秀，一切基于 JavaScript 并且实现了组件化开发的思想；\n* 开发团队实力强悍，不必担心不更新的情况；\n* 强大的社区支持，很多问题都能找到对应的解决方案；\n* 提高工作效率，虚拟 DOM 操作，组件可复用，有效使用开发工具；\n* 受到大厂的信赖，前端项目的技术选型采用的是 React.js；\n* 提供了无缝切换到 React Native 上的移动端开发体验，让我们的技术能力得到了拓展，增强了我们的核心竞争力。\n\nReact的设计思想及其独特，属于革命性创新，性能出众，代码逻辑却非常简单。所以，越来越多的人开始关注和使用，认为它可能是将来WEB开发的主流工具。😋\n\n# 理解几个核心概念👍\n\n## 虚拟 DOM（Virtual Document Object Model）\n\n* DOM 的本质是什么：浏览器中的概念，用JS对象来表示页面上的元素，并提供了操作 DOM 对象的 API；\n* 什么是 React 中的虚拟 DOM：是框架中的概念，是程序猿用JS对象来模拟页面上的 DOM 元素和嵌套关系（<span style=\"color:red\">虚拟 DOM是以JS对象的形式存在</span>）；\n* 为什么要实现虚拟 DOM：为了实现页面中，DOM 元素的高效更新。\n\n## Diff 算法\n\n* <span style=\"color:red\">Tree Diff</span> - 新旧两棵 DOM 树，逐层对比的过程，就是 Tree Diff。当整棵 DOM 树逐层对比完毕，则所有需要被按需更新的元素，必然能够找到；\n* <span style=\"color:red\">Component Diff</span> - 在进行 Tree Diff 的时候，每一层中，组件级别的对比，叫做 Component Diff。如果对比前后，组件的类型相同，则暂时认为此组件不需要被更新。如果对比前后，组件类型不同，则需要移除旧组件，创建新组件，并追加到页面上；\n* <span style=\"color:red\">Element Diff</span> - 在进行组件对比的时候，如果两个组件类型相同，则需要进行元素级别的对比，这叫做 Element Diff。 \n\n## 生命周期函数\n\n1）<span style=\"color:red\">组件创建阶段</span>：一辈子只执行一次\n\n* componentWillMount：组件将要被挂载；\n\n* render：第一次开始渲染真正的虚拟DOM，当render执行完。内存中就有完整的虚拟DOM了；\n\n* componentDidMount：组件完成挂载，此时组件已经显示在页面上。\n\n2）<span style=\"color:red\">组件运行阶段</span>：按需根据props属性或state状态的改变，有选择性的执行0次到多次\n\n* componentWillReceiveProps：组件将要接受新的属性；\n\n* shouldComponentUpdate：组件是否需要进行更新。此时，组件尚未被更新；\n\n* componentWillUpdate：组件将要被更新；\n\n* render：根据新的state和props重新的渲染内存中的虚拟DOM数；\n\n* componentDidUpdate：此时页面被重新渲染。\n\n3）<span style=\"color:red\">组件销毁阶段</span>：一辈子只执行一次\n\n* componentWillUnmount：组件将要被卸载的时候。\n\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b6ab18a3b77b44369737ddbd846969a1~tplv-k3u1fbpfcp-zoom-1.image)\n\n## 高阶组件\n\n高阶组件（HOC）是 React 中用于复用组件逻辑的一种高级技巧。HOC 自身不是 React API 的一部分，它是一种基于 React 的组合特性而形成的设计模式。\n\n具体而言，高阶组件是参数为组件，返回值为新组件的函数。\n\n组件是将 props 转换为 UI，而高阶组件是将组件转换为另一个组件。\n\n## 状态state和属性props的区别\n\n* 从来源上来看，状态是组件内部创建并维持的，属性虽然也可以在组件内创建，但一般是从父组件传递过来;\n* 属性可以由父组件修改，状态不能;\n* 父组件能设置子组件的属性初始值，状态不行;\n* 状态只能在组件内部更新，属性除非外部组件主动传来新的props否则永远保持不变。\n\n\n以上内容是对React的初步认识，如需详细学习可以移步到React官网[https://reactjs.org/](https://reactjs.org/)\n\n# TypeScript 是什么？\n\n## 介绍\n\n* TypeScript 是 JavaScript 类型的超集，支持 ECMAScript 6 标准；\n* TypeScript 由微软开发的自由和开源的编程语言；\n* TypeScript 设计目标是开发大型应用，它可以编译成纯 JavaScript，编译出来的 JavaScript 可以运行在任何浏览器、任何计算机和任何操作系统上。\n\n## 语言特性\n\n* 类型批注和编译时类型检查\n* 类型推断\n* 类型擦除\n* 接口\n* 枚举\n* Mixin\n* 泛型编程\n* 名字空间\n* 元组\n* async / await\n* 类\n* 模块\n* 箭头函数表达式\n* 可选参数和默认参数\n\n## 为什么要用 TypeScript？\n\n* 增加了代码的可读性和可维护性，增加了编辑器和IDE的功能；\n* 拥有活跃的社区，拥抱 ES6 规范；\n* TypeScript 非常包容，后缀 .js 文件可以直接重命名 .ts 即可。\n\n## 缺点\n\n* 有一定的学习成本，需要理解接口（Interfaces）、泛型（Generics）、类（Classes）、枚举类型（Enums）等前端工程师可能不是很熟悉的概念；\n* 短期可能会增加一些开发成本，毕竟要多写一些类型的定义，不过对于一个需要长期维护的项目，TypeScript 能够减少其维护成本；\n* 集成到构建流程需要一些工作量；\n* 可能和一些库结合的不是很完美。\n\n上述内容是对 TypeScript 的初步认识，如需详细学习可以移步到TypeScript官网[https://www.typescriptlang.org/](https://www.typescriptlang.org/)\n\n另外推荐学习 [TypeScript 入门教程](https://ts.xcatliu.com/)\n\n# Ant Design of React （简称 antd）\n\n## 介绍\n\nantd 是基于 [Ant Design](https://ant.design/docs/react/introduce-cn) 设计体系的 React UI 组件库，主要用于研发企业级中后台产品。\n\n## 特性\n\n* 🌈 提炼自企业级中后台产品的交互语言和视觉风格。\n* 📦 开箱即用的高质量 React 组件。\n* 🌀 使用 TypeScript 开发，提供完整的类型定义文件。\n* ⚙️ 全链路开发和设计工具体系。\n* 🌍 数十个国际化语言支持。\n* 🎨 深入每个细节的主题定制能力。\n\n# 前后端分离\n\n前端项目采用的技术栈是基于`React全家桶 + TS + Antd`，用`create-react-app`官方脚手架构建的前端界面，后端项目采用的技术栈是基于`Node.js + Express + MySQL`，用Express搭建的后端服务器。\n\n在线演示DEMO地址👉：[http://106.55.168.13:9000/](http://106.55.168.13:9000/)\n\n如果觉得还不错的话，就请给个👍和❤️收藏，您们的点赞是作者继续创作的动力。\n\n# 部分效果截图\n\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2ef511287b0441d68787c60d9d0f8a92~tplv-k3u1fbpfcp-zoom-1.image)\n\n![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c5e5af7c493441d3b44d873be743079a~tplv-k3u1fbpfcp-zoom-1.image)\n\n![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/903c1f02f12a44a696449e215f125e99~tplv-k3u1fbpfcp-zoom-1.image)\n\n![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8fdc9c6390874c5985ab9d7c9de3bd1f~tplv-k3u1fbpfcp-zoom-1.image)\n\n![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2baeb7a255da4147a56da9c603e28892~tplv-k3u1fbpfcp-zoom-1.image)\n\n\n# 目录结构\n\n```javascript\n│  .gitignore                 // git忽略配置\n│  config-overrides.js        // webpack自定义配置\n│  package.json               // npm包管理所需模块及配置信息\n│  paths.json                 // src路径配置\n│  tsconfig.json              // typescript配置\n│  yarn.lock                  // 自动锁定安装包版本       \n├─public\n│      favicon.ico            // 图标\n│      index.html             // 入口html文件          \n└─src\n    │  App.tsx                // 路由组件 \n    │  declaration.d.ts       // 依赖声明文件\n    │  index.tsx              // 入口主文件\n    │  react-app-env.d.ts     // 声明文件\n    ├─assets                  // 存放公共图片\n    ├─components              // 公共组件 \n    │      404.tsx            // 错误页面\n    │      Footer.tsx         // 底部模板组件\n    │      Header.tsx         // 头部模板组件\n    ├─router\n    │      config.js          // 项目路由配置 \n    │      index.js           // 单页面路由注册组件\n    │      permissionAuth.js  // 登录权限控制组件\n    ├─store                   // 全局store状态管理\n    │  │  actionTypes.js      // 拆分actionType的类型定义常量\n    │  │  index.js            // 创建store管理仓库  \n    │  ├─actions              // 拆分action，将它封装到一个函数里面去管理\n    │  │      auth.js         // 权限action单独管理\n    │  │      index.js        // 合并多个不同action，统一对外输出\n    │  │      user.js         // 用户action单独管理\n    │  └─reducers             // 创建reducer，更新state数据操作\n    │          index.js       // 合并多个不同reducer，统一对外输出\n    │          user.js        // 创建用户reducer，更新state数据操作\n    ├─styles\n    │      base.less           // 基础样式  \n    │      footer.less         // 底部样式\n    │      header.less         // 头部样式\n    │      home.less           // 首页样式\n    │      login.less          // 登录样式\n    ├─utils\n    │      api.js              // 统一封装API接口调用方法\n    │      network.js          // axios封装与拦截器配置\n    │      url.js              // 自动部署服务器环境\n    │      valid.js            // 统一封装公用模块方法\n    └─views\n            Home.tsx           // 首页\n            Login.tsx          // 登录页面\n```\n\n# 前端部分\n\n## 技术栈\n\n* create-react-app\n* React v16.13\n* react-router-dom v5.2\n* redux v4.0\n* react-redux v7.2\n* react-thunk v2.3\n* typescript v3.7\n* antd v4.5\n* axios v0.19\n* react-persist v6.0\n\n## 功能模块\n\n* 登录（登出）\n* 注册\n* 记住密码\n* 忘记密码（修改密码）\n* todoList增删改查\n* 点亮红星标记\n* 查询条件筛选\n* 错误页面\n\n## 代码实现\n\n在 TypeScript 中使用 `create-react-app` 官方脚手架一步步地创建一个 TypeScript 项目，并引入 antd。\n\n### 准备工作\n\n请确保电脑上已经安装 [nodejs v10+](https://nodejs.org/en/) 或者最新版的 [yarn](https://yarnpkg.com/getting-started/install)。\n\n```js\n// 使用npm安装yarn\nnpm i yarn -g\n\n// 查看版本号\nyarn -v\n```\n\n推荐全部使用yarn安装依赖包及运行项目，保证畅通无阻，速度飞快。\n\n请将npm设置为淘宝源\n\n```js\nnpm config set registry https://registry.npm.taobao.org\nnpm config set disturl https://npm.taobao.org/dist\n```\n\n请将yarn设置为淘宝源\n\n```js\nyarn config set registry https://registry.npm.taobao.org --global\nyarn config set disturl https://npm.taobao.org/dist --global\n```\n\n### 安装和初始化\n\n使用yarn或npm创建项目\n\n```js\nnpx create-react-app react-ts-antd --typescript\nOR\nyarn create react-app react-ts-antd --template typescript\n```\n\n进入项目并启动\n\n```js\ncd react-ts-antd\nyarn start\n```\n\n此时浏览器会访问 http://localhost:3000/，看到 Welcome to React 的界面就算成功了。\n\n引入 antd 和 less 文件\n\n* 安装依赖\n\n```js\n// less-loader必须指定5.0版本\nyarn add antd less less-loader@5.0.0\n```\n\n* 在src/index.tsx文件顶部引入antd样式\n\n```js\nimport 'antd/dist/antd.less';\n```\n\n* 或者在src/base.less文件顶部引入antd样式\n\n```js\n@import '~antd/dist/antd.less';\n```\n\n* 在自定义组件中按需引入antd的相关组件，比如按钮组件\n\n```js\nimport * as React from 'react';\nimport { Button } from 'antd';\nimport 'antd/dist/antd.less';\n\nclass Custom extends React.Component {\n  <div className=\"container\">\n    <Button type=\"primary\">按钮</Button>\n  </div>\n};\n\nexport default Custom;\n```\n\n## webpack 自定义配置\n\n### 引入 react-app-rewired 和 customize-cra\n\n```js\nyarn add react-app-rewired customize-cra -D\n```\n\n### 修改package.json文件\n\n将react-scripts命令全部替换成react-app-rewired，已改代码如下：\n\n```js\n\"scripts\": {\n    \"start\": \"set BROWSER=none&& set PORT=9000&& react-app-rewired start\",\n    \"build\": \"react-app-rewired build\",\n    \"test\": \"react-app-rewired test\",\n    \"eject\": \"react-app-rewired eject\"\n  }\n```\n\n另外开发环境配置关闭浏览器自动打开以及更改默认端口号3000\n\n```js\nset BROWSER=none&& set PORT=9000&& react-app-rewired start\n```\n\n### 配置config-overrides.js文件\n\n在项目根目录下(和package.json同级)新建配置文件 config-overrides.js，并添加如下内容：\n\n```js\nconst {\n    override,\n    fixBabelImports,\n    addLessLoader,\n    addWebpackPlugin, \n    addWebpackAlias,\n    addDecoratorsLegacy,\n    overrideDevServer\n  } = require('customize-cra');\n\n  const path = require('path');\n  const webpack = require('webpack');\n  const UglifyJsPlugin = require('uglifyjs-webpack-plugin');\n  const CompressionWebpackPlugin = require('compression-webpack-plugin');\n\n  const isProduction = process.env.NODE_ENV === 'production';\n\n  function resolve (pathUrl) {\n    return path.join(__dirname, pathUrl);\n  }\n\n  const addCustomize = () => (config) => {\n    // 配置打包后的文件位置\n    // config.output.path = resolve('dist');\n    if (config.output.publicPath) {\n      config.output.publicPath = '/';\n        // isProduction ? '/react-ts-antd-admin/' : '/';\n    }\n\n    if (config.resolve) {\n      config.resolve.extensions = ['.js', '.tsx', '.less', '.css'];\n    }\n\n    // 添加js、css打包gzip配置\n    config.plugins.push(\n      new CompressionWebpackPlugin({\n        test: /\\.js$|\\.css$/,\n        threshold: 1024,\n      }),\n    )\n\n    return config;\n  };\n\n  // 设置代理\n  const devServerConfig = () => config => {\n    return {\n      ...config,\n      proxy: {\n        '/api': {\n          target: 'http://106.55.168.13:9000',\n          changeOrigin: true,\n          secure: false\n        }\n      }\n    };\n  };\n\n  // 关掉 sourceMap\n  process.env.GENERATE_SOURCEMAP = isProduction ? 'false' : 'true';\n\n  module.exports = {\n    webpack: override(\n    // 判断环境，只有在生产环境的时候才去使用这个插件\n    isProduction && addWebpackPlugin(new UglifyJsPlugin({\n      uglifyOptions: {\n        compress: {\n          drop_debugger: true,\n          drop_console: true\n        }\n      }\n    })),  \n      \n    // 配置antd按需引入\n    fixBabelImports('import', {\n      libraryName: 'antd',\n      libraryDirectory: 'es',\n      style: true, // 自动打包相关的样式\n    }),\n  \n    // 使用less-loader对源码中的less的变量进行重新指定\n    addLessLoader({\n      javascriptEnabled: true,\n      modifyVars: { '@primary-color': '#2d8cf0' },\n    }),\n  \n    // 配置路径别名\n    addWebpackAlias({\n      '@': resolve('src'),\n    }),\n    \n    // 支持装饰器\n    addDecoratorsLegacy(),\n\n    // 压缩JS等\n    addCustomize()\n  ),\n\n  // 本地启动配置，可以设置代理\n  devServer: overrideDevServer(devServerConfig())\n};\n```\n\n#### 配置 antd 按需加载组件\n\n```js\nyarn add babel-plugin-import -D\n```\n\n```js\nconst { override, fixBabelImports } = require('customize-cra');\nconst webpack = require('webpack');\n\nmodule.exports = {\n\twebpack: override(\n　　\t  fixBabelImports('import', {\n    \t\tlibraryName: 'antd',\n    \t\tlibraryDirectory: 'es',\n    \t\tstyle: true,\n\t\t})\n\t);\n}\n```\n\n#### 通过引入 customize-cra 模块中的 addLessLoader 来实现 antd 自定义主题\n\n```js\nconst { override, addLessLoader } = require('customize-cra');\nconst webpack = require('webpack');\n\n// 利用less-loader的modifyVars参数来进行主题配置\nmodule.exports = {\n\twebpack: override(\n　　\t  addLessLoader({\n        \tjavascriptEnabled: true,\n        \tmodifyVars: {}\n    \t})\n\t);\n}\n```\n\n#### 配置装饰器\n\n```js\nyarn add @babel/plugin-proposal-decorators -D\n```\n\n```js\nconst { override, addDecoratorsLegacy} = require('customize-cra');\nconst webpack = require('webpack');\n\nmodule.exports = {\n\twebpack: override(\n    \taddDecoratorsLegacy()\n\t);\n}\n```\n\n以上基本工作已准备就绪，架构搭建也已完善，下面终于要进入页面组件功能开发，心情十分鸡冻，敲代码的日子才刚刚开始。一般开发项目之前，需要先分析页面需求，有哪些功能模块（功能扩展），技术选型，有无技术难点（是否可替代），哪些组件可复用，手机适配，前端性能考虑，是否多人协作开发，与后端约定API接口规则等等。时间过得真快，周末就过完了，先写到这吧~🐶\n\n# 写在最后\n\n由于时间关系，文章写的仓促，难免会有些小问题或BUG出现，愿接受批评和指正。此次实战项目分享内容**分为上下两篇文章**。下一篇要分享的内容大概是结合实例讲解<span style=\"color:red\">React全家桶的组合使用、有状态组件和无状态组件的使用、组件间通信、封装工具函数库、前端性能优化、RESTFUL API接口开发</span>等等。\n\n> 如果小伙伴看完，感觉还不错的话，老铁们是不是来<span style=\"color:red\">github里赏个★Star</span>鼓励一哈。你们的赞和`star`是作者编写更多更精彩文章的动力！\n\ngithub地址：[https://github.com/jackchen0120/react-ts-antd](https://github.com/jackchen0120/react-ts-antd)\n\n此项目其实还有很多不足或优化的地方，也期望与大家一起交流学习。😃\n\n**推荐阅读相关优质文章**\n\n* [开发一款微信小程序的个性简历，能打开大厂之门并获得门票？（附源码）](https://juejin.im/post/5f01b5325188252e6e15095c)\n* [Vue+Echarts构建大数据可视化酷炫展示公司品牌实战项目分享（附源码）](https://juejin.im/post/5efca542f265da22c058d8ed)\n* [前端必知必会MySQL的那些事儿 - NodeJS全栈成长之路](https://juejin.im/post/5ee6010ef265da76d3188ea8)\n* [2020值得收藏与学习280多款H5小游戏，从入门到彻底了解它（附源码）](https://juejin.im/post/5ef8a8ed6fb9a07e944ed6d6)\n\n**欢迎关注作者公众号：懒人码农**\n\n![](https://user-gold-cdn.xitu.io/2020/7/5/1731eb762d539047?w=750&h=520&f=gif&s=81787)\n\n", "user_name": "懒人码农", "description": "「懒人码农」公众号作者，支持文章投稿及相互开白名单。一切技术问题，", "got_view_count": 27939, "category_name": "前端", "ctime": 1457483942}
{"tag_name": "JavaScript", "concern_user_count": 343215, "user_id": "4212984289442750", "title": "Web开发应了解的5种设计模式🍊", "mark_content": "<section id=\"nice\" data-tool=\"mdnice编辑器\" data-website=\"https://www.mdnice.com\" style=\"color: black; line-height: 1.6; word-spacing: 0px; letter-spacing: 0px; word-break: break-word; word-wrap: break-word; text-align: left; font-family: Optima-Regular, Optima, PingFangSC-light, PingFangTC-light, 'PingFang SC', Cambria, Cochin, Georgia, Times, 'Times New Roman', serif; font-size: 14px; padding: 10px;\"><h2 data-tool=\"mdnice编辑器\" style=\"margin-top: 30px; margin-bottom: 15px; padding: 0px; font-size: 22px; text-align: center; position: relative; font-weight: bold; color: black; line-height: 1.1em; padding-top: 12px; padding-bottom: 12px; margin: 70px 30px 30px; border: 1px solid #000;\"><span style=\"float: left; display: block; width: 90%; border-top: 1px solid #000; height: 1px; line-height: 1px; margin-left: -5px; margin-top: -17px;\"> </span><span class=\"prefix\" style=\"display: block; width: 3px; margin: 0 0 0 5%; height: 3px; line-height: 3px; overflow: hidden; background-color: #000; box-shadow: 3px 0 #000,\n    0 3px #000,\n    -3px 0 #000,\n    0 -3px #000;\"></span><span class=\"content\" style=\"display: block; -webkit-box-reflect: below 0em -webkit-gradient(linear,left top,left bottom, from(rgba(0,0,0,0)),to(rgba(255,255,255,0.1)));\">什么是设计模式？</span><span class=\"suffix\" style=\"display: block; width: 3px; margin: 0 0 0 95%; height: 3px; line-height: 3px; overflow: hidden; background-color: #000; box-shadow: 3px 0 #000,\n    0 3px #000,\n    -3px 0 #000,\n    0 -3px #000;\"></span><span style=\"float: right; display: block; width: 90%; border-bottom: 1px solid #000; height: 1px; line-height: 1px; margin-right: -5px; margin-top: 16px;\"> </span></h2>\n<p data-tool=\"mdnice编辑器\" style=\"padding-top: 8px; padding-bottom: 8px; margin: 0; line-height: 26px; color: black; font-size: 14px;\">设计模式是对软件设计开发过程中<strong style=\"font-weight: bold; color: black;\">反复出现的某类问题的通用解决方案</strong>。设计模式更多的是指导思想和方法论，而不是现成的代码，当然每种设计模式都有每种语言中的具体实现方式。学习设计模式更多的是理解各种模式的内在思想和解决的问题，毕竟这是前人无数经验总结成的最佳实践，而代码实现则是对加深理解的辅助。使用设计模式是为了<strong style=\"font-weight: bold; color: black;\">可重用代码、让代码更容易被他人理解、保证代码可靠性</strong>。</p>\n<p data-tool=\"mdnice编辑器\" style=\"padding-top: 8px; padding-bottom: 8px; margin: 0; line-height: 26px; color: black; font-size: 14px;\">在本文中，我将介绍其中常见的四种设计模式在JavaScript中实际使用场景：</p>\n<h2 data-tool=\"mdnice编辑器\" style=\"margin-top: 30px; margin-bottom: 15px; padding: 0px; font-size: 22px; text-align: center; position: relative; font-weight: bold; color: black; line-height: 1.1em; padding-top: 12px; padding-bottom: 12px; margin: 70px 30px 30px; border: 1px solid #000;\"><span style=\"float: left; display: block; width: 90%; border-top: 1px solid #000; height: 1px; line-height: 1px; margin-left: -5px; margin-top: -17px;\"> </span><span class=\"prefix\" style=\"display: block; width: 3px; margin: 0 0 0 5%; height: 3px; line-height: 3px; overflow: hidden; background-color: #000; box-shadow: 3px 0 #000,\n    0 3px #000,\n    -3px 0 #000,\n    0 -3px #000;\"></span><span class=\"content\" style=\"display: block; -webkit-box-reflect: below 0em -webkit-gradient(linear,left top,left bottom, from(rgba(0,0,0,0)),to(rgba(255,255,255,0.1)));\">单例设计模式</span><span class=\"suffix\" style=\"display: block; width: 3px; margin: 0 0 0 95%; height: 3px; line-height: 3px; overflow: hidden; background-color: #000; box-shadow: 3px 0 #000,\n    0 3px #000,\n    -3px 0 #000,\n    0 -3px #000;\"></span><span style=\"float: right; display: block; width: 90%; border-bottom: 1px solid #000; height: 1px; line-height: 1px; margin-right: -5px; margin-top: 16px;\"> </span></h2>\n<h3 data-tool=\"mdnice编辑器\" style=\"margin-top: 30px; margin-bottom: 15px; font-weight: bold; background-color: #000; color: #fff; padding: 2px 10px; width: fit-content; font-size: 17px; margin: 60px auto 10px;\"><span class=\"prefix\" style=\"display: none;\"></span><span class=\"content\">定义</span><span class=\"suffix\" style=\"display: none;\"></span></h3>\n<blockquote data-tool=\"mdnice编辑器\" style=\"display: block; font-size: 0.9em; overflow: auto; overflow-scrolling: touch; color: #6a737d; padding-top: 10px; padding-bottom: 10px; padding-left: 20px; padding-right: 10px; margin-bottom: 20px; margin-top: 20px; border-left: 3px solid rgba(0, 0, 0, 0.65); border-right: 1px solid rgba(0, 0, 0, 0.65); background: rgb(249, 249, 249);\">\n<p style=\"padding-top: 8px; padding-bottom: 8px; font-size: 14px; margin: 0px; color: black; line-height: 26px;\">单例模式仅允许类或对象具有单个实例，并且它使用全局变量来存储该实例。</p>\n</blockquote>\n<ul data-tool=\"mdnice编辑器\" style=\"margin-top: 8px; margin-bottom: 8px; padding-left: 25px; color: black; list-style-type: square;\">\n<li><section style=\"margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;\"><strong style=\"font-weight: bold; color: black;\">实现方法</strong>是判断是否存在该对象的实例，如果已存在则不再创建</section></li><li><section style=\"margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;\"><strong style=\"font-weight: bold; color: black;\">使用场景</strong>适用于业务场景中只能存在一个的实例，比如弹窗，购物车</section></li></ul>\n<h3 data-tool=\"mdnice编辑器\" style=\"margin-top: 30px; margin-bottom: 15px; font-weight: bold; background-color: #000; color: #fff; padding: 2px 10px; width: fit-content; font-size: 17px; margin: 60px auto 10px;\"><span class=\"prefix\" style=\"display: none;\"></span><span class=\"content\">实现</span><span class=\"suffix\" style=\"display: none;\"></span></h3>\n<p data-tool=\"mdnice编辑器\" style=\"padding-top: 8px; padding-bottom: 8px; margin: 0; line-height: 26px; color: black; font-size: 14px;\"><strong style=\"font-weight: bold; color: black;\">单例模式分为懒汉式和饿汉式:</strong></p>\n<ul data-tool=\"mdnice编辑器\" style=\"margin-top: 8px; margin-bottom: 8px; padding-left: 25px; color: black; list-style-type: square;\">\n<li><section style=\"margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;\">懒汉式</section></li></ul>\n<pre class=\"custom\" data-tool=\"mdnice编辑器\" style=\"margin-top: 10px; margin-bottom: 10px; box-shadow: rgba(170, 170, 170, 0.48) 0px 0px 6px 0px; max-width: 100%; border-radius: 4px; margin: 10px auto 0 auto;\"><code class=\"hljs\" style=\"overflow-x: auto; padding: 16px; color: #333; background: #f8f8f8; display: -webkit-box; font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; border-radius: 0px; font-size: 12px; -webkit-overflow-scrolling: touch;\"><span class=\"hljs-keyword\" style=\"color: #333; font-weight: bold; line-height: 26px;\">let</span>&nbsp;ShopCar&nbsp;=&nbsp;(<span class=\"hljs-function\" style=\"line-height: 26px;\"><span class=\"hljs-keyword\" style=\"color: #333; font-weight: bold; line-height: 26px;\">function</span>&nbsp;(<span class=\"hljs-params\" style=\"line-height: 26px;\"></span>)&nbsp;</span>{<br>&nbsp;<span class=\"hljs-keyword\" style=\"color: #333; font-weight: bold; line-height: 26px;\">let</span>&nbsp;instance;&nbsp;<br>&nbsp;<span class=\"hljs-function\" style=\"line-height: 26px;\"><span class=\"hljs-keyword\" style=\"color: #333; font-weight: bold; line-height: 26px;\">function</span>&nbsp;<span class=\"hljs-title\" style=\"color: #900; font-weight: bold; line-height: 26px;\">init</span>(<span class=\"hljs-params\" style=\"line-height: 26px;\"></span>)&nbsp;</span>{<br>&nbsp;&nbsp;&nbsp;<span class=\"hljs-comment\" style=\"color: #998; font-style: italic; line-height: 26px;\">/*这里定义单例代码*/</span><br>&nbsp;&nbsp;&nbsp;<span class=\"hljs-keyword\" style=\"color: #333; font-weight: bold; line-height: 26px;\">return</span>&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;buy(good)&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class=\"hljs-keyword\" style=\"color: #333; font-weight: bold; line-height: 26px;\">this</span>.goods.push(good);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;},<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class=\"hljs-attr\" style=\"line-height: 26px;\">goods</span>:&nbsp;[],<br>&nbsp;&nbsp;&nbsp;};<br>&nbsp;}<br>&nbsp;<span class=\"hljs-keyword\" style=\"color: #333; font-weight: bold; line-height: 26px;\">return</span>&nbsp;{<br>&nbsp;&nbsp;&nbsp;<span class=\"hljs-attr\" style=\"line-height: 26px;\">getInstance</span>:&nbsp;<span class=\"hljs-function\" style=\"line-height: 26px;\"><span class=\"hljs-keyword\" style=\"color: #333; font-weight: bold; line-height: 26px;\">function</span>&nbsp;(<span class=\"hljs-params\" style=\"line-height: 26px;\"></span>)&nbsp;</span>{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class=\"hljs-keyword\" style=\"color: #333; font-weight: bold; line-height: 26px;\">if</span>&nbsp;(!instance)&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;instance&nbsp;=&nbsp;init();<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class=\"hljs-keyword\" style=\"color: #333; font-weight: bold; line-height: 26px;\">return</span>&nbsp;instance;<br>&nbsp;&nbsp;&nbsp;},<br>&nbsp;};<br>})();<br><span class=\"hljs-keyword\" style=\"color: #333; font-weight: bold; line-height: 26px;\">let</span>&nbsp;car1&nbsp;=&nbsp;ShopCar.getInstance();<br><span class=\"hljs-keyword\" style=\"color: #333; font-weight: bold; line-height: 26px;\">let</span>&nbsp;car2&nbsp;=&nbsp;ShopCar.getInstance();<br>car1.buy(<span class=\"hljs-string\" style=\"color: #d14; line-height: 26px;\">'橘子'</span>);&nbsp;<br>car2.buy(<span class=\"hljs-string\" style=\"color: #d14; line-height: 26px;\">'苹果'</span>);&nbsp;<br><span class=\"hljs-built_in\" style=\"color: #0086b3; line-height: 26px;\">console</span>.log(car1.goods);<span class=\"hljs-comment\" style=\"color: #998; font-style: italic; line-height: 26px;\">//[&nbsp;'橘子',&nbsp;'苹果'&nbsp;]</span><br><span class=\"hljs-built_in\" style=\"color: #0086b3; line-height: 26px;\">console</span>.log(car1&nbsp;===&nbsp;car2);&nbsp;<span class=\"hljs-comment\" style=\"color: #998; font-style: italic; line-height: 26px;\">//&nbsp;true</span><br></code></pre>\n<ul data-tool=\"mdnice编辑器\" style=\"margin-top: 8px; margin-bottom: 8px; padding-left: 25px; color: black; list-style-type: square;\">\n<li><section style=\"margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;\">饿汉式</section></li></ul>\n<pre class=\"custom\" data-tool=\"mdnice编辑器\" style=\"margin-top: 10px; margin-bottom: 10px; box-shadow: rgba(170, 170, 170, 0.48) 0px 0px 6px 0px; max-width: 100%; border-radius: 4px; margin: 10px auto 0 auto;\"><code class=\"hljs\" style=\"overflow-x: auto; padding: 16px; color: #333; background: #f8f8f8; display: -webkit-box; font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; border-radius: 0px; font-size: 12px; -webkit-overflow-scrolling: touch;\"><span class=\"hljs-keyword\" style=\"color: #333; font-weight: bold; line-height: 26px;\">var</span>&nbsp;ShopCar&nbsp;=&nbsp;(<span class=\"hljs-function\" style=\"line-height: 26px;\"><span class=\"hljs-keyword\" style=\"color: #333; font-weight: bold; line-height: 26px;\">function</span>&nbsp;(<span class=\"hljs-params\" style=\"line-height: 26px;\"></span>)&nbsp;</span>{<br>&nbsp;<span class=\"hljs-keyword\" style=\"color: #333; font-weight: bold; line-height: 26px;\">var</span>&nbsp;instance&nbsp;=&nbsp;init();<br>&nbsp;<span class=\"hljs-function\" style=\"line-height: 26px;\"><span class=\"hljs-keyword\" style=\"color: #333; font-weight: bold; line-height: 26px;\">function</span>&nbsp;<span class=\"hljs-title\" style=\"color: #900; font-weight: bold; line-height: 26px;\">init</span>(<span class=\"hljs-params\" style=\"line-height: 26px;\"></span>)&nbsp;</span>{<br>&nbsp;&nbsp;&nbsp;<span class=\"hljs-comment\" style=\"color: #998; font-style: italic; line-height: 26px;\">/*这里定义单例代码*/</span><br>&nbsp;&nbsp;&nbsp;<span class=\"hljs-keyword\" style=\"color: #333; font-weight: bold; line-height: 26px;\">return</span>&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;buy(good)&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class=\"hljs-keyword\" style=\"color: #333; font-weight: bold; line-height: 26px;\">this</span>.goods.push(good);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;},<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class=\"hljs-attr\" style=\"line-height: 26px;\">goods</span>:&nbsp;[],<br>&nbsp;&nbsp;&nbsp;};<br>&nbsp;}<br>&nbsp;<span class=\"hljs-keyword\" style=\"color: #333; font-weight: bold; line-height: 26px;\">return</span>&nbsp;{<br>&nbsp;&nbsp;&nbsp;<span class=\"hljs-attr\" style=\"line-height: 26px;\">getInstance</span>:&nbsp;<span class=\"hljs-function\" style=\"line-height: 26px;\"><span class=\"hljs-keyword\" style=\"color: #333; font-weight: bold; line-height: 26px;\">function</span>&nbsp;(<span class=\"hljs-params\" style=\"line-height: 26px;\"></span>)&nbsp;</span>{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class=\"hljs-keyword\" style=\"color: #333; font-weight: bold; line-height: 26px;\">return</span>&nbsp;instance;<br>&nbsp;&nbsp;&nbsp;},<br>&nbsp;};<br>})();<br><span class=\"hljs-keyword\" style=\"color: #333; font-weight: bold; line-height: 26px;\">let</span>&nbsp;car1&nbsp;=&nbsp;ShopCar.getInstance();<br><span class=\"hljs-keyword\" style=\"color: #333; font-weight: bold; line-height: 26px;\">let</span>&nbsp;car2&nbsp;=&nbsp;ShopCar.getInstance();<br>car1.buy(<span class=\"hljs-string\" style=\"color: #d14; line-height: 26px;\">'橘子'</span>);<br>car2.buy(<span class=\"hljs-string\" style=\"color: #d14; line-height: 26px;\">'苹果'</span>);&nbsp;<span class=\"hljs-comment\" style=\"color: #998; font-style: italic; line-height: 26px;\">//[&nbsp;'橘子',&nbsp;'苹果'&nbsp;]</span><br><span class=\"hljs-built_in\" style=\"color: #0086b3; line-height: 26px;\">console</span>.log(car1.goods);<br><span class=\"hljs-built_in\" style=\"color: #0086b3; line-height: 26px;\">console</span>.log(car1&nbsp;===&nbsp;car2);&nbsp;<span class=\"hljs-comment\" style=\"color: #998; font-style: italic; line-height: 26px;\">//&nbsp;true</span><br></code></pre>\n<blockquote data-tool=\"mdnice编辑器\" style=\"display: block; font-size: 0.9em; overflow: auto; overflow-scrolling: touch; color: #6a737d; padding-top: 10px; padding-bottom: 10px; padding-left: 20px; padding-right: 10px; margin-bottom: 20px; margin-top: 20px; border-left: 3px solid rgba(0, 0, 0, 0.65); border-right: 1px solid rgba(0, 0, 0, 0.65); background: rgb(249, 249, 249);\">\n<p style=\"padding-top: 8px; padding-bottom: 8px; font-size: 14px; margin: 0px; color: black; line-height: 26px;\"><code style=\"font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #ff6441;\">懒汉式</code>在类加载时，不创建实例，因此类加载速度快，但运行时获取对象的速度慢；<code style=\"font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #ff6441;\">饿汉式</code>在类加载时就完成了初始化，所以类加载较慢，但获取对象的速度快</p>\n</blockquote>\n<h2 data-tool=\"mdnice编辑器\" style=\"margin-top: 30px; margin-bottom: 15px; padding: 0px; font-size: 22px; text-align: center; position: relative; font-weight: bold; color: black; line-height: 1.1em; padding-top: 12px; padding-bottom: 12px; margin: 70px 30px 30px; border: 1px solid #000;\"><span style=\"float: left; display: block; width: 90%; border-top: 1px solid #000; height: 1px; line-height: 1px; margin-left: -5px; margin-top: -17px;\"> </span><span class=\"prefix\" style=\"display: block; width: 3px; margin: 0 0 0 5%; height: 3px; line-height: 3px; overflow: hidden; background-color: #000; box-shadow: 3px 0 #000,\n    0 3px #000,\n    -3px 0 #000,\n    0 -3px #000;\"></span><span class=\"content\" style=\"display: block; -webkit-box-reflect: below 0em -webkit-gradient(linear,left top,left bottom, from(rgba(0,0,0,0)),to(rgba(255,255,255,0.1)));\">策略模式</span><span class=\"suffix\" style=\"display: block; width: 3px; margin: 0 0 0 95%; height: 3px; line-height: 3px; overflow: hidden; background-color: #000; box-shadow: 3px 0 #000,\n    0 3px #000,\n    -3px 0 #000,\n    0 -3px #000;\"></span><span style=\"float: right; display: block; width: 90%; border-bottom: 1px solid #000; height: 1px; line-height: 1px; margin-right: -5px; margin-top: 16px;\"> </span></h2>\n<h3 data-tool=\"mdnice编辑器\" style=\"margin-top: 30px; margin-bottom: 15px; font-weight: bold; background-color: #000; color: #fff; padding: 2px 10px; width: fit-content; font-size: 17px; margin: 60px auto 10px;\"><span class=\"prefix\" style=\"display: none;\"></span><span class=\"content\">定义</span><span class=\"suffix\" style=\"display: none;\"></span></h3>\n<blockquote data-tool=\"mdnice编辑器\" style=\"display: block; font-size: 0.9em; overflow: auto; overflow-scrolling: touch; color: #6a737d; padding-top: 10px; padding-bottom: 10px; padding-left: 20px; padding-right: 10px; margin-bottom: 20px; margin-top: 20px; border-left: 3px solid rgba(0, 0, 0, 0.65); border-right: 1px solid rgba(0, 0, 0, 0.65); background: rgb(249, 249, 249);\">\n<p style=\"padding-top: 8px; padding-bottom: 8px; font-size: 14px; margin: 0px; color: black; line-height: 26px;\">策略模式定义一系列的算法，将每一个算法封装起来，并让他们可以相互替换。</p>\n</blockquote>\n<ul data-tool=\"mdnice编辑器\" style=\"margin-top: 8px; margin-bottom: 8px; padding-left: 25px; color: black; list-style-type: square;\">\n<li><section style=\"margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;\"><strong style=\"font-weight: bold; color: black;\">实现方法</strong>定义一组可变的策略类封装具体算法，定义一组不变的环境类将请求委托给某一个策略类</section></li><li><section style=\"margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;\"><strong style=\"font-weight: bold; color: black;\">使用场景</strong>适用于业务场景中需要判断多种条件，甚至包含复杂条件嵌套的，可以使用策略模式来提升代码的可维护性和可读性。比如支付，博客权限校验</section></li></ul>\n<h3 data-tool=\"mdnice编辑器\" style=\"margin-top: 30px; margin-bottom: 15px; font-weight: bold; background-color: #000; color: #fff; padding: 2px 10px; width: fit-content; font-size: 17px; margin: 60px auto 10px;\"><span class=\"prefix\" style=\"display: none;\"></span><span class=\"content\">实现</span><span class=\"suffix\" style=\"display: none;\"></span></h3>\n<p data-tool=\"mdnice编辑器\" style=\"padding-top: 8px; padding-bottom: 8px; margin: 0; line-height: 26px; color: black; font-size: 14px;\"><strong style=\"font-weight: bold; color: black;\">实例:</strong></p>\n<pre class=\"custom\" data-tool=\"mdnice编辑器\" style=\"margin-top: 10px; margin-bottom: 10px; box-shadow: rgba(170, 170, 170, 0.48) 0px 0px 6px 0px; max-width: 100%; border-radius: 4px; margin: 10px auto 0 auto;\"><code class=\"hljs\" style=\"overflow-x: auto; padding: 16px; color: #333; background: #f8f8f8; display: -webkit-box; font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; border-radius: 0px; font-size: 12px; -webkit-overflow-scrolling: touch;\"><span class=\"hljs-comment\" style=\"color: #998; font-style: italic; line-height: 26px;\">//&nbsp;定义几个策略类</span><br><span class=\"hljs-keyword\" style=\"color: #333; font-weight: bold; line-height: 26px;\">var</span>&nbsp;PaymentMethodStrategy&nbsp;=&nbsp;{<br>&nbsp;<span class=\"hljs-attr\" style=\"line-height: 26px;\">BankAccount</span>:&nbsp;<span class=\"hljs-function\" style=\"line-height: 26px;\"><span class=\"hljs-keyword\" style=\"color: #333; font-weight: bold; line-height: 26px;\">function</span>&nbsp;(<span class=\"hljs-params\" style=\"line-height: 26px;\">money</span>)&nbsp;</span>{<br>&nbsp;&nbsp;&nbsp;<span class=\"hljs-keyword\" style=\"color: #333; font-weight: bold; line-height: 26px;\">return</span>&nbsp;money&nbsp;&gt;&nbsp;<span class=\"hljs-number\" style=\"color: #008080; line-height: 26px;\">50</span>&nbsp;?&nbsp;money&nbsp;*&nbsp;<span class=\"hljs-number\" style=\"color: #008080; line-height: 26px;\">0.7</span>&nbsp;:&nbsp;money;<br>&nbsp;},<br>&nbsp;<span class=\"hljs-attr\" style=\"line-height: 26px;\">CreditCard</span>:&nbsp;<span class=\"hljs-function\" style=\"line-height: 26px;\"><span class=\"hljs-keyword\" style=\"color: #333; font-weight: bold; line-height: 26px;\">function</span>&nbsp;(<span class=\"hljs-params\" style=\"line-height: 26px;\">money</span>)&nbsp;</span>{<br>&nbsp;&nbsp;&nbsp;<span class=\"hljs-keyword\" style=\"color: #333; font-weight: bold; line-height: 26px;\">return</span>&nbsp;money&nbsp;*&nbsp;<span class=\"hljs-number\" style=\"color: #008080; line-height: 26px;\">0.8</span>;<br>&nbsp;},<br>&nbsp;<span class=\"hljs-attr\" style=\"line-height: 26px;\">Alipay</span>:&nbsp;<span class=\"hljs-function\" style=\"line-height: 26px;\"><span class=\"hljs-keyword\" style=\"color: #333; font-weight: bold; line-height: 26px;\">function</span>&nbsp;(<span class=\"hljs-params\" style=\"line-height: 26px;\">money</span>)&nbsp;</span>{<br>&nbsp;&nbsp;&nbsp;<span class=\"hljs-keyword\" style=\"color: #333; font-weight: bold; line-height: 26px;\">return</span>&nbsp;money;<br>&nbsp;},<br>};<br><span class=\"hljs-comment\" style=\"color: #998; font-style: italic; line-height: 26px;\">/*环境类*/</span><br><span class=\"hljs-keyword\" style=\"color: #333; font-weight: bold; line-height: 26px;\">var</span>&nbsp;userPay&nbsp;=&nbsp;<span class=\"hljs-function\" style=\"line-height: 26px;\"><span class=\"hljs-keyword\" style=\"color: #333; font-weight: bold; line-height: 26px;\">function</span>&nbsp;(<span class=\"hljs-params\" style=\"line-height: 26px;\">selectedStrategy,&nbsp;money</span>)&nbsp;</span>{<br>&nbsp;<span class=\"hljs-keyword\" style=\"color: #333; font-weight: bold; line-height: 26px;\">return</span>&nbsp;PaymentMethodStrategy[selectedStrategy](money);<br>};<br><span class=\"hljs-built_in\" style=\"color: #0086b3; line-height: 26px;\">console</span>.log(<span class=\"hljs-string\" style=\"color: #d14; line-height: 26px;\">'银行卡支付价格为：'</span>&nbsp;+&nbsp;userPay(<span class=\"hljs-string\" style=\"color: #d14; line-height: 26px;\">'BankAccount'</span>,&nbsp;<span class=\"hljs-number\" style=\"color: #008080; line-height: 26px;\">100</span>));&nbsp;<span class=\"hljs-comment\" style=\"color: #998; font-style: italic; line-height: 26px;\">//70</span><br><span class=\"hljs-built_in\" style=\"color: #0086b3; line-height: 26px;\">console</span>.log(<span class=\"hljs-string\" style=\"color: #d14; line-height: 26px;\">'支付宝支付价格为：'</span>&nbsp;+&nbsp;userPay(<span class=\"hljs-string\" style=\"color: #d14; line-height: 26px;\">'Alipay'</span>,&nbsp;<span class=\"hljs-number\" style=\"color: #008080; line-height: 26px;\">100</span>));&nbsp;<span class=\"hljs-comment\" style=\"color: #998; font-style: italic; line-height: 26px;\">//100</span><br><span class=\"hljs-built_in\" style=\"color: #0086b3; line-height: 26px;\">console</span>.log(<span class=\"hljs-string\" style=\"color: #d14; line-height: 26px;\">'信用卡支付价格为：'</span>&nbsp;+&nbsp;userPay(<span class=\"hljs-string\" style=\"color: #d14; line-height: 26px;\">'CreditCard'</span>,&nbsp;<span class=\"hljs-number\" style=\"color: #008080; line-height: 26px;\">100</span>));&nbsp;<span class=\"hljs-comment\" style=\"color: #998; font-style: italic; line-height: 26px;\">//80</span><br></code></pre>\n<h2 data-tool=\"mdnice编辑器\" style=\"margin-top: 30px; margin-bottom: 15px; padding: 0px; font-size: 22px; text-align: center; position: relative; font-weight: bold; color: black; line-height: 1.1em; padding-top: 12px; padding-bottom: 12px; margin: 70px 30px 30px; border: 1px solid #000;\"><span style=\"float: left; display: block; width: 90%; border-top: 1px solid #000; height: 1px; line-height: 1px; margin-left: -5px; margin-top: -17px;\"> </span><span class=\"prefix\" style=\"display: block; width: 3px; margin: 0 0 0 5%; height: 3px; line-height: 3px; overflow: hidden; background-color: #000; box-shadow: 3px 0 #000,\n    0 3px #000,\n    -3px 0 #000,\n    0 -3px #000;\"></span><span class=\"content\" style=\"display: block; -webkit-box-reflect: below 0em -webkit-gradient(linear,left top,left bottom, from(rgba(0,0,0,0)),to(rgba(255,255,255,0.1)));\">观察者模式</span><span class=\"suffix\" style=\"display: block; width: 3px; margin: 0 0 0 95%; height: 3px; line-height: 3px; overflow: hidden; background-color: #000; box-shadow: 3px 0 #000,\n    0 3px #000,\n    -3px 0 #000,\n    0 -3px #000;\"></span><span style=\"float: right; display: block; width: 90%; border-bottom: 1px solid #000; height: 1px; line-height: 1px; margin-right: -5px; margin-top: 16px;\"> </span></h2>\n<h3 data-tool=\"mdnice编辑器\" style=\"margin-top: 30px; margin-bottom: 15px; font-weight: bold; background-color: #000; color: #fff; padding: 2px 10px; width: fit-content; font-size: 17px; margin: 60px auto 10px;\"><span class=\"prefix\" style=\"display: none;\"></span><span class=\"content\">定义</span><span class=\"suffix\" style=\"display: none;\"></span></h3>\n<blockquote data-tool=\"mdnice编辑器\" style=\"display: block; font-size: 0.9em; overflow: auto; overflow-scrolling: touch; color: #6a737d; padding-top: 10px; padding-bottom: 10px; padding-left: 20px; padding-right: 10px; margin-bottom: 20px; margin-top: 20px; border-left: 3px solid rgba(0, 0, 0, 0.65); border-right: 1px solid rgba(0, 0, 0, 0.65); background: rgb(249, 249, 249);\">\n<p style=\"padding-top: 8px; padding-bottom: 8px; font-size: 14px; margin: 0px; color: black; line-height: 26px;\">观察者模式，也叫订阅-发布模式，是对象的行为模式，在对象之间定义了一对多的依赖关系，就是多个观察者和一个被观察者之间的关系，当被观察者发生变化的时候，会通知所有的观察者对象，他们做出相对应的操作。</p>\n</blockquote>\n<ul data-tool=\"mdnice编辑器\" style=\"margin-top: 8px; margin-bottom: 8px; padding-left: 25px; color: black; list-style-type: square;\">\n<li><section style=\"margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;\"><strong style=\"font-weight: bold; color: black;\">实现方法</strong>定义一组可变的策略类封装具体算法，定义一组不变的环境类将请求委托给某一个策略类</section></li><li><section style=\"margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;\"><strong style=\"font-weight: bold; color: black;\">使用场景</strong>适用于业务场景中当一个对象的状态发生变化时，需要自动通知其他关联对象，自动刷新对象状态，或者说执行对应对象的方法，比如你是一个老师，需要通知班里家长的时候，你可以建一个群（列表）。每次通知事件的时候只要循环执行这个列表就好了（群发），而不用关心这个列表里有谁。</section></li></ul>\n<h3 data-tool=\"mdnice编辑器\" style=\"margin-top: 30px; margin-bottom: 15px; font-weight: bold; background-color: #000; color: #fff; padding: 2px 10px; width: fit-content; font-size: 17px; margin: 60px auto 10px;\"><span class=\"prefix\" style=\"display: none;\"></span><span class=\"content\">实现</span><span class=\"suffix\" style=\"display: none;\"></span></h3>\n<p data-tool=\"mdnice编辑器\" style=\"padding-top: 8px; padding-bottom: 8px; margin: 0; line-height: 26px; color: black; font-size: 14px;\"><strong style=\"font-weight: bold; color: black;\">实例:</strong></p>\n<pre class=\"custom\" data-tool=\"mdnice编辑器\" style=\"margin-top: 10px; margin-bottom: 10px; box-shadow: rgba(170, 170, 170, 0.48) 0px 0px 6px 0px; max-width: 100%; border-radius: 4px; margin: 10px auto 0 auto;\"><code class=\"hljs\" style=\"overflow-x: auto; padding: 16px; color: #333; background: #f8f8f8; display: -webkit-box; font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; border-radius: 0px; font-size: 12px; -webkit-overflow-scrolling: touch;\"><span class=\"hljs-comment\" style=\"color: #998; font-style: italic; line-height: 26px;\">//&nbsp;创建一个群，保存通知，通知变化之后通知每个家长（触发所有观察者对象）</span><br><span class=\"hljs-class\" style=\"line-height: 26px;\"><span class=\"hljs-keyword\" style=\"color: #333; font-weight: bold; line-height: 26px;\">class</span>&nbsp;<span class=\"hljs-title\" style=\"color: #458; font-weight: bold; line-height: 26px;\">Group</span>&nbsp;</span>{<br>&nbsp;<span class=\"hljs-keyword\" style=\"color: #333; font-weight: bold; line-height: 26px;\">constructor</span>()&nbsp;{<br>&nbsp;&nbsp;&nbsp;<span class=\"hljs-keyword\" style=\"color: #333; font-weight: bold; line-height: 26px;\">this</span>.message&nbsp;=&nbsp;<span class=\"hljs-string\" style=\"color: #d14; line-height: 26px;\">'暂无通知'</span>;<br>&nbsp;&nbsp;&nbsp;<span class=\"hljs-keyword\" style=\"color: #333; font-weight: bold; line-height: 26px;\">this</span>.parents&nbsp;=&nbsp;[];<br>&nbsp;}<br><br>&nbsp;getMessage()&nbsp;{<br>&nbsp;&nbsp;&nbsp;<span class=\"hljs-keyword\" style=\"color: #333; font-weight: bold; line-height: 26px;\">return</span>&nbsp;<span class=\"hljs-keyword\" style=\"color: #333; font-weight: bold; line-height: 26px;\">this</span>.message;<br>&nbsp;}<br><br>&nbsp;setMassage(message)&nbsp;{<br>&nbsp;&nbsp;&nbsp;<span class=\"hljs-keyword\" style=\"color: #333; font-weight: bold; line-height: 26px;\">this</span>.message&nbsp;=&nbsp;message;<br>&nbsp;&nbsp;&nbsp;<span class=\"hljs-keyword\" style=\"color: #333; font-weight: bold; line-height: 26px;\">this</span>.notifyAllObservers();<br>&nbsp;}<br><br>&nbsp;notifyAllObservers()&nbsp;{<br>&nbsp;&nbsp;&nbsp;<span class=\"hljs-keyword\" style=\"color: #333; font-weight: bold; line-height: 26px;\">this</span>.parents.forEach(<span class=\"hljs-function\" style=\"line-height: 26px;\">(<span class=\"hljs-params\" style=\"line-height: 26px;\">parent</span>)&nbsp;=&gt;</span>&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;parent.update();<br>&nbsp;&nbsp;&nbsp;});<br>&nbsp;}<br><br>&nbsp;attach(parent)&nbsp;{<br>&nbsp;&nbsp;&nbsp;<span class=\"hljs-keyword\" style=\"color: #333; font-weight: bold; line-height: 26px;\">this</span>.parents.push(parent);<br>&nbsp;}<br>}<br><br><span class=\"hljs-comment\" style=\"color: #998; font-style: italic; line-height: 26px;\">//&nbsp;观察者，每个家长</span><br><span class=\"hljs-class\" style=\"line-height: 26px;\"><span class=\"hljs-keyword\" style=\"color: #333; font-weight: bold; line-height: 26px;\">class</span>&nbsp;<span class=\"hljs-title\" style=\"color: #458; font-weight: bold; line-height: 26px;\">Parent</span>&nbsp;</span>{<br>&nbsp;<span class=\"hljs-keyword\" style=\"color: #333; font-weight: bold; line-height: 26px;\">constructor</span>(name,&nbsp;group)&nbsp;{<br>&nbsp;&nbsp;&nbsp;<span class=\"hljs-keyword\" style=\"color: #333; font-weight: bold; line-height: 26px;\">this</span>.name&nbsp;=&nbsp;name;<br>&nbsp;&nbsp;&nbsp;<span class=\"hljs-keyword\" style=\"color: #333; font-weight: bold; line-height: 26px;\">this</span>.group&nbsp;=&nbsp;group;<br>&nbsp;&nbsp;&nbsp;<span class=\"hljs-keyword\" style=\"color: #333; font-weight: bold; line-height: 26px;\">this</span>.group.attach(<span class=\"hljs-keyword\" style=\"color: #333; font-weight: bold; line-height: 26px;\">this</span>);<br>&nbsp;}<br>&nbsp;update()&nbsp;{<br>&nbsp;&nbsp;&nbsp;<span class=\"hljs-built_in\" style=\"color: #0086b3; line-height: 26px;\">console</span>.log(<span class=\"hljs-string\" style=\"color: #d14; line-height: 26px;\">`<span class=\"hljs-subst\" style=\"color: #333; font-weight: normal; line-height: 26px;\">${<span class=\"hljs-keyword\" style=\"color: #333; font-weight: bold; line-height: 26px;\">this</span>.name}</span>&nbsp;收到通知:&nbsp;<span class=\"hljs-subst\" style=\"color: #333; font-weight: normal; line-height: 26px;\">${<span class=\"hljs-keyword\" style=\"color: #333; font-weight: bold; line-height: 26px;\">this</span>.group.getMessage()}</span>`</span>);<br>&nbsp;}<br>}<br><br><span class=\"hljs-keyword\" style=\"color: #333; font-weight: bold; line-height: 26px;\">let</span>&nbsp;group&nbsp;=&nbsp;<span class=\"hljs-keyword\" style=\"color: #333; font-weight: bold; line-height: 26px;\">new</span>&nbsp;Group();<br><span class=\"hljs-keyword\" style=\"color: #333; font-weight: bold; line-height: 26px;\">let</span>&nbsp;t1&nbsp;=&nbsp;<span class=\"hljs-keyword\" style=\"color: #333; font-weight: bold; line-height: 26px;\">new</span>&nbsp;Parent(<span class=\"hljs-string\" style=\"color: #d14; line-height: 26px;\">'李妈妈'</span>,&nbsp;group);<br><span class=\"hljs-keyword\" style=\"color: #333; font-weight: bold; line-height: 26px;\">let</span>&nbsp;t2&nbsp;=&nbsp;<span class=\"hljs-keyword\" style=\"color: #333; font-weight: bold; line-height: 26px;\">new</span>&nbsp;Parent(<span class=\"hljs-string\" style=\"color: #d14; line-height: 26px;\">'王爸爸'</span>,&nbsp;group);<br><span class=\"hljs-keyword\" style=\"color: #333; font-weight: bold; line-height: 26px;\">let</span>&nbsp;t3&nbsp;=&nbsp;<span class=\"hljs-keyword\" style=\"color: #333; font-weight: bold; line-height: 26px;\">new</span>&nbsp;Parent(<span class=\"hljs-string\" style=\"color: #d14; line-height: 26px;\">'张爷爷'</span>,&nbsp;group);<br><br>group.setMassage(<span class=\"hljs-string\" style=\"color: #d14; line-height: 26px;\">'开家长会'</span>);<br>group.setMassage(<span class=\"hljs-string\" style=\"color: #d14; line-height: 26px;\">'开运动会'</span>);<br><br><br><span class=\"hljs-comment\" style=\"color: #998; font-style: italic; line-height: 26px;\">/*<br>李妈妈&nbsp;收到通知:&nbsp;开家长会<br>王爸爸&nbsp;收到通知:&nbsp;开家长会<br>张爷爷&nbsp;收到通知:&nbsp;开家长会<br>李妈妈&nbsp;收到通知:&nbsp;开运动会<br>王爸爸&nbsp;收到通知:&nbsp;开运动会<br>张爷爷&nbsp;收到通知:&nbsp;开运动会<br>*/</span><br></code></pre>\n<h2 data-tool=\"mdnice编辑器\" style=\"margin-top: 30px; margin-bottom: 15px; padding: 0px; font-size: 22px; text-align: center; position: relative; font-weight: bold; color: black; line-height: 1.1em; padding-top: 12px; padding-bottom: 12px; margin: 70px 30px 30px; border: 1px solid #000;\"><span style=\"float: left; display: block; width: 90%; border-top: 1px solid #000; height: 1px; line-height: 1px; margin-left: -5px; margin-top: -17px;\"> </span><span class=\"prefix\" style=\"display: block; width: 3px; margin: 0 0 0 5%; height: 3px; line-height: 3px; overflow: hidden; background-color: #000; box-shadow: 3px 0 #000,\n    0 3px #000,\n    -3px 0 #000,\n    0 -3px #000;\"></span><span class=\"content\" style=\"display: block; -webkit-box-reflect: below 0em -webkit-gradient(linear,left top,left bottom, from(rgba(0,0,0,0)),to(rgba(255,255,255,0.1)));\">装饰器模式</span><span class=\"suffix\" style=\"display: block; width: 3px; margin: 0 0 0 95%; height: 3px; line-height: 3px; overflow: hidden; background-color: #000; box-shadow: 3px 0 #000,\n    0 3px #000,\n    -3px 0 #000,\n    0 -3px #000;\"></span><span style=\"float: right; display: block; width: 90%; border-bottom: 1px solid #000; height: 1px; line-height: 1px; margin-right: -5px; margin-top: 16px;\"> </span></h2>\n<h3 data-tool=\"mdnice编辑器\" style=\"margin-top: 30px; margin-bottom: 15px; font-weight: bold; background-color: #000; color: #fff; padding: 2px 10px; width: fit-content; font-size: 17px; margin: 60px auto 10px;\"><span class=\"prefix\" style=\"display: none;\"></span><span class=\"content\">定义</span><span class=\"suffix\" style=\"display: none;\"></span></h3>\n<blockquote data-tool=\"mdnice编辑器\" style=\"display: block; font-size: 0.9em; overflow: auto; overflow-scrolling: touch; color: #6a737d; padding-top: 10px; padding-bottom: 10px; padding-left: 20px; padding-right: 10px; margin-bottom: 20px; margin-top: 20px; border-left: 3px solid rgba(0, 0, 0, 0.65); border-right: 1px solid rgba(0, 0, 0, 0.65); background: rgb(249, 249, 249);\">\n<p style=\"padding-top: 8px; padding-bottom: 8px; font-size: 14px; margin: 0px; color: black; line-height: 26px;\">在不改变原来的结构和功能基础上，动态装饰一些针对特别场景所适用的方法或属性，即添加一些新功能以增强它的某种能力</p>\n</blockquote>\n<ul data-tool=\"mdnice编辑器\" style=\"margin-top: 8px; margin-bottom: 8px; padding-left: 25px; color: black; list-style-type: square;\">\n<li><section style=\"margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;\"><strong style=\"font-weight: bold; color: black;\">实现方法</strong>定义一组可变的策略类封装具体算法，定义一组不变的环境类将请求委托给某一个策略类</section></li><li><section style=\"margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;\"><strong style=\"font-weight: bold; color: black;\">使用场景</strong>原有方法维持不变，在原有方法上再挂载其他方法来满足现有需求；函数的解耦，将函数拆分成多个可复用的函数，再将拆分出来的函数挂载到某个函数上，实现相同的效果但增强了复用性。比如多孔插座，机车改装</section></li></ul>\n<h3 data-tool=\"mdnice编辑器\" style=\"margin-top: 30px; margin-bottom: 15px; font-weight: bold; background-color: #000; color: #fff; padding: 2px 10px; width: fit-content; font-size: 17px; margin: 60px auto 10px;\"><span class=\"prefix\" style=\"display: none;\"></span><span class=\"content\">实现</span><span class=\"suffix\" style=\"display: none;\"></span></h3>\n<p data-tool=\"mdnice编辑器\" style=\"padding-top: 8px; padding-bottom: 8px; margin: 0; line-height: 26px; color: black; font-size: 14px;\"><strong style=\"font-weight: bold; color: black;\">实例:</strong></p>\n<pre class=\"custom\" data-tool=\"mdnice编辑器\" style=\"margin-top: 10px; margin-bottom: 10px; box-shadow: rgba(170, 170, 170, 0.48) 0px 0px 6px 0px; max-width: 100%; border-radius: 4px; margin: 10px auto 0 auto;\"><code class=\"hljs\" style=\"overflow-x: auto; padding: 16px; color: #333; background: #f8f8f8; display: -webkit-box; font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; border-radius: 0px; font-size: 12px; -webkit-overflow-scrolling: touch;\"><span class=\"hljs-keyword\" style=\"color: #333; font-weight: bold; line-height: 26px;\">const</span>&nbsp;Man&nbsp;=&nbsp;<span class=\"hljs-function\" style=\"line-height: 26px;\"><span class=\"hljs-keyword\" style=\"color: #333; font-weight: bold; line-height: 26px;\">function</span>&nbsp;(<span class=\"hljs-params\" style=\"line-height: 26px;\"></span>)&nbsp;</span>{<br>&nbsp;<span class=\"hljs-keyword\" style=\"color: #333; font-weight: bold; line-height: 26px;\">this</span>.run&nbsp;=&nbsp;<span class=\"hljs-function\" style=\"line-height: 26px;\"><span class=\"hljs-keyword\" style=\"color: #333; font-weight: bold; line-height: 26px;\">function</span>&nbsp;(<span class=\"hljs-params\" style=\"line-height: 26px;\"></span>)&nbsp;</span>{<br>&nbsp;&nbsp;&nbsp;<span class=\"hljs-built_in\" style=\"color: #0086b3; line-height: 26px;\">console</span>.log(<span class=\"hljs-string\" style=\"color: #d14; line-height: 26px;\">'跑步'</span>);<br>&nbsp;};<br>};<br><br><span class=\"hljs-keyword\" style=\"color: #333; font-weight: bold; line-height: 26px;\">const</span>&nbsp;Decorator&nbsp;=&nbsp;<span class=\"hljs-function\" style=\"line-height: 26px;\"><span class=\"hljs-keyword\" style=\"color: #333; font-weight: bold; line-height: 26px;\">function</span>&nbsp;(<span class=\"hljs-params\" style=\"line-height: 26px;\">old</span>)&nbsp;</span>{<br>&nbsp;<span class=\"hljs-keyword\" style=\"color: #333; font-weight: bold; line-height: 26px;\">this</span>.oldAbility&nbsp;=&nbsp;old.run;<br>&nbsp;<span class=\"hljs-keyword\" style=\"color: #333; font-weight: bold; line-height: 26px;\">this</span>.fly&nbsp;=&nbsp;<span class=\"hljs-function\" style=\"line-height: 26px;\"><span class=\"hljs-keyword\" style=\"color: #333; font-weight: bold; line-height: 26px;\">function</span>&nbsp;(<span class=\"hljs-params\" style=\"line-height: 26px;\"></span>)&nbsp;</span>{<br>&nbsp;&nbsp;&nbsp;<span class=\"hljs-built_in\" style=\"color: #0086b3; line-height: 26px;\">console</span>.log(<span class=\"hljs-string\" style=\"color: #d14; line-height: 26px;\">'具备飞行能力'</span>);<br>&nbsp;};<br>&nbsp;<span class=\"hljs-keyword\" style=\"color: #333; font-weight: bold; line-height: 26px;\">this</span>.newAbility&nbsp;=&nbsp;<span class=\"hljs-function\" style=\"line-height: 26px;\"><span class=\"hljs-keyword\" style=\"color: #333; font-weight: bold; line-height: 26px;\">function</span>&nbsp;(<span class=\"hljs-params\" style=\"line-height: 26px;\"></span>)&nbsp;</span>{<br>&nbsp;&nbsp;&nbsp;<span class=\"hljs-keyword\" style=\"color: #333; font-weight: bold; line-height: 26px;\">this</span>.oldAbility();<br>&nbsp;&nbsp;&nbsp;<span class=\"hljs-keyword\" style=\"color: #333; font-weight: bold; line-height: 26px;\">this</span>.fly();<br>&nbsp;};<br>};<br><br><span class=\"hljs-keyword\" style=\"color: #333; font-weight: bold; line-height: 26px;\">const</span>&nbsp;man&nbsp;=&nbsp;<span class=\"hljs-keyword\" style=\"color: #333; font-weight: bold; line-height: 26px;\">new</span>&nbsp;Man();<br><span class=\"hljs-keyword\" style=\"color: #333; font-weight: bold; line-height: 26px;\">const</span>&nbsp;superMan&nbsp;=&nbsp;<span class=\"hljs-keyword\" style=\"color: #333; font-weight: bold; line-height: 26px;\">new</span>&nbsp;Decorator(man);<br>superMan.fly();&nbsp;<span class=\"hljs-comment\" style=\"color: #998; font-style: italic; line-height: 26px;\">//&nbsp;具备飞行能力</span><br></code></pre>\n<h2 data-tool=\"mdnice编辑器\" style=\"margin-top: 30px; margin-bottom: 15px; padding: 0px; font-size: 22px; text-align: center; position: relative; font-weight: bold; color: black; line-height: 1.1em; padding-top: 12px; padding-bottom: 12px; margin: 70px 30px 30px; border: 1px solid #000;\"><span style=\"float: left; display: block; width: 90%; border-top: 1px solid #000; height: 1px; line-height: 1px; margin-left: -5px; margin-top: -17px;\"> </span><span class=\"prefix\" style=\"display: block; width: 3px; margin: 0 0 0 5%; height: 3px; line-height: 3px; overflow: hidden; background-color: #000; box-shadow: 3px 0 #000,\n    0 3px #000,\n    -3px 0 #000,\n    0 -3px #000;\"></span><span class=\"content\" style=\"display: block; -webkit-box-reflect: below 0em -webkit-gradient(linear,left top,left bottom, from(rgba(0,0,0,0)),to(rgba(255,255,255,0.1)));\">代理模式</span><span class=\"suffix\" style=\"display: block; width: 3px; margin: 0 0 0 95%; height: 3px; line-height: 3px; overflow: hidden; background-color: #000; box-shadow: 3px 0 #000,\n    0 3px #000,\n    -3px 0 #000,\n    0 -3px #000;\"></span><span style=\"float: right; display: block; width: 90%; border-bottom: 1px solid #000; height: 1px; line-height: 1px; margin-right: -5px; margin-top: 16px;\"> </span></h2>\n<h3 data-tool=\"mdnice编辑器\" style=\"margin-top: 30px; margin-bottom: 15px; font-weight: bold; background-color: #000; color: #fff; padding: 2px 10px; width: fit-content; font-size: 17px; margin: 60px auto 10px;\"><span class=\"prefix\" style=\"display: none;\"></span><span class=\"content\">定义</span><span class=\"suffix\" style=\"display: none;\"></span></h3>\n<blockquote data-tool=\"mdnice编辑器\" style=\"display: block; font-size: 0.9em; overflow: auto; overflow-scrolling: touch; color: #6a737d; padding-top: 10px; padding-bottom: 10px; padding-left: 20px; padding-right: 10px; margin-bottom: 20px; margin-top: 20px; border-left: 3px solid rgba(0, 0, 0, 0.65); border-right: 1px solid rgba(0, 0, 0, 0.65); background: rgb(249, 249, 249);\">\n<p style=\"padding-top: 8px; padding-bottom: 8px; font-size: 14px; margin: 0px; color: black; line-height: 26px;\">代理模式给某一个对象提供一个代理对象，并由代理对象控制对原对象的引用。通俗的来讲代理模式就是我们生活中常见的中介。</p>\n</blockquote>\n<ul data-tool=\"mdnice编辑器\" style=\"margin-top: 8px; margin-bottom: 8px; padding-left: 25px; color: black; list-style-type: square;\">\n<li><section style=\"margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;\"><strong style=\"font-weight: bold; color: black;\">实现方法</strong>定义一个委托者和一个代理，需要委托的事情在代理中完成</section></li><li><section style=\"margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;\"><strong style=\"font-weight: bold; color: black;\">使用场景</strong>在某些情况下，一个客户类不想或者不能直接引用一个委托对象，而代理类对象可以在客户类和委托对象之间起到中介的作用。代理可以帮客户过滤掉一些请求并且把一些开销大的对象，延迟到真正需要它时才创建。中介购车、代购、课代表替老师收作业</section></li></ul>\n<h3 data-tool=\"mdnice编辑器\" style=\"margin-top: 30px; margin-bottom: 15px; font-weight: bold; background-color: #000; color: #fff; padding: 2px 10px; width: fit-content; font-size: 17px; margin: 60px auto 10px;\"><span class=\"prefix\" style=\"display: none;\"></span><span class=\"content\">实现</span><span class=\"suffix\" style=\"display: none;\"></span></h3>\n<p data-tool=\"mdnice编辑器\" style=\"padding-top: 8px; padding-bottom: 8px; margin: 0; line-height: 26px; color: black; font-size: 14px;\"><strong style=\"font-weight: bold; color: black;\">实例:</strong></p>\n<pre class=\"custom\" data-tool=\"mdnice编辑器\" style=\"margin-top: 10px; margin-bottom: 10px; box-shadow: rgba(170, 170, 170, 0.48) 0px 0px 6px 0px; max-width: 100%; border-radius: 4px; margin: 10px auto 0 auto;\"><code class=\"hljs\" style=\"overflow-x: auto; padding: 16px; color: #333; background: #f8f8f8; display: -webkit-box; font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; border-radius: 0px; font-size: 12px; -webkit-overflow-scrolling: touch;\"><span class=\"hljs-class\" style=\"line-height: 26px;\"><span class=\"hljs-keyword\" style=\"color: #333; font-weight: bold; line-height: 26px;\">class</span>&nbsp;<span class=\"hljs-title\" style=\"color: #458; font-weight: bold; line-height: 26px;\">Letter</span>&nbsp;</span>{<br>&nbsp;<span class=\"hljs-keyword\" style=\"color: #333; font-weight: bold; line-height: 26px;\">constructor</span>(name)&nbsp;{<br>&nbsp;&nbsp;&nbsp;<span class=\"hljs-keyword\" style=\"color: #333; font-weight: bold; line-height: 26px;\">this</span>.name&nbsp;=&nbsp;name;<br>&nbsp;}<br>}<br><span class=\"hljs-comment\" style=\"color: #998; font-style: italic; line-height: 26px;\">//&nbsp;暗恋人小明</span><br><span class=\"hljs-keyword\" style=\"color: #333; font-weight: bold; line-height: 26px;\">let</span>&nbsp;XiaoMing&nbsp;=&nbsp;{<br>&nbsp;<span class=\"hljs-attr\" style=\"line-height: 26px;\">name</span>:&nbsp;<span class=\"hljs-string\" style=\"color: #d14; line-height: 26px;\">'小明'</span>,<br>&nbsp;sendLetter(target)&nbsp;{<br>&nbsp;&nbsp;&nbsp;target.receiveLetter(<span class=\"hljs-keyword\" style=\"color: #333; font-weight: bold; line-height: 26px;\">this</span>.name);<br>&nbsp;},<br>};<br><span class=\"hljs-comment\" style=\"color: #998; font-style: italic; line-height: 26px;\">//&nbsp;代理小华</span><br><span class=\"hljs-keyword\" style=\"color: #333; font-weight: bold; line-height: 26px;\">let</span>&nbsp;xiaoHua&nbsp;=&nbsp;{<br>&nbsp;receiveLetter(customer)&nbsp;{<br>&nbsp;&nbsp;&nbsp;<span class=\"hljs-comment\" style=\"color: #998; font-style: italic; line-height: 26px;\">//&nbsp;当然要等小红好心情时才送情书，也在送情书也才创建情书</span><br>&nbsp;&nbsp;&nbsp;XiaoHong.listenGoodMood(<span class=\"hljs-function\" style=\"line-height: 26px;\"><span class=\"hljs-params\" style=\"line-height: 26px;\">()</span>&nbsp;=&gt;</span>&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;XiaoHong.receiveLetter(<span class=\"hljs-keyword\" style=\"color: #333; font-weight: bold; line-height: 26px;\">new</span>&nbsp;Letter(customer&nbsp;+&nbsp;<span class=\"hljs-string\" style=\"color: #d14; line-height: 26px;\">'的情书'</span>));<br>&nbsp;&nbsp;&nbsp;});<br>&nbsp;},<br>};<br><span class=\"hljs-comment\" style=\"color: #998; font-style: italic; line-height: 26px;\">//&nbsp;心仪对象小红</span><br><span class=\"hljs-keyword\" style=\"color: #333; font-weight: bold; line-height: 26px;\">let</span>&nbsp;XiaoHong&nbsp;=&nbsp;{<br>&nbsp;<span class=\"hljs-attr\" style=\"line-height: 26px;\">name</span>:&nbsp;<span class=\"hljs-string\" style=\"color: #d14; line-height: 26px;\">'小红'</span>,<br>&nbsp;receiveLetter(letter)&nbsp;{<br>&nbsp;&nbsp;&nbsp;<span class=\"hljs-built_in\" style=\"color: #0086b3; line-height: 26px;\">console</span>.log(<span class=\"hljs-keyword\" style=\"color: #333; font-weight: bold; line-height: 26px;\">this</span>.name&nbsp;+&nbsp;<span class=\"hljs-string\" style=\"color: #d14; line-height: 26px;\">'收到：'</span>&nbsp;+&nbsp;letter.name);<br>&nbsp;},<br>&nbsp;listenGoodMood(fn)&nbsp;{<br>&nbsp;&nbsp;&nbsp;setTimeout(<span class=\"hljs-function\" style=\"line-height: 26px;\"><span class=\"hljs-params\" style=\"line-height: 26px;\">()</span>&nbsp;=&gt;</span>&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;fn();<br>&nbsp;&nbsp;&nbsp;},&nbsp;<span class=\"hljs-number\" style=\"color: #008080; line-height: 26px;\">1000</span>);<br>&nbsp;},<br>};<br><br>XiaoMing.sendLetter(xiaoHua);<span class=\"hljs-comment\" style=\"color: #998; font-style: italic; line-height: 26px;\">//小红收到：小明的情书</span><br></code></pre>\n<blockquote data-tool=\"mdnice编辑器\" style=\"display: block; font-size: 0.9em; overflow: auto; overflow-scrolling: touch; color: #6a737d; padding-top: 10px; padding-bottom: 10px; padding-left: 20px; padding-right: 10px; margin-bottom: 20px; margin-top: 20px; border-left: 3px solid rgba(0, 0, 0, 0.65); border-right: 1px solid rgba(0, 0, 0, 0.65); background: rgb(249, 249, 249);\">\n<p style=\"padding-top: 8px; padding-bottom: 8px; font-size: 14px; margin: 0px; color: black; line-height: 26px;\">Proxy 是 ES6 提供的专门以代理角色出现的代理器,Vue 3.0 的响应式数据部分弃用了 Object.defineProperty，使用 Proxy 来代替它。</p>\n</blockquote>\n<pre class=\"custom\" data-tool=\"mdnice编辑器\" style=\"margin-top: 10px; margin-bottom: 10px; box-shadow: rgba(170, 170, 170, 0.48) 0px 0px 6px 0px; max-width: 100%; border-radius: 4px; margin: 10px auto 0 auto;\"><code class=\"hljs\" style=\"overflow-x: auto; padding: 16px; color: #333; background: #f8f8f8; display: -webkit-box; font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; border-radius: 0px; font-size: 12px; -webkit-overflow-scrolling: touch;\"><span class=\"hljs-keyword\" style=\"color: #333; font-weight: bold; line-height: 26px;\">var</span>&nbsp;proxy&nbsp;=&nbsp;<span class=\"hljs-keyword\" style=\"color: #333; font-weight: bold; line-height: 26px;\">new</span>&nbsp;<span class=\"hljs-built_in\" style=\"color: #0086b3; line-height: 26px;\">Proxy</span>(target,&nbsp;handler);<br></code></pre>\n<p data-tool=\"mdnice编辑器\" style=\"padding-top: 8px; padding-bottom: 8px; margin: 0; line-height: 26px; color: black; font-size: 14px;\">现在用Proxy模拟一下另一种场景:为了保护不及格的同学，课代表拿到全班成绩单后只会公示及格人的成绩。对考分有疑问的考生，复议后新分数比以前大10分才有权利去更新成绩</p>\n<pre class=\"custom\" data-tool=\"mdnice编辑器\" style=\"margin-top: 10px; margin-bottom: 10px; box-shadow: rgba(170, 170, 170, 0.48) 0px 0px 6px 0px; max-width: 100%; border-radius: 4px; margin: 10px auto 0 auto;\"><code class=\"hljs\" style=\"overflow-x: auto; padding: 16px; color: #333; background: #f8f8f8; display: -webkit-box; font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; border-radius: 0px; font-size: 12px; -webkit-overflow-scrolling: touch;\"><span class=\"hljs-keyword\" style=\"color: #333; font-weight: bold; line-height: 26px;\">const</span>&nbsp;scoreList&nbsp;=&nbsp;{<br>&nbsp;&nbsp;<span class=\"hljs-string\" style=\"color: #d14; line-height: 26px;\">'wang'</span>:&nbsp;<span class=\"hljs-number\" style=\"color: #008080; line-height: 26px;\">90</span>,<br>&nbsp;&nbsp;<span class=\"hljs-string\" style=\"color: #d14; line-height: 26px;\">'li'</span>:&nbsp;<span class=\"hljs-number\" style=\"color: #008080; line-height: 26px;\">60</span>,<br>&nbsp;&nbsp;<span class=\"hljs-string\" style=\"color: #d14; line-height: 26px;\">'wu'</span>:<span class=\"hljs-number\" style=\"color: #008080; line-height: 26px;\">100</span>,<br>}<br><br><br><span class=\"hljs-keyword\" style=\"color: #333; font-weight: bold; line-height: 26px;\">const</span>&nbsp;yyProxy&nbsp;=&nbsp;<span class=\"hljs-keyword\" style=\"color: #333; font-weight: bold; line-height: 26px;\">new</span>&nbsp;<span class=\"hljs-built_in\" style=\"color: #0086b3; line-height: 26px;\">Proxy</span>(scoreList,&nbsp;{<br>&nbsp;&nbsp;<span class=\"hljs-attr\" style=\"line-height: 26px;\">get</span>:<span class=\"hljs-function\" style=\"line-height: 26px;\"><span class=\"hljs-keyword\" style=\"color: #333; font-weight: bold; line-height: 26px;\">function</span>(<span class=\"hljs-params\" style=\"line-height: 26px;\">scoreList,name</span>)&nbsp;</span>{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class=\"hljs-keyword\" style=\"color: #333; font-weight: bold; line-height: 26px;\">if</span>(scoreList[name]&nbsp;&gt;&nbsp;<span class=\"hljs-number\" style=\"color: #008080; line-height: 26px;\">69</span>)&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class=\"hljs-built_in\" style=\"color: #0086b3; line-height: 26px;\">console</span>.log(<span class=\"hljs-string\" style=\"color: #d14; line-height: 26px;\">'输出成绩'</span>)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class=\"hljs-keyword\" style=\"color: #333; font-weight: bold; line-height: 26px;\">return</span>&nbsp;scoreList[name]<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<span class=\"hljs-keyword\" style=\"color: #333; font-weight: bold; line-height: 26px;\">else</span>&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class=\"hljs-built_in\" style=\"color: #0086b3; line-height: 26px;\">console</span>.log(<span class=\"hljs-string\" style=\"color: #d14; line-height: 26px;\">'不及格的成绩无法公示'</span>)<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;},<br>&nbsp;&nbsp;<span class=\"hljs-attr\" style=\"line-height: 26px;\">set</span>:<span class=\"hljs-function\" style=\"line-height: 26px;\"><span class=\"hljs-keyword\" style=\"color: #333; font-weight: bold; line-height: 26px;\">function</span>(<span class=\"hljs-params\" style=\"line-height: 26px;\">scoreList,&nbsp;name,&nbsp;val</span>)&nbsp;</span>{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class=\"hljs-keyword\" style=\"color: #333; font-weight: bold; line-height: 26px;\">if</span>(val&nbsp;-&nbsp;scoreList[name]&nbsp;&gt;&nbsp;<span class=\"hljs-number\" style=\"color: #008080; line-height: 26px;\">10</span>)&nbsp;{<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class=\"hljs-built_in\" style=\"color: #0086b3; line-height: 26px;\">console</span>.log(<span class=\"hljs-string\" style=\"color: #d14; line-height: 26px;\">'修改成绩'</span>)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;scoreList[name]&nbsp;=&nbsp;val<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<span class=\"hljs-keyword\" style=\"color: #333; font-weight: bold; line-height: 26px;\">else</span>&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class=\"hljs-built_in\" style=\"color: #0086b3; line-height: 26px;\">console</span>.log(<span class=\"hljs-string\" style=\"color: #d14; line-height: 26px;\">'无法修改成绩'</span>);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;}<br>})<br><br>yyProxy[<span class=\"hljs-string\" style=\"color: #d14; line-height: 26px;\">'wang'</span>]&nbsp;=&nbsp;<span class=\"hljs-number\" style=\"color: #008080; line-height: 26px;\">98</span>&nbsp;<span class=\"hljs-comment\" style=\"color: #998; font-style: italic; line-height: 26px;\">//无法修改成绩</span><br>yyProxy[<span class=\"hljs-string\" style=\"color: #d14; line-height: 26px;\">\"li\"</span>]&nbsp;=&nbsp;<span class=\"hljs-number\" style=\"color: #008080; line-height: 26px;\">80</span>&nbsp;<span class=\"hljs-comment\" style=\"color: #998; font-style: italic; line-height: 26px;\">//修改成绩</span><br></code></pre>\n<h2 data-tool=\"mdnice编辑器\" style=\"margin-top: 30px; margin-bottom: 15px; padding: 0px; font-size: 22px; text-align: center; position: relative; font-weight: bold; color: black; line-height: 1.1em; padding-top: 12px; padding-bottom: 12px; margin: 70px 30px 30px; border: 1px solid #000;\"><span style=\"float: left; display: block; width: 90%; border-top: 1px solid #000; height: 1px; line-height: 1px; margin-left: -5px; margin-top: -17px;\"> </span><span class=\"prefix\" style=\"display: block; width: 3px; margin: 0 0 0 5%; height: 3px; line-height: 3px; overflow: hidden; background-color: #000; box-shadow: 3px 0 #000,\n    0 3px #000,\n    -3px 0 #000,\n    0 -3px #000;\"></span><span class=\"content\" style=\"display: block; -webkit-box-reflect: below 0em -webkit-gradient(linear,left top,left bottom, from(rgba(0,0,0,0)),to(rgba(255,255,255,0.1)));\">总结</span><span class=\"suffix\" style=\"display: block; width: 3px; margin: 0 0 0 95%; height: 3px; line-height: 3px; overflow: hidden; background-color: #000; box-shadow: 3px 0 #000,\n    0 3px #000,\n    -3px 0 #000,\n    0 -3px #000;\"></span><span style=\"float: right; display: block; width: 90%; border-bottom: 1px solid #000; height: 1px; line-height: 1px; margin-right: -5px; margin-top: 16px;\"> </span></h2>\n<p data-tool=\"mdnice编辑器\" style=\"padding-top: 8px; padding-bottom: 8px; margin: 0; line-height: 26px; color: black; font-size: 14px;\">我曾经以为设计模式是疯狂的，遥远的软件开发指南。然后我发现我一直在使用它们！</p>\n<p data-tool=\"mdnice编辑器\" style=\"padding-top: 8px; padding-bottom: 8px; margin: 0; line-height: 26px; color: black; font-size: 14px;\">我介绍的一些模式已在许多应用程序中使用。但归根结底，它们只是理论而已。作为开发人员，是否使用取决于使用后是否使代码逻辑更易于实现和维护。</p>\n<span style=\"font-size: 15px; display: block; text-align: center; margin-top: 50px; color: #999; border-bottom: 1px solid #eee;\">- END -</span></section>", "user_name": "johnYu", "description": "一个人像一支军队", "got_view_count": 24308, "category_name": "前端", "ctime": 1457483942}
{"tag_name": "Webpack", "concern_user_count": 181325, "user_id": "3737995267297838", "title": "面试官：webpack原理都不会？", "mark_content": "## 引言\n\n前一段时间我把`webpack`源码大概读了一遍，`webpack` 到`4.x`版本后，其源码已经比较庞大，对各种开发场景进行了高度抽象，阅读成本也愈发昂贵。\n\n过度分析源码对于大家并没有太大的帮助。本文主要是想通过分析`webpack`的构建流程以及实现一个简单的`webpack`来让大家对`webpack`的内部原理有一个大概的了解。（保证能看懂，不懂你打我 🙈）\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/38c47ae39f994be4b81915f1656a03ff~tplv-k3u1fbpfcp-zoom-1.image)\n\n## webpack 构建流程分析\n\n首先，无须多言，上图～\n![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/71b263000fa94db792cf1e98d67a578a~tplv-k3u1fbpfcp-zoom-1.image)\n\n`webpack` 的运行流程是一个串行的过程，从启动到结束会依次执行以下流程：首先会从配置文件和 `Shell` 语句中读取与合并参数，并初始化需要使用的插件和配置插件等执行环境所需要的参数；初始化完成后会调用`Compiler`的`run`来真正启动`webpack`编译构建过程，`webpack`的构建流程包括`compile`、`make`、`build`、`seal`、`emit`阶段，执行完这些阶段就完成了构建过程。\n\n### 初始化\n\n#### entry-options 启动\n\n从配置文件和 `Shell` 语句中读取与合并参数，得出最终的参数。\n\n#### run 实例化\n\n`compiler`：用上一步得到的参数初始化 `Compiler` 对象，加载所有配置的插件，执行对象的 `run` 方法开始执行编译\n\n### 编译构建\n\n#### `entry 确定入口`\n\n根据配置中的 `entry` 找出所有的入口文件\n\n#### `make 编译模块`\n\n从入口文件出发，调用所有配置的 `Loader` 对模块进行翻译，再找出该模块依赖的模块，再递归本步骤直到所有入口依赖的文件都经过了本步骤的处理\n\n#### `build module 完成模块编译`\n\n经过上面一步使用 `Loader` 翻译完所有模块后，得到了每个模块被翻译后的最终内容以及它们之间的依赖关系\n\n#### `seal 输出资源`\n\n根据入口和模块之间的依赖关系，组装成一个个包含多个模块的 `Chunk`，再把每个 `Chunk` 转换成一个单独的文件加入到输出列表，这步是可以修改输出内容的最后机会\n\n#### `emit 输出完成`\n\n在确定好输出内容后，根据配置确定输出的路径和文件名，把文件内容写入到文件系统\n\n分析完构建流程，下面让我们自己动手实现一个简易的`webpack`吧～\n![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/89b1790f738e4dcc88913033414f52d3~tplv-k3u1fbpfcp-zoom-1.image)\n\n## 实现一个简易的 webpack\n\n### 准备工作\n\n#### 目录结构\n\n我们先来初始化一个项目，结构如下：\n\n```\n|-- forestpack\n    |-- dist\n    |   |-- bundle.js\n    |   |-- index.html\n    |-- lib\n    |   |-- compiler.js\n    |   |-- index.js\n    |   |-- parser.js\n    |   |-- test.js\n    |-- src\n    |   |-- greeting.js\n    |   |-- index.js\n    |-- forstpack.config.js\n    |-- package.json\n```\n\n这里我先解释下每个文件/文件夹对应的含义：\n\n- `dist`：打包目录\n- `lib`：核心文件，主要包括`compiler`和`parser`\n  - `compiler.js`：编译相关。`Compiler`为一个类, 并且有`run`方法去开启编译，还有构建`module`（`buildModule`）和输出文件（`emitFiles`）\n  - `parser.js`：解析相关。包含解析`AST`（`getAST`）、收集依赖（`getDependencies`）、转换（`es6转es5`）\n  - `index.js`：实例化`Compiler`类，并将配置参数（对应`forstpack.config.js`）传入\n  - `test.js`：测试文件，用于测试方法函数打`console`使用\n- `src`：源代码。也就对应我们的业务代码\n- `forstpack.config.js`： 配置文件。类似`webpack.config.js`\n- `package.json`：这个就不用我多说了～～～（什么，你不知道？？）\n\n#### 先完成“造轮子”前 30%的代码\n\n项目搞起来了，但似乎还少点东西～～\n![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4f46adb6a5434a6f97cbc37d8ba5cb0d~tplv-k3u1fbpfcp-zoom-1.image)\n\n对了！基础的文件我们需要先完善下：`forstpack.config.js`和`src`。\n\n首先是`forstpack.config.js`：\n\n```js\nconst path = require(\"path\");\n\nmodule.exports = {\n  entry: path.join(__dirname, \"./src/index.js\"),\n  output: {\n    path: path.join(__dirname, \"./dist\"),\n    filename: \"bundle.js\",\n  },\n};\n```\n\n内容很简单，定义一下入口、出口（你这也太简单了吧！！别急，慢慢来嘛）\n\n其次是`src`，这里在`src`目录下定义了两个文件：\n\n- `greeting.js`：\n\n```js\n// greeting.js\nexport function greeting(name) {\n  return \"你好\" + name;\n}\n```\n\n- `index.js`：\n\n```js\nimport { greeting } from \"./greeting.js\";\n\ndocument.write(greeting(\"森林\"));\n```\n\nok，到这里我们已经把需要准备的工作都完成了。（问：为什么这么基础？答：当然要基础了，我们的核心是“造轮子”！！）\n\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a4763d030f684890836605179d3ab367~tplv-k3u1fbpfcp-zoom-1.image)\n### 梳理下逻辑\n\n短暂的停留一下，我们梳理下逻辑：\n\n`Q`: 我们要做什么？\n\n`A`: 做一个比`webpack`更强的`super webpack`（不好意思，失态了，一不小心说出了我的心声）。还是低调点（防止一会被疯狂打脸）\n![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e86b0e957ba840cc8c0aa8a08fbf8789~tplv-k3u1fbpfcp-zoom-1.image)\n\n`Q`: 怎么去做？\n\n`A`: 看下文（23333）\n\n`Q`: 整个的流程是什么？\n\n`A`: 哎嘿，大概流程就是：\n\n- 读取入口文件\n- 分析入口文件，递归的去读取模块所依赖的文件内容，生成`AST`语法树。\n- 根据`AST`语法树，生成浏览器能够运行的代码\n\n### 正式开工\n\n#### compile.js 编写\n\n```js\nconst path = require(\"path\");\nconst fs = require(\"fs\");\n\nmodule.exports = class Compiler {\n  // 接收通过lib/index.js new Compiler(options).run()传入的参数，对应`forestpack.config.js`的配置\n  constructor(options) {\n    const { entry, output } = options;\n    this.entry = entry;\n    this.output = output;\n    this.modules = [];\n  }\n  // 开启编译\n  run() {}\n  // 构建模块相关\n  buildModule(filename, isEntry) {\n    // filename: 文件名称\n    // isEntry: 是否是入口文件\n  }\n  // 输出文件\n  emitFiles() {}\n};\n```\n\n`compile.js`主要做了几个事情：\n\n- 接收`forestpack.config.js`配置参数，并初始化`entry`、`output`\n- 开启编译`run`方法。处理构建模块、收集依赖、输出文件等。\n- `buildModule`方法。主要用于构建模块（被`run`方法调用）\n- `emitFiles`方法。输出文件（同样被`run`方法调用）\n\n到这里，`compiler.js`的大致结构已经出来了，但是得到模块的源码后, 需要去解析,替换源码和获取模块的依赖项, 也就对应我们下面需要完善的`parser.js`。\n\n#### parser.js 编写\n\n```js\nconst fs = require(\"fs\");\n// const babylon = require(\"babylon\");\nconst parser = require(\"@babel/parser\");\nconst traverse = require(\"@babel/traverse\").default;\nconst { transformFromAst } = require(\"babel-core\");\nmodule.exports = {\n  // 解析我们的代码生成AST抽象语法树\n  getAST: (path) => {\n    const source = fs.readFileSync(path, \"utf-8\");\n\n    return parser.parse(source, {\n      sourceType: \"module\", //表示我们要解析的是ES模块\n    });\n  },\n  // 对AST节点进行递归遍历\n  getDependencies: (ast) => {\n    const dependencies = [];\n    traverse(ast, {\n      ImportDeclaration: ({ node }) => {\n        dependencies.push(node.source.value);\n      },\n    });\n    return dependencies;\n  },\n  // 将获得的ES6的AST转化成ES5\n  transform: (ast) => {\n    const { code } = transformFromAst(ast, null, {\n      presets: [\"env\"],\n    });\n    return code;\n  },\n};\n```\n\n看完这代码是不是有点懵（说好的保证让看懂的 😤）\n\n别着急，你听我辩解！！😷\n![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f842c011ba914a5392bdf8710b585d2a~tplv-k3u1fbpfcp-zoom-1.image)\n\n这里要先着重说下用到的几个`babel`包：\n\n- `@babel/parser`：用于将源码生成`AST`\n- `@babel/traverse`：对`AST`节点进行递归遍历\n- `babel-core`/`@babel/preset-env`：将获得的`ES6`的`AST`转化成`ES5`\n\n`parser.js`中主要就三个方法：\n\n- `getAST`： 将获取到的模块内容 解析成`AST`语法树\n- `getDependencies`：遍历`AST`，将用到的依赖收集起来\n- `transform`：把获得的`ES6`的`AST`转化成`ES5`\n\n#### 完善 compiler.js\n\n在上面我们已经将`compiler.js`中会用到的函数占好位置，下面我们需要完善一下`compiler.js`，当然会用到`parser.js`中的一些方法（废话，不然我上面干嘛要先把`parser.js`写完～～）\n![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/369b385f2ac1493daac93efdb7cdd633~tplv-k3u1fbpfcp-zoom-1.image)\n\n直接上代码：\n\n```js\nconst { getAST, getDependencies, transform } = require(\"./parser\");\nconst path = require(\"path\");\nconst fs = require(\"fs\");\n\nmodule.exports = class Compiler {\n  constructor(options) {\n    const { entry, output } = options;\n    this.entry = entry;\n    this.output = output;\n    this.modules = [];\n  }\n  // 开启编译\n  run() {\n    const entryModule = this.buildModule(this.entry, true);\n    this.modules.push(entryModule);\n    this.modules.map((_module) => {\n      _module.dependencies.map((dependency) => {\n        this.modules.push(this.buildModule(dependency));\n      });\n    });\n    // console.log(this.modules);\n    this.emitFiles();\n  }\n  // 构建模块相关\n  buildModule(filename, isEntry) {\n    let ast;\n    if (isEntry) {\n      ast = getAST(filename);\n    } else {\n      const absolutePath = path.join(process.cwd(), \"./src\", filename);\n      ast = getAST(absolutePath);\n    }\n\n    return {\n      filename, // 文件名称\n      dependencies: getDependencies(ast), // 依赖列表\n      transformCode: transform(ast), // 转化后的代码\n    };\n  }\n  // 输出文件\n  emitFiles() {\n    const outputPath = path.join(this.output.path, this.output.filename);\n    let modules = \"\";\n    this.modules.map((_module) => {\n      modules += `'${_module.filename}' : function(require, module, exports) {${_module.transformCode}},`;\n    });\n\n    const bundle = `\n        (function(modules) {\n          function require(fileName) {\n            const fn = modules[fileName];\n            const module = { exports:{}};\n            fn(require, module, module.exports)\n            return module.exports\n          }\n          require('${this.entry}')\n        })({${modules}})\n    `;\n\n    fs.writeFileSync(outputPath, bundle, \"utf-8\");\n  }\n};\n```\n\n关于`compiler.js`的内部函数，上面我说过一遍，这里主要来看下`emitFiles`：\n\n```js\nemitFiles() {\n    const outputPath = path.join(this.output.path, this.output.filename);\n    let modules = \"\";\n    this.modules.map((_module) => {\n      modules += `'${_module.filename}' : function(require, module, exports) {${_module.transformCode}},`;\n    });\n\n    const bundle = `\n        (function(modules) {\n          function require(fileName) {\n            const fn = modules[fileName];\n            const module = { exports:{}};\n            fn(require, module, module.exports)\n            return module.exports\n          }\n          require('${this.entry}')\n        })({${modules}})\n    `;\n\n    fs.writeFileSync(outputPath, bundle, \"utf-8\");\n  }\n\n```\n\n这里的`bundle`一大坨，什么鬼？\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/111299bc59044ed5870c759768659e86~tplv-k3u1fbpfcp-zoom-1.image)\n\n我们先来了解下`webpack`的文件 📦 机制。下面一段代码是经过`webpack`打包精简过后的代码：\n\n```js\n// dist/index.xxxx.js\n(function(modules) {\n  // 已经加载过的模块\n  var installedModules = {};\n\n  // 模块加载函数\n  function __webpack_require__(moduleId) {\n    if(installedModules[moduleId]) {\n      return installedModules[moduleId].exports;\n    }\n    var module = installedModules[moduleId] = {\n      i: moduleId,\n      l: false,\n      exports: {}\n    };\n    modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n    module.l = true;\n    return module.exports;\n  }\n  __webpack_require__(0);\n})([\n/* 0 module */\n(function(module, exports, __webpack_require__) {\n  ...\n}),\n/* 1 module */\n(function(module, exports, __webpack_require__) {\n  ...\n}),\n/* n module */\n(function(module, exports, __webpack_require__) {\n  ...\n})]);\n\n```\n\n简单分析下：\n\n- `webpack` 将所有模块(可以简单理解成文件)包裹于一个函数中，并传入默认参数，将所有模块放入一个数组中，取名为 `modules`，并通过数组的下标来作为 `moduleId`。\n- 将 `modules` 传入一个自执行函数中，自执行函数中包含一个 `installedModules` 已经加载过的模块和一个模块加载函数，最后加载入口模块并返回。\n- `__webpack_require__` 模块加载，先判断 `installedModules` 是否已加载，加载过了就直接返回 `exports` 数据，没有加载过该模块就通过 `modules[moduleId].call(module.exports, module, module.exports, __webpack_require__)` 执行模块并且将 `module.exports` 给返回。\n\n（你上面说的这一坨又是什么鬼？我听不懂啊啊啊啊！！！）\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d6c8cba5cad8456eb1f0ef69f132fac0~tplv-k3u1fbpfcp-zoom-1.image)\n\n那我换个说法吧：\n\n- 经过`webpack`打包出来的是一个匿名闭包函数（`IIFE`）\n- `modules`是一个数组，每一项是一个模块初始化函数\n- `__webpack_require__`用来加载模块，返回`module.exports`\n- 通过`WEBPACK_REQUIRE_METHOD(0)`启动程序\n\n（小声 bb：怎么样，这样听懂了吧）\n![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f44e4ab3fb4744cf8c42fddf4af379a3~tplv-k3u1fbpfcp-zoom-1.image)\n\n#### lib/index.js 入口文件编写\n\n到这里，就剩最后一步了（似乎见到了胜利的曙光）。在`lib`目录创建`index.js`：\n\n```js\nconst Compiler = require(\"./compiler\");\nconst options = require(\"../forestpack.config\");\n\nnew Compiler(options).run();\n```\n\n这里逻辑就比较简单了：实例化`Compiler`类，并将配置参数（对应`forstpack.config.js`）传入。\n\n运行`node lib/index.js`就会在`dist`目录下生成`bundle.js`文件。\n\n```js\n(function (modules) {\n  function require(fileName) {\n    const fn = modules[fileName];\n    const module = { exports: {} };\n    fn(require, module, module.exports);\n    return module.exports;\n  }\n  require(\"/Users/fengshuan/Desktop/workspace/forestpack/src/index.js\");\n})({\n  \"/Users/fengshuan/Desktop/workspace/forestpack/src/index.js\": function (\n    require,\n    module,\n    exports\n  ) {\n    \"use strict\";\n\n    var _greeting = require(\"./greeting.js\");\n\n    document.write((0, _greeting.greeting)(\"森林\"));\n  },\n  \"./greeting.js\": function (require, module, exports) {\n    \"use strict\";\n\n    Object.defineProperty(exports, \"__esModule\", {\n      value: true,\n    });\n    exports.greeting = greeting;\n\n    function greeting(name) {\n      return \"你好\" + name;\n    }\n  },\n});\n```\n\n和上面用`webpack`打包生成的`js`文件作下对比，是不是很相似呢？\n![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2fb2ae629fcf4a75926443e7a84a84cc~tplv-k3u1fbpfcp-zoom-1.image)\n\n#### 来吧！展示\n\n我们在`dist`目录下创建`index.html`文件，引入打包生成的`bundle.js`文件：\n\n```html\n<!DOCTYPE html>\n<html lang=\"en\">\n  <head>\n    <meta charset=\"UTF-8\" />\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\" />\n    <title>Document</title>\n  </head>\n  <body>\n    <script src=\"./bundle.js\"></script>\n  </body>\n</html>\n```\n\n此时打开浏览器：\n![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/530176a945e0475eab2520ef3ea75612~tplv-k3u1fbpfcp-zoom-1.image)\n\n如你所愿，得到了我们预期的结果～\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5464e1f3296c4db1a7f8cd5e05933fd0~tplv-k3u1fbpfcp-zoom-1.image)\n\n## 总结\n\n通过对`webpack`构建流程的分析以及实现了一个简易的`forestpack`，相信你对`webpack`的构建原理已经有了一个清晰的认知！（当然，这里的`forestpack`和`webpack`相比还很弱很弱，，，，）\n![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d484014578e0455ea7f93e4f5d7b2a4f~tplv-k3u1fbpfcp-zoom-1.image)\n\n## 参考\n\n本文是看过极客时间程柳锋老师的「玩转 webpack」课程后整理的。这里也十分推荐大家去学习这门课程～\n![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0b941e17454f45ec9d6fa26a10fd7949~tplv-k3u1fbpfcp-zoom-1.image)\n\n## ❤️ 爱心三连击\n\n1.如果觉得这篇文章还不错，来个<b style=\"color: #ff6441\">分享、点赞、在看</b>三连吧，让更多的人也看到～\n\n2.关注公众号<b style=\"color: #ff6441\">前端森林</b>，定期为你推送新鲜干货好文。\n\n3.特殊阶段，带好口罩，做好个人防护。\n", "user_name": "前端森林", "description": "「前端森林」公众号作者，支持文章投稿及相互开白名单", "got_view_count": 134115, "category_name": "前端", "ctime": 1457483942}
{"tag_name": "React.js", "concern_user_count": 199177, "user_id": "4265760847567016", "title": "React Fiber 源码解析", "mark_content": "\n> 图片作者：Artem Sapegin，来源：https://unsplash.com/photos/b18TRXc8UPQ\n\n> 本文作者：刘鹏\n\n## 前言\n\n在 React v16.13 版本中，正式推出了实验性的 Concurrent Mode，尤其是提供一种新的机制 Suspense，非常自然地解决了一直以来存在的异步副作用问题。结合前面 v16.8 推出的 Hooks，v16.0 底层架构 Fiber，React 给开发者体验上带来了极大提升以及一定程度上更佳的用户体验。所以，对 React 17，你会有什么期待？\n\n## Stack Reconciler 和  Fiber Reconciler\n\n我们知道，Stack Reconciler 是 React v15 及之前版本使用的协调算法。而 React Fiber 则是从 v16 版本开始对 Stack Reconciler 进行的重写，是 v16 版本的核心算法实现。\nStack Reconciler 的实现使用了同步递归模型，该模型依赖于内置堆栈来遍历。React 团队 Andrew 之前有提到：\n\n> 如果只依赖内置调用堆栈，那么它将一直工作，直到堆栈为空，如果我们可以随意中断调用堆栈并手动操作堆栈帧，这不是很好吗? 这就是 React Fiber 的目标。Fiber 是内置堆栈的重新实现，专门用于 React 组件，可以将一个 fiber 看作是一个虚拟堆栈帧。\n\n正是由于其内置 Stack Reconciler 天生带来的局限性，使得 DOM 更新过程是同步的。也就是说，在虚拟 DOM 的比对过程中，如果发现一个元素实例有更新，则会立即同步执行操作，提交到真实 DOM 的更改。这在动画、布局以及手势等领域，可能会带来非常糟糕的用户体验。因此，为了解决这个问题，React 实现了一个虚拟堆栈帧。实际上，这个所谓的虚拟堆栈帧本质上是建立了多个包含节点和指针的链表数据结构。每一个节点就是一个 fiber 基本单元，这个对象存储了一定的组件相关的数据域信息。而指针的指向，则是串联起整个 fibers 树。重新自定义堆栈带来显而易见的优点是，可以将堆栈保留在内存中，在需要执行的时候执行它们，这使得暂停遍历和停止堆栈递归成为可能。\n\nFiber 的主要目标是实现虚拟 DOM 的增量渲染，能够将渲染工作拆分成块并将其分散到多个帧的能力。在新的更新到来时，能够暂停、中止和复用工作，能为不同类型的更新分配优先级顺序的能力。理解 React 运行机制对我们更好理解它的设计思想以及后续版本新增特性，比如 v17 版本可能带来的异步渲染能力，相信会有很好的帮助。本文基于 React v16.8.6 版本源码，输出一些浅见，希望对你也有帮助，如有不对，还望指正。\n\n## 基础概念\n\n在了解 React Fiber 架构的实现机制之前，有必要先把几个主要的基础概念抛出来，以便于我们更好地理解。\n\n### Work\n\n在 React Reconciliation 过程中出现的各种必须执行计算的活动，比如 state update，props update 或 refs update 等，这些活动我们可以统一称之为 work。\n\n### Fiber 对象\n\n> 文件位置：packages/react-reconciler/src/ReactFiber.js\n\n每一个 React 元素对应一个 fiber 对象，一个 fiber 对象通常是表征 work 的一个基本单元。fiber 对象有几个属性，这些属性指向其他 fiber 对象。\n\n-   child： 对应于父 fiber 节点的子 fiber\n-   sibling： 对应于 fiber 节点的同类兄弟节点\n-   return： 对应于子 fiber 节点的父节点\n\n因此 fibers 可以理解为是一个包含 React 元素上下文信息的数据域节点，以及由 child, sibling 和 return 等指针域构成的链表结构。\n\nfiber 对象主要的属性如下所示：\n\n```javascript\nFiber = {\n    // 标识 fiber 类型的标签，详情参看下述 WorkTag\n    tag: WorkTag,\n\n    // 指向父节点\n    return: Fiber | null,\n\n    // 指向子节点\n    child: Fiber | null,\n\n    // 指向兄弟节点\n    sibling: Fiber | null,\n\n    // 在开始执行时设置 props 值\n    pendingProps: any,\n\n    // 在结束时设置的 props 值\n    memoizedProps: any,\n\n    // 当前 state\n    memoizedState: any,\n\n    // Effect 类型，详情查看以下 effectTag\n    effectTag: SideEffectTag,\n\n    // effect 节点指针，指向下一个 effect\n    nextEffect: Fiber | null,\n\n    // effect list 是单向链表，第一个 effect\n    firstEffect: Fiber | null,\n\n    // effect list 是单向链表，最后一个 effect\n    lastEffect: Fiber | null,\n\n    // work 的过期时间，可用于标识一个 work 优先级顺序\n    expirationTime: ExpirationTime,\n};\n```\n\n从 React 元素创建一个 fiber 对象\n\n> 文件位置：react-reconciler/src/ReactFiber.js\n\n```javascript\nexport function createFiberFromElement(\n    element: ReactElement,\n    mode: TypeOfMode,\n    expirationTime: ExpirationTime\n): Fiber {\n    const fiber = createFiberFromTypeAndProps(type, key, pendingProps, owner, mode, expirationTime);\n    return fiber;\n}\n```\n\n### workTag\n\n> 文件位置：shared/ReactWorkTags.js\n\n上述 fiber 对象的 tag 属性值，称作 workTag，用于标识一个 React 元素的类型，如下所示：\n\n```javascript\nexport const FunctionComponent = 0;\nexport const ClassComponent = 1;\nexport const IndeterminateComponent = 2; // Before we know whether it is function or class\nexport const HostRoot = 3; // Root of a host tree. Could be nested inside another node.\nexport const HostPortal = 4; // A subtree. Could be an entry point to a different renderer.\nexport const HostComponent = 5;\nexport const HostText = 6;\nexport const Fragment = 7;\nexport const Mode = 8;\nexport const ContextConsumer = 9;\nexport const ContextProvider = 10;\nexport const ForwardRef = 11;\nexport const Profiler = 12;\nexport const SuspenseComponent = 13;\nexport const MemoComponent = 14;\nexport const SimpleMemoComponent = 15;\nexport const LazyComponent = 16;\nexport const IncompleteClassComponent = 17;\nexport const DehydratedSuspenseComponent = 18;\nexport const EventComponent = 19;\nexport const EventTarget = 20;\nexport const SuspenseListComponent = 21;\n```\n\n### EffectTag\n\n> 文件位置：shared/ReactSideEffectTags.js\n\n上述 fiber 对象的 effectTag 属性值，每一个 fiber 节点都有一个和它相关联的 effectTag 值。  \n我们把不能在 render 阶段完成的一些 work 称之为副作用，React 罗列了可能存在的各类副作用，如下所示：\n\n```javascript\nexport const NoEffect = /*              */ 0b000000000000;\nexport const PerformedWork = /*         */ 0b000000000001;\n\nexport const Placement = /*             */ 0b000000000010;\nexport const Update = /*                */ 0b000000000100;\nexport const PlacementAndUpdate = /*    */ 0b000000000110;\nexport const Deletion = /*              */ 0b000000001000;\nexport const ContentReset = /*          */ 0b000000010000;\nexport const Callback = /*              */ 0b000000100000;\nexport const DidCapture = /*            */ 0b000001000000;\nexport const Ref = /*                   */ 0b000010000000;\nexport const Snapshot = /*              */ 0b000100000000;\nexport const Passive = /*               */ 0b001000000000;\n\nexport const LifecycleEffectMask = /*   */ 0b001110100100;\nexport const HostEffectMask = /*        */ 0b001111111111;\n\nexport const Incomplete = /*            */ 0b010000000000;\nexport const ShouldCapture = /*         */ 0b100000000000;\n```\n\n### Reconciliation 和 Scheduling\n\n协调（Reconciliation）：  \n简而言之，根据 diff 算法来比较虚拟 DOM，从而可以确认哪些部分的 React 元素需要更改。\n\n调度（Scheduling）：  \n可以简单理解为是一个确定在什么时候执行 work 的过程。\n\n### Render 阶段和 Commit 阶段\n\n相信很多同学都看过这张图，这是 React 团队作者 Dan Abramov 画的一张生命周期阶段图，[详情点击查看](https://twitter.com/dan_abramov/status/981712092611989509?lang=en)。他把 React 的生命周期主要分为两个阶段：render 阶段和 commit 阶段。其中 commit 阶段又可以细分为 pre-commit 阶段和 commit 阶段，如下图所示：\n\n![image.png](https://p1.music.126.net/sxGbXXgh_vcsGIBSpgzUwQ==/109951165071751568.png)\n\n从 v16.3 版本开始，在 render 阶段，以下几个生命周期被认为是不安全的，它们将在未来的版本中被移除，可以看到这些生命周期在上图中未被包括进去，如下所示：\n\n-   [UNSAFE_]componentWillMount (deprecated)\n-   [UNSAFE_]componentWillReceiveProps (deprecated)\n-   [UNSAFE_]componentWillUpdate (deprecated)\n\n在 React 官网中明确提到了废弃的原因，这些被标记为不安全的生命周期由于常常被开发者错误理解甚至被滥用，比如一些开发人员会倾向于将带有请求数据等副作用的逻辑放在这些生命周期方法中，认为能带来更好的性能，而实际上真正带来的收益几乎可以忽略。在未来， React 逐步推崇异步渲染模式下，这很有可能会因为不兼容而带来很多问题。\n\n在 render 阶段，React 可以根据当前可用的时间片处理一个或多个 fiber 节点，并且得益于 fiber 对象中存储的元素上下文信息以及指针域构成的链表结构，使其能够将执行到一半的工作保存在内存的链表中。当 React 停止并完成保存的工作后，让出时间片去处理一些其他优先级更高的事情。之后，在重新获取到可用的时间片后，它能够根据之前保存在内存的上下文信息通过快速遍历的方式找到停止的 fiber 节点并继续工作。由于在此阶段执行的工作并不会导致任何用户可见的更改，因为并没有被提交到真实的 DOM。所以，我们说是 fiber 让调度能够实现暂停、中止以及重新开始等增量渲染的能力。相反，在 commit 阶段，work 执行总是同步的，这是因为在此阶段执行的工作将导致用户可见的更改。这就是为什么在 commit 阶段， React 需要一次性提交并完成这些工作的原因。\n\n### Current 树和 WorkInProgress 树\n\n首次渲染之后，React 会生成一个对应于 UI 渲染的 fiber 树，称之为 current 树。实际上，React 在调用生命周期钩子函数时就是通过判断是否存在 current 来区分何时执行 componentDidMount 和 componentDidUpdate。当 React 遍历 current 树时，它会为每一个存在的 fiber 节点创建了一个替代节点，这些节点构成一个 workInProgress 树。后续所有发生 work 的地方都是在 workInProgress 树中执行，如果该树还未创建，则会创建一个 current 树的副本，作为 workInProgress 树。当 workInProgress 树被提交后将会在 commit 阶段的某一子阶段被替换成为 current 树。\n\n这里增加两个树的主要原因是为了避免更新的丢失。比如，如果我们只增加更新到 workInProgress 树，当 workInProgress 树通过从 current 树中克隆而重新开始时，一些更新可能会丢失。同样的，如果我们只增加更新到 current 树，当 workInProgress 树被提交后会被替换为 current 树，更新也会被丢失。通过在两个队列都保持更新，可以确保更新始终是下一个 workInProgress 树的一部分。并且，因为 workInProgress 树被提交成为 current 树，并不会出现相同的更新而被重复应用两次的情况。\n\n### Effects list\n\neffect list 可以理解为是一个存储 effectTag 副作用列表容器。它是由 fiber 节点和指针 nextEffect 构成的单链表结构，这其中还包括第一个节点 firstEffect，和最后一个节点 lastEffect。如下图所示：\n\n![image.png](https://p1.music.126.net/iLgNdiRLxrM0WZGYA1ORAA==/109951165071746326.png)\n\nReact 采用深度优先搜索算法，在 render 阶段遍历 fiber 树时，把每一个有副作用的 fiber 筛选出来，最后构建生成一个只带副作用的 effect list 链表。  \n在 commit 阶段，React 拿到 effect list 数据后，通过遍历 effect list，并根据每一个 effect 节点的 effectTag 类型，从而对相应的 DOM 树执行更改。\n\n更多 effect list 构建演示流程，可以点击查看动画 [《Effect List —— 又一个 Fiber 链表的构建过程》](https://www.bilibili.com/video/av48384879/)。\n\n## Render 阶段\n\n在本文中，我们以类组件为例，假设已经开始调用了一个 setState 方法。\n\n### enqueueSetState\n\n每个 React 组件都有一个相关联的 updater，作为组件层和核心库之间的桥梁。  \nreact.Component 本质上就是一个函数，在它的原型对象上挂载了 setState 方法\n\n> 文件位置：react/src/ReactBaseClasses.js\n\n```javascript\n// Component函数\nfunction Component(props, context, updater) {\n    this.props = props;\n    this.context = context;\n    this.updater = updater || ReactNoopUpdateQueue;\n}\n\n// Component原型对象挂载 setState\nComponent.prototype.setState = function (partialState, callback) {\n    this.updater.enqueueSetState(this, partialState, callback, 'setState');\n};\n```\n\nReact 给 work 大致分成以下几种优先级类型，其中 immediate 比较特殊，它的优先级最高，可以理解为是同步调度，调度过程中不会被中断。\n\n```javascript\nexport const NoPriority = 0;\nexport const ImmediatePriority = 1;\nexport const UserBlockingPriority = 2;\nexport const NormalPriority = 3;\nexport const LowPriority = 4;\nexport const IdlePriority = 5;\n```\n\nReact 有一套计算逻辑，根据不同的优先级类型为不同的 work 计算出一个过期时间 expirationTime，其实就是一个时间戳。所谓的 React 在新的更新到来时，能为不同类型的更新分配优先级顺序的能力，本质上是根据过期时间 expirationTime 的大小来确定优先级顺序，expirationTime 数值越小，则优先级越高。在相差一定时间范围内的 work，React 会认为它们是同一个批次（batch）的，因此这一批次的 work 会在一次更新中完成。\n\n> 文件位置：react-reconciler/src/ReactFiberClassComponent.js\n\n```javascript\nconst classComponentUpdater = {\n    enqueueSetState(inst, payload, callback) {\n        // 获取 fiber 对象\n        const fiber = getInstance(inst);\n        const currentTime = requestCurrentTime();\n\n        // 计算到期时间 expirationTime\n        const expirationTime = computeExpirationForFiber(currentTime, fiber, suspenseConfig);\n\n        const update = createUpdate(expirationTime, suspenseConfig);\n        // 插入 update 到队列\n        enqueueUpdate(fiber, update);\n        // 调度 work 方法\n        scheduleWork(fiber, expirationTime);\n    },\n};\n```\n\n### renderRoot\n\n> 文件位置：react-reconciler/src/ReactFiberWorkLoop.js\n\n协调过程总是 renderRoot 开始，方法调用栈：scheduleWork -->  scheduleCallbackForRoot  --> renderRoot\n\n代码如下：\n\n```javascript\nfunction renderRoot(\n  root: FiberRoot,\n  expirationTime: ExpirationTime,\n  isSync: boolean,\n) | null {\n  do {\n    // 优先级最高，走同步分支\n    if (isSync) {\n      workLoopSync();\n    } else {\n      workLoop();\n    }\n  } while (true);\n}\n\n// 所有的fiber节点都在workLoop 中被处理\nfunction workLoop() {\n  while (workInProgress !== null && !shouldYield()) {\n    workInProgress = performUnitOfWork(workInProgress);\n  }\n}\n```\n\n### performUnitOfWork\n\n所有的 fiber 节点都在 workLoop 方法处理。协调过程总是从最顶层的 hostRoot 节点开始进行 workInProgress 树的遍历。但是，React 会跳过已经处理过的 fiber 节点，直到找到还未完成工作的节点。例如，如果在组件树的深处调用 setState，React 将从顶部开始，但会快速跳过父节点，直到到达调用了 setState 方法的组件。整个过程采用的是深度优先搜索算法，处理完当前 fiber 节点后，workInProgress 将包含对树中下一个 fiber 节点的引用，如果下一个节点为 null 不存在，则认为执行结束退出 workLoop 循环并准备进行一次提交更改。\n\n方法调用栈如下：\nperformUnitOfWork  -->  beginWork -->  updateClassComponent --> finishedComponent --> completeUnitOfWork\n\n代码如下所示：\n\n> 文件位置：react-reconciler/src/ReactFiberWorkLoop.js\n\n```javascript\nfunction performUnitOfWork(unitOfWork: Fiber): Fiber | null {\n    const current = unitOfWork.alternate;\n\n    let next;\n    next = beginWork(current, unitOfWork, renderExpirationTime);\n\n    // 如果没有新的 work，则认为已完成当前工作\n    if (next === null) {\n        next = completeUnitOfWork(unitOfWork);\n    }\n\n    return next;\n}\n```\n\n了解树的深度优先搜索算法，可点击参考该示例 [《js-ntqfill》](https://stackblitz.com/edit/js-ntqfil?file=index.js)。\n\n### completeUnitOfWork\n\n> 文件位置：react-reconciler/src/completeUnitOfWork.js\n\n在 completeUnitOfWork 方法中构建 effect-list 链表，该 effect list 在下一个 commit 阶段非常重要，关于 effect list 上述有介绍。\n\n如下所示：\n\n```javascript\nfunction completeUnitOfWork(unitOfWork: Fiber): Fiber | null {\n    // 深度优先搜索算法\n    workInProgress = unitOfWork;\n    do {\n        const current = workInProgress.alternate;\n        const returnFiber = workInProgress.return;\n\n        /*\n    \t构建 effect-list部分\n    */\n        if (returnFiber.firstEffect === null) {\n            returnFiber.firstEffect = workInProgress.firstEffect;\n        }\n        if (workInProgress.lastEffect !== null) {\n            if (returnFiber.lastEffect !== null) {\n                returnFiber.lastEffect.nextEffect = workInProgress.firstEffect;\n            }\n            returnFiber.lastEffect = workInProgress.lastEffect;\n        }\n\n        if (returnFiber.lastEffect !== null) {\n            returnFiber.lastEffect.nextEffect = workInProgress;\n        } else {\n            returnFiber.firstEffect = workInProgress;\n        }\n        returnFiber.lastEffect = workInProgress;\n\n        const siblingFiber = workInProgress.sibling;\n        if (siblingFiber !== null) {\n            // If there is more work to do in this returnFiber, do that next.\n            return siblingFiber;\n        }\n        // Otherwise, return to the parent\n        workInProgress = returnFiber;\n    } while (workInProgress !== null);\n}\n```\n\n至此，一个 render 阶段大概流程结束。\n\n## Commit 阶段\n\ncommit 阶段是 React 更新真实 DOM 并调用 pre-commit phase 和 commit phase 生命周期方法的地方。与 render 阶段不同，commit 阶段的执行始终是同步的，它将依赖上一个 render 阶段构建的 effect list 链表来完成。\n\n### commitRootImpl\n\ncommit 阶段实质上被分为如下三个子阶段：\n\n-   before mutation\n-   mutation phase\n-   layout phase\n\nmutation 阶段主要做的事情是遍历 effect-list 列表，拿到每一个 effect 存储的信息，根据副作用类型 effectTag 执行相应的处理并提交更新到真正的 DOM。所有的 mutation effects 都会在 layout phase 阶段之前被处理。当该阶段执行结束时，workInProgress 树会被替换成 current 树。因此在 mutation phase 阶段之前的子阶段 before mutation，是调用 getSnapshotBeforeUpdate 生命周期的地方。在 before mutation 这个阶段，真正的 DOM 还没有被变更。最后一个子阶段是 layout phase，在这个阶段生命周期 componentDidMount/Update 被执行。\n\n> 文件位置：react-reconciler/src/ReactFiberWorkLoop.js\n\n如下所示：\n\n```javascript\nfunction commitRootImpl(root) {\n    if (firstEffect !== null) {\n        // before mutation 阶段，遍历 effect list\n        do {\n            try {\n                commitBeforeMutationEffects();\n            } catch (error) {\n                nextEffect = nextEffect.nextEffect;\n            }\n        } while (nextEffect !== null);\n\n        // the mutation phase 阶段，遍历 effect list\n        nextEffect = firstEffect;\n        do {\n            try {\n                commitMutationEffects();\n            } catch (error) {\n                nextEffect = nextEffect.nextEffect;\n            }\n        } while (nextEffect !== null);\n\n        // 将 work-in-progress 树替换为 current 树\n        root.current = finishedWork;\n\n        // layout phase 阶段，遍历 effect list\n        nextEffect = firstEffect;\n        do {\n            try {\n                commitLayoutEffects(root, expirationTime);\n            } catch (error) {\n                captureCommitPhaseError(nextEffect, error);\n                nextEffect = nextEffect.nextEffect;\n            }\n        } while (nextEffect !== null);\n\n        nextEffect = null;\n    } else {\n        // No effects.\n        root.current = finishedWork;\n    }\n}\n```\n\n### commitBeforeMutationEffects\n\nbefore mutation 调用链路：commitRootImpl -->  commitBeforeMutationEffects --> commitBeforeMutationLifeCycles\n\n代码如下：\n\n```javascript\nfunction commitBeforeMutationLifeCycles(\n  current: Fiber | null,\n  finishedWork: Fiber,\n): void {\n  switch (finishedWork.tag) {\n    case FunctionComponent:\n    case ForwardRef:\n    case SimpleMemoComponent:\n    ...\n    // 属性 stateNode 表示对应组件的实例\n    // 在这里 class 组件实例执行 instance.getSnapshotBeforeUpdate()\n    case ClassComponent: {\n      if (finishedWork.effectTag & Snapshot) {\n        if (current !== null) {\n          const prevProps = current.memoizedProps;\n          const prevState = current.memoizedState;\n          const instance = finishedWork.stateNode;\n          const snapshot = instance.getSnapshotBeforeUpdate(\n            finishedWork.elementType === finishedWork.type\n              ? prevProps\n              : resolveDefaultProps(finishedWork.type, prevProps),\n            prevState,\n          );\n\n          instance.__reactInternalSnapshotBeforeUpdate = snapshot;\n        }\n      }\n      return;\n    }\n    case HostRoot:\n    case HostComponent:\n    case HostText:\n    case HostPortal:\n    case IncompleteClassComponent:\n      ...\n  }\n}\n```\n\n### commitMutationEffects\n\n> 文件位置：react-reconciler/src/ReactFiberWorkLoop.js\n\nmutation phase 阶段调用链路：\ncommitRootImpl -->  commitMutationEffects --> commitWork\n\n代码如下：\n\n```javascript\nfunction commitMutationEffects() {\n  while (nextEffect !== null) {\n    const effectTag = nextEffect.effectTag;\n\n    let primaryEffectTag = effectTag & (Placement | Update | Deletion);\n    switch (primaryEffectTag) {\n      case Placement:\n        ...\n      case PlacementAndUpdate:\n        ...\n      case Update: {\n        const current = nextEffect.alternate;\n        commitWork(current, nextEffect);\n        break;\n      }\n      case Deletion: {\n        commitDeletion(nextEffect);\n        break;\n      }\n    }\n  }\n}\n```\n\n### commitLayoutEffects\n\n> 文件位置：react-reconciler/src/ReactFiberCommitWork.js\n\nlayout phase 调用链路：commitRootImpl -->  commitLayoutEffects --> commitLifeCycles\n\n代码如下：\n\n```javascript\nfunction commitLifeCycles(\n  finishedRoot: FiberRoot,\n  current: Fiber | null,\n  finishedWork: Fiber,\n  committedExpirationTime: ExpirationTime,\n): void {\n  switch (finishedWork.tag) {\n    case FunctionComponent:\n    case ForwardRef:\n    case SimpleMemoComponent:\n      ...\n    case ClassComponent: {\n      // 属性 stateNode 表示对应组件的实例\n      // 在这里 class 组件实例执行 componentDidMount/DidUpdate\n      const instance = finishedWork.stateNode;\n      if (finishedWork.effectTag & Update) {\n        // 首次渲染时，还没有 current 树\n        if (current === null) {\n          instance.componentDidMount();\n        } else {\n          const prevProps =\n            finishedWork.elementType === finishedWork.type\n              ? current.memoizedProps\n              : resolveDefaultProps(finishedWork.type, current.memoizedProps);\n          const prevState = current.memoizedState;\n          instance.componentDidUpdate(\n            prevProps,\n            prevState,\n            instance.__reactInternalSnapshotBeforeUpdate,\n          );\n        }\n      }\n      const updateQueue = finishedWork.updateQueue;\n      if (updateQueue !== null) {\n        commitUpdateQueue(\n          finishedWork,\n          updateQueue,\n          instance,\n          committedExpirationTime,\n        );\n      }\n      return;\n    }\n    case HostRoot:\n    case HostComponent:\n    case HostText:\n    case HostPortal:\n    case Profiler:\n    case SuspenseComponent:\n    case SuspenseListComponent:\n      ...\n  }\n}\n```\n\n## 扩展\n\n以下是一些关于 Fiber 的扩展内容。\n\n### 调用链路\n\n如下图所示，根据 React 源码绘制的调用链路图，主要罗列了一些比较重要的函数方法，可作为大家了解 Fiber 的参考。源码调试过程可以找到对应的函数方法打断点，以了解实际运行的过程，便于更好梳理出各个逻辑方法之间的关系。\n\n![fiber调用链路.jpg](https://p1.music.126.net/VU37zHp-6hAUfNaZbu3HRw==/109951165071751567.jpg)\n\n### requestIdleCallback\n\n之前有文章在总结 React Fiber 的调度原理时提到，客户端线程执行任务时会以帧的形式划分，在两个执行帧之间，主线程通常会有一小段空闲时间，在这个空闲期触发 requestIdleCallback 方法，能够执行一些优先级较低的 work。\n\n据说在早期的 React 版本上确实是这么做的，但使用 requestIdleCallback 实际上有一些限制，执行频次不足，以致于无法实现流畅的 UI 渲染，扩展性差。因此 React 团队放弃了 requestIdleCallback 用法，实现了自定义的版本。比如，在发布 v16.10 版本中，推出实验性的 Scheduler，尝试使用 postMessage 来代替 requestAnimationFrame。更多了解可以查看 React 源码 packages/scheduler 部分。\n\n## 小结\n\nFiber 由来已久，可以说是 React 设计思想的一个典型表现。相比业界其他流行库更多采用当新数据到达时再计算模式，React 坚持拉取模式，即能够把计算资源延迟到必要时候再用，并且它知道，什么时候更适合执行，什么时候不执行。看起来虽然只是微小的区别，却意义很大。随着后续异步渲染能力等新特性的推出，我们有理由相信，在未来，React 将会在人机交互的应用中给我们带来更多的惊喜。\n\n## 参考\n\n-   [react-fiber-architecture](https://github.com/acdlite/react-fiber-architecture)\n-   [In-depth explanation of state and props update in react](https://medium.com/react-in-depth/in-depth-explanation-of-state-and-props-update-in-react-51ab94563311)\n-   [in-depth overview of the new reconciliation algorithm in react](https://medium.com/react-in-depth/inside-fiber-in-depth-overview-of-the-new-reconciliation-algorithm-in-react-e1c04700ef6e)\n-   [The how and why on React’s usage of linked list in Fiber to walk the component’s tree](https://medium.com/react-in-depth/in-depth-explanation-of-state-and-props-update-in-react-51ab94563311)\n-   [Effect List —— 又一个 Fiber 链表的构建过程](https://www.bilibili.com/video/av48384879/)\n-   [js-ntqfill](https://stackblitz.com/edit/js-ntqfil?file=index.js)\n\n> 本文发布自 [网易云音乐大前端团队](https://github.com/x-orpheus)，文章未经授权禁止任何形式的转载。我们常年招收前端、iOS、Android，如果你准备换工作，又恰好喜欢云音乐，那就加入我们 grp.music-fe(at)corp.netease.com！\n", "user_name": "网易云音乐大前端团队", "description": "", "got_view_count": 229068, "category_name": "前端", "ctime": 1457483942}
{"tag_name": "前端", "concern_user_count": 455667, "user_id": "395479919373991", "title": "一份优秀的前端开发工程师简历是怎么样的？", "mark_content": "![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7ce90573b81246ba9bfbc98bcbc01a13~tplv-k3u1fbpfcp-zoom-1.image)\n作者|沈砾捷(磐冲)\n\n编辑|橙子君\n\n出品|阿里巴巴新零售淘系技术\n\n家是否有这样的困惑？在公司跟了几个项目，可能就是组长跟我们说下需求然后就开始动手写页面，也不用自己选型，脚手架也是现成的，除了 Vue 就是拿Echarts写过图表都没什么技术含量，照着文档写，遇到问题查一下就解决了。但写简历时又要体现出在项目中的作用。怎样找到只属于自己的那些亮点呢？\n\n# 你负责的业务是什么？(学会发现问题)\n\n我接触过不少同学，有说在小公司，被业务需求压着。既然大家都说在做业务，那么，正看到这里的你，能不能5分钟说明白，你负责的业务是什么？\n\n这个问题我在活动群的 github issue 活动中，带有业务理解标签的题目里经常会问到，可是大部分同学都没有说到位，甚至答非所问。\n\n这里谈谈我个人对业务的理解，或许没有普遍意义，所以仅供参考。\n\n\n## 业务最核心的要素是业务本身的价值\n\n一家公司，或者一个部门，做的事情有许许多多，零零散散。也有很多事情合到一起，促成了一件大事的时候。那么，我们是把那些零散的事情都看成业务？还是只把那一件大事看成业务呢？我认为都可以。决定权在于这件事是否逻辑自洽，以及是否具有独特的价值。\n\n接下来让我们拿着一个例子来说，假设你在开发一个营销活动页，这个页面能够给公司带来3000人的新用户，这些人有可能会购买公司的产品，从而带来收入。\n\n这里明显可以感受到，营销是一个业务线，他的商业逻辑是投放页面 -> 拉新回流 -> 商品销售，价值在于新用户的触达，以及商品销售利益。基于这两点，我们就值得投入精力，因为做的越好，公司业绩越好。\n\n## 那么，做个页面就是亮点了？\n\n当然不是，但是亮点已经离我们很近了。如果你想要有亮点，那你需要保持思考。在上面的例子中，我们有许多可以优化和验证的事情。\n\n1、营销页每天换内容，怎么快速替换？\n\n2、营销部门人越来越多了，页面每天要10个，一个人怎么做得完？\n\n3、前端的人也越来越多了，改个组件不能只靠复制黏贴，怎么管理？\n\n4、拉新回流效率具体有多高？新人真的有买我们的商品吗？这么多人投入，都是要工资的，卖出去的商品能够发我们的工资吗？\n\n5、转化率低了，怎么才能提升？\n\n6、这个按钮写错个样式到了右边，居然点的人特别多？那下次是不是都应该放右边？\n\n上面列举的几个问题，估计很多同学日常都有做类似的事情。但问题是，这些事情是你想做的，还是产品让你做的？这些事情能诞生什么出来呢？\n\n1、运营配置后台与投放策略\n\n2、营销搭建体系\n\n3、工程化研发套件\n\n4、业务埋点与数据分析系统\n\n5、数据仓库与数据分析后台\n\n6、A/B test系统\n\n至少在我看来，如果面试的同学上来自我介绍的时候，能够讲一下上面例子中遇到的问题，之后再说做了下面对应的某一个系统，那么，这就是绝对够分量的亮点。只可惜这样的同学少之又少，大部分同学是因为产品说要做就去做了。\n\n所以，你真的想过业务是什么吗？有为业务想过什么吗？有了你，业务有什么不同吗？\n\n\n# 可以开始写代码了？(学会思考的方式)\n\n\n好了，假设我们思考了一下，想了点东西出来，接下来我们可以开始写代码了.....吗？\n\n\n做一个有亮点的技术产出，可不是撸起袖子就能快速干出来的，当然，如果你是个天才，那请自便。如果和我一样是普通人，那么请先做好技术方案设计。而设计的第一步，就是做一个ppt工程师，画图。\n\n\n## 图，是思想的结晶\n\n在上面提到过的github issue活动里，大部分同学的业务大图或者技术架构图，都没法说明白先表达的意思。\n\n几个最典型的问题是：\n\n\n**1、思路混乱：** 下面几个框在写业务的系统，上面画了一个vue或者webpack的框。\n\n**2、层级混乱：** 底层写的是native容器，上层画了个api gateway。\n\n**3、答非所问：** 要求画业务大图，结果画了一堆前端脚手架的关键字，或者画成了流程图。\n\n如果看到这里，不明白画图是干什么的同学，可以去查一下架构图是什么，以及如何做程序设计。这经常是被大家忽略的事情，虽然很多同学在大学里学习的时候，都学过相关的课程，但是估计大部分都还回去了。\n\n\n\n## 怎么画好一张图？\n\n这里不做具体的展开，毕竟我自己也不是画图高手，每次画图也是迟迟不知如何下笔。只给到几个建议，供大家参考。\n\n同时，以一个模拟面试同学的案例来做参考。\n\n原图：\n\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ac5c272f65024ddfbd70206363da44b8~tplv-k3u1fbpfcp-zoom-1.image)\n\n\n**第一步，先想明白这张图要表达什么？**\n\n\n这位同学说他参加过很多技术会议，看那些分享的ppt里面的大图，都很酷炫，自己平时也有总结(这点非常好)，但是总画不出那种图来。面试过程中我问了这位同学，这张图他想表达什么，答案是他想说明白消息通信业务的技术方案。但是，这张图并不能表达出一个技术方案来。\n\n\n\n这张图第一个问题是不够完整，他只有一条主链路，对于IM这样的复杂技术产品，主链路只是冰山一角，如果真的只做了主链路，那么代表思考不够，早晚会出现线上故障。\n\n\n\n第二个问题在于含义不明与层次混乱。最下面的UI层有个箭头指向存储层，那是指渲染进程会去调用localStorage？那再向上2级的网关层呢？UI层会调用网关层？这里显然逻辑是不通顺的。\n\n\n\n**第二步，图里的每一个大块必须是同一个领域或类似概念的，每一个框都有意义**\n\n\n在这个问题上，这位同学做的还是很好的，但也还是有些小问题，比如UI层里的两个进程。这两个框显得意义不明，在没有描述的情况下，至少我是不明白他想表达的意思，而实际在沟通过程中，他也觉得这里挺奇怪的。\n\n\n\n**第三步，画完回顾一下是否描述清楚了第一步里的核心逻辑**\n\n\n很多时候我们一气呵成画了一张大图，结果一不小心容易画成一张流程图，把怎么写代码的思路也画到图上了。这就会导致图上有些地方是模块划分，而有些地方则是细节流程，整体就很失调。这只能通过反复的回顾和思考，进行自我调整了。\n\n\n\n最后，我给出当时模拟面试时，对于这个业务的粗略设想：\n\n\n![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b8cdcaf772bd467fb48bf3bb55a046f1~tplv-k3u1fbpfcp-zoom-1.image)\n\n\n\n\n# 知道原理有什么用？(技术如何赋能)\n\n\n有了大图，我们终于可以开始实现亮点了......吗？\n\n\n现实很残酷，哪怕我们想出了一个大饼，并不代表我们能吃到嘴里，从图变成面饼，我们需要太多的中间步骤。\n\n\n\n而摆在技术人面前的问题是：如果有面粉了，你会揉面吗？你揉面的技术能保证烤出来的饼好吃吗？\n\n\n\n## 知其然，而后使其然\n\n\n我认为这就是为什么我们要了解原理。曾经有一位模拟面试的同学，在最后互问互答的时候问了我一个问题，怎么看待面试造火箭，平时拧螺丝？我觉得有点冤枉，因为一面大部分问的都是怎么拧螺丝，以及螺丝的型号，二面开始也就问问怎么造飞机，但是真的进入工作状态，阿里的场景里，至少在我们团队的场景里，我们就是在造火箭，只是造火箭的时候必须要拧拧螺丝，没螺丝你敢上？\n\n\n\n有同学又不服了，我会拧螺丝，和我需要知道用什么螺丝有什么关系。那么上面那个烤饼，你能告诉我放白芝麻好吃还是放黑芝麻好吃吗？我相信大厨一定能回答上来，他甚至连小麦原产地都会和你掰扯一下。为什么到了同样需要匠心的编码领域，我们就不用关心用什么螺丝了呢？\n\n\n\n当时我给这个同学举了个实际的例子：简历中有提到上传，那你能不能当场告诉我，这个上传是服务端http接口配合你上传，还是用阿里云oss？用oss是服务端每次加签，还是用sts，还是前端直接加签？http上传你用什么contentType？用form表单组件提交还是自己通过xhr发送？如果需要登录鉴权怎么办？如果出现跨域问题怎么办？两种场景都有，都要实现，怎么封装组件？\n\n\n\n什么？你说你要百度一下？你要百度一天？那我为什么不聘用那个不用百度的人呢？一天的工资算上5金这些成本，月薪20k来算，估计也得有小2000了，如果我把这2000增加到一个懂原理的大神手里，我们岂不是双赢，为什么要等你去搜索呢？只是个简单的上传文件功能，也就是页面里的一个豆腐块，这么小的螺丝，里面却有大大的学问。而日常工作中我们遇到类似的问题有非常多，具体可以参考我上一篇文章的解读，这里就不重复了。\n\n\n\n## 任务的拆解\n\n\n对于平时愿意学习的同学，到这一步可能开始陷入迷茫了，我之前也遇到过类似的困惑，那就是：要不要造轮子\n\n\n\n我们经常会发现好像什么都能做，比如：你有的，我改改也能实现；社区有个差不多能用的，要不要直接用；好像大图上都有差不多的，那是不是拼拼凑凑就可以了，这个方案是不是没什么好做的了。\n\n\n\n从我个人来说，每次画图我都会陷入这样的思考，还常常会钻牛角尖，为了整点差异化，故意换一些思路去做，这样能保证这个饼是我的。但最后我都会绕出来，这得益于上面画图的第三步，每次画完我都会重新回顾一下我真正想做的事情是什么。我认为这也是是否造轮子的一个评判标准：从业务的价值出发，思考真正核心的目标，并且为之努力，如果有现成的轮子，能满足业务核心诉求，那就放手去用。\n\n\n\n首先，现实往往是这样的，当我们放手去用的时候，会发现这个轮子好像不那么好用，或者这个轮子没人维护了，又或者业务变化太快，轮子自己觉得顶不住了。机会自然会来到身边，而触发这些机会的，是我们不断的站在业务的视角去思考问题，业务的变化一定比一个平台化的轮子要来得快。\n\n\n\n其次，真正核心的系统一定是紧贴业务，而且很难大范围复用的，好的技术架构在设计的时候，讲究的是够用即可，过度设计大部分就是没用的设计。在之后的迭代中，会随着业务的不断变化，被带动着自我进化，那最终的产物也自然是和业务形态非常贴合。所以，我个人在选择的时候，一些核心的轮子，该造就造起来，但这些轮子一定是带有业务特色的，比如我会去造一个业务组件库，但是我绝不会去造一个antd。\n\n\n\n最后，随着事物的演变，分久必合合久必分，单一业务用的好的系统一定是可以在更高的视角上抽象、整合的，在整个过程中，每个人的成长就会是我们想要的亮点了。或许在简历上你写下的是一个已经废弃的系统，但是它的灵魂在你心里，也存在于把他整合了的系统里，这种亮点在个人介绍的时候，一定是能侃侃而谈的。\n\n\n\n\n\n# 从1到10能做什么？(思考方式的抽象)\n\n\n终于，我们经历的各种抉择，投入了大量的时间，把一个亮点做出来了，完成了美好的从0到1，可有时候我们会发现的问题：从0到1看上去有很多要做的，做完了，从1到10还能做什么？\n\n\n\n这个问题我个人也没有太多话语权，因为这两年总是在做从0到1的事情，甚至和我老板也聊过这个，总感觉自己没有个确定的事情。从0到1做一次挺爽的，一直做，不会一直爽，却只会让人觉得心慌，毕竟谁能保证永远能想出从0到1的事情呢？\n\n\n\n而静下来反思之后，我发现事情并不是这么一刀切的，谁能说明白现在做的事情是0到1，还是1到10呢？这里的边界其实并没有那么明确，但抽象看，他们都是同一个套路\n\n\n\n**业务/技术思考 => 发现痛点 => 产出方案 => 拆解实现**\n\n\n\n伴随着这个闭环，业务永远在变化，而变化又会带来新的问题，只要保持一个思考的状态，没有必要区分具体再哪个阶段，因为你总能找到可以实现自我价值的地方，发现属于你的亮点。\n\n\n\n\n\n## 阿里巴巴淘宝技术部-躺平技术团队\n\n我在阿里巴巴淘宝技术部-躺平技术团队。目前，躺平正在深耕家居家装行业，纵向深入行业内部，希望能给行业带来一些创新。我们还有更多有趣、充满挑战和超出你想象的业务。\n\n如果你愿意来和我们一起相信，那请发送简历过来，我们一定会一起看见，一起创造无数的亮点！\n\n前端简历请发送到：yefei.niuyf@alibaba-inc.com 或 lijie.slj@alibaba-inc.com\n\n主攻3d方向的同学，简历请发送到：jiangcheng.wxd@alibaba-inc.com\n\njava简历请发送到：xiaoxian.zzy@taobao.com 或 wuxin.sn@taobao.com\n\n客户端简历请发送到：fangying.fy@alibaba-inc.com\n\n", "user_name": "阿里巴巴淘系技术", "description": "如果你也够有好奇心、有恒心、有思考力，希望一起创造时代传奇！ 欢迎加", "got_view_count": 111726, "category_name": "前端", "ctime": 1457483942}
{"tag_name": "JavaScript", "concern_user_count": 343215, "user_id": "1961184474432830", "title": "模板引擎实现原理（Vue篇）", "mark_content": "在 Vue 框架里面内置了一个模板引擎，用于编译 Vue 专有语法，例如：\n\n```html\n<div id=\"app\">\n  你好，{{ message }}！\n  <p v-if=\"seen\" styles=\"color: red; fontSize: 16px\">条件渲染</p>\n  <button v-on:click=\"reverseMessage\">反转消息</button>\n  <ol>\n    <li v-for=\"todo in todos\" class=\"color-gray ml-2\">\n      {{ todo.text }}\n    </li>\n  </ol>\n</div>\n```\n\n这里面有 `{{ message }}`、`v-if`、`v-on:click`、`v-for` 等特殊的语法，Vue 需要把这些内容提取出来，转换成响应式的函数或者对应的 DOM 事件。\n\n在 Vue 中同样是用正则来提取这些内容的，它的转化流程如下：\n\n- 通过正则把模板转换成 AST 抽象语法树\n- 用 AST 生成 JS 代码\n- 用 `new Function` 配合 `with` 来执行 JS 代码\n\n## AST 抽象语法树\n\nAST 中的节点是具有特殊属性的 JS 对象，它的结构大致如下：\n\n```js\n{\n  tag: tagName, // 标签名\n  type: 1, // 元素类型\n  children: [], // 孩子列表\n  attrs, // 属性集合\n  parent: null, // 父元素\n  text: null // 文本节点内容\n  ...\n}\n```\n\n在 AST 抽象语法树中，会按照节点类型的不同进行区分：\n\n- 元素类型\n- 文本类型\n- 注释类型\n- ...\n\n\n## 正则分析\n\n接下来开始用正则对节点进行提取，先看下 Vue 中定义的正则：\n\n```js\nconst ncname = `[a-zA-Z_][\\\\-\\\\.0-9_a-zA-Z]*`; // 标签名\nconst qnameCapture = `((?:${ncname}\\\\:)?${ncname})`; // ?: 表示匹配不捕获\nconst startTagOpen = new RegExp(`^<${qnameCapture}`); // 标签开头的正则 捕获的内容是标签名\nconst endTag = new RegExp(`^<\\\\/${qnameCapture}[^>]*>`); // 匹配标签结尾的 </div>\nconst attribute = /^\\s*([^\\s\"'<>\\/=]+)(?:\\s*(=)\\s*(?:\"([^\"]*)\"+|'([^']*)'+|([^\\s\"'=<>`]+)))?/; // 匹配属性\nconst startTagClose = /^\\s*(\\/?)>/; // 匹配标签结束的 > \n```\n\n### ncname\n\nncname 就是不包含前缀的XML标签名称，规则如下：\n\n> 字母（a-zA-Z）或下划线（_）开头，后面可以跟任意数量的：\n> \n> - 中横线（-）\n> - 点（.）\n> - 数字（0-9）\n> - 下划线（_）\n> - 字母（a-zA-Z）\n\n### qname 和 qnameCapture\n\nqname 是合法的 XML 标签，它的组成规则是 `<前缀:标签名称>`，例如：`<abc:span></abc:span>`，其中前缀可以省略，也就是说，可能是一个 ncname，或者两个 ncname 中间通过冒号拼接起来。\n\n这个正则中冒号和冒号前面的部分是一个非捕获分组，后面的标签名是捕获分组，即可以取到标签名称。\n\n\n### startTagOpen\n\n匹配开始标签，例如 `<div`、`<abc:span`。\n\n\n### endTag\n\n来匹配结束标签\n\n### attribute\n\n```\n/^\\s*([^\\s\"'<>\\/=]+)(?:\\s*(=)\\s*(?:\"([^\"]*)\"+|'([^']*)'+|([^\\s\"'=<>`]+)))?/\n```\n\n这个正则比较长，是用于匹配 HTML 标签属性的，可能的属性写法有：\n\n- 双引号：`class=\"some-class\"`\n- 单引号：`class='some-class'`\n- 不用引号：`class=some-class`\n- 单独的属性名：`disabled`\n\n这个表达式有五个捕获组，第一个捕获组用来匹配属性名，第二个捕获组用来匹配等于号，第三、第四、第五个捕获组都是用来匹配属性值的，同时 ? 表明第三、四、五个分组是可选的。\n\n### startTagClose\n\n用于匹配结束标签，例如：`br />` 或 `/div>`。\n\n## 解析器\n\n利用上面的正则，可以写出下面简化版 AST 解析器：\n\n```js\nfunction parseHTML(html) {\n  let root, parent, stack = []\n  // 只要剩余的 html 不为空就一直解析\n  while (html) {\n    let textEnd = html.indexOf('<')\n    if (textEnd == 0) {\n      const { tag, attrs } = parseStartTag() || {}\n      if (tag) {\n        start(tag, attrs)\n        continue\n      }\n      const endTagMatch = html.match(endTag)\n      if (endTag) {\n        advance(endTagMatch[0].length)\n        end(endTagMatch[1])\n        continue\n      }\n    } else {\n      const text = textEnd > 0 ? html.substring(0, textEnd) : html\n      advance(text.length)\n      chars(text)\n    }\n  }\n  // 获取截取后剩余的html\n  function advance(n) {\n    html = html.substring(n)\n  }\n  // 解析开始标签\n  function parseStartTag() {\n    const start = html.match(startTagOpen)\n    if (start) {\n      const match = { tag: start[1], attrs: [] }\n      advance(start[0].length)\n      let end, attr\n      while (!(end = html.match(startTagClose)) && (attr = html.match(attribute))) {\n        match.attrs.push({\n          name: attr[1],\n          value: attr[3] || attr[4] || attr[5],\n        })\n        advance(attr[0].length)\n      }\n      if (end) {\n        advance(end[0].length)\n        return match\n      }\n    }\n  }\n  // 解析到开始标签时触发\n  function start(tag, attrs) {\n    const el = createASTElement(tag, attrs)\n    if (!root) root = el\n    stack.push((parent = el))\n    processFor(el) // 处理 v-for\n    processIf(el) // 处理 v-if\n    processAttrs(el) // 处理 v-on、v-show、v-bind 等\n  }\n  // 解析到结束标签时触发\n  function end(tag) {\n    const el = stack.pop()\n    parent = stack[stack.length - 1]\n    if (parent) {\n      el.parent = parent\n      parent.children.push(el)\n    }\n  }\n  // 解析到文本时触发\n  function chars(text) {\n    text = text.trim()\n    if (!text) return\n    const el = { type: 3, text }\n    if (parent) {\n      parent.children.push(el)\n      el.parent = parent\n    }\n  }\n  return root\n}\n// 创建元素节点\nfunction createASTElement(tag, attrs, parent) {\n  return {\n    type: 1,\n    tag,\n    attrsList: attrs,\n    attrsMap: makeAttrsMap(attrs),\n    parent,\n    children: [],\n  }\n}\n// 把数组类型的属性转换为对象\nfunction makeAttrsMap(attrs) {\n  const map = {}\n  attrs.forEach((it) => (map[it.name] = it.value))\n  return map\n}\n// 获取并删除数组中的某个属性\nfunction getAndRemoveAttr(el, name) {\n  let val\n  if ((val = el.attrsMap[name]) != null) {\n    const list = el.attrsList\n    for (let i = list.length - 1; i >= 0; i--) {\n      if (list[i].name === name) {\n        list.splice(i, 1)\n        break\n      }\n    }\n  }\n  return val\n}\n// 处理v-for\nfunction processFor(el) {\n  let exp\n  if ((exp = getAndRemoveAttr(el, 'v-for'))) {\n    const inMatch = exp.match(/([\\s\\S]*?)\\s+(?:in|of)\\s+([\\s\\S]*)/)\n    if (!inMatch) return\n    Object.assign(el, {\n      alias: inMatch[1].trim(),\n      for: inMatch[2].trim(),\n    })\n  }\n}\n// 处理v-if\nfunction processIf(el) {\n  const exp = getAndRemoveAttr(el, 'v-if')\n  if (exp) el.if = exp\n}\n// 处理各种属性，这里以v-on为例\nfunction processAttrs(el) {\n  const list = el.attrsList,\n    onRE = /^@|^v-on:/\n  let i, l, name, rawName, value\n  for (i = 0, l = list.length; i < l; i++) {\n    name = rawName = list[i].name\n    value = list[i].value\n    if (onRE.test(name)) {\n      name = name.replace(onRE, '')\n      el.events = { [name]: value }\n      list.splice(i, 1)\n      break\n    }\n  }\n}\n```\n\n对文章开头的示例模板运行这段代码，可以得到如下的 AST 树：\n\n```js\n{\n  type: 1,\n  tag: 'div',\n  attrsList: [ { name: 'id', value: 'app' } ],\n  attrsMap: { id: 'app' },\n  children: [\n    { type: 3, text: '你好，{{ message }}！' },\n    {\n      type: 1,\n      tag: 'p',\n      attrsList: [ { name: 'style', value: 'color: red; fontSize: 16px' } ],\n      attrsMap: { 'v-if': 'seen', style: 'color: red; fontSize: 16px' },\n      children: [ { type: 3, text: '条件渲染' } ],\n      if: 'seen'\n    },\n    {\n      type: 1,\n      tag: 'button',\n      attrsList: [],\n      attrsMap: { 'v-on:click': 'reverseMessage' },\n      children: [ { type: 3, text: '反转消息' } ],\n      events: { click: 'reverseMessage' }\n    },\n    {\n      type: 1,\n      tag: 'ol',\n      attrsList: [],\n      attrsMap: {},\n      children: [\n        {\n          type: 1,\n          tag: 'li',\n          attrsList: [ { name: 'class', value: 'color-gray ml-2' } ],\n          attrsMap: { 'v-for': 'todo in todos', class: 'color-gray ml-2' },\n          children: [ { type: 3, text: '{{ todo.text }}' } ],\n          alias: 'todo',\n          for: 'todos'\n        }\n      ]\n    }\n  ]\n}\n```\n\n注意这里并没有对注释节点等进行解析，只处理了元素节点和文本节点。\n\n\n## 生成器\n\n有了 AST 之后，就需要将其组装成代码了，本质上就是拼接代码字符串，用 `new Function` 和 `with` 进行处理。所以接下来要写一个函数来处理上面的 AST 树：\n\n```js\nfunction generate(node) {\n  return node.type === 1 ? genElement(node) : genText(node.text)\n}\n```\n\n同样这里只考虑元素节点和文本节点两种情况。\n\n### 生成元素节点代码\n\n对于元素节点，要拼成 `_c(tag, data, childNodes)` 函数，\n\n```js\nfunction genElement(el) {\n  const { tag, attrsList, children } = el\n  const childNodes = children.map((child) => generate(child))\n  if (el.for && !el.forProcessed) {\n    el.forProcessed = true\n    return (\n      `_l((${el.for}),` +\n      `function(${el.alias}){` +\n      `return ${genElement(el)}` +\n      '})'\n    )\n  } else if (el.if && !el.ifProcessed) {\n    el.ifProcessed = true\n    return `${el.if} ? ${genElement(el)}: _e('')`\n  }\n  return `_c('${tag}',${genAttrs(attrsList)},${childNodes})`\n}\n```\n\n### 处理元素节点上的属性\n\n下面的代码用于处理属性：\n\n```js\nfunction genAttrs(attrs) {\n  const obj = {}\n  for (let i = 0; i < attrs.length; i++) {\n    let attr = attrs[i]\n    if (attr.name === 'style') {\n      const kv = {} // 对样式进行特殊的处理\n      attr.value.split(';').forEach((item) => {\n        let [key, value] = item.split(':')\n        kv[key.trim()] = value.trim()\n      })\n      attr.value = kv\n    }\n    obj[attr.name] = attr.value\n  }\n  return JSON.stringify(obj)\n}\n```\n\n### 生成文本节点代码\n\n```js\nfunction genText(text) {\n  const defaultTagRE = /\\{\\{((?:.|\\r?\\n)+?)\\}\\}/g\n  if (!defaultTagRE.test(text)) {\n    return `_v(${JSON.stringify(text)})`\n  }\n  let tokens = []\n  let lastIndex = (defaultTagRE.lastIndex = 0)\n  let match, index\n  while ((match = defaultTagRE.exec(text))) {\n    index = match.index\n    if (index > lastIndex) {\n      tokens.push(JSON.stringify(text.slice(lastIndex, index)))\n    }\n    tokens.push(`_s(${match[1].trim()})`)\n    lastIndex = index + match[0].length\n  }\n  if (lastIndex < text.length) {\n    tokens.push(JSON.stringify(text.slice(lastIndex)))\n  }\n  return `_v(${tokens.join('+')})`\n}\n```\n\n### 代码生成结果\n\n将 ast 带入函数得到代码字符串为：\n\n```js\n_c(\n  'div',\n  { id: 'app' },\n  _v('你好，' + _s(message) + '！'),\n  seen\n    ? _c('p', { style: { color: 'red', fontSize: '16px' } }, _v('条件渲染'))\n    : _e(''),\n  _c('button', {}, _v('反转消息')),\n  _c(\n    'ol',\n    {},\n    _l(todos, function (todo) {\n      return _c('li', { class: 'color-gray ml-2' }, _v(_s(todo.text)))\n    })\n  )\n)\n```\n\n\n## 虚拟 DOM\n\n有了代码字符串之后，就可以带入环境变量来生成虚拟 DOM 了，下面是生成虚拟 DOM 用到的一些辅助函数：\n\n```js\nfunction _c(tag, data, ...children) {\n  return { tag, data, children: children.flat() }\n}\nfunction _v(text) {\n  return { text }\n}\n\nfunction _s(val) {\n  if (val == null) return ''\n  if (typeof val == 'object') return JSON.stringify(val, null, 2)\n  return String(val)\n}\n\nfunction _l(val, render) {\n  const ret = new Array(val.length)\n  for (i = 0, l = val.length; i < l; i++) {\n    ret[i] = render(val[i], i)\n  }\n  return ret\n}\n\nfunction _e(text) {\n  return { text, isComment: true }\n}\n\nfunction createVdom(vm, code) {\n  const f = new Function('vm', `with(vm){return ${code}}`)\n  return f({ ...vm, _c, _s, _v, _l, _e })\n}\n```\n\n如果 vm 用下面的变量带入：\n\n```js\n{\n  message: '消息',\n  seen: false,\n  todos: [{ text: 'study' }, { text: 'reading' }],\n}\n```\n\n会得到虚拟 DOM：\n\n```js\n{\n  tag: 'div',\n  data: { id: 'app' },\n  children: [\n    { text: '你好，消息！' },\n    { text: '', isComment: true },\n    { tag: 'button', data: {}, children: [ { text: '反转消息' } ] },\n    {\n      tag: 'ol',\n      data: {},\n      children: [\n        {\n          tag: 'li',\n          data: { class: 'color-gray ml-2' },\n          children: [ { text: 'study' } ]\n        },\n        {\n          tag: 'li',\n          data: { class: 'color-gray ml-2' },\n          children: [ { text: 'reading' } ]\n        }\n      ]\n    }\n  ]\n}\n```\n\n如果 vm 换成下面的环境：\n\n```js\n{\n  message: '水果',\n  seen: true,\n  todos: [{ text: '香蕉' }, { text: '苹果' }, { text: '西瓜' }],\n}\n```\n\n则可以生成另一种 DOM 结构：\n\n```js\n{\n  tag: 'div',\n  data: { id: 'app' },\n  children: [\n    { text: '你好，水果！' },\n    {\n      tag: 'p',\n      data: { style: { color: 'red', fontSize: '16px' } },\n      children: [ { text: '条件渲染' } ]\n    },\n    { tag: 'button', data: {}, children: [ { text: '反转消息' } ] },\n    {\n      tag: 'ol',\n      data: {},\n      children: [\n        {\n          tag: 'li',\n          data: { class: 'color-gray ml-2' },\n          children: [ { text: '香蕉' } ]\n        },\n        {\n          tag: 'li',\n          data: { class: 'color-gray ml-2' },\n          children: [ { text: '苹果' } ]\n        },\n        {\n          tag: 'li',\n          data: { class: 'color-gray ml-2' },\n          children: [ { text: '西瓜' } ]\n        }\n      ]\n    }\n  ]\n}\n```\n\n由于 vue 的数据是响应式的，数据改变会触发页面渲染，而页面渲染的逻辑就是新旧虚拟 DOM 利用 patch 算法进行比较得到差异，最终更新真实 DOM。\n\n\n", "user_name": "乔珂力", "description": "", "got_view_count": 1357, "category_name": "前端", "ctime": 1457483942}
{"tag_name": "Linux", "concern_user_count": 198821, "user_id": "501033032750472", "title": "聊聊虚拟内存", "mark_content": "大家好，我是良许。\n\n熟悉计算机的小伙伴都知道，我们常说的主机三大件分别是主板，CPU，内存，可见内存在计算机主机中的角色也非同一般，喜欢 DIY 主机的小伙伴对这三大件的了解更是精益求精。\n\n编写过程序的小伙伴对于程序的执行过程，也是耳熟能详了，先从硬盘加载到内存，然后 CPU 与内存进行数据交换与处理，完成相应的操作（真实执行细节相当复杂），从而实现相应的功能。\n\n但是内存的容量非常有限，由于内存的造价较高（目前常用的内存为双倍速 SDRAM ），计算机用户升级内存容量也是一笔不小的开支。\n\n那么良许就和大家来讨论下计算机的内存如果不够用了, 虚拟内存技术的应用，虚拟内存的出现，让机器内存不够的情况得到部分解决，大家需要注意的是有些资料也将虚拟内存称之为交换内存。\n\n#### 1\\. 讨论虚拟内存前的热身\n\n我们需要知道的是计算机对内存分为物理内存与虚拟内存（注意虚拟内存和虚拟地址空间的区别）。物理内存就是计算机的实际内存大小，由 RAM 芯片组成的。虚拟内存则是虚拟出来的、使用磁盘代替内存。\n\n#### 2\\. 虚拟内存的工作原理\n\n正如前面所描述的，当系统的物理内存不够用的时候，就需要将物理内存中的一部分空间释放出来，以供当前运行的程序使用。\n\n那些被释放的空间可能来自一些很长时间没有什么操作的程序，这些被释放的空间被临时保存到交换空间中，等到那些程序要运行时，再从交换空间中恢复保存的数据到内存中。\n\n#### 3\\. Linux 虚拟内存的实现方式\n\nLinux 系统实现虚拟内存有两种方法，分别是交换分区（ **swap** 分区）和交换文件。\n\n#####　交换分区\n\n交换分区其实就是新建一个分区，然后将该分区挂载作为交换空间，方法步骤与传统的新建分区一样。只不过格式化分区和挂载分区分别采用 **mkswap** 和 **swapon** 命令。\n\n##### 交换文件\n\n硬盘驱动器中没有足够的空间来创建交换分区，我们就会手动创建一个交换文件以将 RAM 的非活动内容交换到其中。\n\n#### 4\\. 理想的交换权重\n\nLinux 允许我们自行设置交换的权重，也就是说我们可以设置交换过程发生的频率。小伙伴们可以根据需要在0到100之间设置交换的权重。值越小则代表会让内核尽量少用交换，值越大会使内核更多的去使用交换空间。\n\n交换权重的默认值和建议值为60，有兴趣的小伙伴可以具体去学习 **swappiness** ，这个 Linux 内核参数,这里不做过多的描述了。\n\n#### 5.使用虚拟内存的好处\n\n*   它可以轻松地保存那些几乎不使用而又被占用的 RAM 块。然后可以将释放的 RAM 用于容纳更多具有更高优先级的程序。\n*   防止 RAM 空间用完，无法执行其他程序的局面。\n*   虚拟内存充当了 RAM 的备份，从而增大了 RAM 的实际空间。\n*   在休眠过程中，RAM 的所有内容均写入交换空间。因此，成功进行休眠，虚拟内存是必需的。\n*   它提高了系统的整体性能。（在内核参数 **swappiness** 设置合理的情况下）\n\n#### 6\\. 结论\n\n在本文中，我们学习了交换内存以及它的许多好处，RAM 空间不足时，它将作为 RAM 的扩充进行使用，避免我们的应用程序因内存不足而崩溃。\n\n其实，**Swap** 的调整对 Linux 服务器，特别是 Web 服务器的性能至关重要。通过调整 **Swap**，有时可以越过系统性能瓶颈，节省系统升级费用。", "user_name": "良许Linux", "description": "公众号：良许Linux，回复1024获取5T技术资料", "got_view_count": 72068, "category_name": "后端", "ctime": 1457483880}
{"tag_name": "Docker", "concern_user_count": 116847, "user_id": "2277843825331959", "title": "【每天30分钟Get新技能】docker容器篇（一）", "mark_content": "\n## Docker是什么\n\n**Docker 属于 Linux 容器的一种封装，提供简单易用的容器使用接口。**它是目前最流行的 Linux 容器解决方案。\n\nDocker 将应用程序与该程序的依赖，打包在一个文件里面。运行这个文件，就会生成一个虚拟容器。程序在这个虚拟容器里运行，就好像在真实的物理机上运行一样。有了 Docker，就不用担心环境问题。\n\n总体来说，Docker 的接口相当简单，用户可以方便地创建和使用容器，把自己的应用放入容器。容器还可以进行版本管理、复制、分享、修改，就像管理普通的代码一样。\n\n## Docker基本概念\n\nDocker 主要包含三个基本概念，分别是镜像、容器和仓库，理解了这三个概念，就理解了 Docker 的整个生命周期。以下简要总结一下这三点。\n\n### 镜像：\n\nDocker 镜像是一个特殊的文件系统，除了提供容器运行时所需的程序、库、资源、配置等文件外，还包含了一些为运行时准备的一些配置参数（如匿名卷、环境变量、用户等）。镜像不包含任何动态数据，其内容在构建之后也不会被改变。\n\n### 容器：\n\n容器的实质是进程，但与直接在宿主执行的进程不同，容器进程运行于属于自己的独立的命名空间容器可以被。创建、启动、停止、删除和暂停等等，说到镜像与容器之间的关系，可以类比面向对象程序设计中的类和实例。\n\n### 仓库：\n\n镜像构建完成后，可以很容易的在当前宿主机上运行，但是，如果需要在其它服务器上使用这个镜像，我们就需要一个集中的存储、分发镜像的服务，Docker Registry 就是这样的服务。一个 Docker Registry 中可以包含多个仓库；每个仓库可以包含多个标签；每个标签对应一个镜像，其中标签可以理解为镜像的版本号。\n\n## Docker 用途\n\nDocker 的主要用途，目前有三大类。\n\n**（1）提供一次性的环境。**比如，本地测试他人的软件、持续集成的时候提供单元测试和构建的环境。\n\n**（2）提供弹性的云服务。**因为 Docker 容器可以随开随关，很适合动态扩容和缩容。\n\n**（3）组建微服务架构。**通过多个容器，一台机器可以跑多个服务，因此在本机就可以模拟出微服务架构。\n\n## Docker安装\n\nDocker 分为 CE 和 EE 两大版本。CE 即社区版（免费，支持周期 7 个月），EE 即企业版，强调安全，付费使用，支持周期 24 个月。\n\nDocker CE 分为 `stable` `test` 和 `nightly` 三个更新频道。\n\n官方网站上有各种环境下的 [安装指南](https://docs.docker.com/install/)，这里主要介绍 Docker CE 在 `Linux` 、`Windows 10` 和 `macOS` 上的安装。\n\n### Ubuntu\n\n#### 系统要求\n\nDocker CE 支持以下版本的 [Ubuntu](https://ubuntu.com/server) 操作系统：\n\n- Ubuntu Focal 20.04 (LTS)\n- Eoan 19.10\n- Bionic 18.04 (LTS)\n- Xenial 16.04 (LTS)\n\nDocker CE 可以安装在 64 位的 x86 平台或 ARM 平台上。Ubuntu 发行版中，LTS（Long-Term-Support）长期支持版本，会获得 5 年的升级维护支持，这样的版本会更稳定，因此在生产环境中推荐使用 LTS 版本。\n\n#### 卸载旧版本\n\n旧版本的 Docker 称为 `docker` 或者 `docker-engine`，使用以下命令卸载旧版本：\n\n```\n$ sudo apt-get remove docker \\\n               docker-engine \\\n               docker.io\n```\n\n#### 使用 APT 安装\n\n由于 `apt` 源使用 HTTPS 以确保软件下载过程中不被篡改。因此，我们首先需要添加使用 HTTPS 传输的软件包以及 CA 证书。\n\n```\n$ sudo apt-get update\n$ sudo apt-get install \\\n    apt-transport-https \\\n    ca-certificates \\\n    curl \\\n    software-properties-common\n```\n\n鉴于国内网络问题，强烈建议使用国内源，官方源请在注释中查看。\n\n为了确认所下载软件包的合法性，需要添加软件源的 `GPG` 密钥。\n\n```\n$ curl -fsSL https://mirrors.ustc.edu.cn/docker-ce/linux/ubuntu/gpg | sudo apt-key add -\n# 官方源\n# $ curl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo apt-key add -\n```\n\n然后，我们需要向 `source.list` 中添加 Docker 软件源\n\n```\n$ sudo add-apt-repository \\\n    \"deb [arch=amd64] https://mirrors.ustc.edu.cn/docker-ce/linux/ubuntu \\\n    $(lsb_release -cs) \\\n    stable\"\n# 官方源\n# $ sudo add-apt-repository \\\n#    \"deb [arch=amd64] https://download.docker.com/linux/ubuntu \\\n#    $(lsb_release -cs) \\\n#    stable\"\n```\n\n> 以上命令会添加稳定版本的 Docker CE APT 镜像源，如果需要测试或每日构建版本的 Docker CE 请将 stable 改为 test 或者 nightly。\n\n#### 安装 Docker CE\n\n更新 apt 软件包缓存，并安装 `docker-ce`：\n\n```\n$ sudo apt-get update\n$ sudo apt-get install docker-ce\n```\n\n#### 使用脚本自动安装\n\n在测试或开发环境中 Docker 官方为了简化安装流程，提供了一套便捷的安装脚本，Ubuntu 系统上可以使用这套脚本安装，另外可以通过 `--mirror` 选项使用国内源进行安装：\n\n```\n$ curl -fsSL get.docker.com -o get-docker.sh\n$ sudo sh get-docker.sh --mirror Aliyun\n# $ sudo sh get-docker.sh --mirror AzureChinaCloud\n```\n\n执行这个命令后，脚本就会自动的将一切准备工作做好，并且把 Docker CE 的稳定(stable)版本安装在系统中。\n\n#### 启动 Docker CE\n\n```\n$ sudo systemctl enable docker\n$ sudo systemctl start docker\n```\n\n### Debian\n\n#### 系统要求\n\nDocker CE 支持以下版本的 [Debian](https://www.debian.org/intro/about) 操作系统：\n\n- Buster 10\n- Stretch 9\n\n#### 卸载旧版本\n\n旧版本的 Docker 称为 `docker` 或者 `docker-engine`，使用以下命令卸载旧版本：\n\n```\n$ sudo apt-get remove docker \\\n               docker-engine \\\n               docker.io\n```\n\n#### 使用 APT 安装\n\n由于 apt 源使用 HTTPS 以确保软件下载过程中不被篡改。因此，我们首先需要添加使用 HTTPS 传输的软件包以及 CA 证书。\n\n```\n$ sudo apt-get update\n$ sudo apt-get install \\\n     apt-transport-https \\\n     ca-certificates \\\n     curl \\\n     gnupg2 \\\n     lsb-release \\\n     software-properties-common\n```\n\n鉴于国内网络问题，强烈建议使用国内源，官方源请在注释中查看。\n\n为了确认所下载软件包的合法性，需要添加软件源的 GPG 密钥。\n\n```\n$ curl -fsSL https://mirrors.ustc.edu.cn/docker-ce/linux/debian/gpg | sudo apt-key add -\n# 官方源\n# $ curl -fsSL https://download.docker.com/linux/debian/gpg | sudo apt-key add -\n```\n\n然后，我们需要向 `source.list` 中添加 Docker CE 软件源：\n\n```\n$ sudo add-apt-repository \\\n   \"deb [arch=amd64] https://mirrors.ustc.edu.cn/docker-ce/linux/debian \\\n   $(lsb_release -cs) \\\n   stable\"\n# 官方源\n# $ sudo add-apt-repository \\\n#    \"deb [arch=amd64] https://download.docker.com/linux/debian \\\n#    $(lsb_release -cs) \\\n#    stable\"\n```\n\n> 以上命令会添加稳定版本的 Docker CE APT 源，如果需要测试或每日构建版本的 Docker CE 请将 stable 改为 test 或者 nightly。\n\n#### 安装 Docker CE\n\n更新 apt 软件包缓存，并安装 `docker-ce`。\n\n```\n$ sudo apt-get update\n$ sudo apt-get install docker-ce\n```\n\n#### 使用脚本自动安装\n\n在测试或开发环境中 Docker 官方为了简化安装流程，提供了一套便捷的安装脚本，Debian 系统上可以使用这套脚本安装，另外可以通过 `--mirror` 选项使用国内源进行安装：\n\n```\n$ curl -fsSL get.docker.com -o get-docker.sh\n$ sudo sh get-docker.sh --mirror Aliyun\n# $ sudo sh get-docker.sh --mirror AzureChinaCloud\n```\n\n执行这个命令后，脚本就会自动的将一切准备工作做好，并且把 Docker CE 的稳定(stable)版本安装在系统中。\n\n#### 启动 Docker CE\n\n```\n$ sudo systemctl enable docker\n$ sudo systemctl start docker\n```\n\n### CentOS\n\n#### 系统要求\n\nDocker CE 支持 64 位版本 CentOS 7，并且要求内核版本不低于 3.10。 CentOS 7 满足最低内核的要求，但由于内核版本比较低，部分功能（如 `overlay2` 存储层驱动）无法使用，并且部分功能可能不太稳定。\n\n#### 卸载旧版本\n\n旧版本的 Docker 称为 `docker` 或者 `docker-engine`，使用以下命令卸载旧版本：\n\n```\n$ sudo yum remove docker \\\n                  docker-client \\\n                  docker-client-latest \\\n                  docker-common \\\n                  docker-latest \\\n                  docker-latest-logrotate \\\n                  docker-logrotate \\\n                  docker-selinux \\\n                  docker-engine-selinux \\\n                  docker-engine\n```\n\n#### 使用 yum 安装\n\n执行以下命令安装依赖包：\n\n```\n$ sudo yum install -y yum-utils \\\n           device-mapper-persistent-data \\\n           lvm2\n```\n\n鉴于国内网络问题，强烈建议使用国内源，官方源请在注释中查看。\n\n执行下面的命令添加 `yum` 软件源：\n\n```\n$ sudo yum-config-manager \\\n    --add-repo \\\n    https://mirrors.ustc.edu.cn/docker-ce/linux/centos/docker-ce.repo\n$ sudo sed -i 's/download.docker.com/mirrors.ustc.edu.cn\\/docker-ce/g' /etc/yum.repos.d/docker-ce.repo\n\n# 官方源\n# $ sudo yum-config-manager \\\n#     --add-repo \\\n#     https://download.docker.com/linux/centos/docker-ce.repo\n```\n\n如果需要测试版本的 Docker CE 请使用以下命令：\n\n```\n$ sudo yum-config-manager --enable docker-ce-test\n```\n\n如果需要每日构建版本的 Docker CE 请使用以下命令：\n\n```\n$ sudo yum-config-manager --enable docker-ce-nightly\n```\n\n#### 安装 Docker CE\n\n更新 `yum` 软件源缓存，并安装 `docker-ce`。\n\n```\n$ sudo yum makecache fast\n$ sudo yum install docker-ce\n```\n\n#### 使用脚本自动安装\n\n在测试或开发环境中 Docker 官方为了简化安装流程，提供了一套便捷的安装脚本，CentOS 系统上可以使用这套脚本安装，另外可以通过 `--mirror` 选项使用国内源进行安装：\n\n```\n$ curl -fsSL get.docker.com -o get-docker.sh\n$ sudo sh get-docker.sh --mirror Aliyun\n# $ sudo sh get-docker.sh --mirror AzureChinaCloud\n```\n\n执行这个命令后，脚本就会自动的将一切准备工作做好，并且把 Docker CE 的稳定(stable)版本安装在系统中。\n\n#### 启动 Docker CE\n\n```\n$ sudo systemctl enable docker\n$ sudo systemctl start docker\n```\n\n#### 建立 docker 用户组\n\n默认情况下，`docker` 命令会使用 [Unix socket](https://en.wikipedia.org/wiki/Unix_domain_socket) 与 Docker 引擎通讯。而只有 `root` 用户和 `docker` 组的用户才可以访问 Docker 引擎的 Unix socket。出于安全考虑，一般 Linux 系统上不会直接使用 `root` 用户。因此，更好地做法是将需要使用 `docker` 的用户加入 `docker` 用户组。\n\n建立 `docker` 组：\n\n```\n$ sudo groupadd docker\n```\n\n将当前用户加入 `docker` 组：\n\n```\n$ sudo usermod -aG docker $USER\n```\n\n退出当前终端并重新登录，进行如下测试。\n\n#### 测试 Docker 是否安装正确\n\n```\n$ docker run hello-world\nUnable to find image 'hello-world:latest' locally\nlatest: Pulling from library/hello-world\n0e03bdcc26d7: Pull complete\nDigest: sha256:49a1c8800c94df04e9658809b006fd8a686cab8028d33cfba2cc049724254202\nStatus: Downloaded newer image for hello-world:latest\n\nHello from Docker!\nThis message shows that your installation appears to be working correctly.\n\nTo generate this message, Docker took the following steps:\n 1. The Docker client contacted the Docker daemon.\n 2. The Docker daemon pulled the \"hello-world\" image from the Docker Hub.\n    (amd64)\n 3. The Docker daemon created a new container from that image which runs the\n    executable that produces the output you are currently reading.\n 4. The Docker daemon streamed that output to the Docker client, which sent it\n    to your terminal.\n\nTo try something more ambitious, you can run an Ubuntu container with:\n $ docker run -it ubuntu bash\n\nShare images, automate workflows, and more with a free Docker ID:\n https://hub.docker.com/\n\nFor more examples and ideas, visit:\n https://docs.docker.com/get-started/\n```\n\n若能正常输出以上信息，则说明安装成功。\n\n### macOS\n\n#### 系统要求\n\n[Docker Desktop for Mac](https://docs.docker.com/docker-for-mac/) 要求系统最低为 macOS Catalina 10.13。\n\n#### 安装\n\n##### 使用 Homebrew 安装\n\n[Homebrew](https://brew.sh/) 的 [Cask](https://github.com/Homebrew/homebrew-cask) 已经支持 Docker Desktop for Mac，因此可以很方便的使用 Homebrew Cask 来进行安装：\n\n```bash\n$ brew cask install docker\n```\n\n##### 手动下载安装\n\n如果需要手动下载，请点击以下链接下载 [Stable](https://download.docker.com/mac/stable/Docker.dmg) 或 [Edge](https://download.docker.com/mac/edge/Docker.dmg) 版本的 Docker Desktop for Mac。\n\n如同 macOS 其它软件一样，安装也非常简单，双击下载的 `.dmg` 文件，然后将那只叫 [Moby](https://www.docker.com/blog/call-me-moby-dock/) 的鲸鱼图标拖拽到 `Application` 文件夹即可（其间需要输入用户密码）。\n\n#### 运行\n\n从应用中找到 Docker 图标并点击运行。\n\n### Windows 10\n\n#### 系统要求\n\n[Docker Desktop for Windows](https://docs.docker.com/docker-for-windows/install/) 支持 64 位版本的 Windows 10 Pro，且必须开启 Hyper-V（若版本为 v2004 及以上则无需开启 Hyper-V），或者 64 位版本的 Windows 10 Home v2004 及以上版本。\n\n#### 安装\n\n**手动下载安装**\n\n点击以下链接下载 [Stable](https://download.docker.com/win/stable/Docker Desktop Installer.exe) 或 [Edge](https://download.docker.com/win/edge/Docker Desktop Installer.exe) 版本的 Docker Desktop for Windows。\n\n下载好之后双击 `Docker Desktop Installer.exe` 开始安装。\n\n#### 运行\n\n在 Windows 搜索栏输入 **Docker** 点击 **Docker Desktop** 开始运行。\n\n## Docker实战\n\n### docker安装nginx\n\n#### 搜索镜像\n\n你可以通过 `docker search` 命令来查找官方仓库中的镜像，并利用 `docker pull` 命令来将它下载到本地。\n\n例如以 `nginx` 为关键词进行搜索：\n\n```\n$ docker search nginx\nNAME                               DESCRIPTION                                     STARS               OFFICIAL            AUTOMATED\nnginx                              Official build of Nginx.                        13580               [OK]\njwilder/nginx-proxy                Automated Nginx reverse proxy for docker con…   1857                                    [OK]\nricharvey/nginx-php-fpm            Container running Nginx + PHP-FPM capable of…   782                                     [OK]\nlinuxserver/nginx                  An Nginx container, brought to you by LinuxS…   126\nbitnami/nginx                      Bitnami nginx Docker Image                      88                                      [OK]\ntiangolo/nginx-rtmp                Docker image with Nginx using the nginx-rtmp…   86                                      [OK]\njc21/nginx-proxy-manager           Docker container for managing Nginx proxy ho…   76\nalfg/nginx-rtmp                    NGINX, nginx-rtmp-module and FFmpeg from sou…   72                                      [OK]\nnginxdemos/hello                   NGINX webserver that serves a simple page co…   58                                      [OK]\njlesage/nginx-proxy-manager        Docker container for Nginx Proxy Manager        53                                      [OK]\nnginx/nginx-ingress                NGINX Ingress Controller for Kubernetes         37\nprivatebin/nginx-fpm-alpine        PrivateBin running on an Nginx, php-fpm & Al…   31                                      [OK]\nschmunk42/nginx-redirect           A very simple container to redirect HTTP tra…   18                                      [OK]\nnginxinc/nginx-unprivileged        Unprivileged NGINX Dockerfiles                  16\nnginx/nginx-prometheus-exporter    NGINX Prometheus Exporter                       14\nraulr/nginx-wordpress              Nginx front-end for the official wordpress:f…   13                                      [OK]\ncentos/nginx-112-centos7           Platform for running nginx 1.12 or building …   13\ncentos/nginx-18-centos7            Platform for running nginx 1.8 or building n…   13\nblacklabelops/nginx                Dockerized Nginx Reverse Proxy Server.          13                                      [OK]\nmailu/nginx                        Mailu nginx frontend                            7                                       [OK]\nsophos/nginx-vts-exporter          Simple server that scrapes Nginx vts stats a…   7                                       [OK]\nbitwarden/nginx                    The Bitwarden nginx web server acting as a r…   7\nbitnami/nginx-ingress-controller   Bitnami Docker Image for NGINX Ingress Contr…   6                                       [OK]\nwodby/nginx                        Generic nginx                                   1                                       [OK]\nansibleplaybookbundle/nginx-apb    An APB to deploy NGINX                          1                                       [OK]\n```\n\n可以看到返回了很多包含关键字的镜像，其中包括镜像名字、描述、收藏数（表示该镜像的受关注程度）、是否官方创建（OFFICIAL）、是否自动构建 （AUTOMATED）。\t\n\n#### 拉取镜像\n\n```\n$ docker pull nginx\nUsing default tag: latest\nlatest: Pulling from library/nginx\nbf5952930446: Pull complete\nba755a256dfe: Pull complete\nc57dd87d0b93: Pull complete\nd7fbf29df889: Pull complete\n1f1070938ccd: Pull complete\nDigest: sha256:36b74457bccb56fbf8b05f79c85569501b721d4db813b684391d63e02287c0b2\nStatus: Downloaded newer image for nginx:latest\ndocker.io/library/nginx:latest\n```\n\n#### 查看镜像\n\n使用以下命令来查看是否已安装了 nginx：\n\n```\n$ docker images\nREPOSITORY                                               TAG                 IMAGE ID            CREATED             SIZE\nnginx                                                    latest              08393e824c32        4 days ago          132MB\n```\n\n在上面的信息中可以看到我们已经安装了最新版本（latest）的 nginx 镜像。\n\n#### 运行容器\n\n拉取镜像完成后，我们可以使用以下命令来运行 nginx 容器：\n\n```\n$ docker run --name nginx-test -p 8081:80 -d nginx\n```\n\n参数说明：\n\n- **--name nginx-test**：容器名称。\n- **-p 8081:80**： 端口进行映射，将本地 8081 端口映射到容器内部的 80 端口。\n- **-d nginx**： 设置容器在在后台一直运行。\n\n#### 测试安装\n\n最后我们可以通过浏览器可以直接访问 8081 端口的 nginx 服务。\n\n> 此处通过安装nginx容器，简单的介绍了docker的一些基础命令。其他更多命令可以参考官网文档。\n\n## Docker 常用命令\n\n### Docker镜像常用命令\n\n下面介绍几种镜像中常用的操作命令。\n\n`docker image pull`是下载镜像的命令。镜像从远程镜像仓库服务的仓库中下载。\n\n默认情况下，镜像会从 [Docker](http://c.biancheng.net/docker/) Hub 的仓库中拉取。\n\n`docker image pull alpine:latest`命令会从 Docker Hub 的 alpine 仓库中拉取标签为 latest 的镜像。\n\n`docker image ls`列出了本地 Docker 主机上存储的镜像。可以通过 --digests 参数来查看镜像的 SHA256 签名。\n\n`docker image inspect`命令非常有用！该命令完美展示了镜像的细节，包括镜像层数据和元数据。\n\n`docker image rm`用于删除镜像。\n\n`docker image rm alpine:latest`命令的含义是删除 alpine:latest 镜像。当镜像存在关联的容器，并且容器处于运行（Up）或者停止（Exited）状态时，不允许删除该镜像。\n\n### Docker容器常用命令\n\n1) `docker container run`\n\n启动新容器的命令。该命令的最简形式接收镜像和命令作为参数。镜像用于创建容器，而命令则是希望容器运行的应用。\n\n`docker container run -it ubuntu /bin/bash` 命令会在前台启动一个 Ubuntu 容器，并运行 Bash Shell。\n\nCtrl-PQ 会断开 Shell 和容器终端之间的链接，并在退出后保持容器在后台处于运行（UP）状态。\n\n2) `docker container ls`\n\n用于列出所有在运行（UP）状态的容器。如果使用 -a 标记，还可以看到处于停止（Exited）状态的容器。\n\n3) `docker container exec`\n\n用于在运行状态的容器中，启动一个新进程。该命令在将 Docker 主机 Shell 连接到一个运行中容器终端时非常有用。\n\n`docker container exec -it <container-name or container-id> bash` 命令会在容器内部启动一个 Bash Shell 进程，并连接到该 Shell。\n\n为了使该命令生效，用于创建容器的镜像必须包含 Bash Shell。\n\n4) `docker container stop`\n\n此命令会停止运行中的容器，并将状态置为 Exited(0)。\n\n该命令通过发送 SIGTERM 信号给容器内 PID 为 1 的进程达到目的。\n\n如果进程没有在 10s 之内得到清理并停止运行，那么会接着发送 SIGKILL 信号来强制停止该容器。\n\ndocker container stop 可以接收容器 ID 以及容器名称作为参数。\n\n5) `docker container start`\n\n重启处于停止（Exited）状态的容器。可以在 docker container start 命令中指定容器的名称或者 ID。\n\n6) `docker container rm`\n\n删除停止运行的容器。可以通过容器名称或者 ID 来指定要删除的容器。推荐首先使用 docker container stop 命令停止容器，然后使用 docker container rm 来完成删除。\n\n7) `docker container inspect`\n\n显示容器的配置细节和运行时信息。该命令接收容器名称和容器 ID 作为主要参数。\n\n> 官方阅读链接：[docs.docker.com/engine/refe…](https://docs.docker.com/engine/reference/commandline/docker/)\n\n## Docker 加速器是什么\n\n使用 Docker 的时候，需要经常从官方获取镜像，但是由于显而易见的网络原因，拉取镜像的过程非常耗时，严重影响使用 Docker 的体验。因\t此 DaoCloud 推出 Docker 加速器解决这个难题，通过智能路由和缓存机制，极大提升了国内网络访问 Docker Hub 的速度，目前已经拥有了广泛的用户群体，并得到了 Docker 官方的大力推荐。如果您是在国内的网络环境使用 Docker，那么 Docker 加速器一定能帮到您。\n\n### Docker Hub 镜像加速器列表\n\n| 镜像加速器                                                   | 镜像加速器地址                            | 专属加速器       | 其它加速                                                     |\n| :----------------------------------------------------------- | ----------------------------------------- | ---------------- | ------------------------------------------------------------ |\n| [Docker 中国官方镜像](https://docker-cn.com/registry-mirror) | `https://registry.docker-cn.com`          |                  | Docker Hub                                                   |\n| [DaoCloud 镜像站](https://daocloud.io/mirror)                | `http://f1361db2.m.daocloud.io`           | 可登录，系统分配 | Docker Hub                                                   |\n| [Azure 中国镜像](https://github.com/Azure/container-service-for-azure-china/blob/master/aks/README.md#22-container-registry-proxy) | `https://dockerhub.azk8s.cn`              |                  | Docker Hub、GCR、Quay                                        |\n| [科大镜像站](https://mirrors.ustc.edu.cn/help/dockerhub.html) | `https://docker.mirrors.ustc.edu.cn`      |                  | Docker Hub、[GCR](https://github.com/ustclug/mirrorrequest/issues/91)、[Quay](https://github.com/ustclug/mirrorrequest/issues/135) |\n| [阿里云](https://cr.console.aliyun.com/)                     | `https://<your_code>.mirror.aliyuncs.com` | 需登录，系统分配 | Docker Hub                                                   |\n| [七牛云](https://kirk-enterprise.github.io/hub-docs/#/user-guide/mirror) | `https://reg-mirror.qiniu.com`            |                  | Docker Hub、GCR、Quay                                        |\n| [网易云](https://c.163yun.com/hub)                           | `https://hub-mirror.c.163.com`            |                  | Docker Hub                                                   |\n| [腾讯云](https://cloud.tencent.com/document/product/457/9113) | `https://mirror.ccs.tencentyun.com`       |                  | Docker Hub                                                   |\n\n### Docker Hub 镜像加速器配置\n\n#### linux\n\n创建或修改 /etc/docker/daemon.json 文件，修改为如下形式 \t\t\n\n```bash\n{\n    \"registry-mirrors\": [\n        \"加速地址\"\n    ],\n    \"insecure-registries\": []\n}\n```\n\n然后重启docker即可\n\n```\n$ sudo systemctl daemon-reload\n$ sudo systemctl restart docker\n```\n\n#### Mac\n\n右键点击桌面顶栏的 docker 图标，选择 Preferences ，在 Daemon 标签（Docker 17.03 之前版本为 Advanced 标签）下的 Registry mirrors 列表中加入加速地址。点击 Apply & Restart 按钮使设置生效。\n\n如图所示\n\n<img src=\"https://i.loli.net/2020/08/09/co4XC8i2GrRpN6a.png\" alt=\"image-20200809171907682\" style=\"zoom:50%;\" />\n\n![image-20200809172307328](https://i.loli.net/2020/08/09/htbC3H5TuDVp1fJ.png)\n\n#### Windows\n\n在桌面右下角状态栏中右键 docker 图标，修改在 Docker Daemon 标签页中的 json ，把 加速地址加到\"registry-mirrors\"的数组里。点击 Apply 使设置生效。\n\n如图所示\n\n![image-20200809173030151](https://i.loli.net/2020/08/09/IrRlytDJbkwWmX8.png)\t\n\n![image-20200809173130377](https://i.loli.net/2020/08/09/sOv9E4Zn3jT2uCJ.png)\n\n\n### 验证Docker Hub加速器 \n\n命令行输出docker info,如果从结果中看到了如下内容，说明配置成功。\n\n```\n[.....]\negistry Mirrors:\n  https://hub-mirror.c.163.com/\n  [....]\n```\n\n### Docker Hub 镜像测速   \n\n通过pull拉取nginx镜像，测试速度。使用 `time` 统计所花费的总时间。测速前先移除本地的镜像！\n\n```\n$ docker rmi nginx:latest\n$ time docker pull nginx:latest\nlatest: Pulling from library/nginx\nbf5952930446: Pull complete\nba755a256dfe: Pull complete\nc57dd87d0b93: Pull complete\nd7fbf29df889: Pull complete\n1f1070938ccd: Pull complete\nDigest: sha256:36b74457bccb56fbf8b05f79c85569501b721d4db813b684391d63e02287c0b2\nStatus: Downloaded newer image for nginx:latest\ndocker.io/library/nginx:latest\ndocker pull nginx:latest  0.09s user 0.05s system 0% cpu 26.465 total\n```\n\n\n\n## \t有趣的docker镜像\n\n镜像①：rastasheep/ubuntu-sshd （带ssh的ubuntu）\n\n地址：[https://hub.docker.com/r/rastasheep/ubuntu-sshd/](https://hub.docker.com/r/rastasheep/ubuntu-sshd/)\n\n```bash\nsudo docker run -d -p 22:22 rastasheep/ubuntu-sshd:16.04\n```\n\n用户名、密码为root\n\n------\n\n镜像②：itscaro/debian-ssh （带ssh的ubuntu） \n\n地址：[https://hub.docker.com/r/itscaro/debian-ssh/](https://hub.docker.com/r/itscaro/debian-ssh/)\n\n```bash\nsudo docker run -d -p 22:22 itscaro/debian-ssh\n```\n\n用户名、密码为root\n\n------\n\n 镜像③：tutum/centos （带ssh的centos） \n\n地址：[https://hub.docker.com/r/tutum/centos/](https://hub.docker.com/r/tutum/centos/)\n\n sudo docker run -d -p 22:22  tutum/centos\n\n（centos7：tutum/centos:centos7 ）\n\n用户名root，\n\n密码随机，请执行 docker logs <CONTAINER_ID> 查看\n\n这个作者还有好多好东西：[https://hub.docker.com/r/tutum/centos/](https://hub.docker.com/r/tutum/centos/)\n\n------\n\n镜像④：alexwhen/docker-2048（游戏2048）\n\n地址：[https://hub.docker.com/r/alexwhen/docker-2048/](https://hub.docker.com/r/alexwhen/docker-2048/)\n\nsudo docker run -d -p 80:80 alexwhen/docker-2048\n\n------\n\n镜像⑤：dorowu/ubuntu-desktop-lxde-vnc（noVNC、Firefox51）\n\n地址：[https://hub.docker.com/r/dorowu/ubuntu-desktop-lxde-vnc/](https://hub.docker.com/r/dorowu/ubuntu-desktop-lxde-vnc/)\n\ndocker run -it  -p 80:80 dorowu/ubuntu-desktop-lxde-vnc\n\nBrowse [http://localhost](http://localhost)\n\n------\n\n镜像⑥：consol/centos-xfce-vnc （VNC、noVNC、密码、chrome、Firefox45）\n\n地址：[https://hub.docker.com/r/consol/ubuntu-xfce-vnc/](https://hub.docker.com/r/consol/ubuntu-xfce-vnc/)\n\nrun -it -p 5901:5901 -p 6901:6901 -e “VNC_PW=my-new-password” -e VNC_RESOLUTION=800×600 consol/centos-xfce-vnc\n\n默认VNC密码：vncpassword\n\nVNC-Server (default VNC port 5901)\n\nnoVNC – HTML5 VNC client (default http port 6901)\n\n其他相关\n\nonsol/centos-xfce-vnc: Centos7 with Xfce4 UI session\n\nconsol/ubuntu-xfce-vnc: Ubuntu with Xfce4 UI session\n\nconsol/centos-icewm-vnc: dev   Centos7 with IceWM UI session\n\nconsol/ubuntu-icewm-vnc: dev    Ubuntu with IceWM UI session\n\n------\n\n镜像⑦：fish/peerflix-server （支持磁力，种子）\n\n地址：[https://hub.docker.com/r/fish/peerflix-server](https://hub.docker.com/r/fish/peerflix-server)\n\ndocker run -it  -p 9000:9000 fish/peerflix-server\n\nBrowse [http://localhost:9000/](http://localhost:9000/)\n\n------\n\n镜像⑧：jpillora/cloud-torrent（种子下载，搜索）\n\n地址：[https://hub.docker.com/r/jpillora/cloud-torrent/]([https://hub.docker.com/r/jpillora/cloud-torrent/)\n\ndocker run -d -p 3000:3000 -v /path/to/my/downloads:/downloads jpillora/cloud-torrent\n\nBrowse [http://localhos](http://localhost) \n\n------\n\n镜像⑨：jim3ma/google-mirror（google镜像，如需ssl要手动添加）\n\n地址：[https://hub.docker.com/r/jim3ma/google-mirror/](https://hub.docker.com/r/jim3ma/google-mirror/)\n\ndocker run -d -p 80:80 jim3ma/google-mirror\n\nBrowse [http://localhos](http://localhost) \n\n------\n\n镜像⒑：google-reverse-proxy（google镜像，有ssl）\n\n地址：[https://hub.docker.com/r/jokester/google-reverse-proxy/](https://hub.docker.com/r/jokester/google-reverse-proxy/)\n\ndocker run -d –publish 54321:20081 –restart=always jokester/google-reverse-proxy\n\nBrowse [https://ip:54321/ ](https://ip:54321/)\n\n------\n\n镜像⒒：forsaken-mail（临时邮箱）\n\n地址：[https://hub.docker.com/r/rockmaity/forsaken-mail/](https://hub.docker.com/r/rockmaity/forsaken-mail/)\n\ndocker run –name forsaken-mail -itd -p 25:25 -p 3000:3000 rockmaity/forsaken-mail\n\nBrowse [http://ip:3000/ ](http://ip:3000/)\n\n------\n\n镜像⒓：imdjh/owncloud-with-ocdownloader（owncloud,torrent,aria2,youtube-dl）\n\n地址：[https://hub.docker.com/r/imdjh/owncloud-with-ocdownloader/](https://hub.docker.com/r/imdjh/owncloud-with-ocdownloader/)\n\ndocker run -d -p 80:80 -e OWNCLOUD_VERSION=9.1.4 -v /var/www/html/data:/var/www/html/data imdjh/owncloud-with-ocdownloader\n\nBrowse [http://ip/ ](http://ip/ )\n\n------\n\n镜像⒔：v2ray/official（v2ray）\n\n地址：[https://hub.docker.com/r/v2ray/official/](https://hub.docker.com/r/v2ray/official/)\ndocker run -d -p 8001:8001 v2ray/official\n\n参考：[https://liyuans.com/archives/arukas-build-v2ray.html](https://liyuans.com/archives/arukas-build-v2ray.html)\n\n------\n\n镜像⒕：timonier/aria2\n\n地址：[https://hub.docker.com/r/timonier/aria2/](https://hub.docker.com/r/timonier/aria2/)\n\ndocker run -i  -t -v /data:/data –net host timonier/aria2 –dir=/data –enable-rpc –rpc-listen-all=true\n\n配合使用：timonier/webui-aria2（aria2web管理）\n\n地址：[https://hub.docker.com/r/timonier/webui-aria2/](https://hub.docker.com/r/timonier/webui-aria2/)\n\ndocker run -i -t -p 80:80 timonier/webui-aria2\n\n------\n\n镜像15：jaegerdocker/pan\n\nDocker Hub: [https://hub.docker.com/r/jaegerdocker/pan/](https://hub.docker.com/r/jaegerdocker/pan/)\n\n简介：Docker-Pan: Filerun + AriaNg + Aria2 实现离线下载及在线播放\n\n详细介绍：老司机使用 docker-pan 一键搭建可离线磁力种子的私有云盘,可在线播放预览文件 \n\nhttps://www.v2ex.com/t/383801\n\n------\n\n镜像16：aria2-ariang-x-docker-compose\n\n代码地址： [https://github.com/wahyd4/aria2-ariang-x-docker-compose](https://github.com/wahyd4/aria2-ariang-x-docker-compose)\n\n简介：docker-compose: docker-pan 老司机优化版 / 在线下载 BT 磁链 / 在线观看 / 全功能文件管理 / 云盘应用\n\n详情：老司机优化版：使用 docker / docker-compose 搭建在线下载 BT, 磁力链接，在线观看，全功能文件管理，云盘应用 \n\nhttps://www.v2ex.com/t/385118\n\n\n\n\n\n## 附：参考资料\t\n\n[https://docs.docker.com/registry/recipes/mirror/](https://docs.docker.com/registry/recipes/mirror/)\n\n[https://y0ngb1n.github.io/a/docker-registry-mirrors.html](https://y0ngb1n.github.io/a/docker-registry-mirrors.html)\n\n[Docker 命令参考文档](https://docs.docker.com/engine/reference/commandline/cli/?spm=5176.8351553.0.0.6eb21991rT7ejF)\n\n[Docker 入门教程](https://www.ruanyifeng.com/blog/2018/02/docker-tutorial.html)\n\n[Docker安装文档](https://docs.docker.com/docker-for-windows/install/)\n\n[https://yeasy.gitbook.io/docker_practice/](https://yeasy.gitbook.io/docker_practice/)", "user_name": "心梦", "description": "心中有梦，脚下有路，未来就有方向。", "got_view_count": 4021, "category_name": "后端", "ctime": 1457483880}
{"tag_name": "Java", "concern_user_count": 252043, "user_id": "536217406939703", "title": "看阿里P7讲MyBatis：从MyBatis的理解以及配置和实现全帮你搞懂", "mark_content": "## 前言\n\nMyBatis 是一款优秀的持久层框架，一个半 ORM（对象关系映射）框架，它支持定制化 SQL、存储过程以及高级映`射。MyBatis 避免了几乎所有的 JDBC 代码和手动设置参数以及获取结果集。MyBatis 可以使用简单的 XML 或注解来配置和映射原生类型、接口和 Java 的 POJO（Plain Old Java Objects，普通老式 Java 对象）为数据库中的记录。\n\n## MyBatis的作用\n\nMyBatis作用是在持久层也就是访问数据库的操作,以前我们访问数据库是用JDBC来访问数据库,JDBC访问数据库需要写很多重复的代码,假如数据库访问很多还需要对数据库连接进行不停的打开连接和关闭连接,很消耗系统性能\nMyBatis封装了JDBC底层访问数据库的代码,让我们程序猿只需要关心如何去写好SQL就好,不在需要去写JDBC底层的代码\n\n## MyBatis的优缺点\n\n## 优点\n\n*   MyBatis封装了JBDC底层访问数据库的细节,使我们程序猿不需要与JDBC API打交道,就可以访问数据库\n*   MyBatis简单易学,程序猿直接编写SQL语句,适合于对SQL语句性能要求比较高的项目\n*   SQL语句封装在配置文件中，便于统一管理与维护，降低了程序的耦合度\n*   SQL代码从程序代码中彻底分离出来，可重用\n*   提供了动态SQL标签，支持编写动态SQL\n*   提供映射标签，支持对象与数据库的ORM字段关系映射\n\n## 缺点\n\n*   过于依赖数据库SQL语句,导致数据库移植性差,更换数据库,如果SQL语句有差异,SQL语句工作量大\n*   由于xml里标签id必须唯一，导致DAO中方法不支持方法重载\n\n# MyBatis的配置文件\n\n## properties元素\n\nproperties元素描述的都是外部化,可替代的属性\n一般用来配置连接数据源,我们可以使用property子节点来配置也可以使用资源路径引用\n\n使用property子节点来配置\n\n```\n    <properties>\n        <property name=\"driver\" value=\"com.mysql.jdbc.Driver\"/>\n        <property name=\"url\" value=\"jdbc:mysql:///mybatis\"/>\n        <property name=\"username\" value=\"root\"/>\n        <property name=\"password\" value=\"root\"/>\n    </properties>\n\n```\n\n使用资源路径引用\n\n```\n    <properties resource=\"jdbcConfig.properties\"/>\n\n```\n\njdbcConfig.properties里面的属性\n\n```\ndriver=com.mysql.jdbc.Driver\nurl=jdbc:mysql://127.0.0.1:3306/test\nusername=root\npassword=123456\n\n```\n\n连接数据源的配置\n\n```\n\t<dataSource type=\"POOLED\">\n        <property name=\"driver\" value=\"${driver}\"/>\n        <property name=\"url\" value=\"${url}\"/>\n        <property name=\"username\" value=\"${username}\"/>\n        <property name=\"password\" value=\"${password}\"/>\n    </dataSource>\n\n```\n\n假如使用property子节点来配置和使用资源路径引用都用了,这个时候MyBatis会调用哪个勒?MyBatis会调用资源路径引用的属性值,因为资源路径引用的优先级高于property子节点的优先级\n\n## settings元素\n\nsettings是 MyBatis 中极为重要的调整设置，它们会改变 MyBatis 的运行时行为\n\n```\n    <settings>\n        <!-- 全局映射器启用缓存 -->\n        <setting name=\"cacheEnabled\" value=\"true\"/>\n\n        <!-- 查询时，关闭关联对象即时加载以提高性能 -->\n        <setting name=\"lazyLoadingEnabled\" value=\"true\"/>\n\n        <!-- 设置关联对象加载的形态，此处为按需加载字段 (加载字段由 SQL指 定 )，不会加载关联表的所有字段，以提高性能 -->\n        <setting name=\"aggressiveLazyLoading\" value=\"false\"/>\n\n        <!-- 对于未知的 SQL查询，允许返回不同的结果集以达到通用的效果 -->\n        <setting name=\"multipleResultSetsEnabled\" value=\"true\"/>\n\n        <!-- 允许使用列标签代替列名 -->\n        <setting name=\"useColumnLabel\" value=\"true\"/>\n\n        <!-- 允许使用自定义的主键值 (比如由程序生成的 UUID 32位编码作为键值 )，数据表的 PK生成策略将被覆盖 -->\n        <setting name=\"useGeneratedKeys\" value=\"true\"/>\n\n        <!-- 给予被嵌套的 resultMap以字段 -属性的映射支持 -->\n        <setting name=\"autoMappingBehavior\" value=\"FULL\"/>\n\n        <!-- 对于批量更新操作缓存 SQL以提高性能 -->\n        <setting name=\"defaultExecutorType\" value=\"BATCH\"/>\n\n        <!-- 数据库超过 25000秒仍未响应则超时 -->\n        <setting name=\"defaultStatementTimeout\" value=\"25000\"/>\n    </settings>\n\n```\n\n## typeAliases元素\n\ntypeAliases元素的作用是给JavaBean取别名,方便我们在mappeer配置文件中使用\n\n当我们没有给JavaBean取别名,mapper配置文件中获取JavaBean的时候,我们就需要获取JavaBean所在项目里面的全路径\n\n```\n    <!--省略部分代码-->\n    <select id=\"login\" resultType=\"cn.friday.pojo.DevUser\">\n        SELECT * FROM dev_user WHERE devCode=#{devCode} AND devPassword=#{devPassword}\n    </select>\n\n```\n\n接下来我们就来给JavaBean取别名\n\n```\n    <typeAliases>\n        <typeAlias type=\"cn.friday.pojo.DevUser\" alias=\"devUser\"/>\n        <typeAlias type=\"cn.friday.pojo.AppInfo\" alias=\"appInfo\"/>\n    </typeAliases>\n\n```\n\n给每个JavaBean去取一个指定的别名,这样是有缺陷的,万一项目中有很多个POJO那么工作量就大了,不过还有一种方法给指定的包里面所有的JavaBean都取一个别名,MyBatis会自动扫描所指定的包下的JavaBean并且给一个默认的别名,默认的别名为JavaBean的名称,请看下面\n\n```\n    <typeAliases>\n        <package name=\"cn.friday.pojo\"/>\n    </typeAliases>\n\n```\n\nmapper里面的配置文件就可以正常使用JavaBean取的别名了,不需要再去获取JavaBean的全路径了\n\n```\n    <!--省略部分代码-->\n    <select id=\"login\" resultType=\"DevUser\">\n        SELECT * FROM dev_user WHERE devCode=#{devCode} AND devPassword=#{devPassword}\n    </select>\n\n```\n\n## environments元素\n\nMyBatis可以配置多种环境,如开发环境、测试环境、生产环境等,我们可以灵活选择不同的配置,从而将SQL映射应用到不同的数据库环境上.这些不同的运行环境我们就可以用environments元素来配置实现\n\nenvironments元素元素的配置\n\n```\n\t<!--开发环境-->\n \t<!--default属性表示在默认的情况下我们将启用的数据源-->\n    <environments default=\"development\">\n    <!--id属性用来标识一个数据源的，方便在MyBatis中使用 -->\n        <environment id=\"development\">\n            <!-- 使用jdbc事务管理 -->\n            <transactionManager type=\"JDBC\"/>\n            <!-- 配置数据库连接池 -->\n            <dataSource type=\"POOLED\">\n                <property name=\"driver\" value=\"com.mysql.jdbc.Driver\"/>\n                <property name=\"url\" value=\"jdbc:mysql://127.0.0.1:3306/test\"/>\n                <property name=\"username\" value=\"root\"/>\n                <property name=\"password\" value=\"123456\"/>\n            </dataSource>\n        </environment>\n\n        <!--我们在来配置一个测试环境-->\n         <environment id=\"test\">\n            <!-- 使用jdbc事务管理 -->\n            <transactionManager type=\"JDBC\"/>\n            <!-- 配置数据库连接池 -->\n            <dataSource type=\"POOLED\">\n                <property name=\"driver\" value=\"com.mysql.jdbc.Driver\"/>\n                <property name=\"url\" value=\"jdbc:mysql://127.0.0.1:3306/test1\"/>\n                <property name=\"username\" value=\"root\"/>\n                <property name=\"password\" value=\"123456\"/>\n            </dataSource>\n        </environment>\n    </environments>\n\n```\n\n假如我们想从开发环境变成测试环境只需要修改environments元素里面的default属性即可\n\n```\n <environments default=\"test\">\n \t<!--省略部分代码-->\n </environments>\n\n```\n\n## mappers元素\n\nmappers映射器,说简单点就是告诉MyBatis去哪里找到SQL语句映射文件,我们可以使用类资源路径或者是URL等\n用类资源路径获取映射文件\n\n```\n    <mappers>\n        <mapper resource=\"cn/friday/dao/developer/DevUserMapper.xml\"/>\n        <mapper resource=\"cn/friday/dao/developer/AppInfoMapper.xml\"/>\n    </mappers>\n\n```\n\n用URL获取映射文件\n\n```\n    <mappers>\n          <mapper url=\"file:///D:/mappers/DevUserMapper.xml\"/>\n          <mapper url=\"file:///D:/mappers/AppInfoMapper.xml\"/>\n    </mappers>\n\n```\n\n## 如何实现MyBatis\n\n先给大家看一下我的项目结构\n![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/fb4483345a7d4de39eb9800072f5e481~tplv-k3u1fbpfcp-zoom-1.image)\n\n## 第一步 导入依赖\n\n我的是maven项目所以只需要在pox.xml配置文件中添加关于MyBatis的依赖即可\n\n```\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<project xmlns=\"http://maven.apache.org/POM/4.0.0\"\n         xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n         xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\">\n    <modelVersion>4.0.0</modelVersion>\n\n    <groupId>org.example</groupId>\n    <artifactId>MyBatis</artifactId>\n    <version>1.0-SNAPSHOT</version>\n\n    <dependencies>\n        <dependency>\n            <groupId>junit</groupId>\n            <artifactId>junit</artifactId>\n            <version>4.11</version>\n            <scope>test</scope>\n        </dependency>\n\n        <dependency>\n        <groupId>mysql</groupId>\n        <artifactId>mysql-connector-java</artifactId>\n        <version>6.0.6</version>\n    </dependency>\n\n        <dependency>\n            <groupId>org.mybatis</groupId>\n            <artifactId>mybatis</artifactId>\n            <version>3.4.4</version>\n        </dependency>\n\n    </dependencies>\n\n    <build>\n    <resources>\n        <resource>\n            <directory>src/main/java/</directory>\n            <includes>\n                <include>**/*.xml</include>\n            </includes>\n        </resource>\n    </resources>\n    </build>\n</project>\n\n```\n\n## 第二步 创建MyBatis配置文件\n\n这些配置文件上面也用讲的过这里就不做过多的解释了\n\n```\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<!DOCTYPE configuration PUBLIC \"-//mybatis.org//DTD Config 3.0//EN\"\n        \"http://mybatis.org/dtd/mybatis-3-config.dtd\">\n<configuration>\n    <properties resource=\"jdbc-config.properties\"/>\n\n    <typeAliases>\n        <package name=\"com.friday.pojo\"/>\n    </typeAliases>\n\n    <environments default=\"test\">\n        <environment id=\"test\">\n            <transactionManager type=\"JDBC\"></transactionManager>\n            <dataSource type=\"POOLED\">\n                <property name=\"driver\" value=\"${driver}\"/>\n                <property name=\"url\" value=\"${url}\"/>\n                <property name=\"username\" value=\"${username}\"/>\n                <property name=\"password\" value=\"${password}\"/>\n            </dataSource>\n        </environment>\n    </environments>\n\n    <mappers>\n        <mapper resource=\"com/friday/dao/UserMapper.xml\"></mapper>\n    </mappers>\n</configuration>\n\n```\n\njdbc-config.properties里面的属性\n\n```\ndriver=com.mysql.jdbc.Driver\nurl=jdbc:mysql://127.0.0.1:3306/test?serverTimezone=UTC\nusername=root\npassword=123456\n\n```\n\n## 第三步 创建接口以及映射文件\n\n接口,普通的java接口\n\n```\npackage com.friday.dao;\n\nimport com.friday.pojo.User;\nimport org.apache.ibatis.annotations.Param;\n\npublic interface UserMapper {\n//@Param相对应给String userCode取了一个别名叫做userPassword,我们到写映射SQL语句的时候只有#{注解名称}即可,如#{userPassword}\n    public User login(@Param(\"userCode\") String userCode,@Param(\"userPassword\") String pwd);\n}\n\n```\n\n映射文件\n\n```\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<!DOCTYPE mapper PUBLIC\n        \"-//mybatis.org//DTD Mapper 3.0//EN\"\n        \"http://mybatis.org/dtd/mybatis-3-mapper.dtd\">\n<mapper namespace=\"com.friday.dao.UserMapper\">\n    <select id=\"login\" resultType=\"User\" parameterType=\"string\">\n        SELECT * FROM smbms_user WHERE userCode=#{userCode} AND userPassword=#{userPassword}\n    </select>\n</mapper>\n\n```\n\nmapper 文件里面的属性\n\n*   namespace属性 指定相对应的接口\n*   id属性 接口里面具体的方法名\n*   resultType 返回值的类型\n*   resultType 传进来的参数的类型\n\n## 第四步 测试\n\n```\npackage com.friday.test;\n\nimport com.friday.dao.UserMapper;\nimport com.friday.pojo.User;\nimport org.apache.ibatis.annotations.Param;\nimport org.apache.ibatis.io.Resources;\nimport org.apache.ibatis.session.SqlSession;\nimport org.apache.ibatis.session.SqlSessionFactory;\nimport org.apache.ibatis.session.SqlSessionFactoryBuilder;\n\nimport java.io.IOException;\nimport java.io.InputStream;\n\npublic class MyBatisTest {\n   public static void main(String[] args) throws IOException {\n       //读取mybatis配置文件\n       String resource = \"mybatis-config.xml\";\n       //获取mybatis配置文件的输入流\n       InputStream is = Resources.getResourceAsStream(resource);\n       //创建SqlSessionFactory对象\n       SqlSessionFactory factory = new SqlSessionFactoryBuilder().build(is);\n       //打开sqlSession对象\n       SqlSession sqlSession =  factory.openSession();\n\n       //获取对应的Mapper，让映射器通过命名空间和方法名称找到对应的SQL，发送给数据库执行后返回结果。\n       User user = sqlSession.getMapper(UserMapper.class).login(\"zhanghua\",\"userPassword\");\n\n       //看一下是否可以查到数据\n       if (user != null) {\n           System.out.println(\"登录成功\");\n       } else {\n           System.out.println(\"登录失败\");\n       }\n\n       //关闭sqlSession对象\n       sqlSession.close();\n   }\n}\n```\n## 最后\n感谢你看到这里，看完有什么的不懂的可以在评论区问我，觉得文章对你有帮助的话记得给我点个赞，每天都会分享java相关技术文章或行业资讯，欢迎大家关注和转发文章！\n", "user_name": "前程有光", "description": "", "got_view_count": 35979, "category_name": "后端", "ctime": 1457483880}
{"tag_name": "Android", "concern_user_count": 240175, "user_id": "272334612601559", "title": "Looper.loop()引发的惨案", "mark_content": "## 1、案件描述\n\n在一个安静的下午，一妹子在`RxHttp`群里反馈(群号：378530627)，自己开发的app，账号被挤下线时，重新登录到首页后，发现有一个请求，代码执行了，却没有任何回调，看得出，妹子很着急。\n\n\n\nwhat ???  还有这种事？原本安静的群，一下活跃了起来，男同胞们一顿狂猜，我总结了下，如下：\n\n- 会不会请求代码没执行，妹子自己搞错了吧？\n\n- 发请求前，出现异常，代码被中断运行？\n\n- 请求过程伴随着页面跳转，导致页面销毁时，请求被自动关闭？\n\n- 请求过程出现异常，被RxJava全局异常捕获了，并吃掉了，所以收不到失败回调？\n\n\n\n这里解释下，妹子采用`RxHttp+RxJava`结合的方式发请求\n\n\n\n经过第一轮询问后，以上猜想轻而易举的被推翻了，我也大概知道了案件的细节，为此，我用代码来还原一下，为简化案件，还原时，我会适当的做出修改，但意思还是那个意思。\n\n## 2、案件还原\n\n妹子在首页`MainActivity`的`OnCreate`方法，会并行3个请求，如下：\n\n```java\n@Override                                                              \nprotected void onCreate(Bundle savedInstanceState) {                   \n    super.onCreate(savedInstanceState);                                \n    setContentView(R.layout.main_activity);                            \n    request1();                                                        \n    request2();                                                        \n    request3();                                                        \n}                                                                      \n                                                                                                                                            \npublic void request1() {                                               \n    RxHttp.get(\"/service/...\")                                         \n        .asString()                                                    \n        .to(RxLife.toMain(this))  //页面销毁，自动关闭请求，并在UI线程回调                        \n        .subscribe(s -> {                                              \n            //成功回调                                                     \n        }, throwable -> {                                              \n            //异常回调                                                     \n        });                                                            \n}                                                                      \n                                                                       \npublic void request2() {                                               \n    //省略请求代码，请求代码类似request1()方法                                        \n}                                                                      \n                                                                       \npublic void request3() {                                               \n    //省略请求代码，请求代码类似request1()方法                                        \n}                                                                      \n```\n\n\n\n这段代码看起来并没有任何问题，正常登录进来后，都是正常的。\n\n但是当账号被挤下线后(挤到登录页)，重新登录到首页后，发现`request1()、request2()、request3()`三个请求方法都执行了，可`request2()`方法却迟迟收不到回调，不管成功/失败都收不到。\n\n\n\n## 3、开始办案\n\n以上猜想全部被推翻，接下来怎么办？很明显，我们要明确一点：\n\n`请求到底有没有发出去？服务端有没有收到这个请求？`\n\n\n\n随后，妹子用`Adnroid Studio`自带的`Profiler`工具，监控了下，发现请求并未发出来，接着，又找后台人员确认了下，后台也并未收到这个请求。\n\n\n\n那就更奇怪了，请求代码执行了，请求却没有发出去？作为程序员的我第一反应，这怎么可能呢？妹子你用的手机有问题吧？要不换个手机试试？显然换了手机，问题一样存在，这就尴尬了。\n\n\n\n接下来，跟妹子不断的调试，一而再，再而三的确认了，请求代码没有任何问题，然而，我却陷入了沉思之中，很绝望，很无助，甚至怀疑这是`OkHttp`的问题。\n\n\n\n作为一名老鸟，最后我还是冷静了下来，重新整理了线索，发现又一条线索被遗漏了，那就是账号被挤，自动跳转到登录页面，为什么只有在账号被挤时，才会出现问题？于是乎，我调整了调查方向\n\n- 账号是如何被挤？又是如何跳转到登录页面的？\n\n终于，凶手露出了水面，凶手就是`Looper`，原来妹子是通过`OkHttp`的拦截器来监听账号被挤，并通过`Looper`来弹出一个`Toast`提示，并且执行页面跳转逻辑，如下：\n\n```java\npublic class TokenInterceptor implements Interceptor {\n    \n    private Context context;\n    \n    //省略部分代码\n\n    @Override\n    public Response intercept(Chain chain) throws IOException {\n        Request request = chain.request();\n        Response originalResponse = chain.proceed(request);\n        String code = originalResponse.header(\"code\");\n        if (\"-1\".equals(code)) { //账号被挤\n            Looper.prepare();\n            Toast.makeText(context, \"你的账号在其它设备上登录\", Toast.LENGTH_LONG).show();\n            context.startActivity(new Intent(context, LoginActivity.class));\n            Looper.loop();\n        }\n        return originalResponse;\n    }\n}\n```\n\n也许你会问，这确定有问题？通过`Looper`在子线程弹出一个`Toast`，这不是很正常的一件事？经常这么干，从来没出现任何问题，为啥到你这就出问题？\n\n\n\n我让妹子把`Looper及Toast`代码注释掉，`if`语句里面只保留一行`startActivity`，妹子试后开心的跟我说，好了，没问题了，这怎么解释？\n\n\n\n## 4、开始破案\n\n`Looper`一脸委屈的说道：你说我是凶手，我就是凶手了，证据呢？\n\nok，我们就来寻找证据，我们知道，`Looper.loop()`方法内部，会开启一个死循环，如下：\n\n```java\n public static void loop() {\n     //省略部分代码\n     for (;;) {                                                         \n         Message msg = queue.next(); // might block                 \n         if (msg == null) {                                             \n            // No message indicates that the message queue is quitting.\n            return;                                                    \n         }\n         //省略部分代码   \n     }\n     //省略部分代码                                                               \n }\n```\n\n可以看到，`queue.next()`这行代码官方注释了，有可能会被堵塞，什么时候会堵塞？没有消息的时候，可见，调用`Looper.loop()`方法所在的线程会进入死循环。\n\n\n\n那这个和我们的案件有什么关系呢？\n\n\n\n这就要来说说`RxJava`的线程池了，上面`TokenInterceptor`回调所在的线程是`RxJava`的`IO`线程，而`RxJava`的`IO`线程池的配置，却仅允许一条核心线程执行任务，当任务在执行，其它任务过来时，必须等待至上一个任务结束。\n\n在`IoScheduler`类中可以找到静态内部类`ThreadWorker`，`ThreadWorker`继承至`NewThreadWorker`，在该类中，我们可以找到线程池对象，如下：\n\n```java\npublic class NewThreadWorker extends Scheduler.Worker implements Disposable {\n    private final ScheduledExecutorService executor;\n\n    //省略部分代码\n    \n    public NewThreadWorker(ThreadFactory threadFactory) {\n        //这里创建了线程池\n        executor = SchedulerPoolFactory.create(threadFactory);\n    }\n    //省略部分代码\n}    \n```\n\n`SchedulerPoolFactory.create`方法点进去看看\n\n```java\npublic static ScheduledExecutorService create(ThreadFactory factory) {\n    final ScheduledExecutorService exec = Executors.newScheduledThreadPool(1, factory);  //核心线程数量为1\n    //省略部分代码\n    return exec;\n}\n```\n\n可以看到，这里传了个1，就是核心线程的数量，继续往下看，最终找到了创建线程池对象代码，如下：\n\n```java\npublic ScheduledThreadPoolExecutor(int corePoolSize,             \n                                   ThreadFactory threadFactory) {\n    super(corePoolSize, Integer.MAX_VALUE,                       \n          DEFAULT_KEEPALIVE_MILLIS, MILLISECONDS,                \n          new DelayedWorkQueue(), threadFactory);                \n}                                                                \n```\n\n这里简单解读一下，该线程池核心线程数量为1，非核心线程数量无上限，非核心线程闲置时间超过10毫秒便会被回收，并使用了延迟队列。\n\n\n\n***注意注意，前方高能预警***\n\n\n\n用简单的话来说，该线程池，同一时间，仅会执行一个任务，也就是串行，这也就解释`Looper`与本案的关系，因为`Looper.loop()`所在线程进入死循环，该线程所在线程池收到其它任务时，便必须得等待至上一个任务执行完毕，然而上一个任务在死循环，所以下一个任务永远得不到执行，这也就是为什么请求代码执行了，请求却没发出去原因。\n\n\n\n## 5、其它思考\n\n到这，估计很多人会有疑问\n\n- `RxJava`的`Io`线程池，是串行执行的，那么它又是如何做到并行的呢？难道以前写的并行代码，其实都是串行实现的？\n\n- 线程池已经有任务在执行了，为啥还会拿到该线程池执行新的任务呢？\n\n- `RxJava`为啥不使用`OkHttp`内部的线程池配置，只要有任务来，都开启非核心线程去执行？\n\n\n\nok，接下来一一解答\n\n首先，第一个，`RxJava`如何根据目前的`Io`线程池，做到并行任务？\n\n其实很简单，在`IoScheduler`的静态内部类`CachedWorkerPool`中，维护了一个线程池队列，每次收到新任务，都会从队列里面取出一个线程池去执行任务，如果没有，则创建一个新的线程池，如下：\n\n```java\nstatic final class CachedWorkerPool implements Runnable {\n    //这个就是线程池队列                                   \n    private final ConcurrentLinkedQueue<ThreadWorker> expiringWorkerQueue\n    final CompositeDisposable allWorkers;                             \n    private final ThreadFactory threadFactory;                        \n                                                                      \n    //省略部分代码                                                              \n    \n    //取出一个线程池                                                                  \n    ThreadWorker get() {                                              \n        if (allWorkers.isDisposed()) {                                \n            return SHUTDOWN_THREAD_WORKER;                            \n        }                                                             \n        while (!expiringWorkerQueue.isEmpty()) {                      \n            ThreadWorker threadWorker = expiringWorkerQueue.poll();   \n            if (threadWorker != null) {                               \n                return threadWorker;  //队列里有，直接返回                                  \n            }                                                         \n        }                                                             \n                                                                      \n        // 队列没有，创建一个新的               \n        ThreadWorker w = new ThreadWorker(threadFactory);             \n        allWorkers.add(w);                                            \n        return w;                                                     \n    }\n    \n    //回收线程池，任务被取消或者正常执行完毕，将线程池添加进缓存队列\n    void release(ThreadWorker threadWorker) {                     \n        //设置线程池过期时间，60s   keepAliveTime=60s\n        threadWorker.setExpirationTime(now() + keepAliveTime);    \n                                                                  \n        expiringWorkerQueue.offer(threadWorker);                  \n    }                                                             \n    //省略部分代码\n}                                                                 \n```\n\n通过多个线程池，就达到了并行的效果；上面代码`release`方法中，我们注意到，被回收的线程池，存活时间为60s，在`CachedWorkerPool` 构造方法中，会开启一个定时任务，每间隔60s，就会去检查线程池队列，如果线程池闲置超过60s，便会将线程池关闭，并从队列中移除。\n\n\n\n接着，回答第二个问题，线程池已经有任务在执行了，为啥还会拿到该线程池执行新的任务？\n\n\n\n看了上面的代码，其实就很好回答了，回收线程池有两个条件会触发，一是任务正常执行完毕，这个好理解，不做解释，另外一个就是，任务被取消，比如，调用`Disposable#isDisposed()`方法取消任务，但是该方法不会取消线程池里的任务，这就导致了，线程池虽然被回收了，但线程池里的任务依然在执行，所以下次拿到该线程池的任务，只能等待。\n\n\n\n最后，就是RxJava为何要如此设计线程池？\n\n\n\n原因很简单，防止线程资源被浪费，如上面说到的，线程池虽然被回收了，但里面的线程却依然在执行任务，这样的线程多了，无疑是一种浪费，怎么办？依靠定时器，让被回收的线程池在一定时间后，关闭任务，并从队列中移除。而如果直接通过线程池去回收线程，那么被`Looper.loop()` 的线程，进入死循环后，将永远得不到回收。\n\n\n到这，我也丢个问题给大家，RxJava在将线程池丢进缓存队列时，为啥不将线程池关闭掉？欢迎评论群留言讨论\n\n\n\n## 6、总结\n\n回顾下案件，从妹子反馈的问题，账号被挤，重新登录到首页后，`request2()`方法内的请求代码执行了，却收不到回调，线程池的原因请求压没有得到执行，故收不到回调，那为啥就`request2()`方法会出问题呢？其实这是一种假象，只要被回收的线程池里还有未完成的任务，那么该线程池再次执行请求，都必须得等待。如果账号在60s内重复被挤3次，那么登录到首页后，3个请求都将得不到执行，因为回收池得3个线程池都不能再执行任务了，直到60s后，被计时器强制关闭并移除。\n\n\n\n最后，提醒大家，一定要慎用`Looper`，不是任何时候都适合用`Looper`的，像妹子遇到的这种场景，完全可以用主线程的`Handler post`一个消息出去，然后处理业务，亦或者通过`EventBus、LiveData`等发送消息到主线程，再处理相关逻辑。\n\n\n\n## 7、关于我\n\n我是[RxHttp](https://github.com/liujingxing/okhttp-RxHttp) 的作者，热爱开源，致力于打造一款简单好用的http请求框架，支持`RxJava2/RxJava3/协程`，截止目前，在[github也有2200+star](https://github.com/liujingxing/okhttp-RxHttp)，目前处于非常火热的一个框架；另外，我还个自己的群：***RxHttp&RxLife 交流群：378530627***，截止目前有500+人，里面经常会有技术交流，开车勿进，非诚勿扰。\n\n\n", "user_name": "不怕天黑", "description": "极简主义者", "got_view_count": 109072, "category_name": "Android", "ctime": 1461266353}
{"tag_name": "Java", "concern_user_count": 252043, "user_id": "377887732546702", "title": "你的登录接口真的安全吗？", "mark_content": "<section id=\"nice\" data-tool=\"mdnice编辑器\" data-website=\"https://www.mdnice.com\" style=\"color: black; line-height: 1.6; word-spacing: 0px; letter-spacing: 0px; word-break: break-word; word-wrap: break-word; text-align: left; font-family: Optima-Regular, Optima, PingFangSC-light, PingFangTC-light, 'PingFang SC', Cambria, Cochin, Georgia, Times, 'Times New Roman', serif; font-size: 14px; padding: 10px;\"><h1 data-tool=\"mdnice编辑器\" style=\"margin-top: 30px; margin-bottom: 15px; padding: 0px; font-weight: bold; color: black; font-size: 24px;\"><span class=\"prefix\" style=\"display: none;\"></span><span class=\"content\">前言</span><span class=\"suffix\"></span></h1>\n<p data-tool=\"mdnice编辑器\" style=\"padding-top: 8px; padding-bottom: 8px; margin: 0; line-height: 26px; color: black; font-size: 14px;\">大家学写程序时，第一行代码都是<code style=\"font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #ff6441;\">hello world</code>。但是当你开始学习WEB后台技术时，很多人的第一个功能就是写的登录 <em style=\"font-style: italic; color: black;\">（小声：别人我不知道，反正我是）。</em><br>\n但是我在和很多工作经验较短的同学面试或沟通的时候，发现很多同学虽然都有在简历上写：<code style=\"font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #ff6441;\">负责项目的登录/注册功能模块的开发和设计工作</code>，但是都只是简单的实现了功能逻辑，在安全方面并没有考虑太多。这篇文章主要是和大家聊一聊，在设计一个登录接口时，不仅仅是功能上的实现，在安全方面，我们还需要考虑哪些地方。</p>\n<h1 data-tool=\"mdnice编辑器\" style=\"margin-top: 30px; margin-bottom: 15px; padding: 0px; font-weight: bold; color: black; font-size: 24px;\"><span class=\"prefix\" style=\"display: none;\"></span><span class=\"content\">安全风险</span><span class=\"suffix\"></span></h1>\n<h2 data-tool=\"mdnice编辑器\" style=\"margin-top: 30px; margin-bottom: 15px; padding: 0px; font-size: 22px; text-align: center; position: relative; font-weight: bold; color: black; line-height: 1.1em; padding-top: 12px; padding-bottom: 12px; margin: 70px 30px 30px; border: 1px solid #000;\"><span style=\"float: left; display: block; width: 90%; border-top: 1px solid #000; height: 1px; line-height: 1px; margin-left: -5px; margin-top: -17px;\"> </span><span class=\"prefix\" style=\"display: block; width: 3px; margin: 0 0 0 5%; height: 3px; line-height: 3px; overflow: hidden; background-color: #000; box-shadow: 3px 0 #000,\n    0 3px #000,\n    -3px 0 #000,\n    0 -3px #000;\"></span><span class=\"content\" style=\"display: block; -webkit-box-reflect: below 0em -webkit-gradient(linear,left top,left bottom, from(rgba(0,0,0,0)),to(rgba(255,255,255,0.1)));\">暴力破解！</span><span class=\"suffix\" style=\"display: block; width: 3px; margin: 0 0 0 95%; height: 3px; line-height: 3px; overflow: hidden; background-color: #000; box-shadow: 3px 0 #000,\n    0 3px #000,\n    -3px 0 #000,\n    0 -3px #000;\"></span><span style=\"float: right; display: block; width: 90%; border-bottom: 1px solid #000; height: 1px; line-height: 1px; margin-right: -5px; margin-top: 16px;\"> </span></h2>\n<p data-tool=\"mdnice编辑器\" style=\"padding-top: 8px; padding-bottom: 8px; margin: 0; line-height: 26px; color: black; font-size: 14px;\">只要网站是暴露在公网的，那么很大概率上会被人盯上，尝试爆破这种简单且有效的方式：<br>\n<strong style=\"font-weight: bold; color: black;\">通过各种方式获得了网站的用户名之后，通过编写程序来遍历所有可能的密码，直至找到正确的密码为止</strong></p>\n<p data-tool=\"mdnice编辑器\" style=\"padding-top: 8px; padding-bottom: 8px; margin: 0; line-height: 26px; color: black; font-size: 14px;\"><em style=\"font-style: italic; color: black;\">伪代码如下：</em></p>\n<pre class=\"custom\" data-tool=\"mdnice编辑器\" style=\"margin-top: 10px; margin-bottom: 10px; box-shadow: rgba(170, 170, 170, 0.48) 0px 0px 6px 0px; max-width: 100%; border-radius: 4px; margin: 10px auto 0 auto;\"><code class=\"hljs\" style=\"overflow-x: auto; padding: 16px; color: #abb2bf; background: #282c34; display: -webkit-box; font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; border-radius: 0px; font-size: 12px; -webkit-overflow-scrolling: touch;\"><span class=\"hljs-comment\" style=\"color: #5c6370; font-style: italic; line-height: 26px;\">#&nbsp;密码字典</span><br>password_dict&nbsp;=&nbsp;[]<br><span class=\"hljs-comment\" style=\"color: #5c6370; font-style: italic; line-height: 26px;\">#&nbsp;登录接口</span><br>login_url&nbsp;=&nbsp;<span class=\"hljs-string\" style=\"color: #98c379; line-height: 26px;\">''</span><br><span class=\"hljs-function\" style=\"line-height: 26px;\"><span class=\"hljs-keyword\" style=\"color: #c678dd; line-height: 26px;\">def</span>&nbsp;<span class=\"hljs-title\" style=\"color: #61aeee; line-height: 26px;\">attack</span><span class=\"hljs-params\" style=\"line-height: 26px;\">(username)</span>:</span><br>&nbsp;<span class=\"hljs-keyword\" style=\"color: #c678dd; line-height: 26px;\">for</span>&nbsp;password&nbsp;<span class=\"hljs-keyword\" style=\"color: #c678dd; line-height: 26px;\">in</span>&nbsp;password_dict:<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;data&nbsp;=&nbsp;{<span class=\"hljs-string\" style=\"color: #98c379; line-height: 26px;\">'username'</span>:&nbsp;username,&nbsp;<span class=\"hljs-string\" style=\"color: #98c379; line-height: 26px;\">'password'</span>:&nbsp;password}<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;content&nbsp;=&nbsp;requests.post(login_url,&nbsp;data).content.decode(<span class=\"hljs-string\" style=\"color: #98c379; line-height: 26px;\">'utf-8'</span>)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class=\"hljs-keyword\" style=\"color: #c678dd; line-height: 26px;\">if</span>&nbsp;<span class=\"hljs-string\" style=\"color: #98c379; line-height: 26px;\">'login&nbsp;success'</span>&nbsp;<span class=\"hljs-keyword\" style=\"color: #c678dd; line-height: 26px;\">in</span>&nbsp;content:<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;print(<span class=\"hljs-string\" style=\"color: #98c379; line-height: 26px;\">'got&nbsp;it!&nbsp;password&nbsp;is&nbsp;:&nbsp;%s'</span>&nbsp;%&nbsp;password)<br></code></pre>\n<p data-tool=\"mdnice编辑器\" style=\"padding-top: 8px; padding-bottom: 8px; margin: 0; line-height: 26px; color: black; font-size: 14px;\">那么这种情况，我们要怎么防范呢？</p>\n<h3 data-tool=\"mdnice编辑器\" style=\"margin-top: 30px; margin-bottom: 15px; font-weight: bold; background-color: #000; color: #fff; padding: 2px 10px; width: fit-content; font-size: 17px; margin: 60px auto 10px;\"><span class=\"prefix\" style=\"display: none;\"></span><span class=\"content\">验证码</span><span class=\"suffix\" style=\"display: none;\"></span></h3>\n<p data-tool=\"mdnice编辑器\" style=\"padding-top: 8px; padding-bottom: 8px; margin: 0; line-height: 26px; color: black; font-size: 14px;\">有聪明的同学就想到了，我可以在它密码错误达到一定次数时，增加验证码校验！ 比如我们设置，当用户密码错误达到3次之后，则需要用户输入图片验证码才可以继续登录操作：</p>\n<p data-tool=\"mdnice编辑器\" style=\"padding-top: 8px; padding-bottom: 8px; margin: 0; line-height: 26px; color: black; font-size: 14px;\"><em style=\"font-style: italic; color: black;\">伪代码如下：</em></p>\n<pre class=\"custom\" data-tool=\"mdnice编辑器\" style=\"margin-top: 10px; margin-bottom: 10px; box-shadow: rgba(170, 170, 170, 0.48) 0px 0px 6px 0px; max-width: 100%; border-radius: 4px; margin: 10px auto 0 auto;\"><code class=\"hljs\" style=\"overflow-x: auto; padding: 16px; color: #abb2bf; background: #282c34; display: -webkit-box; font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; border-radius: 0px; font-size: 12px; -webkit-overflow-scrolling: touch;\">fail_count&nbsp;=&nbsp;get_from_redis(fail_username)<br><span class=\"hljs-keyword\" style=\"color: #c678dd; line-height: 26px;\">if</span>&nbsp;fail_count&nbsp;&gt;=&nbsp;<span class=\"hljs-number\" style=\"color: #d19a66; line-height: 26px;\">3</span>:<br>&nbsp;<span class=\"hljs-keyword\" style=\"color: #c678dd; line-height: 26px;\">if</span>&nbsp;captcha&nbsp;<span class=\"hljs-keyword\" style=\"color: #c678dd; line-height: 26px;\">is</span>&nbsp;<span class=\"hljs-literal\" style=\"color: #56b6c2; line-height: 26px;\">None</span>:<br>&nbsp;&nbsp;<span class=\"hljs-keyword\" style=\"color: #c678dd; line-height: 26px;\">return</span>&nbsp;error(<span class=\"hljs-string\" style=\"color: #98c379; line-height: 26px;\">'需要验证码'</span>)<br>&nbsp;&nbsp;&nbsp;&nbsp;check_captcha(captcha)<br>success&nbsp;=&nbsp;do_login(username,&nbsp;password)<br><span class=\"hljs-keyword\" style=\"color: #c678dd; line-height: 26px;\">if</span>&nbsp;<span class=\"hljs-keyword\" style=\"color: #c678dd; line-height: 26px;\">not</span>&nbsp;success:<br>&nbsp;set_redis(fail_username,&nbsp;fail_count&nbsp;+&nbsp;<span class=\"hljs-number\" style=\"color: #d19a66; line-height: 26px;\">1</span>)<br></code></pre>\n<blockquote data-tool=\"mdnice编辑器\" style=\"display: block; font-size: 0.9em; overflow: auto; overflow-scrolling: touch; color: #6a737d; padding-top: 10px; padding-bottom: 10px; padding-left: 20px; padding-right: 10px; margin-bottom: 20px; margin-top: 20px; border-left: 3px solid rgba(0, 0, 0, 0.65); border-right: 1px solid rgba(0, 0, 0, 0.65); background: rgb(249, 249, 249);\">\n<p style=\"padding-top: 8px; padding-bottom: 8px; font-size: 14px; margin: 0px; color: black; line-height: 26px;\">伪代码未考虑并发，实际开发可以考虑加锁。</p>\n</blockquote>\n<p data-tool=\"mdnice编辑器\" style=\"padding-top: 8px; padding-bottom: 8px; margin: 0; line-height: 26px; color: black; font-size: 14px;\">这样确实可以过滤掉一些非法的攻击，但是以目前的OCR技术来说的话，普通的图片验证码真的很难做到有效的防止机器人（<em style=\"font-style: italic; color: black;\">我们就在这个上面吃过大亏</em>）。当然，我们也可以花钱购买类似于三方公司提供的滑动验证等验证方案，但是也并不是100%的安全，一样可以被破解（<em style=\"font-style: italic; color: black;\">惨痛教训</em>）。</p>\n<h3 data-tool=\"mdnice编辑器\" style=\"margin-top: 30px; margin-bottom: 15px; font-weight: bold; background-color: #000; color: #fff; padding: 2px 10px; width: fit-content; font-size: 17px; margin: 60px auto 10px;\"><span class=\"prefix\" style=\"display: none;\"></span><span class=\"content\">登录限制</span><span class=\"suffix\" style=\"display: none;\"></span></h3>\n<p data-tool=\"mdnice编辑器\" style=\"padding-top: 8px; padding-bottom: 8px; margin: 0; line-height: 26px; color: black; font-size: 14px;\">那这时候又有同学说了，那我可以直接限制非正常用户的登录操作，当它密码错误达到一定次数时，直接拒绝用户的登录，隔一段时间再恢复。比如我们设置某个账号在登录时错误次数达到10次时，则5分钟内拒绝该账号的所有登录操作。</p>\n<p data-tool=\"mdnice编辑器\" style=\"padding-top: 8px; padding-bottom: 8px; margin: 0; line-height: 26px; color: black; font-size: 14px;\"><em style=\"font-style: italic; color: black;\">伪代码如下：</em></p>\n<pre class=\"custom\" data-tool=\"mdnice编辑器\" style=\"margin-top: 10px; margin-bottom: 10px; box-shadow: rgba(170, 170, 170, 0.48) 0px 0px 6px 0px; max-width: 100%; border-radius: 4px; margin: 10px auto 0 auto;\"><code class=\"hljs\" style=\"overflow-x: auto; padding: 16px; color: #abb2bf; background: #282c34; display: -webkit-box; font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; border-radius: 0px; font-size: 12px; -webkit-overflow-scrolling: touch;\">fail_count&nbsp;=&nbsp;get_from_redis(fail_username)<br>locked&nbsp;=&nbsp;get_from_redis(lock_username)<br><br><span class=\"hljs-keyword\" style=\"color: #c678dd; line-height: 26px;\">if</span>&nbsp;locked:<br>&nbsp;<span class=\"hljs-keyword\" style=\"color: #c678dd; line-height: 26px;\">return</span>&nbsp;error(<span class=\"hljs-string\" style=\"color: #98c379; line-height: 26px;\">'拒绝登录'</span>)<br><span class=\"hljs-keyword\" style=\"color: #c678dd; line-height: 26px;\">if</span>&nbsp;fail_count&nbsp;&gt;=&nbsp;<span class=\"hljs-number\" style=\"color: #d19a66; line-height: 26px;\">3</span>:<br>&nbsp;<span class=\"hljs-keyword\" style=\"color: #c678dd; line-height: 26px;\">if</span>&nbsp;captcha&nbsp;<span class=\"hljs-keyword\" style=\"color: #c678dd; line-height: 26px;\">is</span>&nbsp;<span class=\"hljs-literal\" style=\"color: #56b6c2; line-height: 26px;\">None</span>:<br>&nbsp;&nbsp;<span class=\"hljs-keyword\" style=\"color: #c678dd; line-height: 26px;\">return</span>&nbsp;error(<span class=\"hljs-string\" style=\"color: #98c379; line-height: 26px;\">'需要验证码'</span>)<br>&nbsp;&nbsp;&nbsp;&nbsp;check_captcha(captcha)&nbsp;<br>success&nbsp;=&nbsp;do_login(username,&nbsp;password)<br><span class=\"hljs-keyword\" style=\"color: #c678dd; line-height: 26px;\">if</span>&nbsp;<span class=\"hljs-keyword\" style=\"color: #c678dd; line-height: 26px;\">not</span>&nbsp;success:<br>&nbsp;set_redis(fail_username,&nbsp;fail_count&nbsp;+&nbsp;<span class=\"hljs-number\" style=\"color: #d19a66; line-height: 26px;\">1</span>)<br>&nbsp;&nbsp;&nbsp;&nbsp;<span class=\"hljs-keyword\" style=\"color: #c678dd; line-height: 26px;\">if</span>&nbsp;fail_count&nbsp;+&nbsp;<span class=\"hljs-number\" style=\"color: #d19a66; line-height: 26px;\">1</span>&nbsp;&gt;=&nbsp;<span class=\"hljs-number\" style=\"color: #d19a66; line-height: 26px;\">10</span>:<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class=\"hljs-comment\" style=\"color: #5c6370; font-style: italic; line-height: 26px;\">#&nbsp;失败超过10次，设置锁定标记</span><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;set_redis(lock_username,&nbsp;true,&nbsp;<span class=\"hljs-number\" style=\"color: #d19a66; line-height: 26px;\">300</span>s)<br></code></pre>\n<p data-tool=\"mdnice编辑器\" style=\"padding-top: 8px; padding-bottom: 8px; margin: 0; line-height: 26px; color: black; font-size: 14px;\">umm，这样确实可以解决用户密码被爆破的问题。但是，这样会带来另一个风险：攻击者虽然不能获取到网站的用户信息，但是它可以让我们网站所有的用户都无法登录！<br>\n攻击者只需要无限循环遍历所有的用户名（<em style=\"font-style: italic; color: black;\">即使没有，随机也行</em>）进行登录，那么这些用户会永远处于锁定状态，导致正常的用户无法登录网站！</p>\n<h3 data-tool=\"mdnice编辑器\" style=\"margin-top: 30px; margin-bottom: 15px; font-weight: bold; background-color: #000; color: #fff; padding: 2px 10px; width: fit-content; font-size: 17px; margin: 60px auto 10px;\"><span class=\"prefix\" style=\"display: none;\"></span><span class=\"content\">IP限制</span><span class=\"suffix\" style=\"display: none;\"></span></h3>\n<p data-tool=\"mdnice编辑器\" style=\"padding-top: 8px; padding-bottom: 8px; margin: 0; line-height: 26px; color: black; font-size: 14px;\">那既然直接针对用户名不行的话，我们可以针对IP来处理，直接把攻击者的IP封了不就万事大吉了嘛。 我们可以设定某个IP下调用登录接口错误次数达到一定时，则禁止该IP进行登录操作。</p>\n<p data-tool=\"mdnice编辑器\" style=\"padding-top: 8px; padding-bottom: 8px; margin: 0; line-height: 26px; color: black; font-size: 14px;\"><em style=\"font-style: italic; color: black;\">伪代码如下：</em></p>\n<pre class=\"custom\" data-tool=\"mdnice编辑器\" style=\"margin-top: 10px; margin-bottom: 10px; box-shadow: rgba(170, 170, 170, 0.48) 0px 0px 6px 0px; max-width: 100%; border-radius: 4px; margin: 10px auto 0 auto;\"><code class=\"hljs\" style=\"overflow-x: auto; padding: 16px; color: #abb2bf; background: #282c34; display: -webkit-box; font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; border-radius: 0px; font-size: 12px; -webkit-overflow-scrolling: touch;\">ip&nbsp;=&nbsp;request[<span class=\"hljs-string\" style=\"color: #98c379; line-height: 26px;\">'IP'</span>]<br>fail_count&nbsp;=&nbsp;get_from_redis(fail_ip)<br><span class=\"hljs-keyword\" style=\"color: #c678dd; line-height: 26px;\">if</span>&nbsp;fail_count&nbsp;&gt;&nbsp;<span class=\"hljs-number\" style=\"color: #d19a66; line-height: 26px;\">10</span>:<br>&nbsp;<span class=\"hljs-keyword\" style=\"color: #c678dd; line-height: 26px;\">return</span>&nbsp;error(<span class=\"hljs-string\" style=\"color: #98c379; line-height: 26px;\">'拒绝登录'</span>)<br><span class=\"hljs-comment\" style=\"color: #5c6370; font-style: italic; line-height: 26px;\">#&nbsp;其它逻辑</span><br><span class=\"hljs-comment\" style=\"color: #5c6370; font-style: italic; line-height: 26px;\">#&nbsp;do&nbsp;something()</span><br>success&nbsp;=&nbsp;do_login(username,&nbsp;password)<br><span class=\"hljs-keyword\" style=\"color: #c678dd; line-height: 26px;\">if</span>&nbsp;<span class=\"hljs-keyword\" style=\"color: #c678dd; line-height: 26px;\">not</span>&nbsp;success:<br>&nbsp;set_redis(fail_ip,&nbsp;true,&nbsp;<span class=\"hljs-number\" style=\"color: #d19a66; line-height: 26px;\">300</span>s)<br></code></pre>\n<p data-tool=\"mdnice编辑器\" style=\"padding-top: 8px; padding-bottom: 8px; margin: 0; line-height: 26px; color: black; font-size: 14px;\">这样也可以一定程度上解决问题，事实上有很多的限流操作都是针对IP进行的，比如niginx的限流模块就可以限制一个IP在单位时间内的访问次数。<br>\n但是这里还是存在问题：</p>\n<ul data-tool=\"mdnice编辑器\" style=\"margin-top: 8px; margin-bottom: 8px; padding-left: 25px; color: black; list-style-type: square;\">\n<li><section style=\"margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;\">比如现在很多学校、公司都是使用同一个出口IP，如果直接按IP限制，可能会误杀其它正常的用户</section></li><li><section style=\"margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;\">现在这么多VPN，攻击者完全可以在IP被封后切换VPN来攻击</section></li></ul>\n<h3 data-tool=\"mdnice编辑器\" style=\"margin-top: 30px; margin-bottom: 15px; font-weight: bold; background-color: #000; color: #fff; padding: 2px 10px; width: fit-content; font-size: 17px; margin: 60px auto 10px;\"><span class=\"prefix\" style=\"display: none;\"></span><span class=\"content\">手机验证</span><span class=\"suffix\" style=\"display: none;\"></span></h3>\n<p data-tool=\"mdnice编辑器\" style=\"padding-top: 8px; padding-bottom: 8px; margin: 0; line-height: 26px; color: black; font-size: 14px;\">那难道就没有一个比较好的方式来防范吗？　当然有。　我们可以看到近些年来，几乎所有的应用都会让用户绑定手机，一个是国家的实名制政策要求，第二个是手机基本上和身份证一样，基本上可以代表一个人的身份标识了。所以很多安全操作都是基于手机验证来进行的，登录也可以。</p>\n<ol data-tool=\"mdnice编辑器\" style=\"margin-top: 8px; margin-bottom: 8px; padding-left: 25px; color: black; list-style-type: decimal;\">\n<li><section style=\"margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;\">当用户输入密码次数大于3次时，要求用户输入验证码（<em style=\"font-style: italic; color: black;\">最好使用滑动验证</em>）</section></li><li><section style=\"margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;\">当用户输入密码次数大于10次时，弹出手机验证，需要用户使用手机验证码和密码双重认证进行登录</section></li></ol>\n<blockquote data-tool=\"mdnice编辑器\" style=\"display: block; font-size: 0.9em; overflow: auto; overflow-scrolling: touch; color: #6a737d; padding-top: 10px; padding-bottom: 10px; padding-left: 20px; padding-right: 10px; margin-bottom: 20px; margin-top: 20px; border-left: 3px solid rgba(0, 0, 0, 0.65); border-right: 1px solid rgba(0, 0, 0, 0.65); background: rgb(249, 249, 249);\">\n<p style=\"padding-top: 8px; padding-bottom: 8px; font-size: 14px; margin: 0px; color: black; line-height: 26px;\">手机验证码防刷就是另一个问题了，这里不展开，以后再有时间再聊聊我们在验证码防刷方面做了哪些工作。</p>\n</blockquote>\n<p data-tool=\"mdnice编辑器\" style=\"padding-top: 8px; padding-bottom: 8px; margin: 0; line-height: 26px; color: black; font-size: 14px;\"><em style=\"font-style: italic; color: black;\">伪代码如下：</em></p>\n<pre class=\"custom\" data-tool=\"mdnice编辑器\" style=\"margin-top: 10px; margin-bottom: 10px; box-shadow: rgba(170, 170, 170, 0.48) 0px 0px 6px 0px; max-width: 100%; border-radius: 4px; margin: 10px auto 0 auto;\"><code class=\"hljs\" style=\"overflow-x: auto; padding: 16px; color: #abb2bf; background: #282c34; display: -webkit-box; font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; border-radius: 0px; font-size: 12px; -webkit-overflow-scrolling: touch;\">fail_count&nbsp;=&nbsp;get_from_redis(fail_username)<br><br><span class=\"hljs-keyword\" style=\"color: #c678dd; line-height: 26px;\">if</span>&nbsp;fail_count&nbsp;&gt;&nbsp;<span class=\"hljs-number\" style=\"color: #d19a66; line-height: 26px;\">3</span>:<br>&nbsp;<span class=\"hljs-keyword\" style=\"color: #c678dd; line-height: 26px;\">if</span>&nbsp;captcha&nbsp;<span class=\"hljs-keyword\" style=\"color: #c678dd; line-height: 26px;\">is</span>&nbsp;<span class=\"hljs-literal\" style=\"color: #56b6c2; line-height: 26px;\">None</span>:<br>&nbsp;&nbsp;<span class=\"hljs-keyword\" style=\"color: #c678dd; line-height: 26px;\">return</span>&nbsp;error(<span class=\"hljs-string\" style=\"color: #98c379; line-height: 26px;\">'需要验证码'</span>)<br>&nbsp;&nbsp;&nbsp;&nbsp;check_captcha(captcha)&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;<br><span class=\"hljs-keyword\" style=\"color: #c678dd; line-height: 26px;\">if</span>&nbsp;fail_count&nbsp;&gt;&nbsp;<span class=\"hljs-number\" style=\"color: #d19a66; line-height: 26px;\">10</span>:<br>&nbsp;<span class=\"hljs-comment\" style=\"color: #5c6370; font-style: italic; line-height: 26px;\">#&nbsp;大于10次，使用验证码和密码登录</span><br>&nbsp;<span class=\"hljs-keyword\" style=\"color: #c678dd; line-height: 26px;\">if</span>&nbsp;dynamic_code&nbsp;<span class=\"hljs-keyword\" style=\"color: #c678dd; line-height: 26px;\">is</span>&nbsp;<span class=\"hljs-literal\" style=\"color: #56b6c2; line-height: 26px;\">None</span>:<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class=\"hljs-keyword\" style=\"color: #c678dd; line-height: 26px;\">return</span>&nbsp;error(<span class=\"hljs-string\" style=\"color: #98c379; line-height: 26px;\">'请输入手机验证码'</span>)<br>&nbsp;&nbsp;&nbsp;&nbsp;<span class=\"hljs-keyword\" style=\"color: #c678dd; line-height: 26px;\">if</span>&nbsp;<span class=\"hljs-keyword\" style=\"color: #c678dd; line-height: 26px;\">not</span>&nbsp;validate_dynamic_code(username,&nbsp;dynamic_code):<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;delete_dynamic_code(username)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class=\"hljs-keyword\" style=\"color: #c678dd; line-height: 26px;\">return</span>&nbsp;error(<span class=\"hljs-string\" style=\"color: #98c379; line-height: 26px;\">'手机验证码错误'</span>)<br><br>&nbsp;success&nbsp;=&nbsp;do_login(username,&nbsp;password,&nbsp;dynamic_code)<br>&nbsp;&nbsp;&nbsp;&nbsp;<br>&nbsp;<span class=\"hljs-keyword\" style=\"color: #c678dd; line-height: 26px;\">if</span>&nbsp;<span class=\"hljs-keyword\" style=\"color: #c678dd; line-height: 26px;\">not</span>&nbsp;success:<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;set_redis(fail_username,&nbsp;fail_count&nbsp;+&nbsp;<span class=\"hljs-number\" style=\"color: #d19a66; line-height: 26px;\">1</span>)<br></code></pre>\n<p data-tool=\"mdnice编辑器\" style=\"padding-top: 8px; padding-bottom: 8px; margin: 0; line-height: 26px; color: black; font-size: 14px;\">我们结合了上面说的几种方式的同时，加上了手机验证码的验证模式，基本上可以阻止相当多的一部分恶意攻击者。但是没有系统是绝对安全的，我们只能够尽可能的增加攻击者的攻击成本。大家可以根据自己网站的实际情况来选择合适的策略。</p>\n<h2 data-tool=\"mdnice编辑器\" style=\"margin-top: 30px; margin-bottom: 15px; padding: 0px; font-size: 22px; text-align: center; position: relative; font-weight: bold; color: black; line-height: 1.1em; padding-top: 12px; padding-bottom: 12px; margin: 70px 30px 30px; border: 1px solid #000;\"><span style=\"float: left; display: block; width: 90%; border-top: 1px solid #000; height: 1px; line-height: 1px; margin-left: -5px; margin-top: -17px;\"> </span><span class=\"prefix\" style=\"display: block; width: 3px; margin: 0 0 0 5%; height: 3px; line-height: 3px; overflow: hidden; background-color: #000; box-shadow: 3px 0 #000,\n    0 3px #000,\n    -3px 0 #000,\n    0 -3px #000;\"></span><span class=\"content\" style=\"display: block; -webkit-box-reflect: below 0em -webkit-gradient(linear,left top,left bottom, from(rgba(0,0,0,0)),to(rgba(255,255,255,0.1)));\">中间人攻击？</span><span class=\"suffix\" style=\"display: block; width: 3px; margin: 0 0 0 95%; height: 3px; line-height: 3px; overflow: hidden; background-color: #000; box-shadow: 3px 0 #000,\n    0 3px #000,\n    -3px 0 #000,\n    0 -3px #000;\"></span><span style=\"float: right; display: block; width: 90%; border-bottom: 1px solid #000; height: 1px; line-height: 1px; margin-right: -5px; margin-top: 16px;\"> </span></h2>\n<h3 data-tool=\"mdnice编辑器\" style=\"margin-top: 30px; margin-bottom: 15px; font-weight: bold; background-color: #000; color: #fff; padding: 2px 10px; width: fit-content; font-size: 17px; margin: 60px auto 10px;\"><span class=\"prefix\" style=\"display: none;\"></span><span class=\"content\">什么是中间人攻击</span><span class=\"suffix\" style=\"display: none;\"></span></h3>\n<p data-tool=\"mdnice编辑器\" style=\"padding-top: 8px; padding-bottom: 8px; margin: 0; line-height: 26px; color: black; font-size: 14px;\">***中间人攻击(man-in-the-middle attack, abbreviated to MITM)***，简单一点来说就是，A和B在通讯过程中，攻击者通过嗅探、拦截等方式获取或修改A和B的通讯内容。</p>\n<p data-tool=\"mdnice编辑器\" style=\"padding-top: 8px; padding-bottom: 8px; margin: 0; line-height: 26px; color: black; font-size: 14px;\">举个栗子： <code style=\"font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #ff6441;\">小白</code>给<code style=\"font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #ff6441;\">小黄</code>发快递，途中要经过快递点A，<code style=\"font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #ff6441;\">小黑</code>就躲在快递点A，或者干脆自己开一个快递点B来冒充快递点A。然后偷偷的拆了<code style=\"font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #ff6441;\">小白</code>给<code style=\"font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #ff6441;\">小黄</code>的快递，看看里面有啥东西。甚至可以把<code style=\"font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #ff6441;\">小白</code>的快递给留下来，自己再打包一个一毛一样的箱子发给<code style=\"font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #ff6441;\">小黄</code>。</p>\n<p data-tool=\"mdnice编辑器\" style=\"padding-top: 8px; padding-bottom: 8px; margin: 0; line-height: 26px; color: black; font-size: 14px;\">那在登录过程中，如果攻击者在嗅探到了从客户端发往服务端的登录请求，就可以很轻易的获取到用户的用户名和密码。</p>\n<h3 data-tool=\"mdnice编辑器\" style=\"margin-top: 30px; margin-bottom: 15px; font-weight: bold; background-color: #000; color: #fff; padding: 2px 10px; width: fit-content; font-size: 17px; margin: 60px auto 10px;\"><span class=\"prefix\" style=\"display: none;\"></span><span class=\"content\">HTTPS</span><span class=\"suffix\" style=\"display: none;\"></span></h3>\n<p data-tool=\"mdnice编辑器\" style=\"padding-top: 8px; padding-bottom: 8px; margin: 0; line-height: 26px; color: black; font-size: 14px;\">防范中间人攻击最简单也是最有效的一个操作，更换HTTPS，把网站中所有的HTTP请求修改为强制使用HTTPS。</p>\n<p data-tool=\"mdnice编辑器\" style=\"padding-top: 8px; padding-bottom: 8px; margin: 0; line-height: 26px; color: black; font-size: 14px;\">***为什么HTTPS可以防范中间人攻击？  ***<br>\nHTTPS实际上就是在HTTP和TCP协议中间加入了SSL/TLS协议，用于保障数据的安全传输。相比于HTTP，HTTPS主要有以下几个特点：</p>\n<ul data-tool=\"mdnice编辑器\" style=\"margin-top: 8px; margin-bottom: 8px; padding-left: 25px; color: black; list-style-type: square;\">\n<li><section style=\"margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;\">内容加密</section></li><li><section style=\"margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;\">数据完整性</section></li><li><section style=\"margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;\">身份验证</section></li></ul>\n<blockquote data-tool=\"mdnice编辑器\" style=\"display: block; font-size: 0.9em; overflow: auto; overflow-scrolling: touch; color: #6a737d; padding-top: 10px; padding-bottom: 10px; padding-left: 20px; padding-right: 10px; margin-bottom: 20px; margin-top: 20px; border-left: 3px solid rgba(0, 0, 0, 0.65); border-right: 1px solid rgba(0, 0, 0, 0.65); background: rgb(249, 249, 249);\">\n<p style=\"padding-top: 8px; padding-bottom: 8px; font-size: 14px; margin: 0px; color: black; line-height: 26px;\">具体的HTTPS原理这里就不再扩展了，大家可以自行Google</p>\n</blockquote>\n<h3 data-tool=\"mdnice编辑器\" style=\"margin-top: 30px; margin-bottom: 15px; font-weight: bold; background-color: #000; color: #fff; padding: 2px 10px; width: fit-content; font-size: 17px; margin: 60px auto 10px;\"><span class=\"prefix\" style=\"display: none;\"></span><span class=\"content\">加密传输</span><span class=\"suffix\" style=\"display: none;\"></span></h3>\n<p data-tool=\"mdnice编辑器\" style=\"padding-top: 8px; padding-bottom: 8px; margin: 0; line-height: 26px; color: black; font-size: 14px;\">在HTTPS之外，我们还可以手动对敏感数据进行加密传输：</p>\n<ul data-tool=\"mdnice编辑器\" style=\"margin-top: 8px; margin-bottom: 8px; padding-left: 25px; color: black; list-style-type: square;\">\n<li><section style=\"margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;\">用户名可以在客户端使用非对称加密，在服务端解密</section></li><li><section style=\"margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;\">密码可以在客户端进行MD5之后传输，防止暴露密码明文</section></li></ul>\n<h1 data-tool=\"mdnice编辑器\" style=\"margin-top: 30px; margin-bottom: 15px; padding: 0px; font-weight: bold; color: black; font-size: 24px;\"><span class=\"prefix\" style=\"display: none;\"></span><span class=\"content\">其它</span><span class=\"suffix\"></span></h1>\n<p data-tool=\"mdnice编辑器\" style=\"padding-top: 8px; padding-bottom: 8px; margin: 0; line-height: 26px; color: black; font-size: 14px;\">除了上面我们聊的这些以外，其实还有很多其它的工作可以考虑，比如：</p>\n<ul data-tool=\"mdnice编辑器\" style=\"margin-top: 8px; margin-bottom: 8px; padding-left: 25px; color: black; list-style-type: square;\">\n<li><section style=\"margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;\"><strong style=\"font-weight: bold; color: black;\">操作日志</strong>，用户的每次登录和敏感操作都需要记录日志（包括IP、设备等）</section></li><li><section style=\"margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;\"><strong style=\"font-weight: bold; color: black;\">异常操作或登录提醒</strong>，有了上面的操作日志，那我们就可以基于日志做风险提醒，比如用户在进行非常登录地登录、修改密码、登录异常时，可以短信提醒用户</section></li><li><section style=\"margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;\"><strong style=\"font-weight: bold; color: black;\">拒绝弱密码</strong> 注册或修改密码时，不允许用户设置弱密码</section></li><li><section style=\"margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;\"><strong style=\"font-weight: bold; color: black;\">防止用户名被遍历</strong> 有些网站在注册时，在输入完用户名之后，会提示用户名是否存在。这样会存在网站的所有用户名被泄露的风险（<em style=\"font-style: italic; color: black;\">遍历该接口即可</em>），需要在交互或逻辑上做限制</section></li><li><section style=\"margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;\">...</section></li></ul>\n<h1 data-tool=\"mdnice编辑器\" style=\"margin-top: 30px; margin-bottom: 15px; padding: 0px; font-weight: bold; color: black; font-size: 24px;\"><span class=\"prefix\" style=\"display: none;\"></span><span class=\"content\">后记</span><span class=\"suffix\"></span></h1>\n<p data-tool=\"mdnice编辑器\" style=\"padding-top: 8px; padding-bottom: 8px; margin: 0; line-height: 26px; color: black; font-size: 14px;\">现在国家不断的出台各种法律，对用户的数据越来越看重。作为开发者，我们也需要在保护用户数据和用户隐私方面做更多的工作。后面我也会和大家聊一聊，我们在数据安全方面，做了哪些工作，希望可以给到大家一点点帮助。</p>\n<h1 data-tool=\"mdnice编辑器\" style=\"margin-top: 30px; margin-bottom: 15px; padding: 0px; font-weight: bold; color: black; font-size: 24px;\"><span class=\"prefix\" style=\"display: none;\"></span><span class=\"content\">扩展阅读</span><span class=\"suffix\"></span></h1>\n<p data-tool=\"mdnice编辑器\" style=\"padding-top: 8px; padding-bottom: 8px; margin: 0; line-height: 26px; color: black; font-size: 14px;\"><a href=\"http://www.ruanyifeng.com/blog/2014/09/illustration-ssl.html\" style=\"text-decoration: none; color: #1e6bb8; word-wrap: break-word; font-weight: bold; border-bottom: 1px solid #1e6bb8;\">图解SSL/TLS协议 - 阮一峰的网络日志</a><br>\n<a href=\"https://en.wikipedia.org/wiki/HTTPS\" style=\"text-decoration: none; color: #1e6bb8; word-wrap: break-word; font-weight: bold; border-bottom: 1px solid #1e6bb8;\">HTTPS - Wikipedia</a><br>\n<a href=\"https://en.wikipedia.org/wiki/Man-in-the-middle_attack\" style=\"text-decoration: none; color: #1e6bb8; word-wrap: break-word; font-weight: bold; border-bottom: 1px solid #1e6bb8;\">Man-in-the-middle attack - Wikipedia</a></p>\n<p data-tool=\"mdnice编辑器\" style=\"padding-top: 8px; padding-bottom: 8px; margin: 0; line-height: 26px; color: black; font-size: 14px;\"><strong style=\"font-weight: bold; color: black;\">【重要】转载请注明出处：https://juejin.im/post/6859214952704999438</strong></p>\n<span style=\"font-size: 15px; display: block; text-align: center; margin-top: 50px; color: #999; border-bottom: 1px solid #eee;\">- END -</span></section>", "user_name": "哒哒哒哒打代码", "description": "", "got_view_count": 1009, "category_name": "后端", "ctime": 1457483880}
{"tag_name": "Kotlin", "concern_user_count": 31708, "user_id": "2524134385917293", "title": "Android Kotlin那些实用的语法糖：空安全、类型转换 & 相等性判断", "mark_content": "# 前言\nKotlin被Google官方认为是Android开发的一级编程语言。今天，我将主要讲解，关于Kotlin的一些实用语法糖，主要包括：\n- 范围使用：in、downTo、step、until\n- 类型检查 & 转换：is、智能转换、as\n- 相等性：equals（）、==、===\n- 空安全\n\n![示意图](https://upload-images.jianshu.io/upload_images/944365-8252687460538ea4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n***\n\n# 1. 范围使用\n主要用于表示范围，主要包括：in、downTo、step、until\n\n```\n/**\n *  1. in\n *  作用：在...范围内\n **/\n// 表示：若i在1-5范围内，则执行下面代码\n// 注：闭区间，[1,5]\nif (i in 1..5) {\n    println(\"i 在 1-5 内\")\n}\n\n// 表示：若i不在1-5范围内，则执行下面代码\n// !in表示不在...范围内\nif (i !in 1..5) {\n    println(\"i 不在 1-5 内\")\n}\n\n/**\n *  2. until\n *  作用：表示开区间\n **/\n// 输出1234\nfor (i in 1 until 5) {\n println(i)\n}\n\n/**\n *  3. downTo\n *  作用：倒序判断\n **/\n for (i in 5 downTo 1) {\n \tprintln(i)\n }\n\n/**\n *  4. step\n *  作用：调整步长\n **/\n// 设置步长为2，顺序输出1、3、5\nfor (i in 1..5 step 2) println(i) \n\n// 设置步长为2，倒序输出5、3、1\nfor (i in 1 downTo 5 step 2) println(i) \n```\n\n***\n\n# 2. 类型检查 & 转换\n包括：is、智能转换 和 as \n```\n/**\n *  1. is\n *  作用：判断一个对象与指定的类型是否一致\n **/\n// 判断变量a的数据类型是否是String\nvar a: Any = \"a\"\nif (a is String) {\n    println(\"a是String类型\")\n}\nif (a !is Int) {\n    println(\"a不是Int类型\")\n}\n\n/**\n *  2. 智能转换\n *  说明： kotlin不必使用显式类型转换操作，因为编译器会跟踪不可变值的is检查以及显式转换，并在需要时自动插入（安全的）转换\n **/\n var a: Any = \"a\"\nif (a is String) {\n    println(\"a是String类型\")\n    println(a.length) // a 自动转换为String类型\n    //输出结果为：1\n}\n\n// 反向检查： a自动转换为String类型\nif (a !is String) {\n\tprint(a.length)\n}\n\n// 在 && 和 || 的右侧也可以智能转换：\n// `&&` 右侧的 a 自动转换为String\nif (a is String && a.length > 0)\n// `||` 右侧的 a 自动转换为String\nif (a is String || a.length > 0)\n\n// 在when表达式和while循环里也能智能转换：\nwhen(a){\n    is String -> a.length\n    is Int -> a + 1\n}\n\n// 需要注意：当编译器不能保证变量在检查和使用之间不可改变时，智能转换不能用。智能转换能否适用根据以下规则：\n// 1. val 局部变量——总是可以，局部委托属性除外；\n// 2. val 属性——如果属性是 private 或 internal，或者该检查在声明属性的同一模块中执行。智能转换不适用于 open 的属性或者具有自定义 getter 的属性；\n// 3. var 局部变量——如果变量在检查和使用之间没有修改、没有在会修改它的 lambda 中捕获、并且不是局部委托属性；\n// 4. var 属性——决不可能（因为该变量可以随时被其他代码修改）\n\n/**\n *  3. 强制类型转换：as\n **/\nvar any: Any = \"abc\"\nvar str: String = any as String\n\n// 强制类型转换是不安全的，若类型不兼容则会抛出一个异常\nvar int: Int = 123\nvar str: String = int as String\n// 抛出ClassCastException\n\n/**\n *  4. 可空转换操作符：as？\n *  作用：null不能转换为String，因该类型不是可空的，此时使用可空转换操作符as?\n **/\nvar str = null\nvar str2 = str as String\n// 抛出TypeCastException\n\n// 使用安全转换操作符as?可以在转换失败时返回null，避免了抛出异常。\nvar str = null\nvar str2 = str as? String\nprintln(str2) //输出结果为：null\n```\n***\n\n# 3. 相等性判断\n在Kotlin中，存在结构相等 & 引用相等 两种相等判断。\n\n```\n/**\n *  1. 结构相等：equals()或 ==\n *  作用：判断两个结构是否相等\n **/\nvar a = \"1\"\nvar b = \"1\"\nif (a.equals(b)) {\n    println(\"a 和 b 结构相等\")\n    // 输出结果为：a 和 b 结构相等\n}\n\nvar a = 1\nvar b = 1\nif (a == b) {\n    println(\"a 和 b 结构相等\")\n    // 输出结果为：a 和 b 结构相等\n}\n\n/**\n *  2. 引用相等：===\n *  作用：判断两个引用是否指向同一对象\n */ \n// 设置一个类如下\ndata class User(var name: String, var age: Int)\n\n// 设置值\nvar a = User(\"Czh\", 22)\nvar b = User(\"Czh\", 22)\nvar c = b\nvar d = a\n\n// 对比两个对象的结构\nif (c == d) {\n    println(\"a 和 b 结构相等\")\n} else {\n    println(\"a 和 b 结构不相等\")\n}\n\n// 对比两个对象的的引用\nif (c === d) {\n    println(\"a 和 b 引用相等\")\n} else {\n    println(\"a 和 b 引用不相等\")\n}\n\n// 输出结果：\na 和 b 结构相等\na 和 b 引用不相等\n```\n\n***\n\n# 4. 空安全\n- 在Java中，NullPointerException异常十分常见\n- 而Kotlin的优点则是可以尽可能避免执行代码时出现的空指针异常\n\n```\n/**\n *  1. 可空类型与非空类型\n *  在Kotlin中，有两种情况最可能导致出现NullPointerException\n **/\n\n// 情况1：显式调用 throw NullPointerException()\n// 情况2：使用!! 操作符\n// 说明：!!操作符将任何值转换为非空类型，若该值为空则抛出异常\nvar a = null\na!!\n// 抛出KotlinNullPointerException\n\n// 情况3：数据类型不能为null\n// 在 Kotlin 中，类型系统区分一个引用可以容纳 null （可空引用） 和 不能容纳（非空引用）\n// 如：String类型变量不能容纳null\n// 若要允许为空，可声明一个变量为可空字符串：在字符串类型后面加一个问号?\n对于String，则是写作：String?\nvar b: String? = \"b\"\nb = null\n\n\n/**\n *  2. 安全调用操作符\n *  作用：表示如果若不为null才继续调用\n **/\n b?.length\n // 表示：若b不为null，才调用b.length\n\n // 注：安全调用符还可以链式调用\n a?.b?.c?.d\n // 假设a不为null，才继续往下调用，以此类推\n // 若该链式调用中任何一个属性为null，整个表达式都会返回null。\n // 若只对非空值执行某个操作，可与let一起使用\na?.b?.let { println(it) }\n```\n\n至此，关于`Kotlin`的入门语法讲解完毕。\n\n***\n# 5. 总结\n- 本文介绍了Kotlin的一些实用语法糖\n- 接下来推出的文章，我将继续讲解Kotlin的相关知识，包括使用、语法特点等，感兴趣的读者可以继续关注我的博客哦：[Carson_Ho的Android博客](https://juejin.im/user/2524134385917293)\n\n***\n\n# 请帮顶 / 评论点赞！因为你们的赞同/鼓励是我写作的最大动力！\n", "user_name": "Carson_Ho", "description": "CSDN博客专家 - 微信公众号：每天学一点Android", "got_view_count": 495704, "category_name": "阅读", "ctime": 1457483895}
{"tag_name": "前端", "concern_user_count": 455667, "user_id": "2119514149365742", "title": "如何设计实现中后台搭建PaaS平台", "mark_content": "**作者：月飞**\n\n**出品：淘系前端团队**\n\n## 前言\n\n本文将给大家分享关于《如何设计实现中后台搭建 PaaS 平台》这个话题，主要围绕阿里淘系技术部飞冰系列产品中的中后台搭建产品 iceluna 来进行展开。\n\n### 话题介绍\n\n[](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7cfab31e8dbc432aa60a14503d66e9bb~tplv-k3u1fbpfcp-zoom-1.image)\n\n搭建，按面向角色的不同大致可以分为面向运营和面向研发两类搭建产品。面向运营的搭建产品主要是以可视化配置 ( No-code ) 的方式进行完整页面搭建，如营销活动页面搭建。面向研发的搭建产品主要以低代码开发 ( Low-code ) 的方式，搭建“中后台系统”或者“无线模块”，如商家、小二后台系统的搭建，无线 Rax 模块的搭建。本文主题是中后台系统搭建，跟营销活动类页面的搭建在面向角色和搭建模式上是非常不同的，接下来主要围绕 “ iceluna 产品 ” 和 “ PaaS 平台建设 ” 2 个维度来展开说明。\n\n### 大纲\n\n![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/bc9cfb3a88194af6aacefb1b5aaa0fa0~tplv-k3u1fbpfcp-zoom-1.image)\n\n大纲如上图，第 1 部分对 iceluna 这个产品进行整体介绍，包括其产品背景、定位及现状。第 2 部分从架构设计、功能模块设计、研发流程设计三方面来介绍中后台搭建产品的设计思路。第 3 部分会着重从中后台搭建基础设施维度来讲一下 iceluna 是如何建设搭建基础设施的。第 4 部分则会回到 PaaS 平台这个焦点，来讲解 PaaS 平台需要建设的核心能力。最后则是总结和展望。\n\n## iceluna 产品介绍\n\n### 产品演示\n\n![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/32f3b5b8cb8643baa7e6f7096cd691e7~tplv-k3u1fbpfcp-zoom-1.image)\n\niceluna 研发中心包含站点首页、站点区块中心、应用研发中心以及低代码搭建编辑器等几个主要界面。上图是 iceluna 的低代码搭建编辑器，也是 iceluna 产品最核心的一个能力，图上示例里中间搭建的是一个商品列表页面。\n\n### 产品背景!\n\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/996a6480acb143a8b353f3ef58bcaf13~tplv-k3u1fbpfcp-zoom-1.image)\n\n\niceluna 产品发展至今已经经历了 3 年半时间，产品一路迭代演进至今的低代码开发 PaaS 平台，背后有着一系列原因。在了解这些原因之前，想先普及一个概念，今天我们一直在提的“低代码开发”。对于 iceluna 通用搭建来说，有着自己的一点理解，它是通过可视化的方式，使具有不同经验水平的开发人员可以通过图形化的用户界面，使用拖拽组件和模型驱动来搭建网页的开发模式。\n\n了解完这个概念，我们来谈下 iceluna 产品的背景：\n\n*   **中后台技术之殇**：在淘系整个业务偏消费者端，中后台这一侧人力投入是偏弱的，这是目前中后台的一个困境。我们有大量的商家或小二操作系统，前端人力相当紧缺，大量系统依赖后端/外包/ ISV 负责研发，由于前端工程环境复杂，技术迭代快，门槛高，在效率/质量/体验/可维护性等方面存在较多问题，对于如何赋能？如何改善协作模式？传统源码模式已不能满足业务发展的诉求，对于低代码开发模式的需求日趋强烈。\n*   **低代码开发模式的崛起**：据 Forrester 市场调研结果，通过低代码开发模式可带来数倍甚至 10 倍以上研发效率的提升。这对于中后台现状面临的一个业务压力，是我们非常迫切需要解决的一个问题，那就是如何提效的问题。它给了我们足够大的想象空间。近年来各大互联网巨头公司都以纷纷投入到低代码或无代码平台的建设上来。在阿里的话，各大 BU 也是重兵投入到这一块的。这也就衍生出来第 3 个问题，那就是搭建泛滥后的技术收敛和统一。\n*   **搭建泛滥后的收敛和统一：**阿里内部各 BU 针对不同业务场景构建保守估计有数十个以上低代码搭建产品，投入成本巨大，能力完善程度相对不一。在搭建这块如何收敛和统一？完善搭建基础设施，由集团层面提供统一的搭建服务的运行和开发环境，是势在必行。我个人作为集团搭建协议的负责人，也是希望通过 iceluna 产品去解决这一块的问题，能讲 iceluna 演进成为一个搭建 PaaS 平台，去提供搭建底层服务的能力，服务全集团的搭建产品。\n\n### 产品定位\n\n![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/342fea7137d74157884e764643b2ed1e~tplv-k3u1fbpfcp-zoom-1.image)\n\n目前 iceluna 产品有着 3 层定位：\n\n1.  **中后台通用搭建产品**：由淘系技术部研发，面向全体研发人员可用，打造一个中后台通用的搭建产品。由于淘系业务几乎以商家，小二运营操作系统为主，业务逻辑多，交互复杂，很难抽象固定场景的业务模版或可视化配置的解决方案。因此，需要我们低代码开发的中后台搭建产品具备有极强的通用性和扩展性，才能够 100% 覆盖复杂交互的中后台系统页面的搭建。\n2.  **全链路低代码开发平台**：集前端应用工程创建、开发、调试、发布，甚至到页面的托管，全链路一体化的低代码平台。屏蔽复杂的前端工程体系，全链路打通。\n3.  **PaaS** **平台**：建设搭建基础设施，基于标准搭建协议生产搭建物料，为各业务场景提供搭建服务的运行和开发环境。 目前 iceluna 的 PaaS 平台主要以以下 2 种模式提供服务：\n\n1.  **平台模式**：业务研发进入 iceluna 研发中心，全链路在 iceluna 平台上进行编辑器定制和运行，业务托管在 iceluna 平台上；\n2.  **中台模式**：脱离 iceluna 研发中心，对外将 iceluna 编辑器能力和低代码能力以 npm 包形式提供出去，助力于孵化各个领域场景的独立的低代码编辑器，独立部署。\n\n然后，我们在目标设定上，对应有如下 3 个目标：\n\n1.  **赋能**：赋能是我们第一重要的目标，因为在目前中后台发展的业务现状下来说，赋能恰恰是目前最能消化中后台业务压力的一个重要手段，这是我们经过 2 - 3 年在业务上不断摸索下得出的一个结论，赋能可以通过后端、外包，改变与前端的一个生产关系，去改善和提升研发项目或者说总个研发团队的生产力，使得我们后端外包可以跨界的工作，减少一些不必要的依赖和成本。\n2.  **提效**：目标还是降低研发成本。提效一直是我们技术永恒的话题，但就 iceluna 现状来说，提效效果并不是特别的理想，在下一页现状会聊到。\n3.  **搭建生态**：希望成为一个 PaaS 平台或搭建中台，去孵化领域搭建产品，形成搭建产品矩阵，在各领域上有更高研发效率。\n\n### 产品现状\n\n![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/31c1b781974b49268e63cb120e2da698~tplv-k3u1fbpfcp-zoom-1.image)\n\niceluna 是一个面向集团提供服务的通用低代码开发平台，基于产品定位和目标，iceluna 在赋能、提效、搭建生态上均取得不错成果。\n\n*   **赋能：**活跃用户数 1000+ ，后端占比 44% ，前端占比 39% ，测试占比 11% ，外包占比 7% 。从占比可以看到，有超过 60% 的用户属于非前端研发人员，在使用 iceluna 进行系统页面搭建。通过数据可以看到， iceluna 在赋能上有不错的效果。\n*   **提效：**上线应用 440+ ，页面 6000+ ，覆盖阿里多个部门中后台应用研发，经霍尔斯特德软件复杂度算法模型测算(后面章节会介绍)，人均研发效能提升 200% 左右。\n*   **搭建生态：**提供完备的搭建基础设施服务 & PaaS 平台服务，已孵化 8+ 业务场景定制的搭建产品。\n\n## iceluna 架构设计\n\n### 架构设计\n\n![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ef7986aeeb2240ac93dbb9f42b6fad4b~tplv-k3u1fbpfcp-zoom-1.image)\n\n上图是 iceluna 产品从 PaaS 角度看的一张架构分层图，从图上我们可以看出，核心包含后端服务、搭建基础设施、PaaS 服务、研发中心、搭建产品 5 层。下面对每一层服务能力做介绍。\n\n*   **后端服务**：基于 Node.js 的 Midway 框架实现的一个 Server 层，提供搭建平台数据接口和 Socket 服务。\n*   **搭建基础设施层**：目标提供搭建编辑器的开发环境。核心包含中后台搭建描述协议、低代码编辑器、插件生态、物料生态 4 个模块能力建设；\n*   **PaaS** **服务层**：提供搭建编辑器的运行环境，使其能具备有完备的搭建配套服务能力。\n*   **研发中心层**：业务研发的主阵地，提供云端一体化的研发流程。包含站点中心，应用中心，物料中心，数据中心 4 个功能模块。\n*   **搭建产品**：最上一层是搭建产品层，是 iceluna 作为 PaaS 平台或中台，目标孵化的各个垂直领域的搭建产品。\n\n### 功能模块设计!\n![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/def7d08e86804abdb3c266aef1b1025e~tplv-k3u1fbpfcp-zoom-1.image)\n\n接下来从功能模块设计角度来进一步了解 iceluna 的功能全貌，还是基于刚 PaaS 角度的架构设计核心 3 个分层来拆解里面的核心模块。\n\n搭建基础设施这层的话，就包括基础能力的建设，包含搭建协议，视觉规范，工程脚手架等源码级别的一些基础能力。其次是我们搭建编辑器内核，包含了骨架、主题包、插件、用于配置可视化属性面板的控件，另外就是我画布和渲染引擎 2 个核心模块，另外还有国际化能力模块。在插件生态模块上，目前整体搭建编辑器上所有的功能模块均是以插件的形式存在。比如在顶部我们会有模型驱动、图像识别、数据驱动、逻辑编排、流程编排等插件，这样一些插件是目前我们重点推广或重点研发的插件，作为研发模式升级提升效率的核心主抓手。其次是编辑器上常规一些的大纲树、属性/事件/样式/数据等插件，在现阶段主要以可视化增强来达到提效目的。在物料生态方面，我们希望构造一个完备的物料生态，通过低代码方式开发搭建组件、搭建区块、搭建模版、组件实例，并进行物料的发布和共享。对于  PaaS 和研发中心模块就不再一一做详细介绍。\n\n### 研发流程设计\n\n![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b1f6a4c848534f68b69775ee43c71c99~tplv-k3u1fbpfcp-zoom-1.image)\n\n图上重点介绍 iceluna 研发中心的研发流程设计，主要分 2 个权限角色：\n\n1.  **站定管理员**：一般由专业业务前端负责，创建站点审核通过后，可以完成站点基本信息、编辑器默认配置、应用默认配置、物料默认配置等信息。该配置讲决定了在该站点下创建的应用主题、搭建编辑形态、以及物料供选池子等。\n2.  **应用管理员**：选择进入某个站点后，可以在该站点下创建应用、创建多分支、进入搭建编辑器搭建页面或组件，在线实时调试，一键发布部署等操作。\n\n## 中后台搭建基础设施建设\n\n![](https://cdn.nlark.com/yuque/0/2020/jpeg/1054258/1585565543859-9615bf31-2678-49d1-8aef-092f0165bbcb.jpeg?x-oss-process=image%2Fresize%2Cw_1500)\n\n了解了 iceluna 从各个维度的设计，相信对 iceluna 的产品设计有了一个更全面的认识；那么接下来，我们从实现层面，看看 iceluna 建设了哪些基础设施能力，来保障搭建平台的技术先进性。\n\n从这一页内容是我们整个低代码搭建基础设施的一个内容全图，从左侧我们可以看到一个物料研发的流程，由专业前端同学研发源码的物料，并沉淀到物料中心，这样一个源码的物料，通过我们一个解析模块，可以生成一份搭建组件描述文件，有了这份描述文件，就可以入驻到我们的低代码搭建编辑器里面来，低代码搭建编辑器会识别这个组件，生成这个组件的属性配置面板，并具备有良好的搭建编辑体验。其次，编辑器可以将已入驻的源码组件，以发布的方式上行到物料中心，沉淀成为一个搭建组件。多个搭建产品矩阵，基于相同协议标准，与物料中心的上下行，使物料得以流通和复用，从而形成物料生态。从最右侧可以看到，前后端、外包、测试都是通过搭建方式来使用低代码编辑器，低代码编辑器成为了最核心的一块能力。如何保障低代码编辑器的技术先进性，总体建设的思路，从以下 5 个方向阐述：\n\n1.  首先要定义一个搭建描述协议的标准规范，所有搭建产品遵循这套搭建规范，这样可以使物料得以流通。\n2.  我们要构造一个搭建编辑器开发生态，iceluna 作为 PaaS 平台或中台提供出来的一个能力，去低成本的孵化各场景下的低代码编辑器；\n3.  就是我们提供出来的低代码编辑器，在面向不同端的一个诉求，我们会包含 React，Rax，小程序等技术栈的搭建，需要编辑器能支持多技术栈，适配多端。\n4.  相比其他低代码编辑器，它如何保持技术先进性，有哪些核心能力建设。\n5.  是我们要打造的插件生态 和 物料生态。\n\n### 搭建描述协议标准规范\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/45747a2746f146fb90a0904932f2e8fd~tplv-k3u1fbpfcp-zoom-1.image)\n\n如何指定搭建描述协议的标准规范？从以下 4 个方面阐述我的一些思考：\n\n1.  **版本化、语义化、渐进性描述**：版本控制，语义清晰，简明易懂，可读性强；搭建的本质是通过源码组件进行嵌套组合，从小往大、依次组合生成组件、区块、页面，最终通过云端构建生成 应用 的过程。因此在搭建基础协议中，我们需要知道如何去渐进性的描述组件、区块、页面、应用这 4 个实体概念。\n2.  **不引入新概念，可与标准源码互转**：不引入新的语法概念，代码部分纯 JS 语法，降低上手门槛；明确每一个属性与源码对应的转换关系，可生成跟手写无差异的高质量标准源代码；\n3.  **可扩展，可流通性，面向多端**：支持第三方 npm 包的引入，增强协议描述能力的扩展性，以应对不同应用复杂多变的需求，如 Lodash ，Moment.js 等第三方工具库；产物能在不同搭建产品中流通，不涉及任何私域数据存储，统一标准，构建搭建物料生态。不能仅面向 React，还有小程序等多端；\n4.  **支持国际化**\n\n### 低代码编辑器开发生态\n![](https://cdn.nlark.com/yuque/0/2020/jpeg/1054258/1585565543844-839c625c-cf99-4adc-9723-d6e32ba8fc24.jpeg?x-oss-process=image%2Fresize%2Cw_1500)\n\niceluna 作为一个 PaaS 平台或搭建中台，我们希望把搭建编辑器底层所有的能力都能原子化的开放出去，所以我们在建设搭建编辑器的时候考虑到了以下几个问题：\n\n1.  **分层架构**：整个框架分为四层能力的建设，最里层为搭建编辑器的内核（主要有消息通讯、状态的管理及配制的解析、骨架的加载、插件的机制的加载等能力）；其次为渲染模块，也就是渲染模块的部分，它的输入就是符合搭建描述协议的 Schema，通过这个模块可以把整个页面渲染出来；再往上为编排模块，主要负责画布区域的物料拖拽、下钻编辑、点击，快捷键，多设计模式等操作，提供了灵活的拓展能力；最上层为整个编辑器的框架，包括骨架、主题以及编辑器里面所有的面板都是以功能插件的形式集成进去的。\n2.  **模块化解耦**：这里的框架分层，每一层均为独立 npm 包，提供原子化服务的能力去开放。比如我们可以以整体低代码编辑器整体开放给需要的场景，也可以只以编排引擎或渲染引擎的方式去开放，如物料中心搭建物料的预览。\n3.  **扩展能力及开发生态**：除了提供现有的能力之外还提供完整的骨架，插件及控件的开发脚手架及命令行工具来保证整个低代码搭建编辑开发机制是完备完善的，同时整个骨架、插件也是可以在我们整个平台进行配制或定制。\n\n### 低代码编辑器多端适配\n\n![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/832af8060f6b49a1a570db75bb9a1973~tplv-k3u1fbpfcp-zoom-1.image)\n\n目前搭建编辑器面向的领域不仅仅是中后台 React 的体系，还包含有 Vue ，小程序、Rax 的体系，这样的一些体系因为底层的技术栈不同，对于组件的解析和渲染存在较大差异，不能通过纯粹的 React 渲染模块来把总个页面渲染出来。所有呢，我们怎样去适配多端，需要针对不同的技术栈，来实现对应的渲染引擎，通过很薄的一层适配层来使得我们的搭建编辑器支持各个技术栈的渲染，从而达到多端适配的目的。比如，阿里表格数据报表的搭建， imgcook 消费者端搭建，淘宝小程序搭建等。\n\n### 低代码编辑器核心能力\n\n![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4722376d85864831b48195b7b1f04aa4~tplv-k3u1fbpfcp-zoom-1.image)\n\n第 4 块内容，就是我们如何保障搭建编辑器技术先进性的一些核心能力。\n\n1.  **开箱即用**： 提供全链路一体化的搭建服务，不需要到线下去 2 次开发。其次支持定制搭建编辑器和定制业务主题风格。同时在我们平台上支持多人协作、多分支并行开发，可以应对大型复杂工程。比如淘系营销系统，同时会有数十个人并行开发同一个应用，往往会建立数个分支并行开发需求。所以呢，像这样一些大型复杂系统，中后台搭建系统不具备有多人协作和多分支并行开发的能力，那基本上在我们的业务场景上是无法落地的。所以这 2 块能力建设非常关键和重要。\n2.  **安全沙箱隔离**：我们对业内比较多的搭建产品做市场调研，发现较多搭建编辑器是没有做好沙箱隔离的。 iceluna 发展 3 年，反复从做隔离到不隔离几个阶段的不断迭代，最终彻底解决掉所有问题，完全实现沙箱隔离，从而保障搭建页面与编辑器本身完全隔离，互不干扰，并支持独立主题设定。\n3.  **实时调试能力**：我们的画布是一个真实的 Runtime ，它不是一个模拟器或不完整的渲染，业内很多低代码编辑器在搭建状态就是一个纯 UI 的渲染，通过低代码方式配置了交互数据或事件，它无法实时实时生效，需要通过预览或发布等链路才能调试 。而中后台场景业务逻辑非常重，往往需要高频的实时调试，这也是跟其他搭建产品不同，是结合业务场景建设的一个重要能力。\n\n### 低代码编辑器物料生态\n\n![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/035a1046881d42b3ac9f3e0461ff0525~tplv-k3u1fbpfcp-zoom-1.image)\n我们提供的通用搭建平台，对于不同的业务场景，对于物料的诉求是不一样的。今天，我们的搭建平台服务于 400 多个前端应用，要服务集团 20+ 部门，或者更大的一个组织体系，如果只提供一套物料库，那搭建平台的可用性会因此而大打折扣。我们需要针对不同 BU 不同业务场景，能够具备有快速接入不同物料的能力，第 1 点我们要能快速生产物料，第 2 点能快速接入已有的物料，第 3 点就是能够让这个物料流通起来，能够变成一个生态的机制，就如 Iconfont 图标生态一样。所以 iceluna 也在致力于怎样去打造一个低代码搭建物料的一个生态。我们在这块做的核心工作，主要如下：\n\n*   **统一搭建物料描述协议**：统一标准，规范生产，提升搭建物料的可复用性。\n*   **实现物料低成本接入**：支持 React 组件 npm 包低成本的接入，不需要对组件进行 2 次包装或开发，通过简单配置一个表单，就可以将组件接入进来，并且保障组件在源码里面完整的所有属性，在属性配置面板可以具备完整的可视化配置能力，无论你的属性是什么类型，数组类型也好，对象类型也好，ReactNode 类型也好，都具备有完整的可视化机制，来保障良好的编辑体验。\n*   **搭建物料流通**：建设搭建物料市场，形成类似 Iconfont 的生态机制。\n\n我们回到左侧图上来看，我们的低代码编辑器，它不仅仅是可以接入组件，最重要的能力就是通过低代码的方式来生产组件，为什么？低代码编辑器面对更广的用户，比如后端和外包同学，他们不掌握很多的源码知识，也不掌握源码的工程体系环境，但是他们同样会有做组件的诉求。其次，搭建编辑器本身就是一个提效的开发模式，无论是前端还是后端，研发页面还是组件，低代码开发同样带来开发侧的效率提升。在 iceluna 上，我们也提供了物料专属的搭建编辑器，可以在我们的平台上通过搭建的方式搭建物料，并且把这个物料上行到我们的物料中心，最后形成物料流通的机制。\n\n## 提供搭建服务的 PaaS 平台建设\n\n![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/31f4d63079f24acebd1f0d86e25d3909~tplv-k3u1fbpfcp-zoom-1.image)\n\n让我们回到主题的核心重点— PaaS 平台能力建设上来。PaaS：平台即服务 ( Platform-as-a-Service )，iceluna 的 PaaS 定位是把搭建编辑器的运行和开发环境作为一种服务，提供给不同业务场景下的搭建产品。\n\n前面章节讲到了搭建基础设施是提供搭建编辑器的开发环境，那上层还需要一个更加完善的平台侧服务能力，来提供搭建编辑器具备完整良好的运行环境，使得我们具备有一体化研发的能力，在整个能力的基础之上去孵化垂直领域的搭建产品。\n\n我们将从下面 6 个维度来介绍 Paas 服务的能力：研发中心编辑器定制、云端构建 & 发布 & 存储、多人协作、多分支开发、代码回滚、效能衡量。\n\n### 搭建编辑器定制服务\n\n![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/96583357b2764f459efc95fdb19ddf66~tplv-k3u1fbpfcp-zoom-1.image)\n在我们的站点中心提供了一个可视的方式来进行一个编辑器的配制，通过云端构建就可以构建出不同搭建编辑器，比如右边的 Iceluna 搭建编辑器及下面的 imgcook 编辑器，就是在研发中心创建了 2 个不同的站点，分别构建出来的编辑器。刚我们看到了编辑器的一份配置，那么编辑器具体可以配置哪些内容呢？\n\n*   **布局定制：**编辑器面向的领域不同，场景不同，做消费的页面和中后台页面，它对于面板画布的大小及可利用区域都是不同的，所有我们对于整个搭建编辑器面板布局是有不同的诉求。而我们可以通过这个的一个布局定制来快速构建出不同的布局出来，再配制不同的插件可以形成一个全新的搭建编辑器。\n\n![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/371e6a0e7acf4fe9a94aeccf0728d78a~tplv-k3u1fbpfcp-zoom-1.image)\n\n*   **主题定制：**搭建编辑器可以嵌入不同的场景，比如在淘系里面我们可嵌入 WebIDE 跟源码进行一个互转能力的打通，你可以同时切换到源码的开发，也可以同时切换到可视化的开发，在 WebIDE 的下面，它整个视觉风格就是个深色系，所以我们在平台上面也提供了主题包配制的一个能力，然后再适配不同主题风格搭配来定制编辑器。\n\n![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c4d3660183094ed580e8b89d0d5cf33a~tplv-k3u1fbpfcp-zoom-1.image)\n\n*   **插件定制**：我们提供了一个完备的插件化机制，整个搭建编辑器上的所有面板都是以插件化的形式来承载的，目前 iceluna 编辑器上总共有 26 个插件（图右可视），同时在插件生态池子里面，我们往后会沉淀越来越多的公共插件，并且这个插件都是可以被嵌入到搭建编辑器里面的。  如果这个插件池子里面没有你想要的插件，我们也提供了插件开发脚手架，给你来实现与编辑器功能解耦，可插拔，可定制的一个独立的插件。\n\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7b53d8509b4d43a9bb812e3c48178264~tplv-k3u1fbpfcp-zoom-1.image)\n\n### 云端构建/发布/ DB 存储服务\n\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f2d1d8b47dbf4bd3ac2b49d60f1e0d52~tplv-k3u1fbpfcp-zoom-1.image)\n\n云端构建服务是 iceluna 低代码开发平台核心链路之一，目前云端构建的能力主要是把我们在应用搭建过程中搭建出来的页面，然后组件产生出来的 Schema ，存在数据库里面之后的碎片化数据，通过云端构建的方式，去发布成应用或组件或者编辑器资源包，同时构建出来的这些应用、组件它们的源代码，我们也推送到 GitLab 作为存储，也会发到 CDN ，申请 CDN 资源最终推送到线上去。目前云端构建主要支持应用（日常/线上发布）、组件（Low code/ Procode发布)、编辑器（画布/框架的构建）3 大功能 6 种形态构建能力。\n\n![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2ba21980843a43d39f43c8c626c16faa~tplv-k3u1fbpfcp-zoom-1.image)\n\n云端构建架构图分为数据层，运行层，通信层，应用层4层，如图左所示。它的核心能力主要包含如下：\n\n1.  **编辑器去中心化**：在我们的平台，站点下创建的每一个应用均对应一个自己的编辑器资源包，这样的话，我们可以给每一个应用去定制自己的主题和组件的扩展，并带有版本化控制的能力。\n2.  **一键发布部署**：进行权限管控；对组件的依赖进行动态分析；在分支发布过程中会需要合并主干，如果产生冲突的话，在线解决冲突；Webpack 构建和 CDN 发布。\n3.  **多系统打通**：GitLab 存储以及通过 GitLab 来做代码回滚的机制，其次通过 Tair 做构建过程的并发锁，最后，通过 ODPS 做构建日志的分析。\n\n### 多人协作服务\n\n![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e52cd793fe8e4c71a07457674572163c~tplv-k3u1fbpfcp-zoom-1.image)\n在 PaaS 平台，多人协作是一个不可缺少的一个能力，它的主要原理是通过 WebSocket 的连接加上一个文件锁的机制，文件锁目前在平台上包含页面锁、组件锁、应用级别公共文件锁这三个维度的锁。大体思路主要是利用WebSocket 的保活的机制，与 Tair 保持一个心跳保活的消息通信。在 Tair 侧则是存储一个主动失效的分布式乐观锁，然后去存储这个锁的信息，大概 10 秒钟之内没有新的心跳过来，这个锁就会失效。所以说一旦客户端或 Server 端的 client 断了之后，那这个文件锁就会被自动释放这样一个机制来做的多人协作服务。我们也对业界多人协作的方案做了一些调研，比如钉钉文档、Google Docs 等都利用了业界比较先进的 OT 技术，实现相对复杂，功能也更强大。对于低代码搭建编辑器场景来说，编辑锁的能力已经够用了。左侧 iceluna 编辑器上红线框出来的点，都是有锁的功能。\n\n### 多分支并行服务\n\n![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c3fdaf19827b49cf88963d115e0754af~tplv-k3u1fbpfcp-zoom-1.image)\n\n多分支并行的能力最重要解决的一个问题是冲突解决，对于源码来说，冲突解决是已经存在的一个能力，但对于低代码云端工程体系来说却是一个非常难解决的问题。截止目前为止 iceluna 冲突解决的代码仍然是搭建描述协议 Schema 的代码，比对时相对比较困难，这是问题之一。其次，总个冲突解决的流程，多分支并行，包括代码回滚到数据库 DB ，这一块总个机制的构建也是相对比较复杂的。总体的流程如上图所示。\n\n### 代码回滚服务\n\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5e025e945a23469b85b0a12f5314c750~tplv-k3u1fbpfcp-zoom-1.image)\n代码回滚服务主要利用的就是基线同步的机制，这个机制保障我们可以指定任意 commit hash 进行编辑器应用代码回滚。因为我们在低代码平台的每一次发布，都会将代码同步到 Git ，所以任何一次发布的代码都可以回滚到我们的低代码编辑器。这里最大的难点就是 “ 数据库的碎片化信息 ” 与 “ Git 仓库上源码工程文件 ” 能具备有一一转换的关系。\n\n### 搭建效能衡量体系\n\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/435ec0dcc18046549812445408835d0b~tplv-k3u1fbpfcp-zoom-1.image)\n低代码搭建平台的效能衡量体系，初看跟技术不太相关，但为什么要讲效能衡量这个体系呢？我们在做搭建平台 3 年，还有其他兄弟团队的搭建平台都面临一个问题，就是都说搭建能提效，但没有一个很精确衡量提效多少的方法或策略，所以我们花了很长时间去研究，怎样有一个策略来衡量搭建是不是真的提效了。具体的实现方式，衡量标准是我们借助业界霍尔斯特德软件复杂度测量算法模型，这个算法模型可以将搭建页面时产出的 Schema 作为一个输入，它通过 Schema 里面的如表达式个数，代码长度等数十个算子，可以计算出 Schema 的复杂度以及预计开发时长。\n\n当然，这个预计开发时长需要反复去调参，比较符合真实情况后会得到一个相对准确的数字。另外呢，低代码搭建相对于源码开发，有一个好处就是用户都是在我们的平台上进行操作，平台侧可以通过埋点，操作日志等手段记录每一个研发人员在某个页面上的操作记录，在 2 次操作间隔时长在 10 分钟之内的算有效开发时间段，有效时间段的总和就是实际开发时长。通过计算公式 研发效能 = 预计开发时长/实际开发时长 就可以知道该用户开发效能是提升还是降低。在 iceluna 平台上数据中心会有专门一个效能中心，来反馈总个平台的总体人均研发效能、个人研发效能等数据。所以说这一点非常有价值，所以分享给大家。\n\n## 总结&展望\n\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3ced97d134c44036b23d3b0e349730da~tplv-k3u1fbpfcp-zoom-1.image)\n\n*   **前路总结**：中后台通用搭建产品建设成本超高，能很好的解决赋能&协作的问题，但研发提效未达数倍甚至 10 倍的预期，需要往模型驱动、智能搭建等 Nocode 新研发模式升级，或建设领域搭建产品矩阵来达成数倍提效的目标。\n*   **展望未来**：致力于将 iceluna 打造为中后台领域的 hpaPaaS 平台（超高生产力平台）。如果志同道合，期待的你的加入！\n![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b9730b71840c44b7ab6eb8c292a698e4~tplv-k3u1fbpfcp-zoom-1.image)", "user_name": "淘系前端团队FED", "description": "阿里巴巴淘系前端团队，东半球最大的前端团队，公众号@淘系前端团队", "got_view_count": 24933, "category_name": "前端", "ctime": 1457483942}
{"tag_name": "数据库", "concern_user_count": 239573, "user_id": "3139860942303527", "title": "【Oracle】手动安装和卸载Oracle，这是最全的一篇了！！", "mark_content": "## 写在前面\n\n> 之前写过一篇在CentOS 7/8上安装Oracle的文章，按照我写的文章安装成功了，但是卸载Oracle时出现了问题。今天，我就整理一篇手动安装和卸载Oracle的文章吧。全文为实战型内容，全程干货。\n>\n> 如果文章对你有所帮助，请不要吝惜你的点赞、在看、留言和转发，你的支持是我持续创作的最大动力！\n\n## 环境准备\n\n1.CentOS7 / CentOS8 64位最小化安装的虚拟机环境（这里的安装步骤，我就直接省略了，大家自行安装虚拟机环境）\n\n2.Oracle 11gR2 64位 Linux版安装包（关注【冰河技术】微信公众号，回复“oracle”关键字即可获取Oracle数据库安装包下载链接）。\n\n> linux.x64_11gR2_database_1of2.zip\n>\n> linux.x64_11gR2_database_2of2.zip\n\n## 安装过程\n\n### 1.关闭防火墙\n\n操作用户：root\n\n```bash\nsystemctl stop firewalld.service\nsystemctl disable firewalld.service\n```\n\n### 2.安装依赖包\n\n操作用户为：root。\n\n执行如下命令安装依赖包。\n\n```bash\nyum install -y automake autotools-dev binutils bzip2 elfutils expat \\\ngawk gcc gcc-multilib g++-multilib lib32ncurses5 lib32z1 \\\nksh less lib32z1 libaio1 libaio-dev libc6-dev libc6-dev-i386 \\\nlibc6-i386 libelf-dev libltdl-dev libodbcinstq4-1 libodbcinstq4-1:i386 \\\nlibpth-dev libpthread-stubs0-dev libstdc++5 make openssh-server rlwrap \\\nrpm sysstat unixodbc unixodbc-dev unzip x11-utils zlibc unzip cifs-utils \\\nlibXext.x86_64  glibc.i686\n```\n\n### 3.创建oracle用户\n\n操作用户为：root\n\n```bash\ngroupadd -g 502 oinstall\ngroupadd -g 503 dba\ngroupadd -g 504 oper\ngroupadd -g 505 asmadmin\nuseradd -u 502 -g oinstall -G oinstall,dba,asmadmin,oper -s /bin/bash -m oracle\npasswd oracle\n```\n\n上述命令执行完毕后，为oracle用户设置密码，例如，我这里设置的密码为oracle\n\n### 4.解压Oracle数据库安装包\n\n操作用户：oracle\n操作目录：/home/oracle\n\n将Oracle 11gR2安装文件上传（可以使用sftp上传）到该操作目录下面，然后顺序解压安装文件到该目录。\n\n```bash\nunzip linux.x64_11gR2_database_1of2.zip\nunzip linux.x64_11gR2_database_2of2.zip\n```\n\n### 5.修改操作系统配置\n\n操作用户：root\n操作文件：/etc/security/limits.conf\n\n```bash\nvim /etc/security/limits.conf\n```\n\n在文件的末尾添加如下配置项。\n\n```bash\noracle          soft      nproc   2047\noracle          hard      nproc   16384\noracle          soft      nofile  1024\noracle          hard      nofile  65536\noracle          soft      stack   10240\n```\n\n### 6.创建Oracle安装目录\n\n操作用户：oracle\n\n```bash\nmkdir ~/tools/oracle11g\n```\n\n### 7.修改环境变量\n\n操作用户：oracle\n操作目录：/home/oracle\n\n```bash\nvim ~/.bash_profile\n```\n\n在文件末尾添加如下配置项\n\n```bash\nexport ORACLE_BASE=/home/oracle/tools/oracle11g\nexport ORACLE_HOME=$ORACLE_BASE/product/11.2.0/dbhome_1\nexport ORACLE_SID=orcl\nexport ORACLE_UNQNAME=orcl\nexport NLS_LANG=.AL32UTF8\nexport PATH=${PATH}:${ORACLE_HOME}/bin/:$ORACLE_HOME/lib64\n```\n\n使得环境变量生效。\n\n```bash\nsource ~/.bash_profile\n```\n\n### 8.修改Oracle配置文件\n\n操作用户：oracle\n操作目录：/home/oracle\n\n复制文件模板\n\n```bash\ncp /home/oracle/database/response/db_install.rsp .\n```\n\n**注意：复制命令的最后一个 . 不能省略，表示将db_install.rsp文件从/home/oracle/database/response目录拷贝到当前目录。**\n\n对db_install.rsp文件进行编辑。\n\n```bash\nvim db_install.rsp\n```\n\n需要修改的配置项如下所示，这里，我将修改后的配置项列举出来。\n\n```bash\noracle.install.option=INSTALL_DB_AND_CONFIG\nORACLE_HOSTNAME=localhost #实际上可以修改成你自己的主机名或者域名(IP)\nUNIX_GROUP_NAME=oinstall\nINVENTORY_LOCATION=/home/oracle/tools/oraInventory\nSELECTED_LANGUAGES=en,zh_CN\nORACLE_HOME=/home/oracle/tools/oracle11g/product/11.2.0/dbhome_1\nORACLE_BASE=/home/oracle/tools/oracle11g\noracle.install.db.InstallEdition=EE\noracle.install.db.DBA_GROUP=dba\noracle.install.db.OPER_GROUP=oper\noracle.install.db.config.starterdb.type=GENERAL_PURPOSE\noracle.install.db.config.starterdb.globalDBName=orcl\noracle.install.db.config.starterdb.SID=orcl\noracle.install.db.config.starterdb.characterSet=AL32UTF8\noracle.install.db.config.starterdb.memoryOption=true\noracle.install.db.config.starterdb.memoryLimit=1024\noracle.install.db.config.starterdb.installExampleSchemas=false\noracle.install.db.config.starterdb.password.ALL=Oracle#123456\noracle.install.db.config.starterdb.control=DB_CONTROL\noracle.install.db.config.starterdb.dbcontrol.enableEmailNotification=false\noracle.install.db.config.starterdb.dbcontrol.emailAddress=test@qq.com #可以填写你自己的邮箱地址\noracle.install.db.config.starterdb.automatedBackup.enable=false\noracle.install.db.config.starterdb.storageType=FILE_SYSTEM_STORAGE\noracle.install.db.config.starterdb.fileSystemStorage.dataLocation=/home/oracle/tools/oracle11g/oradata\noracle.install.db.config.starterdb.fileSystemStorage.recoveryLocation=/home/oracle/tools/oracle11g/fast_recovery_area\noracle.install.db.config.starterdb.automatedBackup.enable=false\nDECLINE_SECURITY_UPDATES=true\n```\n\n### 9.静默安装Oracle 11gR2\n\n操作用户：oracle\n操作目录：/home/oracle/database\n\n```bash\n./runInstaller -silent -ignoreSysPrereqs -responseFile /home/oracle/db_install.rsp\n```\n\n接下来，就是默默的等待Oracle自行安装了，等待一段时间后，如果输出如下信息，则表明Oracle数据库已经安装成功。\n\n```bash\nThe following configuration scripts need to be executed as the \"root\" user.\n#!/bin/sh\n#Root scripts to run\n\n/home/oracle/tools/oraInventory/orainstRoot.sh\n/home/oracle/tools/oracle11g/product/11.2.0/dbhome_1/root.sh\nTo execute the configuration scripts:\n\n        1. Open a terminal window\n         2. Log in as \"root\"\n         3. Run the scripts\n         4. Return to this window and hit \"Enter\" key to continue\n\nSuccessfully Setup Software.\n```\n\n### 10.安装完成\n\n操作用户：root\n\n根据上一步完成信息提示，执行以下两行命令，具体位置需要根据你的安装位置决定：\n\n```bash\n/home/oracle/tools/oraInventory/orainstRoot.sh\n/home/oracle/tools/oracle11g/product/11.2.0/dbhome_1/root.sh\n```\n\n### 11.创建连接用户\n\n操作用户：oracle\n\n```bash\nsqlplus /nolog\nconn /as sysdba\nstartup\n```\n\n接下来，执行如下命令。\n\n```bash\nalter user system identified by system;\nalter user sys identified by sys;\n```\n\n创建连接用户。\n\n```bash\ncreate user SYNC identified by SYNC;\ngrant connect,resource,dba to SYNC;\n```\n\n## 验证安装结果\n\n### 1.启动数据库\n\n启动已经安装的数据库orcl。\n\n操作用户oracle\n\n```bash\nsqlplus /nolog\n```\n\n使用dba权限连接Oralce\n\n```bash\nconnect / as sysdba\n```\n\n启动数据库\n\n```bash\nstartup\n```\n\n确认启动结果：\n\n```bash\nORACLE instance started.\n\nTotal System Global Area  534462464 bytes\nFixed Size                  2215064 bytes\nVariable Size            373293928 bytes\nDatabase Buffers          150994944 bytes\nRedo Buffers                7958528 bytes\nDatabase mounted.\nDatabase opened.\n```\n\n### 2.验证数据库\n\n这里，我们使用Navicat连接Oracle数据库，如下所示。\n\n![](https://img-blog.csdnimg.cn/2020052412331415.jpg#pic_center)\n\n这里，输入的用户名为SYNC，密码为SYNC。\n\n接下来，点击“连接测试”，如下所示。\n\n![](https://img-blog.csdnimg.cn/20200524123327698.jpg#pic_center)\n\n可以看到，Oracle数据库连接成功。\n\n## 手动卸载Oracle\n\n### 1.停止监听\n\n```bash\n[oracle@binghe101 ~]$ lsnrctl stop\n[oracle@binghe101 ~]$ lsnrctl status\n```\n\n### 2.停止数据库\n\n```bash\n[oracle@binghe101 ~]$ sqlplus / as sysdba\nSQL> shutdown immediate\n```\n\n### 3.删除oracle的inventory 目录\n\n```bash\n[root@binghe101 app]# rm -rf /home/oracle/tools/oraInventory/\n```\n\n### 4.删除Oracle的base目录下所有的目录\n\n```bash\n[root@binghe101 oracle]# rm -rf /home/oracle/tools/oracle11g/*\n```\n\n### 5.删除临时目录/tmp\n\n```bash\n[root@binghe101 tmp]# rm -rf /tmp/*\n```\n\n### 6.删除Oracle的配置文件\n\n```bash\n[root@binghe101 tmp]# rm -f /etc/ora*\n```\n\n### 7.删除oracle产生命令\n\n```bash\n[root@binghe101 tmp]# rm -f /usr/local/bin/*\n```\n\n### 8.其他的文件\n\n```bash\n[root@binghe101 .oracle]# rm -rf /usr/tmp/.oracle/\n```\n\n### 9.删除用户和组\n\n```bash\n[root@binghe101 tmp]# userdel -r oracle\n[root@binghe101 tmp]# groupdel oper\n[root@binghe101 tmp]# groupdel dba    \n[root@binghe101 tmp]# groupdel oinstall\n[root@binghe101 tmp]# groupdel asmadmin\n```\n\n### 10.撤销oracle的资源限制文件\n\n```bash\n[root@binghe101 tmp]# vi /etc/security/limits.conf\n```\n\n### 11.内核参数\n\n```bash\n[root@binghe101 tmp]# vi /etc/sysctl.conf \n[root@binghe101 tmp]# sysctl -p\n```\n\n### 12.删除oracle base\n\n```bash\n[root@binghe101 ~]# rm -rf /home/oracle/tools/oracle11g\n```\n\n## 重磅福利\n\n关注「 **冰河技术** 」微信公众号，后台回复 “**设计模式**” 关键字领取《**深入浅出Java 23种设计模式**》PDF文档。回复“**Java8**”关键字领取《**Java8新特性教程**》PDF文档。回复“**限流**”关键字获取《**亿级流量下的分布式限流解决方案**》PDF文档，三本PDF均是由冰河原创并整理的超硬核教程，面试必备！！\n\n<font color=\"#FF0000\">**好了，今天就聊到这儿吧！别忘了点个赞，给个在看和转发，让更多的人看到，一起学习，一起进步！！**</font>\n\n## 写在最后\n\n> 如果你觉得冰河写的还不错，请微信搜索并关注「 **冰河技术** 」微信公众号，跟冰河学习高并发、分布式、微服务、大数据、互联网和云原生技术，「 **冰河技术** 」微信公众号更新了大量技术专题，每一篇技术文章干货满满！不少读者已经通过阅读「 **冰河技术** 」微信公众号文章，吊打面试官，成功跳槽到大厂；也有不少读者实现了技术上的飞跃，成为公司的技术骨干！如果你也想像他们一样提升自己的能力，实现技术能力的飞跃，进大厂，升职加薪，那就关注「 **冰河技术** 」微信公众号吧，每天更新超硬核技术干货，让你对如何提升技术能力不再迷茫！\n\n![](https://img-blog.csdnimg.cn/20200716220443647.png#pic_center)\n\n\n\n", "user_name": "冰_河", "description": "大数据架构师，编程专家，Mykit系列开源框架作者，多年来致力于分布式系", "got_view_count": 16819, "category_name": "后端", "ctime": 1457483880}
{"tag_name": "Node.js", "concern_user_count": 245462, "user_id": "166781497387390", "title": "一年Node.js开发经验总结", "mark_content": "> 本文首发于公众号：符合预期的CoyPan\n\n#### 写在前面\n\n不知不觉的，写Node.js已经一年了。不同于最开始的demo、本地工具等，这一年里，都是用Node.js写的线上业务。从一开始的Node.js同构直出，到最近的Node接入层，也算是对Node开发入门了吧。目前，我一个人维护了大部分组内流传下来的Node服务，包括内部系统和线上服务。新增的后台服务，也是尽可能地使用Node进行开发。本文是一下自己最近的一些小小的总结和思考。\n\n> 本文不会深入讲解Node.js本身的特性，架构等等。我也没有写过Node扩展或者库什么的，对Node.js的了解也并不够深入。\n\n\n#### 为何用Node\n\n对于我来说，对于团队来说，适用Node的原因其实很简单：**开发起来快**。熟悉JS的前端同学可以很快上手，节省成本。选一个http server库起一个server，选择合适的中间件，匹配好请求路由，看情况合理使用ORM库链接数据库、增删改查即可。\n\n\n\n#### Node的适用场景\n\nNode.js 使用了一个事件驱动、非阻塞式 I/O 的模型，使其轻量又高效。这种模型使得Node.js 可以避免了由于需要等待输入或者输出（数据库、文件系统、Web服务器...）响应而造成的 CPU 时间损失。所以，Node.js适合运用在高并发、I/O密集、少量业务逻辑的场景。\n\n对应到平时具体的业务上，如果是内部的系统，大部分仅仅就是需要对某个数据库进行增删改查，那么Server端直接就是Node.js一把梭。\n\n对于线上业务，如果流量不大，并且业务逻辑简单的情况下，Server端也可以完全使用Node.js。对于流量巨大，复杂度高的项目，一般用Node.js作为接入层，后台同学负责实现服务。如下图：\n\n![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0de09a1e9f284a138bf7bec13f135d72~tplv-k3u1fbpfcp-zoom-1.image)\n\n#### 同样是写JS，Node.js开发和页面开发有什么区别\n\n在浏览器端开发页面，是和用户打交道、重交互，浏览器还提供了各种Web Api供我们使用。Node.js主要面向数据，收到请求后，返回具体的数据。这是两者在业务路径上的区别。而真正的区别其实是在于业务模型上（业务模型，这是我自己瞎想的一个词）。直接用图表示吧。\n\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7fb3d2e65f6841af919bccbbae940734~tplv-k3u1fbpfcp-zoom-1.image)\n\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e447232843224ef09d08f4a16cc9af94~tplv-k3u1fbpfcp-zoom-1.image)\n\n开发页面时，每一个用户的浏览器上都有一份JS代码。如果代码在某种情况下崩了，只会对当前用户产生影响，并不会影响其他用户，用户刷新一下即可恢复。而在Node.js中，**在不开启多进程的情况下**，所有用户的请求，都会走进同一份JS代码，并且只有一个线程在执行这份JS代码。如果某个用户的请求，导致发生错误，Node.js进程挂掉，server端直接就挂了。尽管可能有进程守护，挂掉的进程会被重启，但是在用户请求量大的情况下，错误会被频繁触发，可能就会出现server端不停挂掉，不停重启的情况，对用户体验造成影响。\n\n以上，可能是Node.js开发和前端JS开发最大的区别。\n\n\n\n#### Node.js开发时的注意事项\n\n用户在访问Node.js服务时，如果某一个请求卡住了，服务迟迟不能返回结果，或者说逻辑出错，导致服务挂掉，都会带来大规模的体验问题。server端的目标，就是要 **快速、可靠** 地返回数据。\n\n##### 缓存\n\n由于Node.js不擅长处理复杂逻辑（JavaScript本身执行效率较低），如果要用Node.js做接入层，应该避免复杂的逻辑。想要快速处理数据并返回，一个至关重要的点：使用缓存。\n\n例如，使用Node做React同构直出，`renderToString`这个Api，可以说是比较重的逻辑了。如果页面的复杂度高，每次请求都完整执行`renderToString`，会长时间占用线程来执行代码，增加响应时间，降低服务的吞吐量。这个时候，缓存就十分重要了。\n\n实现缓存的主要方式：内存缓存。可以使用Map，WeakMap，WeakRef等实现。参考以下简单的示例代码：\n\n```javascript\nconst cache = new Map();\n\nrouter.get('/getContent', async (req, res) => {\n  const id = req.query.id;\n  \n  // 命中缓存\n  if(cache.get(id)) {\n    return res.send(cache.get(id));\n  }\n  \n  // 请求数据\n  const rsp = await rpc.get(id);\n \t// 经过一顿复杂的操作，处理数据\n  const content = process(rsp);\n  // 设置缓存\n  cache.set(id, content);\n  \n  return res.send(content);\n});\n```\n\n使用缓存时，有一个很重要的问题是：内存缓存如何更新。一种最简单的方法，开一个定时器，定期删除缓存，下一次请求到来时，重新设置缓存即可。在上述代码中，增加如下代码：\n\n```javascript\nsetTimeout(function() {\n  cache.clear();\n}, 1000 * 60); // 1分钟删除一次缓存\n```\n\n如果server端完全使用Node实现，需要用Node端直接连接数据库，在数据时效性要求不太高、且流量不太大的情况下，就可以使用上述类似的模型，如下图。这样可以降低数据库的压力且加快Node的响应速度。\n\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/52d75d6bcd6d4bb083369ab455e570f0~tplv-k3u1fbpfcp-zoom-1.image)\n\n\n\n另外，**还需要注意内存缓存的大小**。如果一直往缓存里写入新数据，那么内存会越来越大，最终爆掉。可以考虑使用LRU（Least Recently Used）算法来做缓存。开辟一块内存专门作为缓存区域。当缓存大小达到上限时，淘汰最久未使用的缓存。\n\n内存缓存会随着进程的重启而全部失效。\n\n当后台业务比较复杂，接入层流量，数据量较大时，可以使用如下的架构，使用独立的内存缓存服务。Node接入层直接从缓存服务取数据，后台服务直接更新缓存服务。\n\n![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0b4daf46a6d8474382fc42c843139198~tplv-k3u1fbpfcp-zoom-1.image)\n\n当然，上图中的架构是最简单的情形，现实中还需要考虑分布式缓存、缓存一致性的问题。这又是另外一个话题了。\n\n\n\n##### 错误处理\n\n由于Node.js语言的特性，Node服务是比较容易出错的。而一旦出错，造成的影响就是服务不可用。因此，对于错误的处理十分的重要。\n\n处理错误，最常用的就是`try catch `了。可是 `try catch`无法捕获异步错误。Node.js中，异步操作是十分常见的，异步操作主要是在回调函数中暴露错误。看一个例子：\n\n```javascript\nconst readFile = function(path) {\n\treturn new Promise((resolve,reject) => {\n\t\tfs.readFile(path, (err, data) => {\n\t\t\tif(err) { \n\t\t\t\tthrow err; // catch无法捕获错误，这和Node的eventloop有关。\n        // reject(err); // catch可以捕获\n      }\n      resolve(data);\n\t\t});\n\t});\n}\n\nrouter.get('/xxx', async function(req, res) {\n  try {\n    const res = await readFile('xxx');\n    ...\n  } catch (e){\n    // 捕获错误处理\n    ...\n    res.send(500);\n  }\n});\n\n```\n\n上面的代码中，readFile 中 throw 出来的错误，是无法被catch捕获的。如果我们把 `throw err` 换成 `Promise.reject(err)`，catch中是可以捕获到错误的。 \n\n**我们可以把异步操作都Promise化，然后统一使用  async 、try、catch 来处理错误**。\n\n但是，总会有地方会被遗漏。这个时候，可以使用process来捕获全局错误，防止进程直接退出，导致后面的请求挂掉。示例代码：\n\n```javascript\nprocess.on('uncaughtException', (err) => {\n  console.error(`${err.message}\\n${err.stack}`);\n});\n\nprocess.on('unhandledRejection', (reason, p) => {\n  console.error(`Unhandled Rejection at: Promise ${p} reason: `, reason);\n});\n```\n\n关于Node.js中错误的捕获，还可以使用```domain```模块。现在这个模块已经不推荐使用了，我也没有在项目中实践过，这里就不展开了。Node.js 近几年推出的 async_hooks 模块，也还处于实验阶段，不太建议线上环境直接使用。做好进程守护，开启多进程，错误告警及时修复，养成良好的编码规范，使用合适的框架，才能提高Node服务的效率及稳定性。\n\n\n\n#### 写在后面\n\n本文总结了Node.js开发一年多以来的实践总结等。Node.js的开发与前端网页的开发思路不同，着重点不一样。我正式开发Node.js的时间也不算太长，一些点并没有深入的理解，本文仅仅是一些经验之谈。欢迎交流。\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5c585aea63ea4fbea508390ca2f2eab7~tplv-k3u1fbpfcp-zoom-1.image)", "user_name": "CoyPan", "description": "公众号: 符合预期的CoyPan", "got_view_count": 48217, "category_name": "前端", "ctime": 1457483942}
{"tag_name": "Node.js", "concern_user_count": 245462, "user_id": "2717648473821736", "title": "从 0 到 1 node 项目管理系统：搭建基础平台（中）", "mark_content": "## 前言\n\n搭建[基础平台搭建上篇](https://juejin.im/post/6856485896724676615)的时候的时候，已经介绍过了项目流程设计、数据库搭建、jwt 登录等模块。\n\n此篇我们介绍分支管理设计及其他的基础模块。\n\n**后端模块**\n\n1. [DevOps - Gitlab Api使用（已完成，点击跳转）](https://juejin.im/post/6855129008066002958)\n2. DevOps - 搭建 DevOps 基础平台（已完成 50%）[基础平台搭建上，点击跳转](https://juejin.im/post/6856485896724676615)\n3. DevOps - Gitlab CI 流水线构建\n4. DevOps - Jenkins 流水线构建\n5. DevOps - Docker 使用\n6. DevOps - 发布任务流程设计\n7. DevOps - 代码审查卡点\n8. DevOps - Node 服务质量监控\n\n> 后期可能会根据 DevOps 项目的实际开发进度对上述系列进行调整\n\n## Git 分支管理流程\n\n### Git Flow 流程\n\n![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c5b691c99f3746fc967b0835227790f9~tplv-k3u1fbpfcp-zoom-1.image)\n\n**Production 分支**\n\n就是常用的 Master 分支，这个分支包含最近发布到生产环境的代码，最近发布的 Release， 这个分支只能从其他分支合并，不能在这个分支直接修改\n\n**Develop 分支**\n\n这个分支是的主开发分支，包含所有要发布到下一个Release的代码，这个主要合并于其他分支，比如 Feature 分支\n\n**Feature 分支**\n\n这个分支主要是用来开发一个新的功能，一旦开发完成，我们合并回 Develop 分支，并进入下一个 Release\n\n**Release 分支**\n\n当需要发布一个新 Release 的时候，基于 Develop 分支创建一个 Release 分支，完成 Release 后，合并到 Master 和 Develop 分支\n\n**Hotfix 分支**\n\n当在 Production 发现新的 Bu g时候，需要创建一个 Hotfix, 完成 Hotfix 后，合并回 Master 和 Develop 分支，所以 Hotfix 的改动会进入下一个 Release\n\n整体的分支管理流程如下图所示\n\n![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e48ee7b35b684ceeb41b0ee2bf875bfa~tplv-k3u1fbpfcp-zoom-1.image)\n\n### 项目自建流程\n\n上述的 Git Flow 流程使用可以规范约束开发质量跟流程，我们稍微修改一下部分流程，融入到项目中进行使用。\n\n![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/eb27b54fe24c485ba062efabc82e0b3a~tplv-k3u1fbpfcp-zoom-1.image)\n\n![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/632d2d88b95941f981d35c5281cbf93a~tplv-k3u1fbpfcp-zoom-1.image)\n\n如图每个工程都共享一个 version 版本号，分支创建分为版本升级、特性更新、修订补丁三种模式，强制项目所有分支创建的命名规则都会升级，不会出现重复跟降级。\n\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1bd83af2a5be4bb48a0f0404ce8f8c0f~tplv-k3u1fbpfcp-zoom-1.image)\n\n**上述流程的优点**：\n\n1. 工程使用固定的版本锁死，版本对应需求流程，上线质量得到保障\n2. 每个开发分支都只能部署到测试环境，必须合并到合并到对应的版本分支之后才能上生产\n3. 所有合并到 master 或者 relase 分支会被删除，防止一条分支处理过多业务，后期 review、回滚难度提升\n4. realse 版本分支上线之后，生成对应 tag\n5. hotfix 版本可以从对应的 tag 拉出，可以明确的知道 hotfix 具体修复的是哪个版本的问题\n\n**上述流程的缺点**：\n\n1. 固化版本流程导致创建命名规则固定，且版本号不能升级只能降级\n2. 流程限制，降低开发灵活性\n\n> 没有完美的解决方法，所有 devops 流程都要结合真实项目需求来设计，上述只是一种解决方案，有更通用的方案设计请加我微信 Cookieboty 探讨 \n\n## DevOps 开发中篇\n\n### 添加全局报错回调\n\n没有绝对安全的程序，所有程序在运行中因各种情况会出现 error，全局错误回调是基础模块必要的。\n\n```js\nexport default class HttpExceptions extends Error { // 继承修改 error 类型\n  code: number;\n  msg: string;\n  httpCode: number;\n\n  constructor({ msg = \"服务器异常\", code = 1, httpCode = 400 }) {\n    super();\n    this.msg = msg;\n    this.code = code;\n    this.httpCode = httpCode;\n  }\n}\n\nimport HttpExceptions from \"../exceptions/http_exceptions\"; // 全局拦截错误处理\n\nexport default () => {\n  return async function errorHandler(ctx, next) {\n    try {\n      await next();\n    } catch (err) {\n      // 所有的异常都在 app 上触发一个 error 事件，框架会记录一条错误日志\n      ctx.app.emit(\"error\", err, ctx);\n\n      let status = err.status || 500;\n      let error: any = {};\n\n      if (err instanceof HttpExceptions) {\n        status = err.httpCode;\n        error.requestUrl = `${ctx.method} : ${ctx.path}`;\n        error.msg = err.msg;\n        error.code = err.code;\n        error.httpCode = err.httpCode;\n      } else {\n        // 未知异常，系统异常，线上不显示堆栈信息\n        // 生产环境时 500 错误的详细错误内容不返回给客户端，因为可能包含敏感信息\n        error.code = 500;\n        error.errsInfo =\n          status === 500 && ctx.app.config.env === \"prod\"\n            ? \"Internal Server Error\"\n            : err.message;\n      }\n      // 从 error 对象上读出各个属性，设置到响应中\n      ctx.body = error;\n      if (status === 422) {\n        ctx.body.detail = err.errors;\n      }\n      ctx.status = status;\n    }\n  };\n};\n```\n如上，我们拓展默认错误类，添加错误中间件拦截全局异常，如果出现自定义异常抛出的时候，则处理全局异常，否则统一抛出 500 错误，去除敏感信息。\n\n### webSocket 使用\n\n#### 为什么要使用 webSocket\n\n项目管理中，会涉及到同一个项目多人协作操作，而 ajax 轮训既消耗性能，实时性也不能完全保证，也会推送大量无效信息。所以项目采用 websocket 来推送多人协作信息以及后期**构建流程的状态推送**。\n\n#### egg-socket\n\n框架提供了 egg-socket.io 插件，增加了以下开发规约：\n\n- namespace: 通过配置的方式定义 namespace（命名空间）\n- middleware: 对每一次 socket 连接的建立/断开、每一次消息/数据传递进行预处理\n- controller: 响应 socket.io 的 event 事件\n- router: 统一了 socket.io 的 event 与 框架路由的处理配置方式。 \n\n具体的使用方式请参考：[egg-socket.io 使用](https://eggjs.org/zh-cn/tutorials/socketio.html)，下面简单说下 ts 的配置\n\n```js\nimport { Application } from \"egg\"; // io路由使用方式\nimport { EggShell } from \"egg-shell-decorators\";\n\nexport default (app: Application) => {\n  const { router, controller, io } = app;\n\n  EggShell(app);\n\n  // socket.io\n  io.of('/').route('server', io.controller.nsp.ping);\n};\n```\n\nts 使用中 io.controller.nsp 会报类型未定义，所以需要修改一下 **typings/index.d.ts** 文件。\n\n```js\nimport \"egg\";\n\ndeclare module \"egg\" {\n  interface Application { }\n  interface CustomController {\n    nsp: any;\n  }\n\n  interface EggSocketNameSpace {\n    emit: any\n  }\n}\n```\n\n#### socket.io-client\n\n```js\nwindow.onload = function () {\n  // init\n  const socket = io('http://127.0.0.1:7001', {\n    // 实际使用中可以在这里传递参数\n    query: {\n      room: 'nsp',\n      userId: `client_${Math.random()}`,\n    },\n\n    transports: ['websocket'],\n  });\n\n  socket.on('connect', () => {\n    const id = socket.id;\n\n    log('#connect,', id, socket);\n\n    // 监听自身 id 以实现 p2p 通讯\n    socket.on(id, (msg: any) => {\n      log('#receive,', msg);\n    });\n  });\n\n  // 接收在线用户信息\n  socket.on('online', (msg: any) => {\n    log('#online,', msg);\n  });\n\n  // 系统事件\n  socket.on('disconnect', (msg: any) => {\n    log('#disconnect', msg);\n  });\n\n  socket.on('disconnecting', () => {\n    log('#disconnecting');\n  });\n\n  socket.on('error', () => {\n    log('#error');\n  });\n\n  window.socket = socket;\n};\n```\n客服端采用 socket.io-client 去链接 websocket。上述是基础链接部分，具体的实现要根据业务需求开发。\n\n### 客服端实现\n\n为了保障项目开发速度，客户端选择了 [ANT DESIGN PRO](https://eggjs.org/zh-cn/tutorials/socketio.html)。具体安装步骤请参考教程，这边展示一下部分业务端的代码。\n\n![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/528e6d7582bc479290b1d1f5ca4aab50~tplv-k3u1fbpfcp-zoom-1.image)\n\n#### JWT 前端使用\n```js\n/**\n * 异常处理程序\n */\nconst errorHandler = (error: { response: Response }): Response => {\n  const { response } = error;\n  if (response && response.status) {\n    const errorText = codeMessage[response.status] || response.statusText;\n    const { status, url } = response;\n\n    if (response.status === 401) {\n      window.location.href = '/user/login';\n    }\n    notification.error({\n      message: `请求错误 ${status}: ${url}`,\n      description: errorText,\n    });\n  } else if (!response) {\n    notification.error({\n      description: '您的网络发生异常，无法连接服务器',\n      message: '网络异常',\n    });\n  }\n  return response;\n};\n\n/**\n * 配置request请求时的默认参数\n */\nconst request = extend({\n  prefix: '/api',\n  errorHandler, // 默认错误处理\n  credentials: 'include', // 默认请求是否带上cookie\n  headers: {\n    authorization: localStorage.getItem('authorization'), // 读取本地保存的 authorization token\n  },\n});\n\nexport default request;\n```\n\n改造 request 模块\n\n```js\nimport request from '@/utils/request';\n\nexport interface LoginParamsType {\n  username: string;\n  password: string;\n  mobile: string;\n  captcha: string;\n}\n\nexport async function fakeAccountLogin(params: LoginParamsType) {\n  return request('/user/getUserToken', {\n    getResponse: true, // 开启可以拿到返回 header 参数，将对应的 authorization token 存入本地使用\n    method: 'POST',\n    data: { params },\n  });\n}\n```\n\n如上，拿到 response header 里面的 token，后续可以正常请求接口。\n\n## 尾声\n\n此项目是从零开发，后续此系列博客会根据实际开发进度推出（**真 TMD 累**），项目完成之后，会开放部分源码供各位同学参考。\n\n如对文章内容有任何疑问、见解可添加微信 Cookieboty 沟通。\n\n另外关注公众号 Cookieboty1024，欢迎加入前端小兵成长营\n", "user_name": "Cookieboty", "description": "工资到位，四皇干废", "got_view_count": 19443, "category_name": "前端", "ctime": 1457483942}
{"tag_name": "Vue.js", "concern_user_count": 263220, "user_id": "3509296847679559", "title": "30行写一个Vue图片懒加载指令", "mark_content": "<section id=\"nice\" data-tool=\"mdnice编辑器\" data-website=\"https://www.mdnice.com\" style=\"font-size: 16px; color: black; padding: 0 10px; line-height: 1.6; word-spacing: 0px; letter-spacing: 0px; word-break: break-word; word-wrap: break-word; text-align: left; font-family: Optima-Regular, Optima, PingFangSC-light, PingFangTC-light, 'PingFang SC', Cambria, Cochin, Georgia, Times, 'Times New Roman', serif;\"><h2 data-tool=\"mdnice编辑器\" style=\"margin-top: 30px; margin-bottom: 15px; padding: 0px; font-weight: bold; color: black; border-bottom: 2px solid rgb(239, 112, 96); font-size: 1.3em;\"><span class=\"prefix\" style=\"display: none;\"></span><span class=\"content\" style=\"display: inline-block; font-weight: bold; background: rgb(239, 112, 96); color: #ffffff; padding: 3px 10px 1px; border-top-right-radius: 3px; border-top-left-radius: 3px; margin-right: 3px;\">前言</span><span class=\"suffix\"></span><span style=\"display: inline-block; vertical-align: bottom; border-bottom: 36px solid #efebe9; border-right: 20px solid transparent;\"> </span></h2>\n<p data-tool=\"mdnice编辑器\" style=\"font-size: 16px; padding-top: 8px; padding-bottom: 8px; margin: 0; line-height: 26px; color: black;\">OK,兄弟们。前面一篇文章就说过要用指令的方式来实现图片的懒加载。其实，前端发展这么多年，要实现图片懒加载非常的简单，配合上Vue的指令，30行轻轻松松实现一个高复用的Vue指令。一起来看看吧。</p>\n<h2 data-tool=\"mdnice编辑器\" style=\"margin-top: 30px; margin-bottom: 15px; padding: 0px; font-weight: bold; color: black; border-bottom: 2px solid rgb(239, 112, 96); font-size: 1.3em;\"><span class=\"prefix\" style=\"display: none;\"></span><span class=\"content\" style=\"display: inline-block; font-weight: bold; background: rgb(239, 112, 96); color: #ffffff; padding: 3px 10px 1px; border-top-right-radius: 3px; border-top-left-radius: 3px; margin-right: 3px;\">v-imgLazy</span><span class=\"suffix\"></span><span style=\"display: inline-block; vertical-align: bottom; border-bottom: 36px solid #efebe9; border-right: 20px solid transparent;\"> </span></h2>\n<p data-tool=\"mdnice编辑器\" style=\"font-size: 16px; padding-top: 8px; padding-bottom: 8px; margin: 0; line-height: 26px; color: black;\">这里我是用的IntersectionObserver API去实现的。</p>\n<blockquote data-tool=\"mdnice编辑器\" style=\"display: block; font-size: 0.9em; overflow: auto; overflow-scrolling: touch; border-left: 3px solid rgba(0, 0, 0, 0.4); color: #6a737d; padding-top: 10px; padding-bottom: 10px; padding-left: 20px; padding-right: 10px; margin-bottom: 20px; margin-top: 20px; border-left-color: rgb(239, 112, 96); background: #fff9f9;\">\n<p style=\"font-size: 16px; padding-top: 8px; padding-bottom: 8px; margin: 0px; color: black; line-height: 26px;\">IntersectionObserver 对象的observe() 方法向IntersectionObserver对象监听的目标集合添加一个元素。一个监听者有一组阈值和一个根， 但是可以监视多个目标元素，以查看这些目标元素可见区域的变化。</p>\n</blockquote>\n<p data-tool=\"mdnice编辑器\" style=\"font-size: 16px; padding-top: 8px; padding-bottom: 8px; margin: 0; line-height: 26px; color: black;\">简单来说可以监听dom元素进出可视区域，并且可以控制具体的变化。</p>\n<p data-tool=\"mdnice编辑器\" style=\"font-size: 16px; padding-top: 8px; padding-bottom: 8px; margin: 0; line-height: 26px; color: black;\">具体的使用请看 <a href=\"https://developer.mozilla.org/zh-CN/docs/Web/API/IntersectionObserver/observe\" style=\"text-decoration: none; word-wrap: break-word; font-weight: bold; color: rgb(239, 112, 96); border-bottom: 1px solid rgb(239, 112, 96);\">IntersectionObserver API</a></p>\n<p data-tool=\"mdnice编辑器\" style=\"font-size: 16px; padding-top: 8px; padding-bottom: 8px; margin: 0; line-height: 26px; color: black;\">新建一个directive用来存放自定义指令</p>\n<blockquote data-tool=\"mdnice编辑器\" style=\"display: block; font-size: 0.9em; overflow: auto; overflow-scrolling: touch; border-left: 3px solid rgba(0, 0, 0, 0.4); color: #6a737d; padding-top: 10px; padding-bottom: 10px; padding-left: 20px; padding-right: 10px; margin-bottom: 20px; margin-top: 20px; border-left-color: rgb(239, 112, 96); background: #fff9f9;\">\n<p style=\"font-size: 16px; padding-top: 8px; padding-bottom: 8px; margin: 0px; color: black; line-height: 26px;\">directive/imgLazy.js</p>\n</blockquote>\n<pre class=\"custom\" data-tool=\"mdnice编辑器\" style=\"margin-top: 10px; margin-bottom: 10px; border-radius: 5px; box-shadow: rgba(0, 0, 0, 0.55) 0px 2px 10px;\"><span style=\"display: block; background: url(https://my-wechat.mdnice.com/point.png); height: 30px; width: 100%; background-size: 40px; background-repeat: no-repeat; background-color: #fff; margin-bottom: -7px; border-radius: 5px; background-position: 10px 10px;\"></span><code class=\"hljs\" style=\"overflow-x: auto; padding: 16px; color: black; display: -webkit-box; font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; font-size: 12px; -webkit-overflow-scrolling: touch; padding-top: 15px; background: #fff; border-radius: 5px;\"><span class=\"hljs-comment\" style=\"color: #007400; line-height: 26px;\">//&nbsp;引入默认图片</span><br><span class=\"hljs-keyword\" style=\"color: #aa0d91; line-height: 26px;\">import</span>&nbsp;baseImg&nbsp;<span class=\"hljs-keyword\" style=\"color: #aa0d91; line-height: 26px;\">from</span>&nbsp;<span class=\"hljs-string\" style=\"color: #c41a16; line-height: 26px;\">'@/assets/logo.png'</span>;<br><br><span class=\"hljs-keyword\" style=\"color: #aa0d91; line-height: 26px;\">let</span>&nbsp;timer&nbsp;=&nbsp;<span class=\"hljs-literal\" style=\"color: #aa0d91; line-height: 26px;\">null</span>;<br><span class=\"hljs-comment\" style=\"color: #007400; line-height: 26px;\">//&nbsp;创建一个监听器</span><br><span class=\"hljs-keyword\" style=\"color: #aa0d91; line-height: 26px;\">let</span>&nbsp;observer&nbsp;=&nbsp;<span class=\"hljs-keyword\" style=\"color: #aa0d91; line-height: 26px;\">new</span>&nbsp;IntersectionObserver(<span class=\"hljs-function\" style=\"line-height: 26px;\">(<span class=\"hljs-params\" style=\"color: #5c2699; line-height: 26px;\">entries</span>)=&gt;</span>{<br>&nbsp;&nbsp;<span class=\"hljs-comment\" style=\"color: #007400; line-height: 26px;\">//&nbsp;entries是所有被监听对象的集合</span><br>&nbsp;&nbsp;entries.forEach(<span class=\"hljs-function\" style=\"line-height: 26px;\"><span class=\"hljs-params\" style=\"color: #5c2699; line-height: 26px;\">entry</span>&nbsp;=&gt;</span>{<br>&nbsp;&nbsp;&nbsp;&nbsp;<span class=\"hljs-keyword\" style=\"color: #aa0d91; line-height: 26px;\">if</span>(entry.isIntersecting&nbsp;||&nbsp;entry.intersectionRatio&gt;<span class=\"hljs-number\" style=\"color: #1c00cf; line-height: 26px;\">0</span>){<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class=\"hljs-comment\" style=\"color: #007400; line-height: 26px;\">//&nbsp;当被监听元素到临界值且未加载图片时触发。</span><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;!entry.target.isLoaded&nbsp;&nbsp;&amp;&amp;&nbsp;showImage(entry.target,entry.target.data_src)<br>&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;})<br>})<br><span class=\"hljs-function\" style=\"line-height: 26px;\"><span class=\"hljs-keyword\" style=\"color: #aa0d91; line-height: 26px;\">function</span>&nbsp;<span class=\"hljs-title\" style=\"color: #1c00cf; line-height: 26px;\">showImage</span>(<span class=\"hljs-params\" style=\"color: #5c2699; line-height: 26px;\">el,imgSrc</span>)</span>{<br>&nbsp;&nbsp;<span class=\"hljs-keyword\" style=\"color: #aa0d91; line-height: 26px;\">const</span>&nbsp;img&nbsp;=&nbsp;<span class=\"hljs-keyword\" style=\"color: #aa0d91; line-height: 26px;\">new</span>&nbsp;Image();<br>&nbsp;&nbsp;img.src&nbsp;=&nbsp;imgSrc;<br>&nbsp;&nbsp;img.onload&nbsp;=&nbsp;<span class=\"hljs-function\" style=\"line-height: 26px;\"><span class=\"hljs-params\" style=\"color: #5c2699; line-height: 26px;\">()</span>=&gt;</span>{<br>&nbsp;&nbsp;&nbsp;&nbsp;el.src&nbsp;=&nbsp;imgSrc;<br>&nbsp;&nbsp;&nbsp;&nbsp;el.isLoaded&nbsp;=&nbsp;<span class=\"hljs-literal\" style=\"color: #aa0d91; line-height: 26px;\">true</span>;<br>&nbsp;&nbsp;}<br>}<br><span class=\"hljs-keyword\" style=\"color: #aa0d91; line-height: 26px;\">export</span>&nbsp;<span class=\"hljs-keyword\" style=\"color: #aa0d91; line-height: 26px;\">default</span>&nbsp;{<br>&nbsp;&nbsp;<span class=\"hljs-comment\" style=\"color: #007400; line-height: 26px;\">//&nbsp;这里用inserted和bind都行，因为IntersectionObserver时异步的，以防意外还是用inserted好一点</span><br>&nbsp;&nbsp;<span class=\"hljs-comment\" style=\"color: #007400; line-height: 26px;\">//&nbsp;inserted和bind的区别在于inserted时元素已经插入页面，能够直接获取到dom元素的位置信息。</span><br>&nbsp;&nbsp;inserted(el,binding,vnode)&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;clearTimeout(timer)<br>&nbsp;&nbsp;&nbsp;&nbsp;<span class=\"hljs-comment\" style=\"color: #007400; line-height: 26px;\">//&nbsp;初始化时展示默认图片</span><br>&nbsp;&nbsp;&nbsp;&nbsp;el.src&nbsp;=&nbsp;baseImg;<br>&nbsp;&nbsp;&nbsp;&nbsp;<span class=\"hljs-comment\" style=\"color: #007400; line-height: 26px;\">//&nbsp;将需要加载的图片地址绑定在dom上</span><br>&nbsp;&nbsp;&nbsp;&nbsp;el.data_src&nbsp;=&nbsp;binding.value;<br>&nbsp;&nbsp;&nbsp;&nbsp;observer.observe(el)<br><br>&nbsp;&nbsp;&nbsp;&nbsp;<span class=\"hljs-comment\" style=\"color: #007400; line-height: 26px;\">//&nbsp;防抖，这里在组件卸载的时候停止监听</span><br>&nbsp;&nbsp;&nbsp;&nbsp;<span class=\"hljs-keyword\" style=\"color: #aa0d91; line-height: 26px;\">const</span>&nbsp;vm&nbsp;=&nbsp;vnode.context;<br>&nbsp;&nbsp;&nbsp;&nbsp;timer&nbsp;=&nbsp;setTimeout(<span class=\"hljs-function\" style=\"line-height: 26px;\"><span class=\"hljs-params\" style=\"color: #5c2699; line-height: 26px;\">()</span>&nbsp;=&gt;</span>&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;vm.$on(<span class=\"hljs-string\" style=\"color: #c41a16; line-height: 26px;\">'hook:beforeDestroy'</span>,&nbsp;()&nbsp;=&gt;&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;observer.disconnect();<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;})<br>&nbsp;&nbsp;&nbsp;&nbsp;},&nbsp;<span class=\"hljs-number\" style=\"color: #1c00cf; line-height: 26px;\">20</span>);<br>&nbsp;&nbsp;},<br>&nbsp;&nbsp;<span class=\"hljs-comment\" style=\"color: #007400; line-height: 26px;\">//&nbsp;图片更新触发</span><br>&nbsp;&nbsp;update(el,binding){<br>&nbsp;&nbsp;&nbsp;&nbsp;el.isLoaded&nbsp;=&nbsp;<span class=\"hljs-literal\" style=\"color: #aa0d91; line-height: 26px;\">false</span>;<br>&nbsp;&nbsp;&nbsp;&nbsp;el.data_src&nbsp;=&nbsp;binding.value;<br>&nbsp;&nbsp;},<br>&nbsp;&nbsp;<span class=\"hljs-comment\" style=\"color: #007400; line-height: 26px;\">//&nbsp;unbind不太好，会执行多次，改进一下用组件的beforeDestroy卸载</span><br>&nbsp;&nbsp;<span class=\"hljs-comment\" style=\"color: #007400; line-height: 26px;\">//&nbsp;unbind(){</span><br>&nbsp;&nbsp;<span class=\"hljs-comment\" style=\"color: #007400; line-height: 26px;\">//&nbsp;&nbsp;&nbsp;//&nbsp;停止监听</span><br>&nbsp;&nbsp;<span class=\"hljs-comment\" style=\"color: #007400; line-height: 26px;\">//&nbsp;&nbsp;&nbsp;observer.disconnect();</span><br>&nbsp;&nbsp;<span class=\"hljs-comment\" style=\"color: #007400; line-height: 26px;\">//&nbsp;}</span><br>}<br></code></pre>\n<p data-tool=\"mdnice编辑器\" style=\"font-size: 16px; padding-top: 8px; padding-bottom: 8px; margin: 0; line-height: 26px; color: black;\"><strong style=\"font-weight: bold; color: black;\">在main.js中使用,注册全局指令</strong></p>\n<blockquote data-tool=\"mdnice编辑器\" style=\"display: block; font-size: 0.9em; overflow: auto; overflow-scrolling: touch; border-left: 3px solid rgba(0, 0, 0, 0.4); color: #6a737d; padding-top: 10px; padding-bottom: 10px; padding-left: 20px; padding-right: 10px; margin-bottom: 20px; margin-top: 20px; border-left-color: rgb(239, 112, 96); background: #fff9f9;\">\n<p style=\"font-size: 16px; padding-top: 8px; padding-bottom: 8px; margin: 0px; color: black; line-height: 26px;\">main.js</p>\n</blockquote>\n<pre class=\"custom\" data-tool=\"mdnice编辑器\" style=\"margin-top: 10px; margin-bottom: 10px; border-radius: 5px; box-shadow: rgba(0, 0, 0, 0.55) 0px 2px 10px;\"><span style=\"display: block; background: url(https://my-wechat.mdnice.com/point.png); height: 30px; width: 100%; background-size: 40px; background-repeat: no-repeat; background-color: #fff; margin-bottom: -7px; border-radius: 5px; background-position: 10px 10px;\"></span><code class=\"hljs\" style=\"overflow-x: auto; padding: 16px; color: black; display: -webkit-box; font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; font-size: 12px; -webkit-overflow-scrolling: touch; padding-top: 15px; background: #fff; border-radius: 5px;\"><span class=\"hljs-keyword\" style=\"color: #aa0d91; line-height: 26px;\">import</span>&nbsp;imgLazy&nbsp;<span class=\"hljs-keyword\" style=\"color: #aa0d91; line-height: 26px;\">from</span>&nbsp;<span class=\"hljs-string\" style=\"color: #c41a16; line-height: 26px;\">'@/directive/imgLazy.js'</span><br>Vue.directive(<span class=\"hljs-string\" style=\"color: #c41a16; line-height: 26px;\">'imgLazy'</span>,&nbsp;imgLazy)<br></code></pre>\n<p data-tool=\"mdnice编辑器\" style=\"font-size: 16px; padding-top: 8px; padding-bottom: 8px; margin: 0; line-height: 26px; color: black;\"><strong style=\"font-weight: bold; color: black;\">在组件中定义directives使用，给当前组件注册指令</strong></p>\n<pre class=\"custom\" data-tool=\"mdnice编辑器\" style=\"margin-top: 10px; margin-bottom: 10px; border-radius: 5px; box-shadow: rgba(0, 0, 0, 0.55) 0px 2px 10px;\"><span style=\"display: block; background: url(https://my-wechat.mdnice.com/point.png); height: 30px; width: 100%; background-size: 40px; background-repeat: no-repeat; background-color: #fff; margin-bottom: -7px; border-radius: 5px; background-position: 10px 10px;\"></span><code class=\"hljs\" style=\"overflow-x: auto; padding: 16px; color: black; display: -webkit-box; font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; font-size: 12px; -webkit-overflow-scrolling: touch; padding-top: 15px; background: #fff; border-radius: 5px;\"><span class=\"hljs-keyword\" style=\"color: #aa0d91; line-height: 26px;\">import</span>&nbsp;imgLazy&nbsp;<span class=\"hljs-keyword\" style=\"color: #aa0d91; line-height: 26px;\">from</span>&nbsp;<span class=\"hljs-string\" style=\"color: #c41a16; line-height: 26px;\">'@/directive/imgLazy.js'</span><br><span class=\"hljs-keyword\" style=\"color: #aa0d91; line-height: 26px;\">export</span>&nbsp;<span class=\"hljs-keyword\" style=\"color: #aa0d91; line-height: 26px;\">default</span>&nbsp;{<br>&nbsp;&nbsp;<span class=\"hljs-comment\" style=\"color: #007400; line-height: 26px;\">//&nbsp;...</span><br>&nbsp;&nbsp;directives:&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;<span class=\"hljs-attr\" style=\"color: #836C28; line-height: 26px;\">imgLazy</span>:&nbsp;imgLazy,<br>&nbsp;&nbsp;},<br>}<br></code></pre>\n<p data-tool=\"mdnice编辑器\" style=\"font-size: 16px; padding-top: 8px; padding-bottom: 8px; margin: 0; line-height: 26px; color: black;\"><strong style=\"font-weight: bold; color: black;\">组件中使用</strong></p>\n<pre class=\"custom\" data-tool=\"mdnice编辑器\" style=\"margin-top: 10px; margin-bottom: 10px; border-radius: 5px; box-shadow: rgba(0, 0, 0, 0.55) 0px 2px 10px;\"><span style=\"display: block; background: url(https://my-wechat.mdnice.com/point.png); height: 30px; width: 100%; background-size: 40px; background-repeat: no-repeat; background-color: #fff; margin-bottom: -7px; border-radius: 5px; background-position: 10px 10px;\"></span><code class=\"hljs\" style=\"overflow-x: auto; padding: 16px; color: black; display: -webkit-box; font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; font-size: 12px; -webkit-overflow-scrolling: touch; padding-top: 15px; background: #fff; border-radius: 5px;\"><span class=\"hljs-tag\" style=\"color: #aa0d91; line-height: 26px;\">&lt;<span class=\"hljs-name\" style=\"color: #aa0d91; line-height: 26px;\">template</span>&gt;</span><br>&nbsp;&nbsp;<span class=\"hljs-tag\" style=\"color: #aa0d91; line-height: 26px;\">&lt;<span class=\"hljs-name\" style=\"color: #aa0d91; line-height: 26px;\">div</span>&nbsp;<span class=\"hljs-attr\" style=\"color: #836C28; line-height: 26px;\">class</span>=<span class=\"hljs-string\" style=\"color: #c41a16; line-height: 26px;\">'container'</span>&gt;</span><br>&nbsp;&nbsp;&nbsp;&nbsp;<span class=\"hljs-tag\" style=\"color: #aa0d91; line-height: 26px;\">&lt;<span class=\"hljs-name\" style=\"color: #aa0d91; line-height: 26px;\">div</span>&nbsp;<span class=\"hljs-attr\" style=\"color: #836C28; line-height: 26px;\">v-for</span>=<span class=\"hljs-string\" style=\"color: #c41a16; line-height: 26px;\">\"(item,index)&nbsp;in&nbsp;imgSrc\"</span>&nbsp;<span class=\"hljs-attr\" style=\"color: #836C28; line-height: 26px;\">:key</span>=<span class=\"hljs-string\" style=\"color: #c41a16; line-height: 26px;\">\"index\"</span>&nbsp;&gt;</span><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class=\"hljs-tag\" style=\"color: #aa0d91; line-height: 26px;\">&lt;<span class=\"hljs-name\" style=\"color: #aa0d91; line-height: 26px;\">img</span>&nbsp;<span class=\"hljs-attr\" style=\"color: #836C28; line-height: 26px;\">v-imgLazy</span>=<span class=\"hljs-string\" style=\"color: #c41a16; line-height: 26px;\">\"item\"</span>&nbsp;&gt;</span><br>&nbsp;&nbsp;&nbsp;&nbsp;<span class=\"hljs-tag\" style=\"color: #aa0d91; line-height: 26px;\">&lt;/<span class=\"hljs-name\" style=\"color: #aa0d91; line-height: 26px;\">div</span>&gt;</span><br>&nbsp;&nbsp;<span class=\"hljs-tag\" style=\"color: #aa0d91; line-height: 26px;\">&lt;/<span class=\"hljs-name\" style=\"color: #aa0d91; line-height: 26px;\">div</span>&gt;</span><br><span class=\"hljs-tag\" style=\"color: #aa0d91; line-height: 26px;\">&lt;/<span class=\"hljs-name\" style=\"color: #aa0d91; line-height: 26px;\">template</span>&gt;</span><br><br><span class=\"hljs-tag\" style=\"color: #aa0d91; line-height: 26px;\">&lt;<span class=\"hljs-name\" style=\"color: #aa0d91; line-height: 26px;\">script</span>&gt;</span><span class=\"javascript\" style=\"line-height: 26px;\"><br><span class=\"hljs-keyword\" style=\"color: #aa0d91; line-height: 26px;\">import</span>&nbsp;imgLazy&nbsp;<span class=\"hljs-keyword\" style=\"color: #aa0d91; line-height: 26px;\">from</span>&nbsp;<span class=\"hljs-string\" style=\"color: #c41a16; line-height: 26px;\">'@/directive/imgLazy.js'</span><br><span class=\"hljs-keyword\" style=\"color: #aa0d91; line-height: 26px;\">export</span>&nbsp;<span class=\"hljs-keyword\" style=\"color: #aa0d91; line-height: 26px;\">default</span>&nbsp;{<br>&nbsp;&nbsp;<span class=\"hljs-attr\" style=\"color: #836C28; line-height: 26px;\">directives</span>:&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;<span class=\"hljs-attr\" style=\"color: #836C28; line-height: 26px;\">imgLazy</span>:&nbsp;imgLazy,<br>&nbsp;&nbsp;},<br>&nbsp;&nbsp;data(){<br>&nbsp;&nbsp;&nbsp;&nbsp;<span class=\"hljs-keyword\" style=\"color: #aa0d91; line-height: 26px;\">return</span>&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class=\"hljs-attr\" style=\"color: #836C28; line-height: 26px;\">imgSrc</span>:[<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class=\"hljs-string\" style=\"color: #c41a16; line-height: 26px;\">\"https://dss1.bdstatic.com/70cFvXSh_Q1YnxGkpoWK1HF6hhy/it/u=1091405991,859863778&amp;fm=26&amp;gp=0.jpg\"</span>,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class=\"hljs-string\" style=\"color: #c41a16; line-height: 26px;\">\"https://dss1.bdstatic.com/70cFvXSh_Q1YnxGkpoWK1HF6hhy/it/u=2396395246,715775841&amp;fm=26&amp;gp=0.jpg\"</span>,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class=\"hljs-string\" style=\"color: #c41a16; line-height: 26px;\">\"https://dss1.bdstatic.com/70cFuXSh_Q1YnxGkpoWK1HF6hhy/it/u=224866248,765861809&amp;fm=26&amp;gp=0.jpg\"</span>,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class=\"hljs-string\" style=\"color: #c41a16; line-height: 26px;\">\"https://dss0.bdstatic.com/70cFuHSh_Q1YnxGkpoWK1HF6hhy/it/u=2670715487,1547868437&amp;fm=26&amp;gp=0.jpg\"</span>,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class=\"hljs-string\" style=\"color: #c41a16; line-height: 26px;\">\"https://dss3.bdstatic.com/70cFv8Sh_Q1YnxGkpoWK1HF6hhy/it/u=2988957523,3295751190&amp;fm=26&amp;gp=0.jpg\"</span>,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class=\"hljs-string\" style=\"color: #c41a16; line-height: 26px;\">\"https://dss2.bdstatic.com/70cFvnSh_Q1YnxGkpoWK1HF6hhy/it/u=2698110318,782174384&amp;fm=26&amp;gp=0.jpg\"</span>,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class=\"hljs-string\" style=\"color: #c41a16; line-height: 26px;\">\"https://dss1.bdstatic.com/70cFuXSh_Q1YnxGkpoWK1HF6hhy/it/u=1102788601,953675482&amp;fm=26&amp;gp=0.jpg\"</span>,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class=\"hljs-string\" style=\"color: #c41a16; line-height: 26px;\">\"https://dss1.bdstatic.com/70cFvXSh_Q1YnxGkpoWK1HF6hhy/it/u=1091405991,859863778&amp;fm=26&amp;gp=0.jpg\"</span>,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class=\"hljs-string\" style=\"color: #c41a16; line-height: 26px;\">\"https://dss1.bdstatic.com/70cFvXSh_Q1YnxGkpoWK1HF6hhy/it/u=2396395246,715775841&amp;fm=26&amp;gp=0.jpg\"</span>,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class=\"hljs-string\" style=\"color: #c41a16; line-height: 26px;\">\"https://dss1.bdstatic.com/70cFuXSh_Q1YnxGkpoWK1HF6hhy/it/u=224866248,765861809&amp;fm=26&amp;gp=0.jpg\"</span>,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class=\"hljs-string\" style=\"color: #c41a16; line-height: 26px;\">\"https://dss0.bdstatic.com/70cFuHSh_Q1YnxGkpoWK1HF6hhy/it/u=2670715487,1547868437&amp;fm=26&amp;gp=0.jpg\"</span>,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class=\"hljs-string\" style=\"color: #c41a16; line-height: 26px;\">\"https://dss3.bdstatic.com/70cFv8Sh_Q1YnxGkpoWK1HF6hhy/it/u=2988957523,3295751190&amp;fm=26&amp;gp=0.jpg\"</span>,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class=\"hljs-string\" style=\"color: #c41a16; line-height: 26px;\">\"https://dss2.bdstatic.com/70cFvnSh_Q1YnxGkpoWK1HF6hhy/it/u=2698110318,782174384&amp;fm=26&amp;gp=0.jpg\"</span>,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class=\"hljs-string\" style=\"color: #c41a16; line-height: 26px;\">\"https://dss1.bdstatic.com/70cFuXSh_Q1YnxGkpoWK1HF6hhy/it/u=1102788601,953675482&amp;fm=26&amp;gp=0.jpg\"</span>,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class=\"hljs-string\" style=\"color: #c41a16; line-height: 26px;\">\"https://ss1.bdstatic.com/70cFuXSh_Q1YnxGkpoWK1HF6hhy/it/u=2004055534,3969071219&amp;fm=26&amp;gp=0.jpg\"</span>,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;]<br>&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;}<br>}<br></span><span class=\"hljs-tag\" style=\"color: #aa0d91; line-height: 26px;\">&lt;/<span class=\"hljs-name\" style=\"color: #aa0d91; line-height: 26px;\">script</span>&gt;</span><br><br><span class=\"hljs-tag\" style=\"color: #aa0d91; line-height: 26px;\">&lt;<span class=\"hljs-name\" style=\"color: #aa0d91; line-height: 26px;\">style</span>&nbsp;<span class=\"hljs-attr\" style=\"color: #836C28; line-height: 26px;\">lang</span>=<span class=\"hljs-string\" style=\"color: #c41a16; line-height: 26px;\">\"scss\"</span>&nbsp;<span class=\"hljs-attr\" style=\"color: #836C28; line-height: 26px;\">scoped</span>&gt;</span><span class=\"css\" style=\"line-height: 26px;\"><br><span class=\"hljs-selector-tag\" style=\"color: #aa0d91; line-height: 26px;\">img</span>{<br>&nbsp;&nbsp;<span class=\"hljs-attribute\" style=\"color: #aa0d91; line-height: 26px;\">width</span>:&nbsp;<span class=\"hljs-number\" style=\"color: #1c00cf; line-height: 26px;\">200px</span>;<br>&nbsp;&nbsp;<span class=\"hljs-attribute\" style=\"color: #aa0d91; line-height: 26px;\">height</span>:&nbsp;<span class=\"hljs-number\" style=\"color: #1c00cf; line-height: 26px;\">200px</span>;<br>}<br></span><span class=\"hljs-tag\" style=\"color: #aa0d91; line-height: 26px;\">&lt;/<span class=\"hljs-name\" style=\"color: #aa0d91; line-height: 26px;\">style</span>&gt;</span><br><br></code></pre>\n<p data-tool=\"mdnice编辑器\" style=\"font-size: 16px; padding-top: 8px; padding-bottom: 8px; margin: 0; line-height: 26px; color: black;\">具体的效果如下：\n<img src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d3732f4bb6024a90b4146a12b45a6869~tplv-k3u1fbpfcp-zoom-1.image\" alt style=\"display: block; margin: 0 auto; max-width: 100%;\"></p>\n<h2 data-tool=\"mdnice编辑器\" style=\"margin-top: 30px; margin-bottom: 15px; padding: 0px; font-weight: bold; color: black; border-bottom: 2px solid rgb(239, 112, 96); font-size: 1.3em;\"><span class=\"prefix\" style=\"display: none;\"></span><span class=\"content\" style=\"display: inline-block; font-weight: bold; background: rgb(239, 112, 96); color: #ffffff; padding: 3px 10px 1px; border-top-right-radius: 3px; border-top-left-radius: 3px; margin-right: 3px;\">IntersectionObserver兼容性</span><span class=\"suffix\"></span><span style=\"display: inline-block; vertical-align: bottom; border-bottom: 36px solid #efebe9; border-right: 20px solid transparent;\"> </span></h2>\n<figure data-tool=\"mdnice编辑器\" style=\"margin: 0; margin-top: 10px; margin-bottom: 10px; display: flex; flex-direction: column; justify-content: center; align-items: center;\"><img src=\"https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/cad186d8d21247d382bebf43fd55a006~tplv-k3u1fbpfcp-zoom-1.image\" alt style=\"display: block; margin: 0 auto; max-width: 100%;\"></figure>\n<p data-tool=\"mdnice编辑器\" style=\"font-size: 16px; padding-top: 8px; padding-bottom: 8px; margin: 0; line-height: 26px; color: black;\">IntersectionObserver API 的兼容性方面基本上除了ie都兼容，所以说你如果想要在ie上实现懒加载就只能自己计算每一个元素了。我在之前一篇文章中介绍mixin的时候有写过懒加载，可以提供参考。</p>\n<p data-tool=\"mdnice编辑器\" style=\"font-size: 16px; padding-top: 8px; padding-bottom: 8px; margin: 0; line-height: 26px; color: black;\"><strong style=\"font-weight: bold; color: black;\">万恶的IE</strong></p>\n<p data-tool=\"mdnice编辑器\" style=\"font-size: 16px; padding-top: 8px; padding-bottom: 8px; margin: 0; line-height: 26px; color: black;\"><strong style=\"font-weight: bold; color: black;\">往期文章：</strong></p>\n<p data-tool=\"mdnice编辑器\" style=\"font-size: 16px; padding-top: 8px; padding-bottom: 8px; margin: 0; line-height: 26px; color: black;\"><a href=\"https://juejin.im/post/6856980221816799245\" style=\"text-decoration: none; word-wrap: break-word; font-weight: bold; color: rgb(239, 112, 96); border-bottom: 1px solid rgb(239, 112, 96);\">手把手教你使用Vue指令，亲手实现一个新闻标记和运动动画指令</a></p>\n<p data-tool=\"mdnice编辑器\" style=\"font-size: 16px; padding-top: 8px; padding-bottom: 8px; margin: 0; line-height: 26px; color: black;\"><a href=\"https://juejin.im/post/6856232743286767624\" style=\"text-decoration: none; word-wrap: break-word; font-weight: bold; color: rgb(239, 112, 96); border-bottom: 1px solid rgb(239, 112, 96);\">Vue的混入(mixin)知多少？如何用mixin实现一个图片懒加载功能</a></p>\n<p data-tool=\"mdnice编辑器\" style=\"font-size: 16px; padding-top: 8px; padding-bottom: 8px; margin: 0; line-height: 26px; color: black;\">以上的的代码已经统一整理到<a href=\"https://gitee.com/yonggecode/vue_directive\" style=\"text-decoration: none; word-wrap: break-word; font-weight: bold; color: rgb(239, 112, 96); border-bottom: 1px solid rgb(239, 112, 96);\">gitee仓库</a></p>\n</section>", "user_name": "YongCode", "description": "默默伐木，在线求职", "got_view_count": 13351, "category_name": "前端", "ctime": 1457483942}
{"tag_name": "程序员", "concern_user_count": 238890, "user_id": "3122268753634541", "title": "阿里实习 90 天：从实习生的视角谈谈个人成长", "mark_content": "<section id=\"nice\" data-tool=\"mdnice编辑器\" data-website=\"https://www.mdnice.com\" style=\"font-size: 16px; padding: 0 10px; word-spacing: 0px; word-break: break-word; word-wrap: break-word; text-align: left; line-height: 1.25; color: #2b2b2b; font-family: Optima-Regular, Optima, PingFangTC-Light, PingFangSC-light, PingFangTC-light; letter-spacing: 2px; background-image: linear-gradient(90deg, rgba(50, 0, 0, 0.04) 3%, rgba(0, 0, 0, 0) 3%), linear-gradient(360deg, rgba(50, 0, 0, 0.04) 3%, rgba(0, 0, 0, 0) 3%); background-size: 20px 20px; background-position: center center;\"><h2 data-tool=\"mdnice编辑器\" style=\"margin-top: 30px; margin-bottom: 15px; padding: 0px; font-weight: bold; color: black; font-size: 22px; display: block; border-bottom: 4px solid #40B8FA;\"><span class=\"prefix\" style=\"display: flex; width: 20px; height: 20px; background-size: 20px 20px; background-image: url(https://files.mdnice.com/fullstack-1.png); margin-bottom: -22px;\"></span><span class=\"content\" style=\"display: flex; color: #40B8FA; font-size: 20px; margin-left: 25px;\">前言</span><span class=\"suffix\" style=\"display: flex; box-sizing: border-box; width: 200px; height: 10px; border-top-left-radius: 20px; background: RGBA(64, 184, 250, .5); color: rgb(255, 255, 255); font-size: 16px; letter-spacing: 0.544px; justify-content: flex-end; float: right; margin-top: -10px; box-sizing: border-box !important; overflow-wrap: break-word !important;\"></span></h2>\n<figure data-tool=\"mdnice编辑器\" style=\"margin: 0; margin-top: 10px; margin-bottom: 10px; display: flex; flex-direction: column; justify-content: center; align-items: center;\"><img src=\"http://cdn.jack-wjq.cn/90%20%E5%A4%A9%E7%BA%AA%E5%BF%B5.png\" alt=\"90 天留念\" style=\"max-width: 100%; border-radius: 6px; display: block; margin: 20px auto; object-fit: contain; box-shadow: 2px 4px 7px #999;\"><figcaption style=\"margin-top: 5px; text-align: center; display: block; font-size: 13px; color: #2b2b2b;\"><span style=\"background-image: url(https://img.alicdn.com/tfs/TB1Yycwyrj1gK0jSZFuXXcrHpXa-32-32.png); display: inline-block; width: 18px; height: 18px; background-size: 18px; background-repeat: no-repeat; background-position: center; margin-right: 5px; margin-bottom: -5px;\"></span>90 天留念</figcaption></figure>\n<p data-tool=\"mdnice编辑器\" style=\"padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: #2b2b2b; margin: 10px 0px; letter-spacing: 2px; font-size: 14px; word-spacing: 2px;\">今天是我到阿里实习的第 90 天了，最近也拜读了不少前辈的文章，尤其是 <a href=\"https://juejin.im/user/4212984287594775\" style=\"text-decoration: none; word-wrap: break-word; color: #40B8FA; font-weight: normal; border-bottom: 1px solid #3BAAFA;\">@于江水</a> 前辈的文章更是让我有种醍醐灌顶的感觉。</p>\n<p data-tool=\"mdnice编辑器\" style=\"padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: #2b2b2b; margin: 10px 0px; letter-spacing: 2px; font-size: 14px; word-spacing: 2px;\">回顾这 90 天的成长，感慨良多，在这里和大家做一下分享，也从实习生的视角，尤其是本科毕业就参加工作的同学的视角，谈谈个人应该如何成长。</p>\n<h2 data-tool=\"mdnice编辑器\" style=\"margin-top: 30px; margin-bottom: 15px; padding: 0px; font-weight: bold; color: black; font-size: 22px; display: block; border-bottom: 4px solid #40B8FA;\"><span class=\"prefix\" style=\"display: flex; width: 20px; height: 20px; background-size: 20px 20px; background-image: url(https://files.mdnice.com/fullstack-1.png); margin-bottom: -22px;\"></span><span class=\"content\" style=\"display: flex; color: #40B8FA; font-size: 20px; margin-left: 25px;\">缘起</span><span class=\"suffix\" style=\"display: flex; box-sizing: border-box; width: 200px; height: 10px; border-top-left-radius: 20px; background: RGBA(64, 184, 250, .5); color: rgb(255, 255, 255); font-size: 16px; letter-spacing: 0.544px; justify-content: flex-end; float: right; margin-top: -10px; box-sizing: border-box !important; overflow-wrap: break-word !important;\"></span></h2>\n<p data-tool=\"mdnice编辑器\" style=\"padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: #2b2b2b; margin: 10px 0px; letter-spacing: 2px; font-size: 14px; word-spacing: 2px;\">2020 年，一场疫情让这个原本平平无奇的年份，变得特殊。新型冠状病毒肺炎席卷了全国，蔓延至全球。</p>\n<p data-tool=\"mdnice编辑器\" style=\"padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: #2b2b2b; margin: 10px 0px; letter-spacing: 2px; font-size: 14px; word-spacing: 2px;\">在这个特殊的一年，我也走到了大三下学期该找实习的时候了。<strong style=\"color: #3594F7; font-weight: bold;\"><span>「</span>曾经梦想自己能够进入大厂，在自己喜欢的城市、喜欢的公司，做自己喜欢的工作。<span>」</span></strong></p>\n<p data-tool=\"mdnice编辑器\" style=\"padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: #2b2b2b; margin: 10px 0px; letter-spacing: 2px; font-size: 14px; word-spacing: 2px;\">在 2 月份的时候，因为疫情的原因，我的老东家出台了疫情期间工作的政策，实习生 2 月份统一不参与办公。于是 2 月份得闲，开始准备复习一些基础知识，春招试一试大厂们。</p>\n<p data-tool=\"mdnice编辑器\" style=\"padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: #2b2b2b; margin: 10px 0px; letter-spacing: 2px; font-size: 14px; word-spacing: 2px;\">无意间逛牛客的时候看到了一个小姐姐发了帖子，说找一起复盘面试找实习的小伙伴，于是就扫码加入了群聊，与她们成为了朋友。</p>\n<p data-tool=\"mdnice编辑器\" style=\"padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: #2b2b2b; margin: 10px 0px; letter-spacing: 2px; font-size: 14px; word-spacing: 2px;\"><strong style=\"color: #3594F7; font-weight: bold;\"><span>「</span>从一开始的不认识，到慢慢熟悉，再到最后大家一起朝着一个目标努力，这种感觉我好像很久都没有体会过了。<span>」</span></strong></p>\n<p data-tool=\"mdnice编辑器\" style=\"padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: #2b2b2b; margin: 10px 0px; letter-spacing: 2px; font-size: 14px; word-spacing: 2px;\"><strong style=\"color: #3594F7; font-weight: bold;\"><span>「</span>上一次有这种并肩作战的感觉，好像只有三年前的高考了。<span>」</span></strong></p>\n<p data-tool=\"mdnice编辑器\" style=\"padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: #2b2b2b; margin: 10px 0px; letter-spacing: 2px; font-size: 14px; word-spacing: 2px;\">逛牛客的同时，还看到了<strong style=\"color: #3594F7; font-weight: bold;\"><span>「</span>淘系<span>」</span></strong>的实习生招聘贴，于是抱着试一试的心态，加了师兄的微信，小心翼翼地整理了自己的简历，发送给了师兄。</p>\n<p data-tool=\"mdnice编辑器\" style=\"padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: #2b2b2b; margin: 10px 0px; letter-spacing: 2px; font-size: 14px; word-spacing: 2px;\">然后我想起来自己还有一个校友 <a href=\"https://juejin.im/user/3210229686482942\" style=\"text-decoration: none; word-wrap: break-word; color: #40B8FA; font-weight: normal; border-bottom: 1px solid #3BAAFA;\">@渊辰</a>，认识很久了，知道他技术还不错，就把师兄也推荐给了他。</p>\n<p data-tool=\"mdnice编辑器\" style=\"padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: #2b2b2b; margin: 10px 0px; letter-spacing: 2px; font-size: 14px; word-spacing: 2px;\">没多久，就收到了提前批的简历初筛，面试官是一个非常和善的师兄，聊天的过程中问了一些基础知识，同时还聊了一些个人的情况和未来的规划，非常亲切，体验非常棒。</p>\n<p data-tool=\"mdnice编辑器\" style=\"padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: #2b2b2b; margin: 10px 0px; letter-spacing: 2px; font-size: 14px; word-spacing: 2px;\">当时暗自下决心，我一定要努力加入<strong style=\"color: #3594F7; font-weight: bold;\"><span>「</span>淘系<span>」</span></strong>，加入这个<strong style=\"color: #3594F7; font-weight: bold;\"><span>「</span>东半球最强的前端团队<span>」</span></strong>。</p>\n<p data-tool=\"mdnice编辑器\" style=\"padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: #2b2b2b; margin: 10px 0px; letter-spacing: 2px; font-size: 14px; word-spacing: 2px;\">后来非常幸运地收到了简历初筛通过的消息，通过了简历初筛的同学被统一拉到了一个群里，这时我惊喜地发现，我的校友 <a href=\"https://juejin.im/user/3210229686482942\" style=\"text-decoration: none; word-wrap: break-word; color: #40B8FA; font-weight: normal; border-bottom: 1px solid #3BAAFA;\">@渊辰</a> 也在里面。</p>\n<p data-tool=\"mdnice编辑器\" style=\"padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: #2b2b2b; margin: 10px 0px; letter-spacing: 2px; font-size: 14px; word-spacing: 2px;\">当时他已经在准备考研了，我把团队的 JD 发给他，让他试试。然后他就试了试，没想到我们通过了简历初筛。</p>\n<p data-tool=\"mdnice编辑器\" style=\"padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: #2b2b2b; margin: 10px 0px; letter-spacing: 2px; font-size: 14px; word-spacing: 2px;\">有一天我在我的学长（也是我的前端启蒙老师）建的京东内购群里，看到了当时内推我的师兄，然后一问 —— 他俩早就认识。</p>\n<p data-tool=\"mdnice编辑器\" style=\"padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: #2b2b2b; margin: 10px 0px; letter-spacing: 2px; font-size: 14px; word-spacing: 2px;\"><strong style=\"color: #3594F7; font-weight: bold;\"><span>「</span>缘，妙不可言<span>」</span></strong>。</p>\n<h2 data-tool=\"mdnice编辑器\" style=\"margin-top: 30px; margin-bottom: 15px; padding: 0px; font-weight: bold; color: black; font-size: 22px; display: block; border-bottom: 4px solid #40B8FA;\"><span class=\"prefix\" style=\"display: flex; width: 20px; height: 20px; background-size: 20px 20px; background-image: url(https://files.mdnice.com/fullstack-1.png); margin-bottom: -22px;\"></span><span class=\"content\" style=\"display: flex; color: #40B8FA; font-size: 20px; margin-left: 25px;\">缘聚</span><span class=\"suffix\" style=\"display: flex; box-sizing: border-box; width: 200px; height: 10px; border-top-left-radius: 20px; background: RGBA(64, 184, 250, .5); color: rgb(255, 255, 255); font-size: 16px; letter-spacing: 0.544px; justify-content: flex-end; float: right; margin-top: -10px; box-sizing: border-box !important; overflow-wrap: break-word !important;\"></span></h2>\n<p data-tool=\"mdnice编辑器\" style=\"padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: #2b2b2b; margin: 10px 0px; letter-spacing: 2px; font-size: 14px; word-spacing: 2px;\">再后来的几轮面试之中，得到了我的师兄，也是现在我的老板的一些指导，整理自己的实习和项目经历：从项目背景、技术方案、重难点以及解决办法和沉淀到项目成果，将自己的每一个项目整理成一个完整的闭环，最后通过了二面三面，走到了交叉面。</p>\n<p data-tool=\"mdnice编辑器\" style=\"padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: #2b2b2b; margin: 10px 0px; letter-spacing: 2px; font-size: 14px; word-spacing: 2px;\">交叉面的面试官是菜鸟的师兄，聊了很多人生规划、前端未来趋势的看法，还有一些项目过程中实际使用过的性能优化方案，非常愉快的面试过程，面试结束的时候面试官还说：<strong style=\"color: #3594F7; font-weight: bold;\"><span>「</span>“要是还有认识的优秀的同学记得帮我推荐到菜鸟来呀！”<span>」</span></strong></p>\n<p data-tool=\"mdnice编辑器\" style=\"padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: #2b2b2b; margin: 10px 0px; letter-spacing: 2px; font-size: 14px; word-spacing: 2px;\">在阿里的面试过程中，都是一个非常愉快的交流学习的过程，问到一些基础的问题，首先会让你能够答得出来最基础的部分，然后再逐步深挖，去探索你的深度。</p>\n<p data-tool=\"mdnice编辑器\" style=\"padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: #2b2b2b; margin: 10px 0px; letter-spacing: 2px; font-size: 14px; word-spacing: 2px;\">同时还会拓展，去探索你的广度。这样的面试方式，你永远不用担心面试官正好问到你不会的部分而没有在你擅长的领域提问，很大程度避免了运气成分。</p>\n<p data-tool=\"mdnice编辑器\" style=\"padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: #2b2b2b; margin: 10px 0px; letter-spacing: 2px; font-size: 14px; word-spacing: 2px;\">面试官还会与你交流一些对某个技术的看法，或是某项技术未来的趋势。从开始面试到最后签下意向书拿下 offer，其中的每一轮面试都是一个学习交流的过程，亦师亦友。</p>\n<p data-tool=\"mdnice编辑器\" style=\"padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: #2b2b2b; margin: 10px 0px; letter-spacing: 2px; font-size: 14px; word-spacing: 2px;\">应聘嘛，也是一个双向选择的过程，阿里的面试官给我留下了非常深刻的印象，不论是淘系，还是在投淘系之前投过的钉钉，面试官都是非常 Nice 的，于我个人而言，我非常喜欢且享受这样的面试过程。</p>\n<p data-tool=\"mdnice编辑器\" style=\"padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: #2b2b2b; margin: 10px 0px; letter-spacing: 2px; font-size: 14px; word-spacing: 2px;\">拿到意向书和 offer 之前，还有一个小插曲：老板希望我们能够尽快入职，于是给我们安排在 4 月初前往杭州，然后我们几个实习生小伙伴买好了票，各自都准备好了前往杭州，然后老板在我们出发的前一天晚上得知要公司政策目前还不能安排实习生入职，于是我们只能退票。</p>\n<p data-tool=\"mdnice编辑器\" style=\"padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: #2b2b2b; margin: 10px 0px; letter-spacing: 2px; font-size: 14px; word-spacing: 2px;\">当时我老板就说：<strong style=\"color: #3594F7; font-weight: bold;\"><span>「</span>你们退票吧，手续费多少我补给你们<span>」</span></strong>，疫情原因集团政策还没放开，估计还要等一段时间。</p>\n<p data-tool=\"mdnice编辑器\" style=\"padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: #2b2b2b; margin: 10px 0px; letter-spacing: 2px; font-size: 14px; word-spacing: 2px;\">签了意向书之后，等 offer 也等了好一段时间，老板在这过程中积极协调，不断跟 HRG 沟通，希望我们能够尽早入职。</p>\n<p data-tool=\"mdnice编辑器\" style=\"padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: #2b2b2b; margin: 10px 0px; letter-spacing: 2px; font-size: 14px; word-spacing: 2px;\">等待 offer 的这段时间，我跑去了腾讯，实习了一段时间。由于是远程办公，然后还是一些打杂的工作，做的不是很开心，后来收到了阿里的 offer 之后，就离职了。</p>\n<p data-tool=\"mdnice编辑器\" style=\"padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: #2b2b2b; margin: 10px 0px; letter-spacing: 2px; font-size: 14px; word-spacing: 2px;\">买了人生中的第一张机票，一个人提着行李箱，人生中第一次坐飞机，落地杭州。</p>\n<p data-tool=\"mdnice编辑器\" style=\"padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: #2b2b2b; margin: 10px 0px; letter-spacing: 2px; font-size: 14px; word-spacing: 2px;\">到了杭州之后因为疫情的原因，暂时只能住酒店远程办公，而且恰逢阿里日，园区内外异常热闹，无法入园的我错过了这一年一度的盛典。只能通过钉钉，看一看师兄师姐们的合照，通过直播，看一看园区里有什么热闹的活动。</p>\n<p data-tool=\"mdnice编辑器\" style=\"padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: #2b2b2b; margin: 10px 0px; letter-spacing: 2px; font-size: 14px; word-spacing: 2px;\">7 天之后，得知可以入园了，激动又兴奋的我，怀揣着自己当初进大厂的梦想，走进了这个我一直向往和憧憬的公司。</p>\n<p data-tool=\"mdnice编辑器\" style=\"padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: #2b2b2b; margin: 10px 0px; letter-spacing: 2px; font-size: 14px; word-spacing: 2px;\">6 号楼北面，一进门就看到了我们用户增长的大旗，然后就是见到了自己的老板。跟老板打了招呼之后，我被领到了我的导师，也就是我的师姐的工位，在师姐的带领下走访了各个师兄的工位，与师兄们打了招呼。</p>\n<p data-tool=\"mdnice编辑器\" style=\"padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: #2b2b2b; margin: 10px 0px; letter-spacing: 2px; font-size: 14px; word-spacing: 2px;\">我其实是一个比较腼腆的人，尤其是第一次见到的时候，会有些扭捏，并不是非常放得开。好在师兄师姐们都非常 Nice，很热情地跟我打了招呼。</p>\n<p data-tool=\"mdnice编辑器\" style=\"padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: #2b2b2b; margin: 10px 0px; letter-spacing: 2px; font-size: 14px; word-spacing: 2px;\">真正与自己未来的同事们见了面，还有一直崇拜的、Rax GitHub 仓库 Star 还没他博客 Star 的零头多的 <a href=\"https://juejin.im/user/712139234359182\" style=\"text-decoration: none; word-wrap: break-word; color: #40B8FA; font-weight: normal; border-bottom: 1px solid #3BAAFA;\">@冴羽</a> 老师（误），没见过世面的农村孩子流露出难以言表的喜悦。</p>\n<p data-tool=\"mdnice编辑器\" style=\"padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: #2b2b2b; margin: 10px 0px; letter-spacing: 2px; font-size: 14px; word-spacing: 2px;\">之后的时光，我白嫖了两三次团建，白嫖了每周两次的下午茶，团建里玩游戏拿了第一名还得到了老板赠送的阿里定制背包等等，享受了一些公司的福利（亲橙里很多店铺阿里同学优惠、杭州口腔医院阿里同学八折），也和师兄师姐们一起参与了一些业务的开发，充实且快乐~</p>\n<h2 data-tool=\"mdnice编辑器\" style=\"margin-top: 30px; margin-bottom: 15px; padding: 0px; font-weight: bold; color: black; font-size: 22px; display: block; border-bottom: 4px solid #40B8FA;\"><span class=\"prefix\" style=\"display: flex; width: 20px; height: 20px; background-size: 20px 20px; background-image: url(https://files.mdnice.com/fullstack-1.png); margin-bottom: -22px;\"></span><span class=\"content\" style=\"display: flex; color: #40B8FA; font-size: 20px; margin-left: 25px;\">成长</span><span class=\"suffix\" style=\"display: flex; box-sizing: border-box; width: 200px; height: 10px; border-top-left-radius: 20px; background: RGBA(64, 184, 250, .5); color: rgb(255, 255, 255); font-size: 16px; letter-spacing: 0.544px; justify-content: flex-end; float: right; margin-top: -10px; box-sizing: border-box !important; overflow-wrap: break-word !important;\"></span></h2>\n<p data-tool=\"mdnice编辑器\" style=\"padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: #2b2b2b; margin: 10px 0px; letter-spacing: 2px; font-size: 14px; word-spacing: 2px;\">前面是一些闲聊的内容，讲述了目前为止我与阿里的故事，这个部分就来讲讲，阿里与我的故事。</p>\n<p data-tool=\"mdnice编辑器\" style=\"padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: #2b2b2b; margin: 10px 0px; letter-spacing: 2px; font-size: 14px; word-spacing: 2px;\">对于阿里在国内的技术实力和影响力，相信应该不用我多说。阿里就像是一所大学，是一个非常广阔的平台，这里有任何你感兴趣的、领域里最前沿的一些知识供你学习，也有各个领域叫得出名字的大佬时常做一些分享。</p>\n<p data-tool=\"mdnice编辑器\" style=\"padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: #2b2b2b; margin: 10px 0px; letter-spacing: 2px; font-size: 14px; word-spacing: 2px;\"><strong style=\"color: #3594F7; font-weight: bold;\"><span>「</span>作为一名阿里的实习生，我很幸运，也很荣幸能够进入这样的一个大平台。<span>」</span></strong></p>\n<p data-tool=\"mdnice编辑器\" style=\"padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: #2b2b2b; margin: 10px 0px; letter-spacing: 2px; font-size: 14px; word-spacing: 2px;\">我说这样一句话肯定有人会说阿里味太重之类的尖酸刻薄的话。没关系，换一个立场：如果你是我，本科还没毕业就能进入一家市值接近万亿美元的公司工作，你的心情是怎样的，你是否会跟我有一样的感受。更何况是一所不知名的双非本科。</p>\n<h3 data-tool=\"mdnice编辑器\" style=\"padding: 0px; color: black; font-size: 17px; font-weight: bold; text-align: center; position: relative; margin-top: 20px; margin-bottom: 20px;\"><span class=\"prefix\" style=\"display: none;\"></span><span class=\"content\" style=\"border-bottom: 2px solid RGBA(79, 177, 249, .65); color: #2b2b2b; padding-bottom: 2px;\"><span style=\"width: 30px; height: 30px; display: block; background-image: url(https://files.mdnice.com/fullstack-2.png); background-position: center; background-size: 30px; margin: auto; opacity: 1; background-repeat: no-repeat; margin-bottom: -8px;\"></span>人际交往</span><span class=\"suffix\" style=\"display: none;\"></span></h3>\n<p data-tool=\"mdnice编辑器\" style=\"padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: #2b2b2b; margin: 10px 0px; letter-spacing: 2px; font-size: 14px; word-spacing: 2px;\">说实话，应届生多少都还带一些书生气，尤其是本科生。如何尽快地融入一个大集体，融入社会，是我最先面临的问题。</p>\n<p data-tool=\"mdnice编辑器\" style=\"padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: #2b2b2b; margin: 10px 0px; letter-spacing: 2px; font-size: 14px; word-spacing: 2px;\">大学入学，大家会通过军训的方式相互了解认识，帮助我们尽快融入集体。</p>\n<p data-tool=\"mdnice编辑器\" style=\"padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: #2b2b2b; margin: 10px 0px; letter-spacing: 2px; font-size: 14px; word-spacing: 2px;\">到了公司，大家都有自己的工作，每天都是忙碌充实的，如何相互了解认识，去建立良好的人际关系是首当其冲需要解决的问题，也是最重要的问题。</p>\n<p data-tool=\"mdnice编辑器\" style=\"padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: #2b2b2b; margin: 10px 0px; letter-spacing: 2px; font-size: 14px; word-spacing: 2px;\">于我而言，我个人的做法就是珍惜每一次表达自我的机会，无论是周会还是团建活动，有表达自我的机会就好好把握在手。</p>\n<p data-tool=\"mdnice编辑器\" style=\"padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: #2b2b2b; margin: 10px 0px; letter-spacing: 2px; font-size: 14px; word-spacing: 2px;\"><strong style=\"color: #3594F7; font-weight: bold;\"><span>「</span>只有首先对他人敞开心扉，才能让他人对你更加了解，才有迸发出火花的可能~<span>」</span></strong></p>\n<p data-tool=\"mdnice编辑器\" style=\"padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: #2b2b2b; margin: 10px 0px; letter-spacing: 2px; font-size: 14px; word-spacing: 2px;\">业余时间可以多聊聊生活，聚餐的时候多聊天，分享自己最近的了解到的奇闻乐事，抛出一个话题，就很容易聊起来。</p>\n<p data-tool=\"mdnice编辑器\" style=\"padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: #2b2b2b; margin: 10px 0px; letter-spacing: 2px; font-size: 14px; word-spacing: 2px;\">对于自己的人际交往，逐渐有了自己的方法，这点应该也算是成长中的一环吧。</p>\n<h3 data-tool=\"mdnice编辑器\" style=\"padding: 0px; color: black; font-size: 17px; font-weight: bold; text-align: center; position: relative; margin-top: 20px; margin-bottom: 20px;\"><span class=\"prefix\" style=\"display: none;\"></span><span class=\"content\" style=\"border-bottom: 2px solid RGBA(79, 177, 249, .65); color: #2b2b2b; padding-bottom: 2px;\"><span style=\"width: 30px; height: 30px; display: block; background-image: url(https://files.mdnice.com/fullstack-2.png); background-position: center; background-size: 30px; margin: auto; opacity: 1; background-repeat: no-repeat; margin-bottom: -8px;\"></span>技术能力</span><span class=\"suffix\" style=\"display: none;\"></span></h3>\n<p data-tool=\"mdnice编辑器\" style=\"padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: #2b2b2b; margin: 10px 0px; letter-spacing: 2px; font-size: 14px; word-spacing: 2px;\">刚进入一个大型的企业，相信很多同学都有一个适应技术的过程，我也一样。</p>\n<p data-tool=\"mdnice编辑器\" style=\"padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: #2b2b2b; margin: 10px 0px; letter-spacing: 2px; font-size: 14px; word-spacing: 2px;\">淘系 ToC 的业务大多数都使用的是跨平台的自研框架 <a href=\"https://rax.js.org/\" style=\"text-decoration: none; word-wrap: break-word; color: #40B8FA; font-weight: normal; border-bottom: 1px solid #3BAAFA;\">Rax</a>，要较好地融入开发，学习 Rax 就是一个不能绕过去的过程。</p>\n<p data-tool=\"mdnice编辑器\" style=\"padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: #2b2b2b; margin: 10px 0px; letter-spacing: 2px; font-size: 14px; word-spacing: 2px;\">好在 Rax 的语法和 React 基本一致，React 的开发已经比较熟练了，Rax 上手也没有什么太大的困难。</p>\n<p data-tool=\"mdnice编辑器\" style=\"padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: #2b2b2b; margin: 10px 0px; letter-spacing: 2px; font-size: 14px; word-spacing: 2px;\">需要适应的地方其实在于：相关的研发平台众多，自己手上的业务涉及到的各种研发平台/搭建平台都需要学会如何使用。</p>\n<p data-tool=\"mdnice编辑器\" style=\"padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: #2b2b2b; margin: 10px 0px; letter-spacing: 2px; font-size: 14px; word-spacing: 2px;\">这一点是非常消耗时间和精力的，从项目的搭建到最后的开发，过程中可能需要使用到四五个研发平台/搭建平台，对于新人来讲不是很友好。</p>\n<p data-tool=\"mdnice编辑器\" style=\"padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: #2b2b2b; margin: 10px 0px; letter-spacing: 2px; font-size: 14px; word-spacing: 2px;\">好在我的师姐非常贴心，涉及到平台的使用的时候，都会一步一步演示给我看，手把手教我如何使用这些平台。</p>\n<p data-tool=\"mdnice编辑器\" style=\"padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: #2b2b2b; margin: 10px 0px; letter-spacing: 2px; font-size: 14px; word-spacing: 2px;\">刚来的一个多月，基本都在熟悉这些平台，开发一些简单的模块。</p>\n<p data-tool=\"mdnice编辑器\" style=\"padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: #2b2b2b; margin: 10px 0px; letter-spacing: 2px; font-size: 14px; word-spacing: 2px;\">开发的过程中肯定也会遇到一些问题，大部分情况是自己的代码有问题，又或是缺少某些配置项，这些问题一般都能通过 Debug 和查文档得到解决。</p>\n<p data-tool=\"mdnice编辑器\" style=\"padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: #2b2b2b; margin: 10px 0px; letter-spacing: 2px; font-size: 14px; word-spacing: 2px;\">老牌大厂的技术沉淀非常深厚，同时也有一些历史包袱，Weex 应该可以说是比较大的历史包袱了。</p>\n<p data-tool=\"mdnice编辑器\" style=\"padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: #2b2b2b; margin: 10px 0px; letter-spacing: 2px; font-size: 14px; word-spacing: 2px;\">大多数时候开发 Weex 的 Native 页，都需要先在 Web 上开发完成了之后再查看 Native 页，然后解决一些兼容问题带来的差异。在 Weex 中的调试是比较困难的，而且还有一些样式/语法约束，在开发的过程中需要时刻注意。</p>\n<p data-tool=\"mdnice编辑器\" style=\"padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: #2b2b2b; margin: 10px 0px; letter-spacing: 2px; font-size: 14px; word-spacing: 2px;\">最近 Rax 小程序的运行时方案也出炉了，能够抛开语法约束直接使用 Rax 写小程序了，这个方案可以说极大地方便了开发者。</p>\n<p data-tool=\"mdnice编辑器\" style=\"padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: #2b2b2b; margin: 10px 0px; letter-spacing: 2px; font-size: 14px; word-spacing: 2px;\">最近在做的业务，就使用到了 Rax 小程序的运行时方案，由于是第一次在业务中落地这个方案，踩了不少坑，这其中还涉及到了不少技术问题，由于自身的技术能力还不够，有些问题没办法自己解决，需要四处请教师兄师姐。</p>\n<p data-tool=\"mdnice编辑器\" style=\"padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: #2b2b2b; margin: 10px 0px; letter-spacing: 2px; font-size: 14px; word-spacing: 2px;\">Rax 的脚手架配置是不透明的，开发者没办法通过修改配置的方式解决开发中遇到的一些问题，只能通过脚手架对外暴露的配置项，进行有限的自定义。</p>\n<p data-tool=\"mdnice编辑器\" style=\"padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: #2b2b2b; margin: 10px 0px; letter-spacing: 2px; font-size: 14px; word-spacing: 2px;\">开发过程中遇到的问题，很多时候会涉及到一些组件或仓库的源码，如果是多端项目还会涉及到一些容器相关的知识，这其中因为自己读源码的能力欠缺，给开发带来了不少困扰。</p>\n<p data-tool=\"mdnice编辑器\" style=\"padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: #2b2b2b; margin: 10px 0px; letter-spacing: 2px; font-size: 14px; word-spacing: 2px;\">经过这一段时间的学习开发，也算是梳理出了一个解决开发过程中的 bug 的思路：</p>\n<figure data-tool=\"mdnice编辑器\" style=\"margin: 0; margin-top: 10px; margin-bottom: 10px; display: flex; flex-direction: column; justify-content: center; align-items: center;\"><img src=\"http://cdn.jack-wjq.cn/BugFix.png\" alt=\"BugFix\" style=\"max-width: 100%; border-radius: 6px; display: block; margin: 20px auto; object-fit: contain; box-shadow: 2px 4px 7px #999;\"><figcaption style=\"margin-top: 5px; text-align: center; display: block; font-size: 13px; color: #2b2b2b;\"><span style=\"background-image: url(https://img.alicdn.com/tfs/TB1Yycwyrj1gK0jSZFuXXcrHpXa-32-32.png); display: inline-block; width: 18px; height: 18px; background-size: 18px; background-repeat: no-repeat; background-position: center; margin-right: 5px; margin-bottom: -5px;\"></span>BugFix</figcaption></figure>\n<p data-tool=\"mdnice编辑器\" style=\"padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: #2b2b2b; margin: 10px 0px; letter-spacing: 2px; font-size: 14px; word-spacing: 2px;\">业务开发过程中的问题，如果自己没办法解决的，基本都能够通过沟通或者咨询解决。</p>\n<p data-tool=\"mdnice编辑器\" style=\"padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: #2b2b2b; margin: 10px 0px; letter-spacing: 2px; font-size: 14px; word-spacing: 2px;\">踩过的坑也需要及时记录下来，其他同学遇到的时候能够给他们指个路。</p>\n<p data-tool=\"mdnice编辑器\" style=\"padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: #2b2b2b; margin: 10px 0px; letter-spacing: 2px; font-size: 14px; word-spacing: 2px;\">开发的过程中也一直在思考，如何写出低耦合、可读性高、可拓展性好的代码。</p>\n<p data-tool=\"mdnice编辑器\" style=\"padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: #2b2b2b; margin: 10px 0px; letter-spacing: 2px; font-size: 14px; word-spacing: 2px;\">为了达成这个目标，最近也一直在学习设计模式，在每次写代码之前思考业务逻辑，设计代码结构实现最终的功能。</p>\n<p data-tool=\"mdnice编辑器\" style=\"padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: #2b2b2b; margin: 10px 0px; letter-spacing: 2px; font-size: 14px; word-spacing: 2px;\">回顾自己的代码，其中有不少没必要的分支结构，就可以尝试使用策略模式对代码重新设计。</p>\n<p data-tool=\"mdnice编辑器\" style=\"padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: #2b2b2b; margin: 10px 0px; letter-spacing: 2px; font-size: 14px; word-spacing: 2px;\">来到淘系之后，我比较系统地了解和学习了<a href=\"https://juejin.im/post/6844904194600599560\" style=\"text-decoration: none; word-wrap: break-word; color: #40B8FA; font-weight: normal; border-bottom: 1px solid #3BAAFA;\">前端自动化测试</a>的一些知识，学会了如何<a href=\"https://github.com/wjq990112/Holiday-Editor\" style=\"text-decoration: none; word-wrap: break-word; color: #40B8FA; font-weight: normal; border-bottom: 1px solid #3BAAFA;\">使用 Electron 进行桌面应用开发</a>，接触到了<a href=\"https://rax.js.org/\" style=\"text-decoration: none; word-wrap: break-word; color: #40B8FA; font-weight: normal; border-bottom: 1px solid #3BAAFA;\"> Rax 和 Weex 实现的架构</a>，见识到了不少研发/搭建平台，了解到了他们的设计思想和实现方式。</p>\n<p data-tool=\"mdnice编辑器\" style=\"padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: #2b2b2b; margin: 10px 0px; letter-spacing: 2px; font-size: 14px; word-spacing: 2px;\">站在现在的角度回顾自己进入淘系之前的学习过程，前后的变化可以用一个段子来形容：<strong style=\"color: #3594F7; font-weight: bold;\"><span>「</span>土八路<span>」</span></strong> 和 <strong style=\"color: #3594F7; font-weight: bold;\"><span>「</span>正规军<span>」</span></strong>。</p>\n<p data-tool=\"mdnice编辑器\" style=\"padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: #2b2b2b; margin: 10px 0px; letter-spacing: 2px; font-size: 14px; word-spacing: 2px;\">淘系这样的大平台，能够提供非常广阔的视野，从前很多从博客中了解到的概念，从只能泛泛而谈到能够结合实际场景谈看法和应用，也许是我这段时间在技术方面最大的成长。</p>\n<h3 data-tool=\"mdnice编辑器\" style=\"padding: 0px; color: black; font-size: 17px; font-weight: bold; text-align: center; position: relative; margin-top: 20px; margin-bottom: 20px;\"><span class=\"prefix\" style=\"display: none;\"></span><span class=\"content\" style=\"border-bottom: 2px solid RGBA(79, 177, 249, .65); color: #2b2b2b; padding-bottom: 2px;\"><span style=\"width: 30px; height: 30px; display: block; background-image: url(https://files.mdnice.com/fullstack-2.png); background-position: center; background-size: 30px; margin: auto; opacity: 1; background-repeat: no-repeat; margin-bottom: -8px;\"></span>业务能力</span><span class=\"suffix\" style=\"display: none;\"></span></h3>\n<p data-tool=\"mdnice编辑器\" style=\"padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: #2b2b2b; margin: 10px 0px; letter-spacing: 2px; font-size: 14px; word-spacing: 2px;\">于我个人而言，学习前端更多的是对前端技术的热爱，一直想做一个技术顶尖的开发者，像尤大一样，能够利用自己的知识和技术，开发出类似 Vue 一样的现象级框架。</p>\n<p data-tool=\"mdnice编辑器\" style=\"padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: #2b2b2b; margin: 10px 0px; letter-spacing: 2px; font-size: 14px; word-spacing: 2px;\">曾经在微信上也与 <a href=\"https://juejin.im/user/430664257382462\" style=\"text-decoration: none; word-wrap: break-word; color: #40B8FA; font-weight: normal; border-bottom: 1px solid #3BAAFA;\">@神三元</a> 做过较为深入的讨论：</p>\n<blockquote data-tool=\"mdnice编辑器\" style=\"display: block; font-size: 0.9em; overflow: auto; overflow-scrolling: touch; padding-top: 10px; padding-bottom: 10px; padding-left: 20px; padding-right: 10px; margin-bottom: 20px; margin-top: 20px; text-size-adjust: 100%; line-height: 1.55em; font-weight: 400; border-radius: 6px; color: #595959; font-style: normal; text-align: left; box-sizing: inherit; border-left: none; border: 1px solid RGBA(64, 184, 250, .4); background: RGBA(64, 184, 250, .1);\"><span style=\"color: RGBA(64, 184, 250, .5); font-size: 34px; line-height: 1; font-weight: 700;\">❝</span>\n<p style=\"padding-top: 8px; padding-bottom: 8px; letter-spacing: 2px; font-size: 14px; word-spacing: 2px; margin: 0px; line-height: 26px; color: #595959;\">在大多数公司里，前端都是以半个工具人的身份，作为后端同学与产品运营之间的纽带进行沟通和开发。大多数的前端都是业务前端，每天跟各种各样的业务方打交道，参加各种各样的业务评审，游走在业务的最前线。</p>\n<p style=\"padding-top: 8px; padding-bottom: 8px; letter-spacing: 2px; font-size: 14px; word-spacing: 2px; margin: 0px; line-height: 26px; color: #595959;\">基于这样的现状，我们应该怎么去平衡技术和业务之间的问题？</p>\n<span style=\"float: right; color: RGBA(64, 184, 250, .5);\">❞</span></blockquote>\n<p data-tool=\"mdnice编辑器\" style=\"padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: #2b2b2b; margin: 10px 0px; letter-spacing: 2px; font-size: 14px; word-spacing: 2px;\">我相信大多数的实习生同学应该跟我一样，不太喜欢去深入了解业务，更加倾向于技术。</p>\n<p data-tool=\"mdnice编辑器\" style=\"padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: #2b2b2b; margin: 10px 0px; letter-spacing: 2px; font-size: 14px; word-spacing: 2px;\">以前我会觉得去理解业务不应该是我们开发来做，而是由产品和运营的同学来做，开发过程中他们提什么需求我们就做什么，这可能也是作为一名在校生的惯性思维。</p>\n<p data-tool=\"mdnice编辑器\" style=\"padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: #2b2b2b; margin: 10px 0px; letter-spacing: 2px; font-size: 14px; word-spacing: 2px;\">一直以来我都是希望做一些纯粹点的技术型项目，用技术解决一些技术问题，开发一些现象级的开源项目，这也是我学习前端的动力和初心。</p>\n<p data-tool=\"mdnice编辑器\" style=\"padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: #2b2b2b; margin: 10px 0px; letter-spacing: 2px; font-size: 14px; word-spacing: 2px;\">直到最近拜读了 <a href=\"https://juejin.im/user/4212984287594775\" style=\"text-decoration: none; word-wrap: break-word; color: #40B8FA; font-weight: normal; border-bottom: 1px solid #3BAAFA;\">@于江水</a> 前辈的<a href=\"https://juejin.im/post/6844903783198097416\" style=\"text-decoration: none; word-wrap: break-word; color: #40B8FA; font-weight: normal; border-bottom: 1px solid #3BAAFA;\">《我在淘宝做前端的这三年》系列</a>，感触颇深，开始从心底改变这种想法。</p>\n<p data-tool=\"mdnice编辑器\" style=\"padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: #2b2b2b; margin: 10px 0px; letter-spacing: 2px; font-size: 14px; word-spacing: 2px;\">其中有一段话让我虎躯一震，有种醍醐灌顶的感觉：</p>\n<blockquote data-tool=\"mdnice编辑器\" style=\"display: block; font-size: 0.9em; overflow: auto; overflow-scrolling: touch; padding-top: 10px; padding-bottom: 10px; padding-left: 20px; padding-right: 10px; margin-bottom: 20px; margin-top: 20px; text-size-adjust: 100%; line-height: 1.55em; font-weight: 400; border-radius: 6px; color: #595959; font-style: normal; text-align: left; box-sizing: inherit; border-left: none; border: 1px solid RGBA(64, 184, 250, .4); background: RGBA(64, 184, 250, .1);\"><span style=\"color: RGBA(64, 184, 250, .5); font-size: 34px; line-height: 1; font-weight: 700;\">❝</span>\n<p style=\"padding-top: 8px; padding-bottom: 8px; letter-spacing: 2px; font-size: 14px; word-spacing: 2px; margin: 0px; line-height: 26px; color: #595959;\"><strong style=\"color: #3594F7; font-weight: bold;\"><span>「</span>业务能力应该是程序员除了技术之外，最具价值的能力，也是最必要的。因为技术本身很难赚钱，业务落地才能赚钱。当程序员具备了业务和产品能力，才可能选取业务和技术的折中点，又快又好的支撑业务，带来价值和效益。懂产品和业务（甚至交互设计）的技术，更容易跟其他工种进行沟通，用通俗易懂的方式介绍技术实现和难度，可以提升在企业中的自身地位和价值。此外，对于架构师，理解业务也是必备能力。<span>」</span></strong></p>\n<span style=\"float: right; color: RGBA(64, 184, 250, .5);\">❞</span></blockquote>\n<p data-tool=\"mdnice编辑器\" style=\"padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: #2b2b2b; margin: 10px 0px; letter-spacing: 2px; font-size: 14px; word-spacing: 2px;\">很多时候纯粹的技术项目是没有用的，一个技术项目的产生，背后一定是有目前生产实际中的痛点驱动的。如果一个技术项目的出现，没办法解决生产实际中的问题，那么整个技术项目出现的意义在哪里？</p>\n<p data-tool=\"mdnice编辑器\" style=\"padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: #2b2b2b; margin: 10px 0px; letter-spacing: 2px; font-size: 14px; word-spacing: 2px;\">任何现象级的开源框架，都是解决了一个领域中一些非常棘手的、迫切改变的问题的。</p>\n<p data-tool=\"mdnice编辑器\" style=\"padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: #2b2b2b; margin: 10px 0px; letter-spacing: 2px; font-size: 14px; word-spacing: 2px;\">最近在逛知乎的时候，看到了阿里的 React Hooks 库 <a href=\"https://ahooks.js.org/zh-CN\" style=\"text-decoration: none; word-wrap: break-word; color: #40B8FA; font-weight: normal; border-bottom: 1px solid #3BAAFA;\">ahooks</a>，然后跳转到官网一看，这简直就是一个神仙库，基本覆盖了大部分业务中可能涉及到的 Hooks 需求，尝试了一下之后直呼过瘾。</p>\n<p data-tool=\"mdnice编辑器\" style=\"padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: #2b2b2b; margin: 10px 0px; letter-spacing: 2px; font-size: 14px; word-spacing: 2px;\">用过之后就在思考，这样一个好用的库，还是从业务中来到业务中去的，印证了前辈的话。</p>\n<p data-tool=\"mdnice编辑器\" style=\"padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: #2b2b2b; margin: 10px 0px; letter-spacing: 2px; font-size: 14px; word-spacing: 2px;\">最近在做的业务算是比较贴近自己的娱乐生活了，在参加评审的时候也会对业务方的需求做出一些思考，有时候在业务开发的过程中遇到一些问题，会站在用户的角度去审视这个需求的必要性和合理性，然后去和产品同学沟通。</p>\n<p data-tool=\"mdnice编辑器\" style=\"padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: #2b2b2b; margin: 10px 0px; letter-spacing: 2px; font-size: 14px; word-spacing: 2px;\">很多时候我们需要站在业务方的角度去思考，用什么样的方式和技术能为业务方带来更大的收益，这点是最能体现自身价值的。</p>\n<p data-tool=\"mdnice编辑器\" style=\"padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: #2b2b2b; margin: 10px 0px; letter-spacing: 2px; font-size: 14px; word-spacing: 2px;\">技术的出现本身就是立足于解决实际问题的，没有任何一个技术是能够脱离现实而存在的。</p>\n<p data-tool=\"mdnice编辑器\" style=\"padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: #2b2b2b; margin: 10px 0px; letter-spacing: 2px; font-size: 14px; word-spacing: 2px;\">对于业务前端，最能展现自身价值的事情应该是在业务支撑的过程中产生一些沉淀，这些沉淀能够为整个业务中的每一个同学减负，优化整个流程，提升开发效率。</p>\n<p data-tool=\"mdnice编辑器\" style=\"padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: #2b2b2b; margin: 10px 0px; letter-spacing: 2px; font-size: 14px; word-spacing: 2px;\">而对于技术前端，则应该深入业务前线，去了解业务中普遍反馈、深恶痛绝的问题，基于这些问题，用技术给出一个完美的解决方案。</p>\n<p data-tool=\"mdnice编辑器\" style=\"padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: #2b2b2b; margin: 10px 0px; letter-spacing: 2px; font-size: 14px; word-spacing: 2px;\">在刚来淘系的一段时间里，由于需求都比较零散，很难去系统地去了解和思考业务中的一些问题，最近深入到了业务中才真正感受到了解业务的重要性。</p>\n<p data-tool=\"mdnice编辑器\" style=\"padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: #2b2b2b; margin: 10px 0px; letter-spacing: 2px; font-size: 14px; word-spacing: 2px;\">事实就是，你只有在深入了解了业务之后，根据业务类型和实际情况，去选择相应的能够又好又快实现业务需求的技术，至于你用 React、Vue、Angular 还是其他框架来实现，业务方并不关心，他们关心的是业务上线后的数据是否符合预期。</p>\n<p data-tool=\"mdnice编辑器\" style=\"padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: #2b2b2b; margin: 10px 0px; letter-spacing: 2px; font-size: 14px; word-spacing: 2px;\">之前在学习完了自动化测试的一些内容之后，在团队里做了一次分享，简单讲了一下学习的心得，但是由于 Rax 的适配原因没能在团队里推广。</p>\n<p data-tool=\"mdnice编辑器\" style=\"padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: #2b2b2b; margin: 10px 0px; letter-spacing: 2px; font-size: 14px; word-spacing: 2px;\">自动化测试的技术好吗？当然好。那为什么没能真正落地？</p>\n<p data-tool=\"mdnice编辑器\" style=\"padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: #2b2b2b; margin: 10px 0px; letter-spacing: 2px; font-size: 14px; word-spacing: 2px;\">抛开 Rax 的适配问题，如果使用的框架是 React，如果没能解决开发中的痛点，只会徒增开发者的负担，一样是一门无用的技术。</p>\n<h3 data-tool=\"mdnice编辑器\" style=\"padding: 0px; color: black; font-size: 17px; font-weight: bold; text-align: center; position: relative; margin-top: 20px; margin-bottom: 20px;\"><span class=\"prefix\" style=\"display: none;\"></span><span class=\"content\" style=\"border-bottom: 2px solid RGBA(79, 177, 249, .65); color: #2b2b2b; padding-bottom: 2px;\"><span style=\"width: 30px; height: 30px; display: block; background-image: url(https://files.mdnice.com/fullstack-2.png); background-position: center; background-size: 30px; margin: auto; opacity: 1; background-repeat: no-repeat; margin-bottom: -8px;\"></span>其他方面</span><span class=\"suffix\" style=\"display: none;\"></span></h3>\n<p data-tool=\"mdnice编辑器\" style=\"padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: #2b2b2b; margin: 10px 0px; letter-spacing: 2px; font-size: 14px; word-spacing: 2px;\">其他方面的成长最多的还是与人沟通的能力吧，越来越能够清晰地描述一个问题，越来越敢于表达自己的看法。</p>\n<p data-tool=\"mdnice编辑器\" style=\"padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: #2b2b2b; margin: 10px 0px; letter-spacing: 2px; font-size: 14px; word-spacing: 2px;\">其实有时候会觉得自己只是一个实习生，害怕自己提了什么很愚蠢的问题，给人印象不好，总是不敢表达自己的看法。</p>\n<p data-tool=\"mdnice编辑器\" style=\"padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: #2b2b2b; margin: 10px 0px; letter-spacing: 2px; font-size: 14px; word-spacing: 2px;\">深入挖掘这其中的原因其实就是对一件事情还不够了解，没能抓住一件事情的本质和主要矛盾。</p>\n<p data-tool=\"mdnice编辑器\" style=\"padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: #2b2b2b; margin: 10px 0px; letter-spacing: 2px; font-size: 14px; word-spacing: 2px;\">还有一点就是预估工期越来越有把握了，以前总是不知道一个功能或者页面开发要多长时间，自己心里没有底，现在大致可以根据页面的复杂程度和其中可能出现的问题估计一个比较准确的工期了。</p>\n<h2 data-tool=\"mdnice编辑器\" style=\"margin-top: 30px; margin-bottom: 15px; padding: 0px; font-weight: bold; color: black; font-size: 22px; display: block; border-bottom: 4px solid #40B8FA;\"><span class=\"prefix\" style=\"display: flex; width: 20px; height: 20px; background-size: 20px 20px; background-image: url(https://files.mdnice.com/fullstack-1.png); margin-bottom: -22px;\"></span><span class=\"content\" style=\"display: flex; color: #40B8FA; font-size: 20px; margin-left: 25px;\">结语</span><span class=\"suffix\" style=\"display: flex; box-sizing: border-box; width: 200px; height: 10px; border-top-left-radius: 20px; background: RGBA(64, 184, 250, .5); color: rgb(255, 255, 255); font-size: 16px; letter-spacing: 0.544px; justify-content: flex-end; float: right; margin-top: -10px; box-sizing: border-box !important; overflow-wrap: break-word !important;\"></span></h2>\n<p data-tool=\"mdnice编辑器\" style=\"padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: #2b2b2b; margin: 10px 0px; letter-spacing: 2px; font-size: 14px; word-spacing: 2px;\"><strong style=\"color: #3594F7; font-weight: bold;\"><span>「</span>90 天，时间真的好快呀~<span>」</span></strong></p>\n<p data-tool=\"mdnice编辑器\" style=\"padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: #2b2b2b; margin: 10px 0px; letter-spacing: 2px; font-size: 14px; word-spacing: 2px;\">这 90 天里感觉每周都有聚餐或者团建活动，在这样的团队工作生活真的非常愉快。</p>\n<p data-tool=\"mdnice编辑器\" style=\"padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: #2b2b2b; margin: 10px 0px; letter-spacing: 2px; font-size: 14px; word-spacing: 2px;\">也非常感谢我的师兄师姐们，给了我很多帮助，在我刚来杭州的时候给人生地不熟的我很多生活上的指导，也在我实习的这段时间教会我如何在业务中独当一面，至少现在做项目有底气有信心，也能很好地预估工期了。</p>\n<p data-tool=\"mdnice编辑器\" style=\"padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: #2b2b2b; margin: 10px 0px; letter-spacing: 2px; font-size: 14px; word-spacing: 2px;\">特别感谢一下全世界最好的元泉师兄，温柔漂亮、脖子以下全是腿的若欢师姐，很温暖很贴心。</p>\n<p data-tool=\"mdnice编辑器\" style=\"padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: #2b2b2b; margin: 10px 0px; letter-spacing: 2px; font-size: 14px; word-spacing: 2px;\">令我感到难过的是师姐没多久转岗了，我的导师换成了接手师姐业务的燃堂师兄。</p>\n<p data-tool=\"mdnice编辑器\" style=\"padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: #2b2b2b; margin: 10px 0px; letter-spacing: 2px; font-size: 14px; word-spacing: 2px;\">其实这个时候是实习生最焦虑的时候，外面各种大厂的秋招信息满天飞，但是实习生手上又有业务，还有转正的压力，很难抽出时间去复习面试，如果转正答辩情况不好，得知结果的时候也已经 9 月份了，错过了很多其他地方的好机会。</p>\n<p data-tool=\"mdnice编辑器\" style=\"padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: #2b2b2b; margin: 10px 0px; letter-spacing: 2px; font-size: 14px; word-spacing: 2px;\">其实这也不是什么吃里扒外或者吃着碗里的看着锅里的什么的，我相信这种焦虑大厂的实习生们应该都有，毕竟公司的岗位数量受环境影响大，如果大环境不是特别好，实习转正的机会也可能不会特别多。</p>\n<p data-tool=\"mdnice编辑器\" style=\"padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: #2b2b2b; margin: 10px 0px; letter-spacing: 2px; font-size: 14px; word-spacing: 2px;\">最近也得知了转正答辩的消息，离转正答辩没多久了，师兄也很认真负责的跟我一起梳理了一些实习的项目，希望我能在师兄的指导下顺利转正，能够留在这个温暖的大家庭，继续跟这群可爱的同事们一起工作。</p>\n<p data-tool=\"mdnice编辑器\" style=\"padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: #2b2b2b; margin: 10px 0px; letter-spacing: 2px; font-size: 14px; word-spacing: 2px;\">就这么多吧，祝自己能够顺利转正，也祝所有正在实习或是秋招面试的小伙伴们能够拿到心仪的 offer，我们一起加油~</p>\n<p data-tool=\"mdnice编辑器\" style=\"padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: #2b2b2b; margin: 10px 0px; letter-spacing: 2px; font-size: 14px; word-spacing: 2px;\">这篇文章我会同步发送到我的公众号：<strong style=\"color: #3594F7; font-weight: bold;\"><span>「</span>Hello FE<span>」</span></strong>，欢迎大家关注~</p>\n<p data-tool=\"mdnice编辑器\" style=\"padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: #2b2b2b; margin: 10px 0px; letter-spacing: 2px; font-size: 14px; word-spacing: 2px;\">我做公众号挺佛系的，更新频率不高，主要都是分享一些在别的公众号看到的好的文章或者实战教程，安利给粉丝们，也给自己做个备忘，仅此而已。</p>\n<p data-tool=\"mdnice编辑器\" style=\"padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: #2b2b2b; margin: 10px 0px; letter-spacing: 2px; font-size: 14px; word-spacing: 2px;\">关注公众号的话还有一些电子书，大多都是我看过的，希望能给正在学习前端的同学们一点帮助~</p>\n</section>", "user_name": "炽翎", "description": "挣扎的小菜鸟 公众号：Hello FE", "got_view_count": 56604, "category_name": "前端", "ctime": 1457483942}
{"tag_name": "JavaScript", "concern_user_count": 343215, "user_id": "1011206425950605", "title": "1.1w字 ｜ 初中级前端 JavaScript 自测清单 - 2", "mark_content": "# 前言\n在[《初中级前端 JavaScript 自测清单 - 1》](https://juejin.im/post/6846687584710557710)部分中，和大家简单过了一遍 JavaScript 基础知识，没看过的朋友可以回顾一下😁\n\n本系列文章是我在我们团队内部的“**现代 JavaScript 突击队**”，第一期学习内容为[《现代 JavaScript 教程》](https://zh.javascript.info/)系列的**第二部分**输出内容，希望这份自测清单，能够帮助大家巩固知识，温故知新。\n\n本部分内容，以 **JavaScript 对象**为主，大致包括以下内容：\n![初中级前端 JavaScript 自测清单 2.png](http://images.pingan8787.com/JavaScript-Base/section2/xmind.png)\n\n# 一、对象\nJavaScript 有八种数据额类型，有七种原始类型，它们值只包含一种类型（字符串，数字或其他），而对象是用来**保存键值对和更复杂实体。**\n我们可以通过使用带有可选**属性列表**的花括号 `**{...}**` 来创建对象，一个属性就是一个键值对 `{\"key\" : \"value\"}` ，其中键（ `key` ）是一个字符串（或称属性名），值（ `value` ）可以是任何类型。\n\n## 1. 创建对象\n我们可以使用 2 种方式来创建一个新对象：\n```javascript\n// 1. 通过“构造函数”创建\nlet user = new Object();\n\n// 2. 通过“字面量”创建\nlet user = {};\n```\n\n## 2. 对象文本和属性\n创建对象时，可以初始化对象的一些属性：\n```javascript\nlet user = {\n\tname : 'leo',\n  age  : 18\n}\n```\n然后可以对该对象进行属性对**增删改查**操作：\n```javascript\n// 增加属性\nuser.addr = \"China\";\n// user => {name: \"leo\", age: 18, addr: \"China\"}\n\n// 删除属性\ndelete user.addr\n// user => {name: \"leo\", age: 18}\n\n// 修改属性\nuser.age  = 20;\n// user => {name: \"leo\", age: 20}\n\n// 查找属性\nuser.age;\n// 20\n```\n\n## 3. 方括号的使用\n当然对象的键（ `key` ）也可以是多词属性，但必须加引号，使用的时候，必须使用方括号（ `[]` ）读取：\n```javascript\nlet user = {\n\tname : 'leo',\n  \"my interest\" : [\"coding\", \"football\", \"cycling\"]\n}\nuser[\"my interest\"]; // [\"coding\", \"football\", \"cycling\"]\ndelete user[\"my interest\"];\n```\n\n我们也可以在方括号中使用变量，来获取属性值：\n```javascript\nlet key = \"name\";\nlet user = {\n\tname : \"leo\",\n  age  : 18 \n}\n// ok\nuser[key]; // \"leo\"\nuser[key] = \"pingan\";\n\n// error\nuser.key; // undefined\n```\n\n## 4. 计算属性\n创建对象时，可以在对象字面量中使用方括号，即 **计算属性** ：\n```javascript\nlet key = \"name\";\nlet inputKey = prompt(\"请输入key\", \"age\");\nlet user = {\n\t[key] : \"leo\",\n  [inputKey] : 18\n}\n// 当用户在 prompt 上输入 \"age\" 时，user 变成下面样子：\n// {name: \"leo\", age: 18}\n```\n当然，计算属性也可以是表达式：\n```javascript\nlet key = \"name\";\nlet user = {\n\t[\"my_\" + key] : \"leo\"\n}\nuser[\"my_\" + key]; // \"leo\"\n```\n\n## 5. 属性名简写\n实际开发中，可以将相同的属性名和属性值简写成更短的语法：\n```javascript\n// 原本书写方式\nlet getUser = function(name, age){\n  // ...\n\treturn {\n\t\tname: name,\n    age: age\n\t}\n}\n\n// 简写方式\nlet getUser = function(name, age){\n  // ...\n\treturn {\n\t\tname,\n    age\n\t}\n}\n```\n也可以混用：\n```javascript\n// 原本书写方式\nlet getUser = function(name, age){\n  // ...\n\treturn {\n\t\tname: name,\n    age: 18\n\t}\n}\n\n// 简写方式\nlet getUser = function(name, age){\n  // ...\n\treturn {\n\t\tname,\n    age: 18\n\t}\n}\n```\n\n## 6. 对象属性存在性检测\n\n### 6.1 使用 in 关键字\n该方法可以判断**对象的自有属性和继承来的属性**是否存在。\n\n```javascript\nlet user = {name: \"leo\"};\n\"name\" in user;            //true，自有属性存在\n\"age\"  in user;            //false\n\"toString\" in user;     //true，是一个继承属性\n```\n\n### 6.2使用对象的 hasOwnProperty() 方法。\n该方法只能判断**自有属性**是否存在，对于**继承属性**会返回 `false` 。\n```javascript\nlet user = {name: \"leo\"};\nuser.hasOwnProperty(\"name\");       //true，自有属性中有 name\nuser.hasOwnProperty(\"age\");        //false，自有属性中不存在 age\nuser.hasOwnProperty(\"toString\");   //false，这是一个继承属性，但不是自有属性\n```\n\n### 6.3 用 undefined 判断\n该方法可以判断对象的**自有属性和继承属性**。\n```javascript\nlet user = {name: \"leo\"};\nuser.name !== undefined;        // true\nuser.age  !== undefined;        // false\nuser.toString !== undefined     // true\n```\n\n该方法存在一个问题，如果属性的值就是 `undefined`  的话，该方法不能返回想要的结果：\n```javascript\nlet user = {name: undefined};\nuser.name !== undefined;        // false，属性存在，但值是undefined\nuser.age  !== undefined;        // false\nuser.toString !== undefined;    // true\n```\n\n### 6.4 在条件语句中直接判断\n```javascript\nlet user = {};\nif(user.name) user.name = \"pingan\";\n//如果 name 是 undefined, null, false, \" \", 0 或 NaN,它将保持不变\n\nuser; // {}\n```\n\n## 7. 对象循环遍历\n当我们需要遍历对象中每一个属性，可以使用 `for...in` 语句来实现\n\n### 7.1 for...in 循环\n[`for...in`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Statements/for...in) 语句以任意顺序遍历一个对象的除 [`Symbol`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Symbol) 以外的[可枚举](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Enumerability_and_ownership_of_properties)属性。\n**注意** ： `for...in` 不应该应用在一个数组，其中索引顺序很重要。\n```javascript\nlet user = {\n\tname : \"leo\",\n  age  : 18\n}\n\nfor(let k in user){\n\tconsole.log(k, user[k]);\n}\n// name leo\n// age 18\n```\n\n### 7.2 ES7 新增方法\nES7中新增加的 `Object.values()`和`Object.entries()`与之前的`Object.keys()`类似，返回数组类型。\n\n#### 1. Object.keys() \n返回一个数组，成员是参数对象自身的（不含继承的）所有**可遍历属性**的健名。\n```javascript\nlet user = { name: \"leo\", age: 18};\nObject.keys(user); // [\"name\", \"age\"]\n```\n\n#### 2. Object.values()\n返回一个数组，成员是参数对象自身的（不含继承的）所有可遍历属性的键值。\n```javascript\nlet user = { name: \"leo\", age: 18};\nObject.values(user); // [\"leo\", 18]\n```\n\n如果参数不是对象，则返回空数组：\n```\nObject.values(10);   // []\nObject.values(true); // []\n```\n\n#### 3. Object.entries()\n返回一个数组，成员是参数对象自身的（不含继承的）所有**可遍历属性**的键值对数组。\n```javascript\nlet user = { name: \"leo\", age: 18};\nObject.entries(user);\n// [[\"name\",\"leo\"],[\"age\",18]]\n```\n\n手动实现`Object.entries()`方法：\n```javascript\n// Generator函数实现：  \nfunction* entries(obj){\n    for (let k of Object.keys(obj)){\n        yield [k ,obj[k]];\n    }\n}\n// 非Generator函数实现：\nfunction entries (obj){\n    let arr = [];\n    for(let k of Object.keys(obj)){\n        arr.push([k, obj[k]]);\n    }\n    return arr;\n}\n```\n\n#### 4. Object.getOwnPropertyNames(Obj)\n该方法返回一个数组，它包含了对象 `Obj` 所有拥有的属性（**无论是否可枚举**）的名称。\n```javascript\nlet user = { name: \"leo\", age: 18};\nObject.getOwnPropertyNames(user);\n// [\"name\", \"age\"]\n```\n\n# 二、对象拷贝\n参考文章[《搞不懂JS中赋值·浅拷贝·深拷贝的请看这里》](https://juejin.im/post/5d235d1ef265da1b855c7b5d)\n\n## 1. 赋值操作\n首先回顾下基本数据类型和引用数据类型：\n\n- 基本类型\n\n概念：基本类型值在内存中占据固定大小，保存在`栈内存`中（不包含`闭包`中的变量）。\n常见包括：undefined,null,Boolean,String,Number,Symbol\n\n- 引用类型\n\n概念：引用类型的值是对象，保存在`堆内存`中。而栈内存存储的是对象的变量标识符以及对象在堆内存中的存储地址(引用)，引用数据类型在栈中存储了指针，该指针指向堆中该实体的起始地址。当解释器寻找引用值时，会首先检索其在栈中的地址，取得地址后从堆中获得实体。\n常见包括：Object,Array,Date,Function,RegExp等\n\n### 1.1 基本数据类型赋值\n在栈内存中的数据发生数据变化的时候，系统会自动为新的变量分配一个新的之值在栈内存中，两个变量相互独立，互不影响的。\n```javascript\nlet user  = \"leo\";\nlet user1 = user;\nuser1 = \"pingan\";\nconsole.log(user);  // \"leo\"\nconsole.log(user1); // \"pingan\" \n```\n\n### 1.2 引用数据类型赋值\n在 JavaScript 中，变量不存储对象本身，而是存储其“内存中的地址”，换句话说就是存储对其的“引用”。\n如下面 `leo`  变量只是保存对`user` 对象对应引用：\n```javascript\nlet user = { name: \"leo\", age: 18};\nlet leo  = user;\n```\n其他变量也可以引用 `user` 对象：\n```javascript\nlet leo1 = user;\nlet leo2 = user;\n```\n但是由于变量保存的是引用，所以当我们修改变量 `leo` \\ `leo1` \\ `leo2` 这些值时，**也会改动到引用对象** `user` ，但当 `user` 修改，则其他引用该对象的变量，值都会发生变化：\n```javascript\nleo.name = \"pingan\";\nconsole.log(leo);   // {name: \"pingan\", age: 18}\nconsole.log(leo1);  // {name: \"pingan\", age: 18}\nconsole.log(leo2);  // {name: \"pingan\", age: 18}\nconsole.log(user);  // {name: \"pingan\", age: 18}\n\nuser.name = \"pingan8787\";\nconsole.log(leo);   // {name: \"pingan8787\", age: 18}\nconsole.log(leo1);  // {name: \"pingan8787\", age: 18}\nconsole.log(leo2);  // {name: \"pingan8787\", age: 18}\nconsole.log(user);  // {name: \"pingan8787\", age: 18}\n```\n这个过程中涉及变量地址指针指向问题，这里暂时不展开讨论，有兴趣的朋友可以网上查阅相关资料。\n\n## 2. 对象比较\n当两个变量引用同一个对象时，它们无论是 `==` 还是 `===` 都会返回 `true` 。\n```javascript\nlet user = { name: \"leo\", age: 18};\nlet leo  = user;\nlet leo1 = user;\nleo ==  leo1;   // true\nleo === leo1;   // true\nleo ==  user;   // true\nleo === user;   // true\n```\n但如果两个变量是空对象 `{}` ，则不相等：\n```javascript\nlet leo1 = {};\nlet leo2 = {};\nleo1 ==  leo2;  // false\nleo1 === leo2;  // false\n```\n\n## 3. 浅拷贝\n\n### 3.1 概念\n概念：**新的对象复制已有对象中非对象属性的值和对象属性的引用**。也可以理解为：**一个新的对象直接拷贝已存在的对象的对象属性的引用**，即浅拷贝。\n\n浅拷贝**只对第一层属性进行了拷贝**，当第一层的属性值是基本数据类型时，新的对象和原对象互不影响，但是如果第一层的属性值是复杂数据类型，那么新对象和原对象的属性值其指向的是同一块内存地址。\n\n通过示例代码演示没有使用浅拷贝场景：\n```javascript\n// 示例1 对象原始拷贝\nlet user = { name: \"leo\", skill: { JavaScript: 90, CSS: 80}};\nlet leo = user;\nleo.name = \"leo1\";\nleo.skill.CSS = 90;\nconsole.log(leo.name);      // \"leo1\"\nconsole.log(user.name);     // \"leo1\"\nconsole.log(leo.skill.CSS); // 90\nconsole.log(user.skill.CSS);// 90\n\n// 示例2 数组原始拷贝\nlet user = [\"leo\", \"pingan\", {name: \"pingan8787\"}];\nlet leo  = user;\nleo[0] = \"pingan888\";\nleo[2][\"name\"] = \"pingan999\";\nconsole.log(leo[0]);          // \"pingan888\"\nconsole.log(user[0]);         // \"pingan888\"\nconsole.log(leo[2][\"name\"]);  // \"pingan999\"\nconsole.log(user[2][\"name\"]); // \"pingan999\"\n```\n从上面示例代码可以看出：\n由于对象被直接拷贝，相当于拷贝 **引用数据类型** ，所以在新对象修改任何值时，都会改动到源数据。\n\n接下来实现浅拷贝，对比以下。\n\n### 3.2 实现浅拷贝\n\n#### 1. Object.assign() \n语法： `Object.assign(target, ...sources)`\nES6中拷贝对象的方法，接受的第一个参数是拷贝的目标target，剩下的参数是拷贝的源对象sources（可以是多个）。\n详细介绍，可以阅读文档[《MDN Object.assign》](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/assign)。\n```javascript\n// 示例1 对象浅拷贝\nlet user = { name: \"leo\", skill: { JavaScript: 90, CSS: 80}};\nlet leo = Object.assign({}, user);\nleo.name = \"leo1\";\nleo.skill.CSS = 90;\nconsole.log(leo.name);      // \"leo1\" ⚠️ 差异！\nconsole.log(user.name);     // \"leo\"  ⚠️ 差异！\nconsole.log(leo.skill.CSS); // 90\nconsole.log(user.skill.CSS);// 90\n\n// 示例2 数组浅拷贝\nlet user = [\"leo\", \"pingan\", {name: \"pingan8787\"}];\nlet leo  = Object.assign({}, user);\nleo[0] = \"pingan888\";\nleo[2][\"name\"] = \"pingan999\";\nconsole.log(leo[0]);          // \"pingan888\"  ⚠️ 差异！\nconsole.log(user[0]);         // \"leo\"        ⚠️ 差异！\nconsole.log(leo[2][\"name\"]);  // \"pingan999\"\nconsole.log(user[2][\"name\"]); // \"pingan999\"\n```\n从打印结果可以看出，浅拷贝只是在根属性(对象的第一层级)创建了一个新的对象，但是对于属性的值是对象的话只会拷贝一份相同的内存地址。\n\n`Object.assign()` 使用注意：\n\n- 只拷贝源对象的自身属性（不拷贝继承属性）；\n- 不会拷贝对象不可枚举的属性；\n- 属性名为`Symbol` 值的属性，可以被Object.assign拷贝；\n- `undefined`和`null`无法转成对象，它们不能作为`Object.assign`参数，但是可以作为源对象。\n```javascript\nObject.assign(undefined); // 报错\nObject.assign(null);      // 报错\n\nObject.assign({}, undefined); // {}\nObject.assign({}, null);      // {}\n\nlet user = {name: \"leo\"};\nObject.assign(user, undefined) === user; // true\nObject.assign(user, null)      === user; // true\n```\n\n#### 2. Array.prototype.slice()\n语法： `arr.slice([begin[, end]])`\n`slice()` 方法返回一个新的数组对象，这一对象是一个由 `begin` 和 `end` 决定的原数组的浅拷贝（包括 `begin`，不包括`end`）。原始数组不会被改变。\n详细介绍，可以阅读文档[《MDN Array slice》](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/slice)。\n```javascript\n// 示例 数组浅拷贝\nlet user = [\"leo\", \"pingan\", {name: \"pingan8787\"}];\nlet leo  = Array.prototype.slice.call(user);\nleo[0] = \"pingan888\";\nleo[2][\"name\"] = \"pingan999\";\nconsole.log(leo[0]);          // \"pingan888\"  ⚠️ 差异！\nconsole.log(user[0]);         // \"leo\"        ⚠️ 差异！\nconsole.log(leo[2][\"name\"]);  // \"pingan999\"\nconsole.log(user[2][\"name\"]); // \"pingan999\"\n```\n\n#### 3. Array.prototype.concat()\n语法： `var new_array = old_array.concat(value1[, value2[, ...[, valueN]]])`\n`concat()` 方法用于合并两个或多个数组。此方法不会更改现有数组，而是返回一个新数组。\n详细介绍，可以阅读文档[《MDN Array concat》](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/concat)。\n```javascript\nlet user  = [{name: \"leo\"},   {age: 18}];\nlet user1 = [{age: 20},{addr: \"fujian\"}];\nlet user2 = user.concat(user1);\nuser1[0][\"age\"] = 25;\nconsole.log(user);  // [{\"name\":\"leo\"},{\"age\":18}]\nconsole.log(user1); // [{\"age\":25},{\"addr\":\"fujian\"}]\nconsole.log(user2); // [{\"name\":\"leo\"},{\"age\":18},{\"age\":25},{\"addr\":\"fujian\"}]\n```\n`Array.prototype.concat` 也是一个浅拷贝，只是在根属性(对象的第一层级)创建了一个新的对象，但是对于属性的值是对象的话只会拷贝一份相同的内存地址。\n\n\n#### 4. 拓展运算符（...）\n语法： `var cloneObj = { ...obj };`\n扩展运算符也是浅拷贝，对于值是对象的属性无法完全拷贝成2个不同对象，但是如果属性都是基本类型的值的话，使用扩展运算符也是优势方便的地方。\n```javascript\nlet user = { name: \"leo\", skill: { JavaScript: 90, CSS: 80}};\nlet leo = {...user};\nleo.name = \"leo1\";\nleo.skill.CSS = 90;\nconsole.log(leo.name);      // \"leo1\" ⚠️ 差异！\nconsole.log(user.name);     // \"leo\"  ⚠️ 差异！\nconsole.log(leo.skill.CSS); // 90\nconsole.log(user.skill.CSS);// 90\n```\n\n### 3.3 手写浅拷贝\n实现原理：新的对象复制已有对象中非对象属性的值和对象属性的**引用**,也就是说对象属性并不复制到内存。\n```javascript\nfunction cloneShallow(source) {\n    let target = {};\n    for (let key in source) {\n        if (Object.prototype.hasOwnProperty.call(source, key)) {\n            target[key] = source[key];\n        }\n    }\n    return target;\n}\n```\n\n- **for in**\n\nfor...in语句以任意顺序遍历一个对象自有的、继承的、`可枚举的`、非Symbol的属性。对于每个不同的属性，语句都会被执行。\n\n- **hasOwnProperty**\n\n该函数返回值为布尔值，所有继承了 Object 的对象都会继承到 `hasOwnProperty` 方法，和 `in` 运算符不同，该函数会忽略掉那些从原型链上继承到的属性和自身属性。\n语法：`obj.hasOwnProperty(prop)`\n`prop` 是要检测的属性**字符串名称**或者`Symbol`。\n\n## 4. 深拷贝\n\n### 4.1 概念\n复制变量值，对于引用数据，则递归至基本类型后，再复制。深拷贝后的对象**与原来的对象完全隔离**，互不影响，对一个对象的修改并不会影响另一个对象。\n\n### 4.2 实现深拷贝\n\n#### 1. JSON.parse(JSON.stringify())\n其原理是把一个对象序列化成为一个JSON字符串，将对象的内容转换成字符串的形式再保存在磁盘上，再用`JSON.parse()` 反序列化将JSON字符串变成一个新的对象。\n```javascript\nlet user = { name: \"leo\", skill: { JavaScript: 90, CSS: 80}};\nlet leo = JSON.parse(JSON.stringify(user));\nleo.name = \"leo1\";\nleo.skill.CSS = 90;\nconsole.log(leo.name);      // \"leo1\" ⚠️ 差异！\nconsole.log(user.name);     // \"leo\"  ⚠️ 差异！\nconsole.log(leo.skill.CSS); // 90 ⚠️ 差异！\nconsole.log(user.skill.CSS);// 80 ⚠️ 差异！\n```\n`JSON.stringify()` 使用注意：\n\n- 拷贝的对象的值中如果有函数， `undefined` ， `symbol` 则经过 `JSON.stringify()` `序列化后的JSON字符串中这个键值对会消失；\n- 无法拷贝不可枚举的属性，无法拷贝对象的原型链；\n- 拷贝 `Date` 引用类型会变成字符串；\n- 拷贝 `RegExp` 引用类型会变成空对象；\n- 对象中含有 `NaN` 、 `Infinity` 和 `-Infinity` ，则序列化的结果会变成 `null` ；\n- 无法拷贝对象的循环应用(即 `obj[key] = obj` )。\n\n\n#### 2. 第三方库\n\n### 4.3 手写深拷贝\n核心思想是**递归**，遍历对象、数组直到里边都是基本数据类型，然后再去复制，就是深度拷贝。 实现代码：\n```javascript\nconst isObject = obj => typeof obj === 'object' && obj != null;\n\nfunction cloneDeep(source) {\n    if (!isObject(source)) return source; // 非对象返回自身\n    const target = Array.isArray(source) ? [] : {};\n    for(var key in source) {\n        if (Object.prototype.hasOwnProperty.call(source, key)) {\n            if (isObject(source[key])) {\n                target[key] = cloneDeep(source[key]); // 注意这里\n            } else {\n                target[key] = source[key];\n            }\n        }\n    }\n    return target;\n}\n```\n该方法缺陷： 遇到循环引用，会陷入一个循环的递归过程，从而导致爆栈。\n其他写法，可以阅读[《如何写出一个惊艳面试官的深拷贝?》](https://juejin.im/post/5d6aa4f96fb9a06b112ad5b1) 。\n\n## 5. 小结\n**浅拷贝**：将对象的每个属性进行依次复制，但是当对象的属性值是引用类型时，实质复制的是其引用，当引用指向的值改变时也会跟着变化。\n\n**深拷贝**：复制变量值，对于引用数据，则递归至基本类型后，再复制。深拷贝后的对象**与原来的对象完全隔离**，互不影响，对一个对象的修改并不会影响另一个对象。\n\n**深拷贝和浅拷贝是针对复杂数据类型来说的，浅拷贝只拷贝一层，而深拷贝是层层拷贝。**\n![深拷贝和浅拷贝](http://images.pingan8787.com/JavaScript-Base/section2/object-copy.png)\n\n# 三、垃圾回收机制（GC）\n[垃圾回收（Garbage Collection，缩写为GC）](https://zh.wikipedia.org/zh-hans/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6_(%E8%A8%88%E7%AE%97%E6%A9%9F%E7%A7%91%E5%AD%B8))是一种自动的存储器管理机制。当某个程序占用的一部分内存空间不再被这个程序访问时，这个程序会借助垃圾回收算法向操作系统归还这部分内存空间。垃圾回收器可以减轻程序员的负担，也减少程序中的错误。垃圾回收最早起源于LISP语言。\n目前许多语言如Smalltalk、Java、C#和D语言都支持垃圾回收器，我们熟知的 JavaScript 具有自动垃圾回收机制。\n\n**在 JavaScript 中，原始类型的数据被分配到栈空间中，引用类型的数据会被分配到堆空间中。**\n\n## 1. 栈空间中的垃圾回收\n当函数 `showName` 调用完成后，通过下移 [ESP（Extended Stack Pointer）](https://baike.baidu.com/item/esp/35173)指针，来销毁 `showName` 函数，之后调用其他函数时，将覆盖掉旧内存，存放另一个函数的执行上下文，实现垃圾回收。\n![](hhttp://images.pingan8787.com/JavaScript-Base/section2/v8-1.jpg)\n图片来自《浏览器工作原理与实践》\n\n## 2. 堆空间中的垃圾回收\n堆中数据垃圾回收策略的基础是：[**代际假说**（The Generational Hypothesis）](https://plumbr.io/handbook/garbage-collection-in-java/generational-hypothesis)。即：\n\n1. 大部分对象在内存中存在时间极短，很多对象很快就不可访问。\n1. 不死的对象将活得更久。\n\n这两个特点不仅仅适用于 JavaScript，同样适用于大多数的动态语言，如 Java、Python 等。\nV8 引擎将堆空间分为**新生代**（存放生存**时间短**的对象）和**老生代**（存放生存**时间长**的对象）两个区域，并使用不同的垃圾回收器。\n\n- 副垃圾回收器，主要负责新生代的垃圾回收。\n- 主垃圾回收器，主要负责老生代的垃圾回收。\n\n不管是哪种垃圾回收器，都使用相同垃圾回收流程：**标记活动对象和非活动对象，回收非活动对象的内存，最后内存整理。**\n**\n\n### 1.1 副垃圾回收器\n使用 Scavenge 算法处理，将新生代空间对半分为两个区域，一个对象区域，一个空闲区域。\n![](hhttp://images.pingan8787.com/JavaScript-Base/section2/v8-2.jpg)\n图片来自《浏览器工作原理与实践》\n\n执行流程：\n\n- 新对象存在在**对象区域**，当对象区域将要写满时，执行一次垃圾回收；\n- 垃圾回收过程中，首先对对象区域中的垃圾做标记，然后副垃圾回收器将存活的对象复制并有序排列到空闲区域，相当于完成内存整理。\n- 复制完成后，将对象区域和空闲区域翻转，完成垃圾回收操作，这也让新生代中两块区域无限重复使用。\n\n当然，这也存在一些问题：若复制操作的数据较大则影响清理效率。\nJavaScript 引擎的解决方式是：将新生代区域设置得比较小，并采用对象晋升策略（经过两次回收仍存活的对象，会被移动到老生区），避免因为新生代区域较小引起存活对象装满整个区域的问题。\n\n### 1.2 主垃圾回收器\n分为：**标记 - 清除（Mark-Sweep）算法**，和**标记 - 整理（Mark-Compact）算法**。\n\n**a)标记 - 清除（Mark-Sweep）算法**\n**过程：**\n\n- 标记过程：从一组根元素开始遍历整个元素，能到达的元素为活动对象，反之为垃圾数据；\n- 清除过程：清理被标记的数据，并产生大量碎片内存。（缺点：导致大对象无法分配到足够的连续内存）\n\n![](hhttp://images.pingan8787.com/JavaScript-Base/section2/v8-3.jpg)\n图片来自《浏览器工作原理与实践》\n\n**b)标记 - 整理（Mark-Compact）算法**\n**过程：**\n\n- 标记过程：从一组根元素开始遍历整个元素，能到达的元素为活动对象，反之为垃圾数据；\n- 整理过程：将所有存活的对象，向一段移动，然后清除端边界以外的内容。\n\n![](hhttp://images.pingan8787.com/JavaScript-Base/section2/v8-4.jpg)\n图片来自《浏览器工作原理与实践》\n\n## 3. 拓展阅读\n1.[《图解Java 垃圾回收机制》](https://blog.csdn.net/justloveyou_/article/details/71216049)\n2.[《MDN 内存管理》](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Memory_Management)\n\n# 四、对象方法和 this\n\n## 1. 对象方法\n具体介绍可阅读 [《MDN 方法的定义》](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Functions/Method_definitions) 。\n将作为对象属性的方法称为“对象方法”，如下面 `user` 对象的 `say` 方法：\n```javascript\nlet user = {};\nlet say = function(){console.log(\"hello!\")};\n\nuser.say = say;  // 赋值到对象上\nuser.say(); // \"hello!\"\n```\n也可以使用更加简洁的方法：\n```javascript\nlet user = {\n\tsay: function(){}\n  \n  // 简写为\n\tsay (){console.log(\"hello!\")}\n\n\t// ES8 async 方法\n\tasync say (){/.../}\n}\nuser.say();\n```\n当然对象方法的名称，还支持计算的属性名称作为方法名：\n```javascript\nconst hello = \"Hello\";\nlet user = {\n\t['say' + hello](){console.log(\"hello!\")}\n}\nuser['say' + hello](); // \"hello!\"\n```\n\n\n另外需要注意的是：所有方法定义不是构造函数，如果您尝试实例化它们，将抛出[`TypeError`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/TypeError)。\n```javascript\nlet user = {\n\tsay(){};\n}\nnew user.say; // TypeError: user.say is not a constructor\n```\n\n## 2. this\n\n### 2.1 this 简介\n当对象方法需要使用对象中的属性，可以使用 `this` 关键字：\n```javascript\nlet user = {\n\tname : 'leo',\n  say(){ console.log(`hello ${this.name}`)}\n}\n\nuser.say(); // \"hello leo\"\n```\n当代码 `user.say()` 执行过程中， `this` 指的是 `user` 对象。当然也可以直接使用变量名 `user` 来引用 `say()` 方法：\n```javascript\nlet user = {\n\tname : 'leo',\n  say(){ console.log(`hello ${user.name}`)}\n}\n\nuser.say(); // \"hello leo\"\n```\n但是这样并不安全，因为 `user` 对象可能赋值给另外一个变量，并且将其他值赋值给 `user` 对象，就可能导致报错：\n```javascript\nlet user = {\n\tname : 'leo',\n  say(){ console.log(`hello ${user.name}`)}\n}\n\nlet leo = user;\nuser = null;\n\nleo.say(); // Uncaught TypeError: Cannot read property 'name' of null\n```\n但将  `user.name`  改成 `this.name` 代码便正常运行。\n\n### 2.2 this 取值\n`this` 的值是在 **代码运行时计算出来** 的，它的值取决于代码上下文：\n```javascript\nlet user = { name: \"leo\"};\nlet admin = {name: \"pingan\"};\nlet say = function (){\n\tconsole.log(`hello ${this.name}`)\n};\n\nuser.fun = say;\nadmin.fun = say;\n\n// 函数内部 this 是指“点符号前面”的对象\nuser.fun();     // \"hello leo\"\nadmin.fun();    // \"hello pingan\"\nadmin['fun'](); // \"hello pingan\"\n```\n规则：如果 `obj.fun()` 被调用，则 `this` 在 `fun` 函数调用期间是 `obj` ，所以上面的 `this` 先是 `user` ，然后是 `admin` 。\n\n\n但是在全局环境中，无论是否开启严格模式， `this` 都指向全局对象\n```javascript\nconsole.log(this == window); // true\n\nlet a = 10;\nthis.b = 10;\na === this.b; // true\n```\n\n### 2.3 箭头函数没有自己的 this\n箭头函数比较特别，没有自己的 `this` ，如果有引用 `this` 的话，则指向外部正常函数，下面例子中， `this` 指向 `user.say()` 方法：\n```javascript\nlet user = {\n\tname : 'leo',\n  say : () => {\n  \tconsole.log(`hello ${this.name}`);\n  },\n  hello(){\n\t\tlet fun = () => console.log(`hello ${this.name}`);\n    fun();\n\t}\n}\n\nuser.say();   // hello      => say() 外部函数是 window\nuser.hello(); // hello leo  => fun() 外部函数是 hello\n```\n\n### 2.4 call / apply / bind\n详细可以阅读[《js基础-关于call,apply,bind的一切》](https://cloud.tencent.com/developer/article/1479810) 。\n当我们想把 `this` 值绑定到另一个环境中，就可以使用 `call` / `apply` / `bind` 方法实现：\n```javascript\nvar user = { name: 'leo' };\nvar name = 'pingan';\nfunction fun(){\n\treturn console.log(this.name); // this 的值取决于函数调用方式\n}\n\nfun();           // \"pingan\"\nfun.call(user);  // \"leo\"\nfun.apply(user); // \"leo\"\n```\n注意：这里的 `var name = 'pingan';` 需要使用 `var` 来声明，使用 `let` 的话， `window` 上将没有 `name` 变量。\n\n三者语法如下：\n```javascript\nfun.call(thisArg, param1, param2, ...)\nfun.apply(thisArg, [param1,param2,...])\nfun.bind(thisArg, param1, param2, ...)\n```\n\n# 五、构造函数和 new 运算符\n\n## 1. 构造函数\n构造函数的作用在于 **实现可重用的对象创建代码** 。\n通常，对于构造函数有两个约定：\n\n- 命名时首字母大写；\n- 只能使用 `new` 运算符执行。\n\n**`new` 运算符**创建一个用户定义的对象类型的实例或具有构造函数的内置对象的实例。\n语法如下：\n```javascript\nnew constructor[([arguments])]\n```\n参数如下：\n\n- `constructor`一个指定对象实例的类型的类或函数。\n- `arguments`一个用于被 `constructor` 调用的参数列表。\n\n## 2. 简单示例\n举个简单示例：\n```javascript\nfunction User (name){\n\tthis.name = name;\n  this.isAdmin = false; \n}\nconst leo = new User('leo');\nconsole.log(leo.name, leo.isAdmin); // \"leo\" false\n```\n\n## 3. new 运算符操作过程\n当一个函数被使用 `new` 运算符执行时，它按照以下步骤：\n\n1. 一个新的空对象被创建并分配给 `this`。\n1. 函数体执行。通常它会修改 `this`，为其添加新的属性。\n1. 返回 `this` 的值。\n\n以前面 `User` 方法为例：\n```javascript\nfunction User(name) {\n  // this = {};（隐式创建）\n\n  // 添加属性到 this\n  this.name = name;\n  this.isAdmin = false;\n\n  // return this;（隐式返回）\n}\nconst leo = new User('leo');\nconsole.log(leo.name, leo.isAdmin); // \"leo\" false\n```\n\n当我们执行 `new User('leo')` 时，发生以下事情：\n\n1. 一个继承自 `User.prototype` 的新对象被创建；\n1. 使用指定参数调用构造函数 `User` ，并将 `this` 绑定到新创建的对象；\n1. 由构造函数返回的对象就是 `new` 表达式的结果。如果构造函数没有显式返回一个对象，则使用步骤1创建的对象。\n\n**需要注意**：\n\n1. 一般情况下，构造函数不返回值，但是开发者可以选择主动返回对象，来覆盖正常的对象创建步骤；\n1. `new User` 等同于 `new User()` ，只是没有指定参数列表，即 `User` 不带参数的情况；\n```javascript\nlet user = new User; // <-- 没有参数\n// 等同于\nlet user = new User();\n```\n\n3. 任何函数都可以作为构造器，即都可以使用 `new` 运算符运行。\n\n## 4. 构造函数中的方法\n在构造函数中，也可以将方法绑定到 `this` 上：\n```javascript\nfunction User (name){\n\tthis.name = name;\n  this.isAdmin = false; \n\tthis.sayHello = function(){\n\t\tconsole.log(\"hello \" + this.name);\n\t}\n}\nconst leo = new User('leo');\nconsole.log(leo.name, leo.isAdmin); // \"leo\" false\nleo.sayHello(); // \"hello leo\"\n```\n\n# 六、可选链 \"?.\"\n详细介绍可以查看 [《MDN 可选链操作符》](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/可选链) 。\n\n## 1. 背景介绍\n在实际开发中，常常出现下面几种报错情况：\n```javascript\n// 1. 对象中不存在指定属性\nconst leo = {};\nconsole.log(leo.name.toString()); \n// Uncaught TypeError: Cannot read property 'toString' of undefined\n\n// 2. 使用不存在的 DOM 节点属性\nconst dom = document.getElementById(\"dom\").innerHTML; \n// Uncaught TypeError: Cannot read property 'innerHTML' of null\n```\n在可选链 `?.` 出现之前，我们会使用短路操作 `&&` 运算符来解决该问题：\n```javascript\nconst leo = {};\nconsole.log(leo && leo.name && leo.name.toString()); // undefined\n```\n这种写法的缺点就是 **太麻烦了** 。\n\n## 2. 可选链介绍 \n可选链 `?.` 是一种 **访问嵌套对象属性的防错误方法** 。即使中间的属性不存在，也不会出现错误。\n如果可选链 `?.` 前面部分是 `undefined` 或者 `null`，它会停止运算并返回 `undefined`。\n\n语法：\n```javascript\nobj?.prop\nobj?.[expr]\narr?.[index]\nfunc?.(args)\n```\n**\n**我们改造前面示例代码：**\n```javascript\n// 1. 对象中不存在指定属性\nconst leo = {};\nconsole.log(leo?.name?.toString()); \n// undefined\n\n// 2. 使用不存在的 DOM 节点属性\nconst dom = document?.getElementById(\"dom\")?.innerHTML; \n// undefined\n```\n\n## 3. 使用注意\n可选链虽然好用，但需要注意以下几点：\n\n1. **不能过度使用可选链**；\n\n我们应该只将 `?.` 使用在一些属性或方法可以不存在的地方，以上面示例代码为例：\n```javascript\nconst leo = {};\nconsole.log(leo.name?.toString()); \n```\n这样写会更好，因为 `leo` 对象是必须存在，而 `name` 属性则可能不存在。\n\n2. **可选链 `?.` 之前的变量必须已声明**；\n\n在可选链 `?.` 之前的变量必须使用 `let/const/var` 声明，否则会报错：\n```javascript\nleo?.name;\n// Uncaught ReferenceError: leo is not defined\n```\n\n3. **可选链不能用于赋值** ；\n```javascript\nlet object = {};\nobject?.property = 1; \n// Uncaught SyntaxError: Invalid left-hand side in assignment\n```\n\n4. **可选链访问数组元素的方法** ；\n```javascript\nlet arrayItem = arr?.[42];\n```\n\n## 4. 其他情况：?.() 和 ?.[]\n需要说明的是 `?.` 是一个特殊的语法结构，而不是一个运算符，它还可以与其 `()` 和 `[]` 一起使用：\n\n### 4.1 可选链与函数调用 ?.()\n`?.()` 用于调用一个可能不存在的函数，比如：\n```javascript\nlet user1 = {\n  admin() {\n    alert(\"I am admin\");\n  }\n}\n\nlet user2 = {};\n\nuser1.admin?.(); // I am admin\nuser2.admin?.();\n```\n`?.()` 会检查它左边的部分：如果 admin 函数存在，那么就调用运行它（对于 `user1`）。否则（对于 `user2`）运算停止，没有错误。\n\n### 4.2 可选链和表达式 ?.[]\n`?.[]` 允许从一个可能不存在的对象上安全地读取属性。\n```javascript\nlet user1 = {\n  firstName: \"John\"\n};\n\nlet user2 = null; // 假设，我们不能授权此用户\n\nlet key = \"firstName\";\n\nalert( user1?.[key] ); // John\nalert( user2?.[key] ); // undefined\n\nalert( user1?.[key]?.something?.not?.existing); // undefined\n```\n\n## 5. 可选链 `?.` 语法总结\n可选链 `?.` 语法有三种形式：\n\n1. `obj?.prop` —— 如果 `obj` 存在则返回 `obj.prop`，否则返回 `undefined`。\n1. `obj?.[prop]` —— 如果 `obj` 存在则返回 `obj[prop]`，否则返回 `undefined`。\n1. `obj?.method()` —— 如果 `obj` 存在则调用 `obj.method()`，否则返回 `undefined`。\n\n正如我们所看到的，这些语法形式用起来都很简单直接。`?.` 检查左边部分是否为 `null/undefined`，如果不是则继续运算。\n`?.` 链使我们能够安全地访问嵌套属性。\n\n# 七、Symbol\n规范规定，JavaScript 中对象的属性只能为 **字符串类型** 或者 **Symbol类型** ，毕竟我们也只见过这两种类型。\n\n## 1. 概念介绍\nES6引入`Symbol`作为一种新的**原始数据类型**，表示**独一无二**的值，主要是为了**防止属性名冲突**。\nES6之后，JavaScript一共有其中数据类型：`Symbol`、`undefined`、`null`、`Boolean`、`String`、`Number`、`Object`。\n**简单使用**：\n```javascript\nlet leo = Symbol();\ntypeof leo; // \"symbol\"\n```\nSymbol 支持传入参数作为 Symbol 名，方便代码调试：\n**\n```javascript\nlet leo = Symbol(\"leo\");\n```\n\n## 2. 注意事项**\n\n- `Symbol`函数不能用`new`，会报错。\n\n由于`Symbol`是一个原始类型，不是对象，所以不能添加属性，它是类似于字符串的数据类型。\n```javascript\nlet leo = new Symbol()\n// Uncaught TypeError: Symbol is not leo constructor\n```\n\n- `Symbol`都是不相等的，**即使参数相同**。\n```javascript\n// 没有参数\nlet leo1 = Symbol();\nlet leo2 = Symbol();\nleo1 === leo2; // false \n\n// 有参数\nlet leo1 = Symbol('leo');\nlet leo2 = Symbol('leo');\nleo1 === leo2; // false\n```\n\n- `Symbol`不能与其他类型的值计算，会报错。\n```javascript\nlet leo = Symbol('hello');\nleo + \" world!\";  // 报错\n`${leo} world!`;  // 报错\n```\n\n- `Symbol` 不能自动转换为字符串，只能显式转换。\n```javascript\nlet leo = Symbol('hello');\nalert(leo); \n// Uncaught TypeError: Cannot convert a Symbol value to a string\n\nString(leo);    // \"Symbol(hello)\"\nleo.toString(); // \"Symbol(hello)\"\n```\n\n- `Symbol` 可以转换为布尔值，但不能转为数值：\n```javascript\nlet a1 = Symbol();\nBoolean(a1);\n!a1;        // false\nNumber(a1); // TypeError\na1 + 1 ;    // TypeError\n```\n\n- `Symbol` 属性不参与 `for...in/of` 循环。\n```javascript\nlet id = Symbol(\"id\");\nlet user = {\n  name: \"Leo\",\n  age: 30,\n  [id]: 123\n};\n\nfor (let key in user) console.log(key); // name, age (no symbols)\n\n// 使用 Symbol 任务直接访问\nconsole.log( \"Direct: \" + user[id] );\n```\n\n## 3. 字面量中使用 Symbol 作为属性名\n在对象字面量中使用 `Symbol` 作为属性名时，需要使用 **方括号** （ `[]` ），如 `[leo]: \"leo\"` 。\n好处：防止同名属性，还有防止键被改写或覆盖。\n```javascript\nlet leo = Symbol();\n// 写法1\nlet user = {};\nuser[leo] = 'leo';\n\n// 写法2\nlet user = {\n    [leo] : 'leo'\n} \n\n// 写法3\nlet user = {};\nObject.defineProperty(user, leo, {value : 'leo' });\n\n// 3种写法 结果相同\nuser[leo]; // 'leo'\n```\n\n**需要注意** ：Symbol作为对象属性名时，不能用点运算符，并且必须放在方括号内。\n```javascript\nlet leo = Symbol();\nlet user = {};\n// 不能用点运算\nuser.leo = 'leo';\nuser[leo] ; // undefined\nuser['leo'] ; // 'leo'\n\n// 必须放在方括号内\nlet user = {\n    [leo] : function (text){\n        console.log(text);\n    }\n}\nuser[leo]('leo'); // 'leo'\n\n// 上面等价于 更简洁\nlet user = {\n    [leo](text){\n        console.log(text);\n    }\n}\n```\n**常常还用于创建一组常量，保证所有值不相等**：\n```javascript\nlet user = {};\nuser.list = {\n    AAA: Symbol('Leo'),\n    BBB: Symbol('Robin'),\n    CCC: Symbol('Pingan')\n}\n```\n\n## 4. 应用：消除魔术字符串\n**魔术字符串**：指代码中多次出现，强耦合的字符串或数值，应该避免，而使用含义清晰的变量代替。\n```javascript\nfunction fun(name){\n    if(name == 'leo') {\n        console.log('hello');\n    }\n}\nfun('leo');   // 'hello' 为魔术字符串\n```\n\n常使用变量，消除魔术字符串：\n```javascript\nlet obj = {\n    name: 'leo'\n};\nfunction fun(name){\n    if(name == obj.name){\n        console.log('hello');\n    }\n}\nfun(obj.name); // 'hello'\n```\n\n使用`Symbol`消除强耦合，使得不需关系具体的值:\n```javascript\nlet obj = {\n    name: Symbol()\n};\nfunction fun (name){\n    if(name == obj.name){\n        console.log('hello');\n    }\n}\nfun(obj.name); // 'hello'\n```\n\n## 5. 属性名遍历\nSymbol作为属性名遍历，不出现在`for...in`、`for...of`循环，也不被`Object.keys()`、`Object.getOwnPropertyNames()`、`JSON.stringify()`返回。\n```javascript\nlet leo = Symbol('leo'), robin = Symbol('robin');\nlet user = {\n    [leo]:'18', [robin]:'28'\n}\nfor(let k of Object.values(user)){console.log(k)}\n// 无输出\n\nlet user = {};\nlet leo = Symbol('leo');\nObject.defineProperty(user, leo, {value: 'hi'});\nfor(let k in user){\n    console.log(k); // 无输出\n}\nObject.getOwnPropertyNames(user);   // []\nObject.getOwnPropertySymbols(user); // [Symbol(leo)]\n```\n`Object.getOwnPropertySymbols`方法返回一个数组，包含当前对象所有用做属性名的Symbol值。\n```javascript\nlet user = {};\nlet leo = Symbol('leo');\nlet pingan = Symbol('pingan');\nuser[leo] = 'hi leo';\nuser[pingan] = 'hi pingan';\nlet obj = Object.getOwnPropertySymbols(user);\nobj; //  [Symbol(leo), Symbol(pingan)]\n```\n\n另外可以使用`Reflect.ownKeys`方法可以返回所有类型的键名，包括常规键名和 Symbol 键名。\n```javascript\nlet user = {\n    [Symbol('leo')]: 1,\n    age : 2, \n    address : 3,\n}\nReflect.ownKeys(user); // ['age', 'address',Symbol('leo')]\n```\n\n由于Symbol值作为名称的属性不被常规方法遍历获取，因此常用于定义对象的一些非私有，且内部使用的方法。\n\n## 6. Symbol.for()、Symbol.keyFor()\n\n### 6.1 Symbol.for()\n**用于重复使用一个Symbol值**，接收一个**字符串**作为参数，若存在用此参数作为名称的Symbol值，返回这个Symbol，否则新建并返回以这个参数为名称的Symbol值。\n```javascript\nlet leo = Symbol.for('leo');\nlet pingan = Symbol.for('leo');\nleo === pingan;  // true\n```\n\n`Symbol()` 和 `Symbol.for()`区别：\n```javascript\nSymbol.for('leo') === Symbol.for('leo'); // true\nSymbol('leo') === Symbol('leo');         // false\n```\n\n### 6.2 Symbol.keyFor()\n**用于返回一个已使用的Symbol类型的key**:\n```javascript\nlet leo = Symbol.for('leo');\nSymbol.keyFor(leo);   //  'leo'\n\nlet leo = Symbol('leo');\nSymbol.keyFor(leo);   //  undefined\n```\n\n## 7. 内置的Symbol值\nES6提供11个内置的Symbol值，指向语言内部使用的方法：\n\n### 7.1 Symbol.hasInstance\n当其他对象使用`instanceof`运算符，判断是否为该对象的实例时，会调用这个方法。比如，`foo instanceof Foo`在语言内部，实际调用的是`Foo[Symbol.hasInstance](foo)`。\n```javascript\nclass P {\n    [Symbol.hasInstance](a){\n        return a instanceof Array;\n    }\n}\n[1, 2, 3] instanceof new P(); // true\n```\nP是一个类，new P()会返回一个实例，该实例的`Symbol.hasInstance`方法，会在进行`instanceof`运算时自动调用，判断左侧的运算子是否为`Array`的实例。\n\n### 7.2 Symbol.isConcatSpreadable\n值为布尔值，表示该对象用于`Array.prototype.concat()`时，是否可以展开。\n```javascript\nlet a = ['aa','bb'];\n['cc','dd'].concat(a, 'ee'); \n// ['cc', 'dd', 'aa', 'bb', 'ee']\na[Symbol.isConcatSpreadable]; // undefined\nlet b = ['aa','bb']; \nb[Symbol.isConcatSpreadable] = false; \n['cc','dd'].concat(b, 'ee'); \n// ['cc', 'dd',[ 'aa', 'bb'], 'ee']\n```\n\n### 7.3 Symbol.species\n指向一个构造函数，在创建衍生对象时会使用，使用时需要用`get`取值器。\n```javascript\nclass P extends Array {\n    static get [Symbol.species](){\n        return this;\n    }\n}\n```\n解决下面问题：\n```javascript\n// 问题：  b应该是 Array 的实例，实际上是 P 的实例\nclass P extends Array{}\nlet a = new P(1,2,3);\nlet b = a.map(x => x);\nb instanceof Array; // true\nb instanceof P; // true\n// 解决：  通过使用 Symbol.species\nclass P extends Array {\n  static get [Symbol.species]() { return Array; }\n}\nlet a = new P();\nlet b = a.map(x => x);\nb instanceof P;     // false\nb instanceof Array; // true\n```\n\n### 7.4 Symbol.match\n当执行`str.match(myObject)`，传入的属性存在时会调用，并返回该方法的返回值。\n```javascript\nclass P {\n    [Symbol.match](string){\n        return 'hello world'.indexOf(string);\n    }\n}\n'h'.match(new P());   // 0\n```\n\n### 7.5 Symbol.replace\n当该对象被`String.prototype.replace`方法调用时，会返回该方法的返回值。\n```javascript\nlet a = {};\na[Symbol.replace] = (...s) => console.log(s);\n'Hello'.replace(a , 'World') // [\"Hello\", \"World\"]\n```\n\n### 7.6 Symbol.hasInstance\n当该对象被`String.prototype.search`方法调用时，会返回该方法的返回值。\n```javascript\nclass P {\n    constructor(val) {\n        this.val = val;\n    }\n    [Symbol.search](s){\n        return s.indexOf(this.val);\n    }\n}\n'hileo'.search(new P('leo')); // 2\n```\n\n### 7.7 Symbol.split\n当该对象被`String.prototype.split`方法调用时，会返回该方法的返回值。\n```javascript\n// 重新定义了字符串对象的split方法的行为\nclass P {\n    constructor(val) {\n        this.val = val;\n    }\n    [Symbol.split](s) {\n        let i = s.indexOf(this.val);\n        if(i == -1) return s;\n        return [\n            s.substr(0, i),\n            s.substr(i + this.val.length)\n        ]\n    }\n}\n'helloworld'.split(new P('hello')); // [\"hello\", \"\"]\n'helloworld'.split(new P('world')); // [\"\", \"world\"] \n'helloworld'.split(new P('leo'));   // \"helloworld\"\n```\n\n### 7.8 Symbol.iterator\n对象进行`for...of`循环时，会调用`Symbol.iterator`方法，返回该对象的默认遍历器。\n```javascript\nclass P {\n    *[Symbol.interator]() {\n        let i = 0;\n        while(this[i] !== undefined ) {\n            yield this[i];\n            ++i;\n        }\n    }\n}\nlet a = new P();\na[0] = 1;\na[1] = 2;\nfor (let k of a){\n    console.log(k);\n}\n```\n\n### 7.9.Symbol.toPrimitive\n该对象被转为原始类型的值时，会调用这个方法，返回该对象对应的原始类型值。调用时，需要接收一个字符串参数，表示当前运算模式，运算模式有：\n\n   - Number : 此时需要转换成数值\n   - String : 此时需要转换成字符串\n   - Default : 此时可以转换成数值或字符串\n```javascript\nlet obj = {\n  [Symbol.toPrimitive](hint) {\n    switch (hint) {\n      case 'number':\n        return 123;\n      case 'string':\n        return 'str';\n      case 'default':\n        return 'default';\n      default:\n        throw new Error();\n     }\n   }\n};\n2 * obj // 246\n3 + obj // '3default'\nobj == 'default' // true\nString(obj) // 'str'\n```\n\n### 7.10 Symbol.toStringTag\n在该对象上面调用`Object.prototype.toString`方法时，如果这个属性存在，它的返回值会出现在`toString`方法返回的字符串之中，表示对象的类型。也就是说，这个属性可以用来定制`[object Object`]或`[object Array]`中`object`后面的那个字符串。\n```javascript\n// 例一\n({[Symbol.toStringTag]: 'Foo'}.toString())\n// \"[object Foo]\"\n// 例二\nclass Collection {\n  get [Symbol.toStringTag]() {\n    return 'xxx';\n  }\n}\nlet x = new Collection();\nObject.prototype.toString.call(x) // \"[object xxx]\"\n```\n\n### 7.11 Symbol.unscopables\n该对象指定了使用with关键字时，哪些属性会被with环境排除。\n```javascript\n// 没有 unscopables 时\nclass MyClass {\n  foo() { return 1; }\n}\nvar foo = function () { return 2; };\nwith (MyClass.prototype) {\n  foo(); // 1\n}\n// 有 unscopables 时\nclass MyClass {\n  foo() { return 1; }\n  get [Symbol.unscopables]() {\n    return { foo: true };\n  }\n}\nvar foo = function () { return 2; };\nwith (MyClass.prototype) {\n  foo(); // 2\n}\n```\n上面代码通过指定`Symbol.unscopables`属性，使得`with`语法块不会在当前作用域寻找`foo`属性，即`foo`将指向外层作用域的变量。\n\n# 八、原始值转换\n前面复习到字符串、数值、布尔值等的转换，但是没有讲到对象的转换规则，这部分就一起看看：。\n需要记住几个规则：\n\n1. 所有对象在布尔上下文中都为 `true` ，并且不存在转换为布尔值的操作，只有字符串和数值转换有。\n1. 数值转换发生在对象相减或应用数学函数时。如 `Date` 对象可以相减，如 `date1 - date2` 结果为两个时间的差值。\n1. 在字符串转换，通常出现在如 `alert(obj)` 这种形式。\n\n当然我们可以使用特殊的对象方法，对字符串和数值转换进行微调。下面介绍三个类型（hint）转换情况：\n\n## 1. object to string\n对象到字符串的转换，当我们对期望一个字符串的对象执行操作时，如 “alert”：\n```javascript\n// 输出\nalert(obj);\n// 将对象作为属性键\nanotherObj[obj] = 123;\n```\n\n## 2. object to number\n对象到数字的转换，例如当我们进行数学运算时：\n```javascript\n// 显式转换\nlet num = Number(obj);\n// 数学运算（除了二进制加法）\nlet n = +obj; // 一元加法\nlet delta = date1 - date2;\n// 小于/大于的比较\nlet greater = user1 > user2;\n```\n\n## 3. object to default\n少数情况下，**当运算符“不确定”期望值类型时**。\n例如，二进制加法 `+` 可用于字符串（连接），也可以用于数字（相加），所以字符串和数字这两种类型都可以。因此，当二元加法得到对象类型的参数时，它将依据 `\"default\"` 来对其进行转换。\n此外，如果对象被用于与字符串、数字或 symbol 进行 `==` 比较，这时到底应该进行哪种转换也不是很明确，因此使用 `\"default\"` 。\n```javascript\n// 二元加法使用默认 hint\nlet total = obj1 + obj2;\n// obj == number 使用默认 hint\nif (user == 1) { ... };\n```\n\n## 4. 类型转换算法\n**为了进行转换，JavaScript 尝试查找并调用三个对象方法：**\n\n1. 调用 `obj[Symbol.toPrimitive](hint)` —— 带有 symbol 键 `Symbol.toPrimitive`（系统 symbol）的方法，如果这个方法存在的话，\n1. 否则，如果 hint 是 `\"string\"` —— 尝试 `obj.toString()` 和 `obj.valueOf()`，无论哪个存在。\n1. 否则，如果 hint 是 `\"number\"` 或 `\"default\"` —— 尝试 `obj.valueOf()` 和 `obj.toString()`，无论哪个存在。\n\n## 5. Symbol.toPrimitive\n详细介绍可阅读[《MDN | Symbol.toPrimitive》](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Symbol/toPrimitive) 。\n`Symbol.toPrimitive` 是一个内置的 Symbol 值，它是作为对象的函数值属性存在的，当一个对象转换为对应的原始值时，会调用此函数。\n简单示例介绍：\n```javascript\nlet user = {\n  name: \"Leo\",\n  money: 9999,\n\n  [Symbol.toPrimitive](hint) {\n    console.log(`hint: ${hint}`);\n    return hint == \"string\" ? `{name: \"${this.name}\"}` : this.money;\n  }\n};\n\nalert(user);     // 控制台：hint: string 弹框：{name: \"John\"}\nalert(+user);    // 控制台：hint: number 弹框：9999\nalert(user + 1); // 控制台：hint: default 弹框：10000\n```\n\n## 6. toString/valueOf\n[`toString`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/toString) / `valueOf` 是两个比较早期的实现转换的方法。当没有 `Symbol.toPrimitive` ，那么 JavaScript 将尝试找到它们，并且按照下面的顺序进行尝试：\n\n- 对于 “string” hint，`toString -> valueOf`。\n- 其他情况，`valueOf -> toString`。\n\n这两个方法必须返回一个原始值。如果 `toString` 或 `valueOf` 返回了一个对象，那么返回值会被忽略。默认情况下，普通对象具有 `toString` 和 `valueOf` 方法：\n\n- `toString` 方法返回一个字符串 `\"[object Object]\"`。\n- `valueOf` 方法返回对象自身。\n\n简单示例介绍：\n```javascript\nconst user = {name: \"Leo\"};\n\nalert(user); // [object Object]\nalert(user.valueOf() === user); // true\n```\n\n我们也可以结合 `toString` / `valueOf`  实现前面第 5 点介绍的 `user` 对象：\n```javascript\nlet user = {\n  name: \"Leo\",\n  money: 9999,\n\n  // 对于 hint=\"string\"\n  toString() {\n    return `{name: \"${this.name}\"}`;\n  },\n\n  // 对于 hint=\"number\" 或 \"default\"\n  valueOf() {\n    return this.money;\n  }\n\n};\n\nalert(user);     // 控制台：hint: string 弹框：{name: \"John\"}\nalert(+user);    // 控制台：hint: number 弹框：9999\nalert(user + 1); // 控制台：hint: default 弹框：10000\n```\n\n# 总结\n本文作为《初中级前端 JavaScript 自测清单》第二部分，介绍的内容以 JavaScript 对象为主，其中有让我眼前一亮的知识点，如 `Symbol.toPrimitive` 方法。我也希望这个清单能帮助大家自测自己的 JavaScript 水平并查缺补漏，温故知新。\n", "user_name": "pingan8787", "description": "Leo , love coding , love life ~📣「前端自习课」公众号", "got_view_count": 222862, "category_name": "前端", "ctime": 1457483942}
{"tag_name": "JavaScript", "concern_user_count": 343215, "user_id": "2858385961407853", "title": "在Vue中使用装饰器，我是认真的", "mark_content": "> 产品上线事繁多，测试产品催不离。\n> 休问Bug剩多少，眼圈如漆身如泥。\n\n作为一个曾经的`Java coder`, 当我第一次看到`js`里面的装饰器(`Decorator`)的时候，就马上想到了`Java`中的注解，当然在实际原理和功能上面，`Java`的注解和`js`的装饰器还是有很大差别的。本文题目是`Vue中使用装饰器，我是认真的`，但本文将从装饰器的概念开发聊起，一起来看看吧。\n\n通过本文内容，你将学到以下内容:\n\n1. 了解什么是装饰器\n2. 在方法使用装饰器\n3. 在`class`中使用装饰器\n4. 在`Vue`中使用装饰器\n\n> 本文首发于公众号【前端有的玩】，不想当咸鱼，想要换工作，关注公众号，带你每日一起刷大厂面试题，关注 `=== `大厂`offer`。\n\n## 什么是装饰器\n\n装饰器是`ES2016`提出来的一个提案，当前处于`Stage 2`阶段，关于装饰器的体验，可以点击 [https://github.com/tc39/proposal-decorators](https://github.com/tc39/proposal-decorators)查看详情。装饰器是一种与类相关的语法糖，用来包装或者修改类或者类的方法的行为，其实装饰器就是设计模式中装饰者模式的一种实现方式。不过前面说的这些概念太干了，我们用人话来翻译一下，举一个例子。\n\n在日常开发写`bug`过程中，我们经常会用到防抖和节流，比如像下面这样\n\n```javascript\nclass MyClass {\n  follow = debounce(function() {\n    console.log('我是子君，关注我哦')\n  }, 100)\n}\n\nconst myClass = new MyClass()\n// 多次调用只会输出一次\nmyClass.follow()\nmyClass.follow()\n```\n\n上面是一个防抖的例子，我们通过`debounce`函数将另一个函数包起来，实现了防抖的功能，这时候再有另一个需求，比如希望在调用`follow`函数前后各打印一段日志，这时候我们还可以再开发一个`log`函数，然后继续将`follow`包装起来\n\n```javascript\n/**\n * 最外层是防抖，否则log会被调用多次\n */\nclass MyClass {\n  follow = debounce(\n    log(function() {\n      console.log('我是子君，关注我哦')\n    }),\n    100\n  )\n}\n```\n\n上面代码中的`debounce`和`log`两个函数，本质上是两个包装函数，通过这两个函数对原函数的包装，使原函数的行为发生了变化，而`js`中的装饰器的原理就是这样的，我们使用装饰器对上面的代码进行改造\n\n```javascript\nclass MyClass {\n  @debounce(100)\n  @log\n  follow() {\n    console.log('我是子君，关注我哦')\n  }\n}\n```\n\n装饰器的形式就是 `@ + 函数名`，如果有参数的话，后面的括号里面可以传参\n\n## 在方法上使用装饰器\n\n装饰器可以应用到`class`上或者`class`里面的属性上面，但一般情况下，应用到`class`属性上面的场景会比较多一些，比如像上面我们说的`log`,`debounce`等等，都一般会应用到类属性上面，接下来我们一起来具体看一下如何实现一个装饰器，并应用到类上面。在实现装饰器之前，我们需要先了解一下属性描述符\n\n### 了解一下属性描述符\n\n在我们定义一个对象里面的属性的时候，其实这个属性上面是有许多属性描述符的，这些描述符标明了这个属性能不能修改，能不能枚举，能不能删除等等，同时`ECMAScript`将这些属性描述符分为两类，分别是数据属性和访问器属性，并且数据属性与访问器属性是不能共存的。\n\n#### 数据属性\n\n数据属性包含一个数据值的位置，在这个位置可以读取和写入值。数据属性包含了四个描述符，分别是\n\n1. `configurable`\n\n   表示能不能通过`delete`删除属性，能否修改属性的其他描述符特性，或者能否将数据属性修改为访问器属性。当我们通过`let obj = {name: ''}`声明一个对象的时候，这个对象里面所有的属性的`configurable`描述符的值都是`true`\n\n2. `enumerable`\n\n   表示能不能通过`for in`或者`Object.keys`等方式获取到属性，我们一般声明的对象里面这个描述符的值是`true`,但是对于`class`类里面的属性来说，这个值是`false`\n\n3. `writable`\n\n   表示能否修改属性的数据值，通过将这个修改为`false`,可以实现属性只读的效果。\n\n4. `value`\n\n   表示当前属性的数据值，读取属性值的时候，从这里读取；写入属性值的时候，会写到这个位置。\n\n#### 访问器属性\n\n访问器属性不包含数据值，他们包含了`getter`与`setter`两个函数，同时`configurable`与`enumerable`是数据属性与访问器属性共有的两个描述符。\n\n1. `getter`\n\n   在读取属性的时候调用这个函数，默认这个函数为`undefined`\n\n2. `setter`\n\n   在写入属性值的时候调用这个函数，默认这个函数为`undefined`\n\n了解了这六个描述符之后，你可能会有几个疑问： 我如何去定义修改这些属性描述符？这些属性描述符与今天的文章主题有什么关系？接下来是揭晓答案的时候了。\n\n### 使用`Object.defineProperty`\n\n了解过`vue2.0`双向绑定原理的同学一定知道，`Vue`的双向绑定就是通过使用`Object.defineProperty`去定义数据属性的`getter`与`setter`方法来实现的，比如下面有一个对象\n\n```javascript\nlet obj = {\n  name: '子君',\n  officialAccounts: '前端有的玩'\n}\n```\n\n我希望这个对象里面的用户名是不能被修改的，用`Object.defineProperty`该如何定义呢?\n\n```javascript\nObject.defineProperty(obj,'name', {\n  // 设置writable 是 false, 这个属性将不能被修改\n  writable: false\n})\n// 修改obj.name\nobj.name = \"君子\"\n// 打印依然是子君\nconsole.log(obj.name)\n```\n\n通过`Object.defineProperty`可以去定义或者修改对象属性的属性描述符，但是因为数据属性与访问器属性是互斥的，所以一次只能修改其中的一类，这一点需要注意。\n\n### 定义一个防抖装饰器\n\n装饰器本质上依然是一个函数，不过这个函数的参数是固定的，如下是防抖装饰器的代码\n\n```javascript\n/**\n*@param wait 延迟时长\n*/\nfunction debounce(wait) {\n  return function(target, name, descriptor) {\n    descriptor.value = debounce(descriptor.value, wait)\n  }\n}\n// 使用方式\nclass MyClass {\n  @debounce(100)\n  follow() {\n    console.log('我是子君，我的公众号是 【前端有的玩】，关注有惊喜哦')\n  }\n}\n```\n\n我们逐行去分析一下代码\n\n1. 首先我们定义了一个 `debounce`函数，同时有一个参数`wait`，这个函数对应的就是在下面调用装饰器时使用的`@debounce(100)`\n2. `debounce`函数返回了一个新的函数，这个函数即装饰器的核心，这个函数有三个参数，下面逐一分析\n   1. `target`: 这个类属性函数是在谁上面挂载的，如上例对应的是`MyClass`类\n   2. `name`: 这个类属性函数的名称，对应上面的`follow`\n   3. `descriptor`: 这个就是我们前面说的属性描述符，通过直接`descriptor`上面的属性，即可实现属性只读，数据重写等功能\n3. 然后第三行 `descriptor.value = debounce(descriptor.value, wait)`, 前面我们已经了解到,属性描述符上面的`value`对应的是这个属性的值，所以我们通过重写这个属性，将其用`debounce`函数包装起来，这样在函数调用`follow`时实际调用的是包装后的函数\n\n通过上面的三步，我们就实现了类属性上面可使用的装饰器，同时将其应用到了类属性上面\n\n## 在`class`上使用装饰器\n\n装饰器不仅可以应用到类属性上面，还可以直接应用到类上面，比如我希望可以实现一个类似`Vue`混入那样的功能，给一个类混入一些方法属性，应该如何去做呢?\n\n```javascript\n// 这个是要混入的对象\nconst methods = {\n  logger() {\n    console.log('记录日志')\n  }\n}\n\n// 这个是一个登陆登出类\nclass Login{\n  login() {}\n  logout() {}\n}\n```\n\n如何将上面的`methods`混入到`Login`中，首先我们先实现一个类装饰器\n\n```javascript\nfunction mixins(obj) {\n  return function (target) {\n    Object.assign(target.prototype, obj)  \n  }\n}\n\n// 然后通过装饰器混入\n@mixins(methods)\nclass Login{\n  login() {}\n  logout() {}\n}\n\n```\n\n这样就实现了类装饰器。对于类装饰器，只有一个参数，即`target`,对应的就是这个类本身。\n\n了解完装饰器，我们接下来看一下如何在`Vue`中使用装饰器。\n\n## 在`Vue`中使用装饰器\n\n使用`ts`开发`Vue`的同学一定对`vue-property-decorator`不会感到陌生，这个插件提供了许多装饰器，方便大家开发的时候使用，当然本文的中点不是这个插件。其实如果我们的项目没有使用`ts`，也是可以使用装饰器的，怎么用呢？\n\n### 配置基础环境\n\n除了一些老的项目，我们现在一般新建`Vue`项目的时候，都会选择使用脚手架`vue-cli3/4`来新建，这时候新建的项目已经默认支持了装饰器，不需要再配置太多额外的东西，如果你的项目使用了`eslint`,那么需要给`eslint`配置以下内容。\n\n```javascript\n  parserOptions: {\n    ecmaFeatures:{\n      // 支持装饰器\n      legacyDecorators: true\n    }\n  }\n```\n\n### 使用装饰器\n\n虽然`Vue`的组件，我们一般书写的时候`export`出去的是一个对象，但是这个并不影响我们直接在组件中使用装饰器，比如就拿上例中的`log`举例。\n\n```javascript\nfunction log() {\n  /**\n   * @param target 对应 methods 这个对象\n   * @param name 对应属性方法的名称\n   * @param descriptor 对应属性方法的修饰符\n   */\n  return function(target, name, descriptor) {\n    console.log(target, name, descriptor)\n    const fn = descriptor.value\n    descriptor.value = function(...rest) {\n      console.log(`这是调用方法【${name}】前打印的日志`)\n      fn.call(this, ...rest)\n      console.log(`这是调用方法【${name}】后打印的日志`)\n    }\n  }\n}\n\nexport default {\n  created() {\n    this.getData()\n  },\n  methods: {\n    @log()\n    getData() {\n      console.log('获取数据')\n    }\n  }\n}\n```\n\n看了上面的代码，是不是发现在`Vue`中使用装饰器还是很简单的，和在`class`的属性上面使用的方式一模一样，但有一点需要注意，在`methods`里面的方法上面使用装饰器，这时候装饰器的`target`对应的是`methods`。\n\n除了在`methods`上面可以使用装饰器之外，你也可以在生命周期钩子函数上面使用装饰器，这时候`target`对应的是整个组件对象。\n\n### 一些常用的装饰器\n\n下面小编罗列了几个小编在项目中常用的几个装饰器，方便大家使用\n\n#### 1. 函数节流与防抖\n\n函数节流与防抖应用场景是比较广的，一般使用时候会通过`throttle`或`debounce`方法对要调用的函数进行包装，现在就可以使用上文说的内容将这两个函数封装成装饰器， 防抖节流使用的是`lodash`提供的方法，大家也可以自行实现节流防抖函数哦\n\n```javascript\nimport { throttle, debounce } from 'lodash'\n/**\n * 函数节流装饰器\n * @param {number} wait 节流的毫秒\n * @param {Object} options 节流选项对象\n * [options.leading=true] (boolean): 指定调用在节流开始前。\n * [options.trailing=true] (boolean): 指定调用在节流结束后。\n */\nexport const throttle =  function(wait, options = {}) {\n  return function(target, name, descriptor) {\n    descriptor.value = throttle(descriptor.value, wait, options)\n  }\n}\n\n/**\n * 函数防抖装饰器\n * @param {number} wait 需要延迟的毫秒数。\n * @param {Object} options 选项对象\n * [options.leading=false] (boolean): 指定在延迟开始前调用。\n * [options.maxWait] (number): 设置 func 允许被延迟的最大值。\n * [options.trailing=true] (boolean): 指定在延迟结束后调用。\n */\nexport const debounce = function(wait, options = {}) {\n  return function(target, name, descriptor) {\n    descriptor.value = debounce(descriptor.value, wait, options)\n  }\n}\n```\n\n封装完之后，在组件中使用\n\n```javascript\nimport {debounce} from '@/decorator'\n\nexport default {\n  methods:{\n    @debounce(100)\n    resize(){}\n  }\n}\n```\n\n\n\n#### 2. loading\n\n在加载数据的时候，为了个用户一个友好的提示，同时防止用户继续操作，一般会在请求前显示一个loading,然后在请求结束之后关掉loading，一般写法如下\n\n```javascript\nexport default {\n  methods:{\n    async getData() {\n      const loading = Toast.loading()\n      try{\n        const data = await loadData()\n        // 其他操作\n      }catch(error){\n        // 异常处理\n        Toast.fail('加载失败');\n      }finally{\n        loading.clear()\n      }  \n    }\n  }\n}\n```\n\n我们可以把上面的`loading`的逻辑使用装饰器重新封装，如下代码\n\n```javascript\nimport { Toast } from 'vant'\n\n/**\n * loading 装饰器\n * @param {*} message 提示信息\n * @param {function} errorFn 异常处理逻辑\n */\nexport const loading =  function(message = '加载中...', errorFn = function() {}) {\n  return function(target, name, descriptor) {\n    const fn = descriptor.value\n    descriptor.value = async function(...rest) {\n      const loading = Toast.loading({\n        message: message,\n        forbidClick: true\n      })\n      try {\n        return await fn.call(this, ...rest)\n      } catch (error) {\n        // 在调用失败，且用户自定义失败的回调函数时，则执行\n        errorFn && errorFn.call(this, error, ...rest)\n        console.error(error)\n      } finally {\n        loading.clear()\n      }\n    }\n  }\n}\n\n```\n\n然后改造上面的组件代码\n\n```javascript\nexport default {\n  methods:{\n    @loading('加载中')\n    async getData() {\n      try{\n        const data = await loadData()\n        // 其他操作\n      }catch(error){\n        // 异常处理\n        Toast.fail('加载失败');\n      }  \n    }\n  }\n}\n```\n\n#### 3. 确认框\n\n当你点击删除按钮的时候，一般都需要弹出一个提示框让用户确认是否删除，这时候常规写法可能是这样的\n\n```javascript\nimport { Dialog } from 'vant'\n\nexport default {\n  methods: {\n    deleteData() {\n      Dialog.confirm({\n        title: '提示',\n        message: '确定要删除数据，此操作不可回退。'\n      }).then(() => {\n        console.log('在这里做删除操作')\n      })\n    }\n  }\n}\n```\n\n我们可以把上面确认的过程提出来做成装饰器，如下代码\n\n```javascript\nimport { Dialog } from 'vant'\n\n/**\n * 确认提示框装饰器\n * @param {*} message 提示信息\n * @param {*} title 标题\n * @param {*} cancelFn 取消回调函数\n */\nexport function confirm(\n  message = '确定要删除数据，此操作不可回退。',\n  title = '提示',\n  cancelFn = function() {}\n) {\n  return function(target, name, descriptor) {\n    const originFn = descriptor.value\n    descriptor.value = async function(...rest) {\n      try {\n        await Dialog.confirm({\n          message,\n          title: title\n        })\n        originFn.apply(this, rest)\n      } catch (error) {\n        cancelFn && cancelFn(error)\n      }\n    }\n  }\n}\n```\n\n然后再使用确认框的时候，就可以这样使用了\n\n```javascript\nexport default {\n  methods: {\n    // 可以不传参，使用默认参数\n    @confirm()\n    deleteData() {\n      console.log('在这里做删除操作')\n    }\n  }\n}\n```\n\n是不是瞬间简单多了,当然还可以继续封装很多很多的装饰器，因为文章内容有限，暂时提供这三个。\n\n### 装饰器组合使用\n\n在上面我们将类属性上面使用装饰器的时候，说道装饰器可以组合使用，在`Vue`组件上面使用也是一样的，比如我们希望在确认删除之后，调用接口时候出现`loading`，就可以这样写(一定要注意顺序)\n\n```javascript\nexport default {\n  methods: {\n    @confirm()\n    @loading()\n    async deleteData() {\n      await delete()\n    }\n  }\n}\n```\n\n> 本节定义的装饰器，均已应用到这个项目中 [https://github.com/snowzijun/vue-vant-base](https://github.com/snowzijun/vue-vant-base), 这是一个基于`Vant`开发的开箱即用移动端框架，你只需要`fork`下来，无需做任何配置就可以直接进行业务开发，欢迎使用，喜欢麻烦给一个`star`。\n\n我是子君，今天就写这么多，本文首发于公众号【前端有的玩】，欢迎关注。\n\n## 结语\n\n> 不要吹灭你的灵感和你的想象力; 不要成为你的模型的奴隶。 ——文森特・梵高", "user_name": "前端进击者", "description": "技术日新月异，我愿紧随不舍。个人公众号【前端有的玩】", "got_view_count": 313497, "category_name": "前端", "ctime": 1457483942}
{"tag_name": "程序员", "concern_user_count": 238890, "user_id": "2101921964109880", "title": "你可以 CRUD，但你不是 CRUD 程序员！", "mark_content": "## 什么是务实\n\n务实程序员他们总是在面临问题时，透过问题看到本质，从具体的场景出发，从大局着想，了解整个问题的来龙去脉，他们会对自己的行为负责，在项目面临问题时，他们不会撒手不管或者任由风险一步步扩大直至无法维护。\n\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/35782b1733154656b679e13b83ac17ee~tplv-k3u1fbpfcp-zoom-1.image)\n\n大多数人都不是务实的程序员，因为成为务实的程序员并不满足 `短期的利益`，需要长期的打磨和持续不断的学习、思考反思。大多数人不是务实的程序员的原因只有一个：`惰性使然`。\n\n程序员是有`戾气`的，许多人向我抱怨\n\n* 工作很久了，年龄也比较大了，感觉工作这些年以来在技术方向上没什么提升\n\n对这些人我有话说：没有及时反思，可能也是由于工作一直很忙，没有停下来静心思考。因为我相信任何有时间思考的程序员，都不会有这种想法。善于反思自己你会及时调整最近的状态，系统化的学习，提高自己的核心竞争力，让自己成为公司不可轻易替代的人才。\n\n* 整天 CRUD，项目技术栈用的比较老旧，想要接触新项目，想要去互联网\n\n对这些人我有话说：整天 CRUD 不是你找理由的根本！CRUD 的业余时间完全有时间提升自己！我也是 CRUD，但我不是一个 CRUD 程序员！千万不要给自己扣各种 CRUD 的帽子。项目技术栈用的比较老旧，我想说，计算机世界发展了 60 多年到现在，仍然只能识别 0 和 1 ，要专注于不变的根本。如果你学完操作系统，你就知道软件最终离不开操作系统，你就知道管程是怎么回事，操作系统实现不同调度算法的抉择时什么。我曾经说我喜欢技术，想要接触新的技术栈，当我被问及你知道哪些 `hibernate` 思想到现在仍然流行，`mybatis` 哪些思想仍然很老旧的时候，你就会发现，技术的新潮只是一时的，没有永远不过时的技术！我听很多前辈讲起，在零几年的时候谁说自己进了互联网那完全是等着被人嘲笑的！为什么互联网现在流行？因为它符合我们大众的诉求！无现金支付，工作之余的放松，饿了就不想自己去买饭，实体购物又麻烦而且还要化解和各种店员的尴尬！！！但是互联网是无法落地的，在发展到一定规模和平台后，互联网也是最重要被淘汰的！而硬件、芯片、通信这些才是永远新潮的技术，只不过无法获取眼前的 feedback，很多高素质人才也不想从事罢了！\n\n* 我应该学哪些技术\n\n对这些人我有话说：这个问题本身就没有意义！没有人能够指导你学哪些技术！问这句话的目的就是想走捷径，但是学习是没有捷径的！学你想学的，学和你工作相关的，学能够让你提升核心竞争力的！如果非要让我说出要学什么话，我建议学基础，学基础，学基础，基础就是计算机组成原理、操作系统、网络、编译原理\n\n>针对上面这些人，我认为他们只是难以接受改变，我认为这类人是 `煮熟的青蛙`。这个故事你一定听说过，它说的就是把青蛙放在慢慢加热的锅炉里面，刚开始青蛙感觉温度很舒适，随着慢慢加热，青蛙已经无力跳出锅炉了！\n>\n>而另外一种人是 `把青蛙仍在滚烫的锅炉里` 的人，它肯定想尽办法跳出来，这类人会想尽一切办法克服困难。\n\n## 不要给自己的人生设限\n\n李小龙曾经说过：**我活着不是为了满足你的期望，正如你也不是因为我的期望**。\n\n说的丧一点就是 **诸君看我多装逼，我料诸君应如是**\n\n软件开发行业绝对是最吃香的行业，因为我们收入颇丰，因为我们可以选择我们想要的工作，我们可以选择办公地点，我们可以实现财务自由，但这些前提是你要有能力。\n\n为什么有人喜欢抱怨呢？因为他们不曾想着改变，`Martin Fowler` 说过 **你可以去改变组织，或者让自己换一个组织**，总的来说，你是自由的，你可以做你想做的。\n\n不知道你听过 `墨菲定律` 没有？最简单的表达形式是越怕出事，越会出事，拿我们老祖宗的话就是 **怕什么，来什么**，但是在软件开发中，出现问题是再正常不过的事情了，就算你有完善的需求、设计文档，完备的自动化测试流程，多轮测试迭代，还是会出现问题，推迟交付，未曾预料的问题的出现。\n\n所以，不要惧怕问题，因为问题任何时刻都会出现，当问题出现时，我们应该依靠我们的专业性去解决问题，我们犯了错误要勇于承认，我们必须坦诚。\n\n勇于承担责任，不要把问题归咎于别人或者其他事情上，也不要寻找藉口，不要把问题归功于环境、编程语言、时间或者同事，这些因素可能影响你，但不是让你找的借口\n\n设想一下，比如银行职员、超市售货员、汽车修理工搪塞或者敷衍你的时候，你是什么反应？是不是恨不得想他了他们的门店？你会如何看待他们的公司？那如果是你呢？你的上司或者甲方会怎么看你？\n\n### 破窗效应\n\n`破窗效应`说的是，如何把一座富丽堂皇的别墅变成一片废墟？也许你只需要一扇破窗，这就是破窗效应的威力。\n\n那么为什么破窗效应的威力这么强大呢？一扇破窗，如果一段时间不去修理和修复，别墅中的主人就会潜移默化产生一种这座别墅很老旧的想法，久而久之更多的窗户也慢慢积满灰尘，不去打理，直到整个别墅成为废墟。\n\n拿到软件开发中就是，如果一扇破窗（糟糕的设计、错误的决定、没有注释的代码，混乱的逻辑）不去修理，慢慢的就会有更多人作出破窗决定，导致整个项目混乱不堪，无法维护。俗称一块臭肉坏了满锅的汤。\n\n### 编制合理的谎言\n\n有三个在战场中的战士已经很久没有吃饭了，他们看完前面有个村庄，但是村庄里面没有人，但是士兵没有气馁，他们烧了一锅水，小心翼翼地在锅里放了三块石头，诡异的村民们都出来围观，然后战士就说：这叫石头汤，你们就在汤里放这个？嗯，是的，士兵回答道，但是有点胡萝卜味道会更好，一个村民就跑回家把自己家里的胡萝卜拿来了，随后士兵又说，如果有牛肉那就更好了，又一个村民跑回家把牛肉拿过来了，最后，他们煮了一大锅汤，士兵把石头扔掉，最后和村民们一起吃了一顿美餐。\n\n这在软件开发中同样适用。你可以通过一个小改动入手，渐渐的拓展全局，但是一定要注意方式和方法，一定要假装`你不在意`，这时候应该坐下来，等他们开始向你问你要不要加些你原本想要的功能。加入一个推进中的成功项目更容易一些。\n\n### 让用户参与评审和设计\n\n你是否经历过这种，你做的东西拿给用户看后发现这并不是他么想要的，每次都需要打回重做。但是没办法，那是你的用户，你们的共同职责就是做出一个双方都满意的软件。为了达到这种目的，沟通就扮演了至关重要的作用。或者说，你还不够了解你的用户，要多和他聊聊，这或许是程序员的短板。多让你的用户参与评审，多问他们这样怎么怎么样。\n\n## 如何学习知识\n\n### 知识理财\n\n本杰明富兰克林说过：**投资知识，收益最高** 。知识和经验确实是你最需要的资产。投资知识在某种程度上和 `理财` 是一样的。什么？这两种毫不相关的概念怎么会扯到一起去的？别着急，且听我慢慢给你分析。\n\n* 首先，理性投资者具有周期性投资的习惯，周期性投资就是定投\n* 理性投资者会衡量或者说平衡高风险高收益和稳定收益的组合\n* 采取多样化是打持久战成功的关键因素\n* 投资者最核心的准则就是低买高卖获得最大的回报\n* 定期审查、反思自己的理财组合\n\n为什么说学习知识和理财一样呢？\n\n**定期投资**\n\n就像金融定投一样，你必须定期为你的技术栈找到合适的学习组合，即使数量有限。\n\n**风险管理**\n\n不要把所有的鸡蛋都放在一个篮子里，你要学新潮的框架同时也要专注于永恒不变的基础知识。这样会让你不止于思考框架，同时也会让你跟进时代的进步适应这个社会。\n\n**多样化**\n\n你知道的越多，你的作用、你的价值也就越大。如果你是一个只专注于某个业务的程序员，一定要从整体把握，不要局限在自己的一亩三分地中。如果你不喜欢业务，那你就要从整体考虑用到什么技术，计算机技术变化迅猛，今天的热点技术可能明天就会被废弃。你要多熟悉技术，成为 T 型人才。T 这个字的写法一定是先横着写再竖着写的，知道广度后，才有可能选择一个切入点深入进去。\n\n**低买高卖**\n\n你在 Java 流行之前绝对不会想着去学习 Java，但是当 Java 流行之后，那些早起的用户已经积累了相当丰厚的回报。\n\n**重新评估**\n\n重新评估你的技术栈，推陈出新，查漏补缺。\n\n### 知识组合\n\n这里有一些对你学习知识的几种组合方式，也是一些建议：\n\n* 每年学习一门新的编程语言：培养自己从不同的角度思考语言这回事，权衡语言的利弊，解决了什么样的问题\n* 每月读一本技术书：这个可能有些费劲，因为一本黑皮书你不可能一个月就读完了，除非你什么都不做，天天只看书，但是有的实战类的书还是可以看完的。这里只是告诉你一个大致的读书周期\n* 读技术书：你的人生不仅仅只有计算机，还有生活，计算机也是通过人类制造出来的，你要站在人的角度思考问题。\n* 上课：去本地大学上课是一件很不错的事情\n* 参加城市技术圈子交流：不要只当听众，要参与进去，了解其他人都在做什么\n* 与时俱进：还是那句话，关心一下你的技术栈，阅读相关的新闻和技术帖子，这是一种很好的方式。\n\n持续投资非常重要，计算机不是一件`速成`的事儿。\n\n### 碎片学习的机会\n\n你要如饥似渴的学习，如果你无法找到问题的答案，去寻觅有能力找到答案的人，而不是要让问题 `沉寂下去`。和其他人交谈有助于构建你的人际网络，而且你会很惊讶的发现，在你寻找答案的这个过程中，你会不断扩大你的知识面。\n\n所有的阅读和研究都需要时间，而时间是永远不够的。所以你需要时刻准备好，确保在无聊的时候有东西可以读。在医院排队也不要忘了放弃阅读的好机会 --- 一定要带上自己的 `kindle` 或者电子阅读器\n\n### 批判性思维\n\n最后一个要点是要具有批判性思维，批判性地思考读到和听到的东西。\n\n网络不是那么干净的。永远不要低估商业的力量。他会把黑的说成白的。\n\n网络搜索引擎会把热门的东西放在前列，而不仅仅是正确的东西，也并不是对你有用的东西。书店会把一本书放在显眼的位置，但并不能说明这是一本好书，有可能包装好，有可能封面好，有可能只是标题吸引人，有可能这本书很流行或者很畅销。\n\n批判性思维有五个你需要思考的方向\n\n* 重复性的问 `为什么`\n* 谁能从中受益，了解资金流的转向\n* 什么背景下发生的这件事情\n* 开始后会发生什么，结束后会发生什么\n* 为什么这是个问题\n\n你好，我是 cxuan，我自己手写了四本 PDF，分别是 Java基础总结、HTTP 核心总结、计算机基础知识，操作系统核心总结，我已经整理成为 PDF，可以关注公众号 Java建设者 回复 PDF 领取优质资料。\n\n![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8de118aa89994647ad076f51bde1600c~tplv-k3u1fbpfcp-zoom-1.image)\n\n\n", "user_name": "程序员cxuan", "description": "公众号 Java 建设者 号主", "got_view_count": 314495, "category_name": "代码人生", "ctime": 1553759544}
{"tag_name": "面试", "concern_user_count": 285351, "user_id": "747323638163768", "title": "《大前端进阶 安全》系列 RSA 算法及 Python 实现", "mark_content": "<div class=\"output_wrapper\" id=\"output_wrapper_id\" style=\"font-size: 15px; color: rgb(62, 62, 62); line-height: 1.8; word-spacing: 2px; letter-spacing: 2px; font-family: 'Helvetica Neue', Helvetica, 'Hiragino Sans GB', 'Microsoft YaHei', Arial, sans-serif; background-image: linear-gradient(90deg, rgba(50, 0, 0, 0.05) 3%, rgba(0, 0, 0, 0) 3%), linear-gradient(360deg, rgba(50, 0, 0, 0.05) 3%, rgba(0, 0, 0, 0) 3%); background-size: 20px 20px; background-position: center center;\"><figure style=\"font-size: inherit; color: inherit; line-height: inherit; margin: 0px; padding: 0px;\"><img src=\"http://jieshuiguai.oss-cn-hangzhou.aliyuncs.com/2020-03-21-023030.jpg\" alt=\"\" title=\"\" style=\"font-size: inherit; color: inherit; line-height: inherit; padding: 0px; display: block; margin: 0px auto; max-width: 100%;\"><figcaption style=\"line-height: inherit; margin: 0px; padding: 0px; margin-top: 10px; text-align: center; color: rgb(153, 153, 153); font-size: 0.7em;\"></figcaption></figure>\n<h3 id=\"h\" style=\"color: inherit; line-height: inherit; padding: 0px; margin: 1.6em 0px; font-weight: bold; border-bottom: 2px solid rgb(239, 112, 96); font-size: 1.3em;\"><span style=\"font-size: inherit; line-height: inherit; margin: 0px; display: inline-block; font-weight: normal; background: rgb(239, 112, 96); color: rgb(255, 255, 255); padding: 3px 10px 1px; border-top-right-radius: 3px; border-top-left-radius: 3px; margin-right: 3px;\">前言</span><span style=\"display: inline-block; vertical-align: bottom; border-bottom: 36px solid rgb(239, 235, 233); border-right: 20px solid transparent;\"> </span></h3>\n<blockquote style=\"line-height: inherit; display: block; padding: 15px 15px 15px 1rem; font-size: 0.9em; margin: 1em 0px; color: rgb(0, 0, 0); border-left: 5px solid rgb(239, 112, 96); background: rgb(239, 235, 233); overflow: auto; overflow-wrap: normal; word-break: normal;\">\n  <p style=\"font-size: inherit; color: inherit; line-height: inherit; padding: 0px; margin: 0px;\">本文已收录 <a href=\"https://github.com/ponkans/F2E\" style=\"font-size: inherit; line-height: inherit; margin: 0px; padding: 0px; text-decoration: none; color: rgb(30, 107, 184); overflow-wrap: break-word;\">GitHub https://github.com/ponkans/F2E</a>（有怪怪整理的大前端知识技能树），欢迎 Star，持续更新💧</p>\n</blockquote>\n<p style=\"font-size: inherit; color: inherit; line-height: inherit; padding: 0px; margin: 1.7em 0px;\">最近做几个 ctf 的 crypto 题，好几道 RSA 都没法用以前无脑工具破搞定了，所以深入研究了一下原理和一些小 trick，把自己的一点体会分享出来，共同学习。</p>\n<h3 id=\"h-1\" style=\"color: inherit; line-height: inherit; padding: 0px; margin: 1.6em 0px; font-weight: bold; border-bottom: 2px solid rgb(239, 112, 96); font-size: 1.3em;\"><span style=\"font-size: inherit; line-height: inherit; margin: 0px; display: inline-block; font-weight: normal; background: rgb(239, 112, 96); color: rgb(255, 255, 255); padding: 3px 10px 1px; border-top-right-radius: 3px; border-top-left-radius: 3px; margin-right: 3px;\">算法基本思路</span><span style=\"display: inline-block; vertical-align: bottom; border-bottom: 36px solid rgb(239, 235, 233); border-right: 20px solid transparent;\"> </span></h3>\n<p style=\"font-size: inherit; color: inherit; line-height: inherit; padding: 0px; margin: 1.7em 0px;\">RSA 算法是一种非对称加密算法，是现在广泛使用的公钥加密算法，主要应用是加密信息和数字签名。详情请看<a href=\"https://zh.wikipedia.org/wiki/RSA加密演算法\" style=\"font-size: inherit; line-height: inherit; margin: 0px; padding: 0px; text-decoration: none; color: rgb(30, 107, 184); overflow-wrap: break-word;\">维基</a></p>\n<h3 id=\"h-2\" style=\"color: inherit; line-height: inherit; padding: 0px; margin: 1.6em 0px; font-weight: bold; border-bottom: 2px solid rgb(239, 112, 96); font-size: 1.3em;\"><span style=\"font-size: inherit; line-height: inherit; margin: 0px; display: inline-block; font-weight: normal; background: rgb(239, 112, 96); color: rgb(255, 255, 255); padding: 3px 10px 1px; border-top-right-radius: 3px; border-top-left-radius: 3px; margin-right: 3px;\">公钥与私钥的生成</span><span style=\"display: inline-block; vertical-align: bottom; border-bottom: 36px solid rgb(239, 235, 233); border-right: 20px solid transparent;\"> </span></h3>\n<ol style=\"font-size: inherit; color: inherit; line-height: inherit; margin: 0px; padding: 0px; padding-left: 32px; list-style-type: decimal;\">\n<li style=\"font-size: inherit; color: inherit; line-height: inherit; margin: 0px; padding: 0px; margin-bottom: 0.5em;\">随机挑选两个大质数 p 和 q，构造 <code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(248, 35, 117); background: rgb(248, 248, 248);\">N = p*q</code>；</li>\n<li style=\"font-size: inherit; color: inherit; line-height: inherit; margin: 0px; padding: 0px; margin-bottom: 0.5em;\">计算欧拉函数 <code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(248, 35, 117); background: rgb(248, 248, 248);\">φ(N) = (p-1) * (q-1)</code>；</li>\n<li style=\"font-size: inherit; color: inherit; line-height: inherit; margin: 0px; padding: 0px; margin-bottom: 0.5em;\">随机挑选 e，使得 <code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(248, 35, 117); background: rgb(248, 248, 248);\">gcd(e, φ(N)) = 1</code>，即 e 与 φ(N) 互素；</li>\n<li style=\"font-size: inherit; color: inherit; line-height: inherit; margin: 0px; padding: 0px; margin-bottom: 0.5em;\">计算 d，使得 <code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(248, 35, 117); background: rgb(248, 248, 248);\">e*d ≡ 1 (mod φ(N))</code>，即 d 是 e 的乘法逆元。</li>\n</ol>\n<p style=\"font-size: inherit; color: inherit; line-height: inherit; padding: 0px; margin: 1.7em 0px;\">此时，公钥为（e, N），私钥为（d, N），公钥公开，私钥自己保管。</p>\n<h3 id=\"h-3\" style=\"color: inherit; line-height: inherit; padding: 0px; margin: 1.6em 0px; font-weight: bold; border-bottom: 2px solid rgb(239, 112, 96); font-size: 1.3em;\"><span style=\"font-size: inherit; line-height: inherit; margin: 0px; display: inline-block; font-weight: normal; background: rgb(239, 112, 96); color: rgb(255, 255, 255); padding: 3px 10px 1px; border-top-right-radius: 3px; border-top-left-radius: 3px; margin-right: 3px;\">加密信息</span><span style=\"display: inline-block; vertical-align: bottom; border-bottom: 36px solid rgb(239, 235, 233); border-right: 20px solid transparent;\"> </span></h3>\n<ol style=\"font-size: inherit; color: inherit; line-height: inherit; margin: 0px; padding: 0px; padding-left: 32px; list-style-type: decimal;\">\n<li style=\"font-size: inherit; color: inherit; line-height: inherit; margin: 0px; padding: 0px; margin-bottom: 0.5em;\"><span style=\"font-size: inherit; color: inherit; line-height: inherit; margin: 0px; padding: 0px;\">待加密信息（明文）为 M，M &lt; N；（因为要做模运算，若 M 大于 N，则后面的运算不会成立，因此当信息比 N 要大时，应该分块加密）</span></li>\n<li style=\"font-size: inherit; color: inherit; line-height: inherit; margin: 0px; padding: 0px; margin-bottom: 0.5em;\">密文 <code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(248, 35, 117); background: rgb(248, 248, 248);\">C = Me mod N</code></li>\n<li style=\"font-size: inherit; color: inherit; line-height: inherit; margin: 0px; padding: 0px; margin-bottom: 0.5em;\">解密 <code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(248, 35, 117); background: rgb(248, 248, 248);\">Cd mod N = (Me)d mod N = Md*e mod N</code> ；</li>\n</ol>\n<p style=\"font-size: inherit; color: inherit; line-height: inherit; padding: 0px; margin: 1.7em 0px;\">要理解为什么能解密？要用到欧拉定理（其实是费马小定理的推广）</p>\n<pre style=\"font-size: inherit; color: inherit; line-height: inherit; margin: 0px; padding: 0px;\"><code class=\"hljs lua\" style=\"overflow-wrap: break-word; margin: 0px 2px; line-height: 18px; font-size: 14px; font-weight: normal; word-spacing: 0px; letter-spacing: 0px; font-family: Consolas, Inconsolata, Courier, monospace; border-radius: 0px; overflow-x: auto; padding: 0.5em; background: rgb(63, 63, 63); color: rgb(220, 220, 220); display: block !important; white-space: pre !important; word-wrap: normal !important; word-break: normal !important; overflow: auto !important;\">aφ(n)&nbsp;≡&nbsp;<span class=\"hljs-number\" style=\"font-size: inherit; line-height: inherit; margin: 0px; padding: 0px; color: rgb(140, 208, 211); word-wrap: inherit !important; word-break: inherit !important;\">1</span>&nbsp;(<span class=\"hljs-built_in\" style=\"font-size: inherit; line-height: inherit; margin: 0px; padding: 0px; color: rgb(204, 147, 147); word-wrap: inherit !important; word-break: inherit !important;\">mod</span>&nbsp;n)<br></code></pre>\n<p style=\"font-size: inherit; color: inherit; line-height: inherit; padding: 0px; margin: 1.7em 0px;\">再推广：</p>\n<pre style=\"font-size: inherit; color: inherit; line-height: inherit; margin: 0px; padding: 0px;\"><code class=\"hljs lua\" style=\"overflow-wrap: break-word; margin: 0px 2px; line-height: 18px; font-size: 14px; font-weight: normal; word-spacing: 0px; letter-spacing: 0px; font-family: Consolas, Inconsolata, Courier, monospace; border-radius: 0px; overflow-x: auto; padding: 0.5em; background: rgb(63, 63, 63); color: rgb(220, 220, 220); display: block !important; white-space: pre !important; word-wrap: normal !important; word-break: normal !important; overflow: auto !important;\">aφ(n)*k&nbsp;≡&nbsp;<span class=\"hljs-number\" style=\"font-size: inherit; line-height: inherit; margin: 0px; padding: 0px; color: rgb(140, 208, 211); word-wrap: inherit !important; word-break: inherit !important;\">1</span>&nbsp;(<span class=\"hljs-built_in\" style=\"font-size: inherit; line-height: inherit; margin: 0px; padding: 0px; color: rgb(204, 147, 147); word-wrap: inherit !important; word-break: inherit !important;\">mod</span>&nbsp;n)<br></code></pre>\n<p style=\"font-size: inherit; color: inherit; line-height: inherit; padding: 0px; margin: 1.7em 0px;\">得：</p>\n<pre style=\"font-size: inherit; color: inherit; line-height: inherit; margin: 0px; padding: 0px;\"><code class=\"hljs lua\" style=\"overflow-wrap: break-word; margin: 0px 2px; line-height: 18px; font-size: 14px; font-weight: normal; word-spacing: 0px; letter-spacing: 0px; font-family: Consolas, Inconsolata, Courier, monospace; border-radius: 0px; overflow-x: auto; padding: 0.5em; background: rgb(63, 63, 63); color: rgb(220, 220, 220); display: block !important; white-space: pre !important; word-wrap: normal !important; word-break: normal !important; overflow: auto !important;\">aφ(n)*k+<span class=\"hljs-number\" style=\"font-size: inherit; line-height: inherit; margin: 0px; padding: 0px; color: rgb(140, 208, 211); word-wrap: inherit !important; word-break: inherit !important;\">1</span>&nbsp;≡&nbsp;a&nbsp;(<span class=\"hljs-built_in\" style=\"font-size: inherit; line-height: inherit; margin: 0px; padding: 0px; color: rgb(204, 147, 147); word-wrap: inherit !important; word-break: inherit !important;\">mod</span>&nbsp;n)<br></code></pre>\n<p style=\"font-size: inherit; color: inherit; line-height: inherit; padding: 0px; margin: 1.7em 0px;\">注意到 <code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(248, 35, 117); background: rgb(248, 248, 248);\">e*d ≡ 1 mod φ(N)</code>，即：<code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(248, 35, 117); background: rgb(248, 248, 248);\">e*d = 1 + k*φ(N)</code>。<br>因此，<code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(248, 35, 117); background: rgb(248, 248, 248);\">Md*e mod N = M1 + k*φ(N) mod N = M</code><br>简单来说，别人用我的公钥加密信息发给我，然后我用私钥解密。</p>\n<h3 id=\"h-4\" style=\"color: inherit; line-height: inherit; padding: 0px; margin: 1.6em 0px; font-weight: bold; border-bottom: 2px solid rgb(239, 112, 96); font-size: 1.3em;\"><span style=\"font-size: inherit; line-height: inherit; margin: 0px; display: inline-block; font-weight: normal; background: rgb(239, 112, 96); color: rgb(255, 255, 255); padding: 3px 10px 1px; border-top-right-radius: 3px; border-top-left-radius: 3px; margin-right: 3px;\">数字签名</span><span style=\"display: inline-block; vertical-align: bottom; border-bottom: 36px solid rgb(239, 235, 233); border-right: 20px solid transparent;\"> </span></h3>\n<ol style=\"font-size: inherit; color: inherit; line-height: inherit; margin: 0px; padding: 0px; padding-left: 32px; list-style-type: decimal;\">\n<li style=\"font-size: inherit; color: inherit; line-height: inherit; margin: 0px; padding: 0px; margin-bottom: 0.5em;\">密文 <code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(248, 35, 117); background: rgb(248, 248, 248);\">C = Md mod N</code></li>\n<li style=\"font-size: inherit; color: inherit; line-height: inherit; margin: 0px; padding: 0px; margin-bottom: 0.5em;\">解密 <code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(248, 35, 117); background: rgb(248, 248, 248);\">M = Ce mod N = (Md)e mod N = Md*e mod N = M</code>；（原理同上）</li>\n</ol>\n<p style=\"font-size: inherit; color: inherit; line-height: inherit; padding: 0px; margin: 1.7em 0px;\">简单来说，我用自己的密钥加密签名，别人用我的公钥解密可以看到这是我的签名。注意，这个不具有隐私性，即任何人都可以解密此签名。</p>\n<p style=\"font-size: inherit; color: inherit; line-height: inherit; padding: 0px; margin: 1.7em 0px;\">算法的安全性：基于大整数 N 难以分解出 p 和 q，构造 φ(N)；或由 N 直接构造 φ(N) 同样难。</p>\n<h3 id=\"hpython\" style=\"color: inherit; line-height: inherit; padding: 0px; margin: 1.6em 0px; font-weight: bold; border-bottom: 2px solid rgb(239, 112, 96); font-size: 1.3em;\"><span style=\"font-size: inherit; line-height: inherit; margin: 0px; display: inline-block; font-weight: normal; background: rgb(239, 112, 96); color: rgb(255, 255, 255); padding: 3px 10px 1px; border-top-right-radius: 3px; border-top-left-radius: 3px; margin-right: 3px;\">Python 实现基本原理</span><span style=\"display: inline-block; vertical-align: bottom; border-bottom: 36px solid rgb(239, 235, 233); border-right: 20px solid transparent;\"> </span></h3>\n<figure style=\"font-size: inherit; color: inherit; line-height: inherit; margin: 0px; padding: 0px;\"><img src=\"http://jieshuiguai.oss-cn-hangzhou.aliyuncs.com/2020-08-09-183248.png\" alt=\"\" title=\"\" style=\"font-size: inherit; color: inherit; line-height: inherit; padding: 0px; display: block; margin: 0px auto; max-width: 100%;\"><figcaption style=\"line-height: inherit; margin: 0px; padding: 0px; margin-top: 10px; text-align: center; color: rgb(153, 153, 153); font-size: 0.7em;\"></figcaption></figure>\n<h3 id=\"hveryeasyrsa\" style=\"color: inherit; line-height: inherit; padding: 0px; margin: 1.6em 0px; font-weight: bold; border-bottom: 2px solid rgb(239, 112, 96); font-size: 1.3em;\"><span style=\"font-size: inherit; line-height: inherit; margin: 0px; display: inline-block; font-weight: normal; background: rgb(239, 112, 96); color: rgb(255, 255, 255); padding: 3px 10px 1px; border-top-right-radius: 3px; border-top-left-radius: 3px; margin-right: 3px;\">veryeasyRSA</span><span style=\"display: inline-block; vertical-align: bottom; border-bottom: 36px solid rgb(239, 235, 233); border-right: 20px solid transparent;\"> </span></h3>\n<blockquote style=\"line-height: inherit; display: block; padding: 15px 15px 15px 1rem; font-size: 0.9em; margin: 1em 0px; color: rgb(0, 0, 0); border-left: 5px solid rgb(239, 112, 96); background: rgb(239, 235, 233); overflow: auto; overflow-wrap: normal; word-break: normal;\">\n  <p style=\"font-size: inherit; color: inherit; line-height: inherit; padding: 0px; margin: 0px;\">已知 RSA 公钥生成参数：<br>p = 3487583947589437589237958723892346254777<br>q = 8767867843568934765983476584376578389<br>e = 65537<br>求 d =<br>请提交 PCTF {d}</p>\n</blockquote>\n<p style=\"font-size: inherit; color: inherit; line-height: inherit; padding: 0px; margin: 1.7em 0px;\">对上述代码稍作修改，取有用的扩展欧拉和计算 d 的两个函数，构造如下代码，即可解出答案。</p>\n<figure style=\"font-size: inherit; color: inherit; line-height: inherit; margin: 0px; padding: 0px;\"><img src=\"http://jieshuiguai.oss-cn-hangzhou.aliyuncs.com/2020-08-09-183306.png\" alt=\"\" title=\"\" style=\"font-size: inherit; color: inherit; line-height: inherit; padding: 0px; display: block; margin: 0px auto; max-width: 100%;\"><figcaption style=\"line-height: inherit; margin: 0px; padding: 0px; margin-top: 10px; text-align: center; color: rgb(153, 153, 153); font-size: 0.7em;\"></figcaption></figure>\n<h3 id=\"heasyrsa\" style=\"color: inherit; line-height: inherit; padding: 0px; margin: 1.6em 0px; font-weight: bold; border-bottom: 2px solid rgb(239, 112, 96); font-size: 1.3em;\"><span style=\"font-size: inherit; line-height: inherit; margin: 0px; display: inline-block; font-weight: normal; background: rgb(239, 112, 96); color: rgb(255, 255, 255); padding: 3px 10px 1px; border-top-right-radius: 3px; border-top-left-radius: 3px; margin-right: 3px;\">easyRSA</span><span style=\"display: inline-block; vertical-align: bottom; border-bottom: 36px solid rgb(239, 235, 233); border-right: 20px solid transparent;\"> </span></h3>\n<blockquote style=\"line-height: inherit; display: block; padding: 15px 15px 15px 1rem; font-size: 0.9em; margin: 1em 0px; color: rgb(0, 0, 0); border-left: 5px solid rgb(239, 112, 96); background: rgb(239, 235, 233); overflow: auto; overflow-wrap: normal; word-break: normal;\">\n  <p style=\"font-size: inherit; color: inherit; line-height: inherit; padding: 0px; margin: 0px;\">还记得 veryeasy RSA 吗？是不是不难？那继续来看看这题吧，这题也不难。<br>已知一段 RSA 加密的信息为：0xdc2eeeb2782c 且已知加密所用的公钥：<br>(N=322831561921859 e = 23)<br>请解密出明文，提交时请将数字转化为 ascii 码提交<br>比如你解出的明文是 0x6162，那么请提交字符串 ab<br>提交格式：PCTF {明文字符串}</p>\n</blockquote>\n<p style=\"font-size: inherit; color: inherit; line-height: inherit; padding: 0px; margin: 1.7em 0px;\">依然是一样的思路，取有用的函数，稍作修改。</p>\n<figure style=\"font-size: inherit; color: inherit; line-height: inherit; margin: 0px; padding: 0px;\"><img src=\"http://jieshuiguai.oss-cn-hangzhou.aliyuncs.com/2020-08-09-183506.png\" alt=\"\" title=\"\" style=\"font-size: inherit; color: inherit; line-height: inherit; padding: 0px; display: block; margin: 0px auto; max-width: 100%;\"><figcaption style=\"line-height: inherit; margin: 0px; padding: 0px; margin-top: 10px; text-align: center; color: rgb(153, 153, 153); font-size: 0.7em;\"></figcaption></figure>\n<h3 id=\"h-5\" style=\"color: inherit; line-height: inherit; padding: 0px; margin: 1.6em 0px; font-weight: bold; border-bottom: 2px solid rgb(239, 112, 96); font-size: 1.3em;\"><span style=\"font-size: inherit; line-height: inherit; margin: 0px; display: inline-block; font-weight: normal; background: rgb(239, 112, 96); color: rgb(255, 255, 255); padding: 3px 10px 1px; border-top-right-radius: 3px; border-top-left-radius: 3px; margin-right: 3px;\">总结</span><span style=\"display: inline-block; vertical-align: bottom; border-bottom: 36px solid rgb(239, 235, 233); border-right: 20px solid transparent;\"> </span></h3>\n<p style=\"font-size: inherit; color: inherit; line-height: inherit; padding: 0px; margin: 1.7em 0px;\">简单介绍了 RSA 算法以及 Python 的实现方式，偶尔面试也会问到哦。</p>\n<p style=\"font-size: inherit; color: inherit; line-height: inherit; padding: 0px; margin: 1.7em 0px;\">喜欢的小伙伴加个关注，点个赞哦，感恩💕😊</p>\n<h3 id=\"h-6\" style=\"color: inherit; line-height: inherit; padding: 0px; margin: 1.6em 0px; font-weight: bold; border-bottom: 2px solid rgb(239, 112, 96); font-size: 1.3em;\"><span style=\"font-size: inherit; line-height: inherit; margin: 0px; display: inline-block; font-weight: normal; background: rgb(239, 112, 96); color: rgb(255, 255, 255); padding: 3px 10px 1px; border-top-right-radius: 3px; border-top-left-radius: 3px; margin-right: 3px;\">联系我 / 公众号</span><span style=\"display: inline-block; vertical-align: bottom; border-bottom: 36px solid rgb(239, 235, 233); border-right: 20px solid transparent;\"> </span></h3>\n<p style=\"font-size: inherit; color: inherit; line-height: inherit; padding: 0px; margin: 1.7em 0px;\">微信搜索【<strong style=\"font-size: inherit; line-height: inherit; margin: 0px; padding: 0px; font-weight: bold; color: rgb(233, 105, 0);\">接水怪</strong>】或扫描下面二维码回复”加群“，我会拉你进技术交流群。讲真的，在这个群，哪怕您不说话，光看聊天记录也是一种成长。（<strong style=\"font-size: inherit; line-height: inherit; margin: 0px; padding: 0px; font-weight: bold; color: rgb(233, 105, 0);\"><em style=\"font-size: inherit; line-height: inherit; margin: 0px; padding: 0px; font-weight: bold; color: rgb(197, 17, 98);\">阿里技术专家、敖丙作者、Java3y、蘑菇街资深前端、蚂蚁金服安全专家</em></strong>、各路大牛都在）。</p>\n<p style=\"font-size: inherit; color: inherit; line-height: inherit; padding: 0px; margin: 1.7em 0px;\">接水怪也会定期原创，定期跟小伙伴进行经验交流或帮忙看简历。加关注，不迷路，有机会一起跑个步🏃 <strong style=\"font-size: inherit; line-height: inherit; margin: 0px; padding: 0px; font-weight: bold; color: rgb(233, 105, 0);\">↓↓↓</strong></p>\n<figure style=\"font-size: inherit; color: inherit; line-height: inherit; margin: 0px; padding: 0px;\"><img src=\"http://jieshuiguai.oss-cn-hangzhou.aliyuncs.com/2020-03-17-064351.jpg\" alt=\"\" title=\"\" style=\"font-size: inherit; color: inherit; line-height: inherit; padding: 0px; display: block; margin: 0px auto; max-width: 100%;\"><figcaption style=\"line-height: inherit; margin: 0px; padding: 0px; margin-top: 10px; text-align: center; color: rgb(153, 153, 153); font-size: 0.7em;\"></figcaption></figure></div>", "user_name": "接水怪", "description": "公众号 @ 接水怪", "got_view_count": 128830, "category_name": "前端", "ctime": 1457483942}
{"tag_name": "RESTful", "concern_user_count": 2398, "user_id": "2805609406139950", "title": "Rest-framework专栏讲解(十一)：Serializers (1)", "mark_content": "![MedusaSorcerer的博客](https://user-gold-cdn.xitu.io/2019/10/26/16e073e7ae704f8b?w=1390&h=400&f=gif&s=2378622)\n\n---\n\n#### [点击跳转到 Rest-Framework 专栏目录](https://juejin.im/post/6844904185163415566)\n\n序列化对象是对检索数据或者请求数据判断的最好方式,\n省略了繁琐的请求数据的判断以及返回响应数据的遍历。\n\n### Serializer\n```python\n#!/usr/bin/env python\n# _*_ Coding: UTF-8 _*_\nfrom datetime import datetime\n\nfrom rest_framework import serializers, settings\n\n\nclass UserSerializer(serializers.Serializer):\n    username = serializers.CharField()\n    blog = serializers.URLField(max_length=200)\n    created = serializers.DateTimeField()\n\n\nclass User:\n    def __init__(self, username, blog, created=None):\n        self.username = username\n        self.blog = blog\n        self.created = created or datetime.now()\n\n\nif __name__ == '__main__':\n    settings.settings.configure()\n\n    user = User(username='MedusaSorcerer', blog='https://juejin.im/user/2805609406139950')\n    serializer = UserSerializer(user)\n    print(serializer.data)\n```\n在上面的代码块中定义了一个用户序列化类,\n此时又定义了一个仿造 `ORM` 的用户类,\n并将 `User` 的实例对象 `user` 传递给序列化的 `data` 参数,\n将可以生成一个序列化对象,\n打印序列化对象的 `.data` 属性可以获得以下数据：\n```python\n{'username': 'MedusaSorcerer', 'blog': 'https://juejin.im/user/2805609406139950', 'created': '2020-08-10T09:58:35.754067'}\n```\n你可以继续将数据渲染成 `JSON` 对象：\n```python\n#!/usr/bin/env python\n# _*_ Coding: UTF-8 _*_\nfrom datetime import datetime\n\nfrom rest_framework import serializers, settings\n\n\nclass UserSerializer(serializers.Serializer):\n    username = serializers.CharField()\n    blog = serializers.URLField(max_length=200)\n    created = serializers.DateTimeField()\n\n\nclass User:\n    def __init__(self, username, blog, created=None):\n        self.username = username\n        self.blog = blog\n        self.created = created or datetime.now()\n\n\nif __name__ == '__main__':\n    settings.settings.configure()\n    from rest_framework.renderers import JSONRenderer\n\n    user = User(username='MedusaSorcerer', blog='https://juejin.im/user/2805609406139950')\n    serializer = UserSerializer(user)\n    print(JSONRenderer().render(serializer.data))\n```\n> 注意在使用脚本执行的时候调用 `settings.settings.configure()` 获取配置信息的位置\n\n运行完成你可以获得字符：\n```python\nb'{\"username\":\"MedusaSorcerer\",\"blog\":\"https://juejin.im/user/2805609406139950\",\"created\":\"2020-08-10T10:03:36.741946\"}'\n```\n\n### 反序列化\n```\n#!/usr/bin/env python\n# _*_ Coding: UTF-8 _*_\nfrom datetime import datetime\nimport io\n\nfrom rest_framework import serializers, settings\n\n\nclass UserSerializer(serializers.Serializer):\n    username = serializers.CharField()\n    blog = serializers.URLField(max_length=200)\n    created = serializers.DateTimeField()\n\n\nclass User:\n    def __init__(self, username, blog, created=None):\n        self.username = username\n        self.blog = blog\n        self.created = created or datetime.now()\n\n\nif __name__ == '__main__':\n    settings.settings.configure()\n    from rest_framework.parsers import JSONParser\n\n    json = b'{\"username\":\"MedusaSorcerer\",\"blog\":\"https://juejin.im/user/2805609406139950\",\"created\":\"2020-08-10T10:03:36.741946\"}'\n    stream = io.BytesIO(json)\n    data = JSONParser().parse(stream)\n    serializer = UserSerializer(data=data)\n    if serializer.is_valid():\n        print(serializer.validated_data)\n    else:\n        print(serializer.errors)\n```\n将保存的序列化数据反序列化一样可以实现,\n注意的是在你反序列的时候需要执行 `.is_valid()` 来判断数据是否符合序列化类声明的对象约束,\n如果返回的是 `False` 的话说明序列化对象不是符合声明对象的那样,\n在返回 `True` 的时候就可以用 `serializer.validated_data` 获取序列化的数据：\n```python\nrderedDict([('username', 'MedusaSorcerer'), ('blog', 'https://juejin.im/user/2805609406139950'), ('created', datetime.datetime(2020, 8, 10, 10, 3, 36, 741946))])\n```\n那不符合约束的情况就可以用 `serializer.errors` 获取错误信息：\n```error\ndjango.core.exceptions.AppRegistryNotReady: The translation infrastructure cannot be initialized before the apps registry is ready. Check that you don't make non-lazy gettext calls at import time.\n```\n事实上在开发中返回的错误信息是一个字典对象,\nkey 是出现错误的字段字符串,\nvalue 是出现不符合约束的描述列表,\n由于没有在 Django 项目中运行,\n所以出现了一个报错信息(忽略)。\n\n### 保存实例\n```python\n#!/usr/bin/env python\n# _*_ Coding: UTF-8 _*_\nfrom datetime import datetime\n\nfrom rest_framework import serializers\n\n\nclass UserSerializer(serializers.Serializer):\n    username = serializers.CharField()\n    blog = serializers.URLField(max_length=200)\n    created = serializers.DateTimeField()\n\n    def create(self, validated_data):\n        return User(**validated_data)\n\n    def update(self, instance, validated_data):\n        instance.username = validated_data.get('username', instance.username)\n        instance.blog = validated_data.get('blog', instance.blog)\n        instance.created = validated_data.get('created', instance.created)\n        return instance\n\n\nclass User:\n    def __init__(self, username, blog, created=None):\n        self.username = username\n        self.blog = blog\n        self.created = created or datetime.now()\n```\n如果你想使用验证后的数据返回一个新的实例对象,\n你需要实现 `create` 或者 `update` 或者两个方法都实现。\n\n在 Django-ORM 中你可能需要做一个保存数据的操作(ps: 实际开发中, 并不会这样操作, 很多操作都可以省略)：\n```\n#!/usr/bin/env python\n# _*_ Coding: UTF-8 _*_\nfrom datetime import datetime\n\nfrom rest_framework import serializers\n\n\nclass UserSerializer(serializers.Serializer):\n    username = serializers.CharField()\n    blog = serializers.URLField(max_length=200)\n    created = serializers.DateTimeField()\n\n    def create(self, validated_data):\n        return User.objects.create(**validated_data)\n\n    def update(self, instance, validated_data):\n        instance.username = validated_data.get('username', instance.username)\n        instance.blog = validated_data.get('blog', instance.blog)\n        instance.created = validated_data.get('created', instance.created)\n        instance.save()\n        return instance\n```\n保存实例或者更新实例的 `save()` 方法,\n主要是看你是否在创建实例序列化对象是否传递了对象：\n```python\n# 没有传递实例对象, 所以这是新增\nserializer = UserSerializer(data=data)\n\n# 传递了一个 user 对象, 所以这是更新了 user 对象的数据\nserializer = UserSerializer(user, data=data)\n```\n\n### 验证数据\n反序列化的时候你可以直接调用序列化实例对象的 `.is_valid()` 方法进行判断约束数据,\n在开发中你也可以使用 `.is_valid(raise_exception=True)` 将错误信息返回给 API 调用者。\n\n如果对一个字段需要特殊的判断,\n你可以使用 `validate_<field_name>` 来进行逻辑判断,\n`<field_name>` 是你在序列化类中声明的字段名称。\n\n\nps：你可以将序列化类和 ORM 类联想,\n但是概念完全不一样,\n逻辑上很相似。\n```python\n#!/usr/bin/env python\n# _*_ Coding: UTF-8 _*_\nfrom rest_framework import serializers\n\nclass BlogPostSerializer(serializers.Serializer):\n    title = serializers.CharField(max_length=100)\n    content = serializers.CharField()\n\n    def validate_title(self, value):\n        \"\"\"\n        对 title 字段进行判断\n        \"\"\"\n        if 'medusa' not in value.lower():\n            raise serializers.ValidationError(\"Blog post is not about Medusa\")\n        return value\n```\n同时对多个字段进行逻辑判断：\n```python\n#!/usr/bin/env python\n# _*_ Coding: UTF-8 _*_\nfrom rest_framework import serializers\n\n\nclass BlogPostSerializer(serializers.Serializer):\n    title = serializers.CharField(max_length=100)\n    content = serializers.CharField()\n    start = serializers.IntegerField()\n    finish = serializers.IntegerField()\n\n    def validate(self, data):\n        \"\"\"\n        判断传递的 start 和 finish 参数是否符合大小逻辑\n        \"\"\"\n        if data['start'] > data['finish']:\n            raise serializers.ValidationError(\"finish must occur after start\")\n        return data\n```\n你也可以使用字段约束上直接声明你的判断：\n```python\n#!/usr/bin/env python\n# _*_ Coding: UTF-8 _*_\nfrom rest_framework import serializers\n\n\ndef multiple_of_ten(value):\n    if value % 10 != 0:\n        raise serializers.ValidationError('Not a multiple of ten')\n\n\nclass GameRecord(serializers.Serializer):\n    score = serializers.IntegerField(validators=[multiple_of_ten])\n    ...\n```\n同时你可以声明完整字段验证器：\n```python\n#!/usr/bin/env python\n# _*_ Coding: UTF-8 _*_\nfrom rest_framework import serializers\nfrom rest_framework.validators import UniqueTogetherValidator\n\n\nclass EventSerializer(serializers.Serializer):\n    name = serializers.CharField()\n    room_number = serializers.IntegerField(choices=[101, 102, 103, 201])\n    date = serializers.DateField()\n\n    class Meta:\n        validators = [\n            # 唯一性验证器\n            UniqueTogetherValidator(\n                queryset=User.objects.all(),\n                fields=['username', 'other']\n            )\n        ]\n```\n\n### 访问实例和初始数据\n当你将初始对象或查询集传递给序列化实例时,\n该对象将变为可使用 `.instance` 属性获取对象,\n如果没有传递初始对象,\n则 `.instance` 属性值为 `None`。\n\n将数据传递给序列化程序实例时,\n未修改的数据将以 `.initial_data` 形式提供,\n如果未传递 `data` 关键字参数,\n则该 `.initial_data` 属性将不存在。\n\n### 部分更新\n默认情况下,\n必须为所有声明的序列化字段传递对应的值,\n否则序列化器会引发验证错误,\n此时你可以使用 `partial` 参数来允许部分更新。\n```python\n#!/usr/bin/env python\n# _*_ Coding: UTF-8 _*_\nfrom rest_framework import serializers\n\n\nclass UpdateSerializer(serializers.Serializer):\n    name = serializers.CharField()\n    room_number = serializers.IntegerField(choices=[101, 102, 103, 201])\n    date = serializers.DateField()\n\n\nUpdateSerializer(user, data={'room_number': 101}, partial=True)\n```\n\n### 序列化嵌套\n如果一个序列化对象的属性是另一个序列化对象,\n又要怎么处理？\n```python\n#!/usr/bin/env python\n# _*_ Coding: UTF-8 _*_\nfrom rest_framework import serializers\n\n\nclass UserSerializer(serializers.Serializer):\n    email = serializers.EmailField()\n    username = serializers.CharField(max_length=100)\n\n\nclass CommentSerializer(serializers.Serializer):\n    user = UserSerializer()\n    content = serializers.CharField(max_length=200)\n    created = serializers.DateTimeField()\n```\n如果嵌套可以选择接受该 `None` 值，则应将 `required=False` 传递给嵌套序列化器：\n```python\nclass CommentSerializer(serializers.Serializer):\n    user = UserSerializer(required=False)\n    content = serializers.CharField(max_length=200)\n    created = serializers.DateTimeField()\n```\n如果嵌套序列对象是多条数据构成,\n则应将 `many=True` 传递给嵌套序列化：\n```python\nclass CommentSerializer(serializers.Serializer):\n    user = UserSerializer(required=False)\n    edits = EditItemSerializer(many=True)\n    content = serializers.CharField(max_length=200)\n    created = serializers.DateTimeField()\n```\n如果反序列化的数据无法通过约束,\n那么会错误信息返回至构造字段中：\n```python\nserializer = CommentSerializer(data={'user': {'email': 'foobar', 'username': 'doe'}, 'content': 'baz'})\nserializer.is_valid()  # False, email 和 content 无法通过验证\n\n# 输出错误数据\nserializer.errors\n# {'user': {'email': ['Enter a valid e-mail address.']}, 'created': ['This field is required.']}\n```\n\n### 嵌套对象处理示例\n```python\n#!/usr/bin/env python\n# _*_ Coding: UTF-8 _*_\nfrom rest_framework import serializers\n\n\nclass UserSerializer(serializers.ModelSerializer):\n    profile = ProfileSerializer()\n\n    class Meta:\n        model = User\n        fields = ['username', 'email', 'profile']\n\n    def create(self, validated_data):\n        profile_data = validated_data.pop('profile')\n        user = User.objects.create(**validated_data)\n        Profile.objects.create(user=user, **profile_data)\n        return user\n```\n\n### 序列化多个对象\n```python\nqueryset = Book.objects.all()\nserializer = BookSerializer(queryset, many=True)\nserializer.data\n```\n序列化 `serializer.data` 的值：\n```python\n[\n    {'id': 0, 'title': 'The electric kool-aid acid test', 'author': 'Tom Wolfe'},\n    {'id': 1, 'title': 'If this is a man', 'author': 'Primo Levi'},\n    {'id': 2, 'title': 'The wind-up bird chronicle', 'author': 'Haruki Murakami'}\n]\n```\n\n### 额外上下文链接\n在某些情况下,\n除了要序列化的对象外,\n还需要为序列化器提供额外的上下文。\n\n一种常见的情况是如果您使用的是包含超链接关系的序列化程序,\n则要求序列化程序有权访问当前请求,\n以便它可以正确生成完全合格的 URL。\n\n您可以在实例化序列化程序时通过传递 `context` 参数来提供任意其他上下文：\n```python\nserializer = AccountSerializer(account, context={'request': request})\nserializer.data\n\n{\n\t'id': 6, \n    'owner': 'denvercoder9', \n    'created': datetime.datetime(2013, 2, 12, 09, 44, 56, 678870), \n    'details': 'http://example.com/accounts/6/details'\n}\n```", "user_name": "MedusaSorcerer", "description": "学无止境， 学无止尽。", "got_view_count": 365567, "category_name": "代码人生", "ctime": 1553759544}
{"tag_name": "Android", "concern_user_count": 240175, "user_id": "149189281194766", "title": "【-Flutter组件篇- 】1.20新增组件InteractiveViewer ", "mark_content": "#### 0、前言\n\n> Flutter更新到1.20，出了一个新组件`InteractiveViewer`,主要对移动、缩放的手势交互进行封装，简化使用。\n\n\n移动 | 缩放\n---|---\n![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/bf75b89426fa4c1e8e991bee9318e1b1~tplv-k3u1fbpfcp-zoom-1.image) | ![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2cd7593aed4c4865bbdb553e26c7ddbb~tplv-k3u1fbpfcp-zoom-1.image)\n\n\n```\n家族: StatefulWidget\n源码行数: 1207\n依赖的核心组件: GestureDetector、Transform、ClipRect、OverflowBox\n```\n\n- 此组件已加入[FlutterUnit](https://github.com/toly1994328/FlutterUnit/tree/master/lib/views/widgets/StatefulWidget/InteractiveViewer),欢迎star~\n\n1 | 2 | 3\n---|---|---\n![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5c14e295a9d347db891e5ff6a55671c0~tplv-k3u1fbpfcp-zoom-1.image)| ![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0d4343ad41d048b097fab4ac5ecf97c6~tplv-k3u1fbpfcp-zoom-1.image) |![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6c4f8551bafa4c6cb7cecb4ef03dcf7d~tplv-k3u1fbpfcp-zoom-1.image)\n\n---\n\n#### 1、子组件的移动\n\n属性名 | 类型| 默认值 | 简介 \n---|---|---|---\nalignPanAxis | bool | false| 沿轴拖动\nboundaryMargin |  EdgeInsets | EdgeInsets.zero |边界边矩\npanEnabled | bool |true |是否可平移\nchild | Widget | @required |子组件\n\n---\n\n\n移动 | 缩放\n---|---\n![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/bf75b89426fa4c1e8e991bee9318e1b1~tplv-k3u1fbpfcp-zoom-1.image) | ![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/74cc57a2062f4855b03b91cdd45524a4~tplv-k3u1fbpfcp-zoom-1.image)\n\n- 如左图，灰色区域是InteractiveViewer的上级区域。\n- `boundaryMargin`是可移动的限定边距。默认是EdgeInsets.zero，即被定死，不能移动\n- `panEnabled`可指定是否支持移动,默认为true\n- `alignPanAxis` 指定是否沿轴拖动，默认为false(左图)。当为true时,按下后只能沿某个轴向进行拖动(如右图)\n\n---\n\n- `示例代码`\n\n```dart\nclass InteractiveViewerDemo extends StatelessWidget {\n\n  @override\n  Widget build(BuildContext context) {\n    return Container(\n      height: 150,\n      color: Colors.grey.withAlpha(33),\n      child: InteractiveViewer(\n//        alignPanAxis: true,\n        panEnabled: true,\n        boundaryMargin: EdgeInsets.all(40.0),\n        child: Container(\n          child: Image.asset('assets/images/caver.jpeg'),\n        ),\n      ),\n    );\n  }\n}\n\n```\n\n---\n\n#### 2、子组件缩放\n\n\n属性名 | 类型| 默认值 | 简介 \n---|---|---|---\nmaxScale | double | 2.5 | 最大放大倍数\nminScale | double | 0.8 | 最小缩小倍数\nscaleEnabled | bool |true |是否可缩放\n\n\n![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2cd7593aed4c4865bbdb553e26c7ddbb~tplv-k3u1fbpfcp-zoom-1.image)\n\n- `scaleEnabled`为是否开启缩放，maxScale和minScale分别确定放大缩小的倍数限值。\n\n\n> `估计百分之九十的人都很难触发缩放效果,昨天在群里讨论后。Alex给出了手势触发情况: 先把一只手指放上去，边移动边放第二只。` 同时提出了一个issues: [ [InteractiveViewer] Hard to scale when two fingers tap down at the same ](timehttps://github.com/flutter/flutter/issues/63320)\n\n---\n\n- `示例代码`\n\n\n\n```dart\nclass InteractiveViewerDemo extends StatelessWidget {\n\n  @override\n  Widget build(BuildContext context) {\n    return Container(\n      height: 150,\n      color: Colors.grey.withAlpha(33),\n      child: InteractiveViewer(\n//        alignPanAxis: true,\n        boundaryMargin: EdgeInsets.all(40.0),\n        maxScale: 2.5,\n        minScale: 0.3,\n        panEnabled: true,\n        scaleEnabled: true,\n        child: Container(\n          child: Image.asset('assets/images/caver.jpeg'),\n        ),\n      ),\n    );\n  }\n}\n```\n\n\n---\n\n\n#### 3、constrained属性\n\n属性名 | 类型| 默认值 | 简介 \n---|---|---|---\nconstrained | bool |true |受约束的\n\n\n![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/21cc1e5df9f84d3da5537bd9509aff73~tplv-k3u1fbpfcp-zoom-1.image)\n\n---\n\n> 关于constrained属性，源码中给了一个小demo。这里的表格可以`上下滚动，左右滑动`。constrained默认为true,当子组件比InteractiveViewer区域大时，将constrained设为false, 子组件将被赋予无限的约束。\n\n\n```dart\nclass InteractiveViewerDemo2 extends StatelessWidget {\n\n  Widget build(BuildContext context) {\n    const int _rowCount = 20;\n    const int _columnCount = 4;\n\n    return Container(\n      width: 300,\n      height: 200,\n      child: InteractiveViewer(\n        constrained: false,\n        scaleEnabled: false,\n        child: Table(\n          columnWidths: <int, TableColumnWidth>{\n            for (int column = 0; column < _columnCount; column += 1)\n              column: const FixedColumnWidth(150.0),\n          },\n          children: buildRows(_rowCount, _columnCount),\n        ),\n      ),\n    );\n  }\n\n  List<TableRow> buildRows(int rowCount, int columnCount) {\n    return <TableRow>[\n          for (int row = 0; row < rowCount; row += 1)\n            TableRow(\n              children: <Widget>[\n                for (int column = 0; column < columnCount; column += 1)\n                  Container(\n                    margin: EdgeInsets.all(2),\n                    height: 50,\n                    alignment: Alignment.center,\n                    color: _colorful(row,column),\n                    child: Text('($row,$column)',style: TextStyle(fontSize: 20,color: Colors.white),),\n                  ),\n              ],\n            ),\n        ];\n  }\n\n  final colors = [Colors.red,Colors.yellow,Colors.blue,Colors.green];\n  final colors2 = [Colors.yellow,Colors.blue,Colors.green,Colors.red];\n\n  _colorful(int row, int column ) => row % 2==0?colors[column]:colors2[column];\n}\n```\n\n---\n\n#### 4、回调事件\n\n属性名 | 类型| 默认值 | 简介 \n---|---|---|---\nonInteractionEnd | GestureScaleEndCallback | null | 交互结束回调\nonInteractionStart | GestureScaleStartCallback | null | 交互开始回调\nonInteractionUpdate | GestureScaleUpdateCallback | null | 交互更新回调\n\n---\n\n- `onInteractionStart`\n> 当触碰时，onInteractionStart 会回调`ScaleStartDetails`对象  \n`focalPoint` 是相对于屏幕左上角的偏移量。  \n`localFocalPoint`是相对于父容器区域左上角的偏移量。\n\n\n```\nScaleStartDetails(\n    focalPoint: Offset(306.0, 168.7), \n    localFocalPoint: Offset(50.4, 63.7)\n)\n```\n\n---\n\n\n- `onInteractionUpdate`\n> 当手指滑动时，onInteractionUpdate 会回调`ScaleUpdateDetails`对象  \n`focalPoint` 是相对于屏幕左上角的偏移量。    \n`localFocalPoint`是相对于父容器区域左上角的偏移量。  \n`scale`缩放量。  \n`horizontalScale`水平缩放量。  \n`verticalScale`竖直缩放量。  \n`rotation`旋转量。------ `这里说明能监听到旋转量`\n\n```\nonInteractionUpdate----\nScaleUpdateDetails(\n    focalPoint: Offset(6.4, 13.7), \n    localFocalPoint: Offset(6.4, 13.7),\n    scale: 1.0,\n    horizontalScale: 1.0, \n    verticalScale: 1.0, \n    rotation: 0.0\n)\n```\n\n\n---\n\n\n- `onInteractionEnd`\n> 当手指滑动时，onInteractionEnd 会回调`ScaleEndDetails`对象  \n`velocity` 水平和竖直方向的速度量。    \n\n```\nonInteractionEnd----\nScaleEndDetails(velocity: Velocity(0.0, 0.0))\n```\n\n---\n\n- `示例代码`\n\n```\nclass InteractiveViewerDemo extends StatelessWidget {\n\n  @override\n  Widget build(BuildContext context) {\n    return Container(\n      height: 150,\n      color: Colors.grey.withAlpha(33),\n      child: InteractiveViewer(\n        boundaryMargin: EdgeInsets.all(40.0),\n        maxScale: 2.5,\n        minScale: 0.3,\n        panEnabled: true,\n        scaleEnabled: true,\n        child: Container(\n          child: Image.asset('assets/images/caver.jpeg'),\n        ),\n        onInteractionStart: _onInteractionStart,\n        onInteractionUpdate: _onInteractionUpdate,\n        onInteractionEnd: _onInteractionEnd,\n      ),\n    );\n  }\n\n  void _onInteractionStart(ScaleStartDetails details) {\n    print('onInteractionStart----' + details.toString());\n  }\n\n  void _onInteractionUpdate(ScaleUpdateDetails details) {\n    print('onInteractionUpdate----' + details.toString());\n  }\n\n  void _onInteractionEnd(ScaleEndDetails details) {\n    print('onInteractionEnd----' + details.toString());\n  }\n}\n```\n\n---\n\n#### 5.变换控制器 `transformationController`\n\n\n属性名 | 类型| 默认值 | 简介 \n---|---|---|---\ntransformationController | TransformationController |null |变化控制器\n\n![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0f2657f96ee64efb9770a18864587ded~tplv-k3u1fbpfcp-zoom-1.image)\n\n---\n\n> 可以通过`transformationController`进行变换控制,如上面通过按钮进行复位、移动  \n`TransformationController`是一个`Matrix4`泛型的ValueNotifier 所以可以通过改变TransformationController.value来对子组件进行高级的变换操作，`Matrix4`的强大，你懂得...\n\n\n```\nclass TransformationController extends ValueNotifier<Matrix4> {\n```\n\n---\n\n- `示例代码`\n\n\n```\nclass InteractiveViewerDemo3 extends StatefulWidget {\n  @override\n  _InteractiveViewerDemo3State createState() => _InteractiveViewerDemo3State();\n}\n\nclass _InteractiveViewerDemo3State extends State<InteractiveViewerDemo3>\n    with SingleTickerProviderStateMixin {\n  final TransformationController _transformationController =\n      TransformationController();\n  Animation<Matrix4> _animationReset;\n  AnimationController _controllerReset;\n\n  void _onAnimateReset() {\n    _transformationController.value = _animationReset.value;\n    if (!_controllerReset.isAnimating) {\n      _animationReset?.removeListener(_onAnimateReset);\n      _animationReset = null;\n      _controllerReset.reset();\n    }\n  }\n\n  void _animateResetInitialize() {\n    _controllerReset.reset();\n    _animationReset = Matrix4Tween(\n      begin: _transformationController.value,\n      end: Matrix4.identity(),\n    ).animate(_controllerReset);\n    _animationReset.addListener(_onAnimateReset);\n    _controllerReset.forward();\n  }\n\n  void _animateResetStop() {\n    _controllerReset.stop();\n    _animationReset?.removeListener(_onAnimateReset);\n    _animationReset = null;\n    _controllerReset.reset();\n  }\n\n  void _onInteractionStart(ScaleStartDetails details) {\n    if (_controllerReset.status == AnimationStatus.forward) {\n      _animateResetStop();\n    }\n  }\n\n  @override\n  void initState() {\n    super.initState();\n    _controllerReset = AnimationController(\n      vsync: this,\n      duration: const Duration(milliseconds: 400),\n    );\n  }\n\n  @override\n  void dispose() {\n    _controllerReset.dispose();\n    super.dispose();\n  }\n\n  @override\n  Widget build(BuildContext context) {\n    return Wrap(\n      direction: Axis.vertical,\n      spacing: 10,\n      crossAxisAlignment: WrapCrossAlignment.center,\n      alignment: WrapAlignment.center,\n      children: [\n        Container(\n          height: 150,\n          color: Colors.grey.withAlpha(33),\n          child: InteractiveViewer(\n            boundaryMargin: EdgeInsets.all(40),\n            transformationController: _transformationController,\n            minScale: 0.1,\n            maxScale: 1.8,\n            onInteractionStart: _onInteractionStart,\n            child: Container(\n              child: Image.asset('assets/images/caver.jpeg'),\n            ),\n          ),\n        ),\n        Row(\n          mainAxisAlignment: MainAxisAlignment.spaceEvenly,\n          children: [\n            _buildButton(),\n            _buildButton2(),\n            _buildButton3(),\n          ],\n        )\n      ],\n    );\n  }\n\n  Widget _buildButton() {\n    return MaterialButton(\n        child: Icon(\n          Icons.refresh,\n          color: Colors.white,\n        ),\n        color: Colors.green,\n        shape: CircleBorder(\n          side: BorderSide(width: 2.0, color: Color(0xFFFFDFDFDF)),\n        ),\n        onPressed: _animateResetInitialize);\n  }\n\n  var _x = 0.0;\n\n  Widget _buildButton2() {\n    return MaterialButton(\n        child: Icon(\n          Icons.navigate_before,\n          color: Colors.white,\n        ),\n        color: Colors.green,\n        shape: CircleBorder(\n          side: BorderSide(width: 2.0, color: Color(0xFFFFDFDFDF)),\n        ),\n        onPressed: () {\n          var temp = _transformationController.value.clone();\n          temp.translate(_x - 4);\n          _transformationController.value = temp;\n        });\n  }\n\n  Widget _buildButton3() {\n    return MaterialButton(\n        child: Icon(\n          Icons.navigate_next,\n          color: Colors.white,\n        ),\n        color: Colors.green,\n        shape: CircleBorder(\n          side: BorderSide(width: 2.0, color: Color(0xFFFFDFDFDF)),\n        ),\n        onPressed: () {\n          var temp = _transformationController.value.clone();\n          temp.translate(_x + 4);\n          _transformationController.value = temp;\n        });\n  }\n}\n```\n\n---\n\n#### 6.InteractiveViewer的核心源码\n\n> `Listener组件 + GestureDetector组件` 实现手势交互相关功能及回调  \n> `Transform组件`通过transformationController的`Matrix4`进行变换  \n> 如果 `constrained=false` 外会附加一层`ClipRect+OverflowBox`。\n\n```\n  @override\n  Widget build(BuildContext context) {\n    Widget child = Transform(\n      transform: _transformationController.value,\n      child: KeyedSubtree(\n        key: _childKey,\n        child: widget.child,\n      ),\n    );\n\n    if (!widget.constrained) {\n      child = ClipRect(\n        child: OverflowBox(\n          alignment: Alignment.topLeft,\n          minWidth: 0.0,\n          minHeight: 0.0,\n          maxWidth: double.infinity,\n          maxHeight: double.infinity,\n          child: child,\n        ),\n      );\n    }\n\n    // A GestureDetector allows the detection of panning and zooming gestures on\n    // the child.\n    return Listener(\n      key: _parentKey,\n      onPointerSignal: _receivedPointerSignal,\n      child: GestureDetector(\n        behavior: HitTestBehavior.opaque, // Necessary when panning off screen.\n        onScaleEnd: _onScaleEnd,\n        onScaleStart: _onScaleStart,\n        onScaleUpdate: _onScaleUpdate,\n        child: child,\n      ),\n    );\n  }\n}\n\n```\n", "user_name": "张风捷特烈", "description": "海的彼岸有我未曾见证的风采", "got_view_count": 456400, "category_name": "Android", "ctime": 1461266353}
{"tag_name": "Java", "concern_user_count": 252043, "user_id": "3122268755225869", "title": "Java并发编程笔记（一）基础（1）", "mark_content": "## 一、可见性、原子性和有序性\nCPU、内存、I/O 设备核心矛盾就是这三者的速度差异。解决方法\n1. CPU 增加了缓存，以均衡与内存的速度差异；\n1. 操作系统增加了进程、线程，以分时复用 CPU，进而均衡 CPU 与 I/O 设备的速度差异；\n1. 编译程序优化指令执行次序，使得缓存能够得到更加合理地利用。\n\n### 缓存导致的可见性问题\n一个线程对共享变量的修改，另外一个线程能够立刻看到，我们称为**可见性**。\n\n单核：\n![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9f70c28f935e4c38bc50d88ebe628dc3~tplv-k3u1fbpfcp-zoom-1.image)\n多核：\n![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/761d95f79ed04361abe584b49df3d837~tplv-k3u1fbpfcp-zoom-1.image)\n\n### 线程切换带来的原子性问题\n操作系统允许某个进程执行一小段时间，例如 50 毫秒，过了 50 毫秒操作系统就会重新选择一个进程来执行（我们称为“任务切换”），这个 50 毫秒称为 **“时间片”**。\n![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ed5f98caf7024b21bd6634ebfe3a8b46~tplv-k3u1fbpfcp-zoom-1.image)\n高级语言里一条语句往往需要多条 CPU 指令完成，例如count += 1，至少需要三条 CPU 指令。\n+ 指令 1：首先，需要把变量 count 从内存加载到 CPU 的寄存器；\n+ 指令 2：之后，在寄存器中执行 +1 操作；\n+ 指令 3：最后，将结果写入内存（缓存机制导致可能写入的是 CPU 缓存而不是内存）。\n![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/99074af9429f4273a2bfe2f30ca9ad90~tplv-k3u1fbpfcp-zoom-1.image)\n我们把一个或者多个操作在 CPU 执行的过程中不被中断的特性称为**原子性**。\n\n### 编译优化带来的有序性问题\n双重检查创建单例对象。\n```\npublic class Singleton {\n  static Singleton instance;\n  static Singleton getInstance(){\n    if (instance == null) {\n      synchronized(Singleton.class) {\n        if (instance == null)\n          instance = new Singleton();\n        }\n    }\n    return instance;\n  }\n}\n```\n假设有两个线程 A、B 同时调用 getInstance() 方法，他们会同时发现 instance == null ，于是同时对 Singleton.class 加锁，此时 JVM 保证只有一个线程能够加锁成功（假设是线程 A），另外一个线程则会处于等待状态（假设是线程 B）；线程 A 会创建一个 Singleton 实例，之后释放锁，锁释放后，线程 B 被唤醒，线程 B 再次尝试加锁，此时是可以加锁成功的，加锁成功后，线程 B 检查 instance == null 时会发现，已经创建过 Singleton 实例了，所以线程 B 不会再创建一个 Singleton 实例。\n\n这看上去一切都很完美，无懈可击，但实际上这个 getInstance() 方法并不完美。问题出在哪里呢？出在 new 操作上，我们以为的 new 操作应该是：\n1. 分配一块内存 M；\n1. 在内存 M 上初始化 Singleton 对象；\n1. 然后 M 的地址赋值给 instance 变量。\n\n但是实际上优化后的执行路径却是这样的：\n1. 分配一块内存 M；\n1. 将 M 的地址赋值给 instance 变量；\n1. 最后在内存 M 上初始化 Singleton 对象。\n优化后会导致什么问题呢？我们假设线程 A 先执行 getInstance() 方法，当执行完指令 2 时恰好发生了线程切换，切换到了线程 B 上；如果此时线程 B 也执行 getInstance() 方法，那么线程 B 在执行第一个判断时会发现 instance != null ，所以直接返回 instance，而此时的 instance 是没有初始化过的，如果我们这个时候访问 instance 的成员变量就可能触发空指针异常。\n![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7b345930e632478aae44495fbcee3ac1~tplv-k3u1fbpfcp-zoom-1.image)\n\n\n\n\n\n\n\n\n\n\n## 二、Java内存模型\n### 什么是 Java 内存模型？\nJava 内存模型规范了 **JVM 如何提供按需禁用缓存和编译优化的方法**。具体来说，这些方法包括 volatile、synchronized 和 final 三个关键字，以及六项 Happens-Before 规则。\n\n### 使用 volatile 的困惑\n例如，我们声明一个 volatile 变量 volatile int x = 0，它表达的是：告诉编译器，对这个变量的读写，不能使用 CPU 缓存，必须从内存中读取或者写入。\n\n例如下面的示例代码，假设线程 A 执行 writer() 方法，按照 volatile 语义，会把变量 “v=true” 写入内存；假设线程 B 执行 reader() 方法，同样按照 volatile 语义，线程 B 会从内存中读取变量 v，如果线程 B 看到 “v == true” 时，那么线程 B 看到的变量 x 是多少呢？\n\n直觉上看，应该是 42，那实际应该是多少呢？这个要看 Java 的版本，如果在低于 1.5 版本上运行，x 可能是 42，也有可能是 0；如果在 1.5 以上的版本上运行，x 就是等于 42。\n```\nclass VolatileExample {\n  int x = 0;\n  volatile boolean v = false;\n  public void writer() {\n    x = 42;\n    v = true;\n  }\n  public void reader() {\n    if (v == true) {\n      // 这里 x 会是多少呢？\n    }\n  }\n}\n```\n分析一下，为什么 1.5 以前的版本会出现 x = 0 的情况呢？我相信你一定想到了，变量 x 可能被 CPU 缓存而导致可见性问题。这个问题在 1.5 版本已经被圆满解决了。Java 内存模型在 1.5 版本对 volatile 语义进行了增强。怎么增强的呢？答案是一项 Happens-Before 规则。\n\n### Happens-Before 规则\n**前面一个操作的结果对后续操作是可见的。** Happens-Before 约束了编译器的优化行为，虽允许编译器优化，但是要求编译器优化后一定遵守 Happens-Before 规则。\n#### 1. 程序的顺序性规则\n指在一个线程中，按照程序顺序，前面的操作 Happens-Before 于后续的任意操作。比如刚才那段示例代码，按照程序的顺序，第 6 行代码 “x = 42;” Happens-Before 于第 7 行代码 “v = true;”。\n\n#### 2. volatile 变量规则 \n指对一个 volatile 变量的写操作， Happens-Before 于后续对这个 volatile 变量的读操作。\n\n这个就有点费解了，对一个 volatile 变量的写操作相对于后续对这个 volatile 变量的读操作可见，这怎么看都是禁用缓存的意思啊，貌似和 1.5 版本以前的语义没有变化啊？如果单看这个规则，的确是这样，但是如果我们关联一下规则 3，就有点不一样的感觉了。\n\n#### 3. 传递性\n这条规则是指如果 A Happens-Before B，且 B Happens-Before C，那么 A Happens-Before C。\n从图中，我们可以看到：\n![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/97778d2877f04f0786ed3416701312b4~tplv-k3u1fbpfcp-zoom-1.image)\n1. “x=42” Happens-Before 写变量 “v=true” ，这是规则 1 的内容；\n1. 写变量“v=true” Happens-Before 读变量 “v=true”，这是规则 2 的内容 。\n\n再根据这个传递性规则，我们得到结果：“x=42” Happens-Before 读变量“v=true”。这意味着什么呢？\n\n如果线程 B 读到了“v=true”，那么线程 A 设置的“x=42”对线程 B 是可见的。也就是说，线程 B 能看到 “x == 42” ，有没有一种恍然大悟的感觉？这就是 1.5 版本对 volatile 语义的增强，这个增强意义重大，1.5 版本的并发工具包（java.util.concurrent）就是靠 volatile 语义来搞定可见性的，这个在后面的内容中会详细介绍。\n\n#### 4. 管程中锁的规则\n是指对一个锁的解锁 Happens-Before 于后续对这个锁的加锁。\n\n要理解这个规则，就首先要了解“管程指的是什么”。管程是一种通用的同步原语，在 Java 中指的就是 synchronized，synchronized 是 Java 里对管程的实现。\n\n管程中的锁在 Java 里是隐式实现的，例如下面的代码，在进入同步块之前，会自动加锁，而在代码块执行完会自动释放锁，加锁以及释放锁都是编译器帮我们实现的。\n```\nsynchronized (this) { // 此处自动加锁\n  // x 是共享变量, 初始值 =10\n  if (this.x < 12) {\n    this.x = 12; \n  }  \n} // 此处自动解锁\n```\n所以结合规则 4——管程中锁的规则，可以这样理解：假设 x 的初始值是 10，线程 A 执行完代码块后 x 的值会变成 12（执行完自动释放锁），线程 B 进入代码块时，能够看到线程 A 对 x 的写操作，也就是线程 B 能够看到 x==12。这个也是符合我们直觉的，应该不难理解。\n\n#### 5. 线程 start() 规则\n这条是关于线程启动的。它是指主线程 A 启动子线程 B 后，子线程 B 能够看到主线程在启动子线程 B 前的操作。\n\n换句话说就是，如果线程 A 调用线程 B 的 start() 方法（即在线程 A 中启动线程 B），那么该 start() 操作 Happens-Before 于线程 B 中的任意操作。\n```\nThread B = new Thread(()->{\n  // 主线程调用 B.start() 之前\n  // 所有对共享变量的修改，此处皆可见\n  // 此例中，var==77\n});\n// 此处对共享变量 var 修改\nvar = 77;\n// 主线程启动子线程\nB.start();\n```\n\n#### 6. 线程 join() 规则\n这条是关于线程等待的。它是指主线程 A 等待子线程 B 完成（主线程 A 通过调用子线程 B 的 join() 方法实现），当子线程 B 完成后（主线程 A 中 join() 方法返回），主线程能够看到子线程的操作。当然所谓的“看到”，指的是对共享变量的操作。\n\n换句话说就是，如果在线程 A 中，调用线程 B 的 join() 并成功返回，那么线程 B 中的任意操作 Happens-Before 于该 join() 操作的返回。\n```\nThread B = new Thread(()->{\n  // 此处对共享变量 var 修改\n  var = 66;\n});\n// 例如此处对共享变量修改，\n// 则这个修改结果对线程 B 可见\n// 主线程启动子线程\nB.start();\nB.join()\n// 子线程所有对共享变量的修改\n// 在主线程调用 B.join() 之后皆可见\n// 此例中，var==66\n```\n\n### final\n前面我们讲 volatile 为的是禁用缓存以及编译优化，我们再从另外一个方面来看，有没有办法告诉编译器优化得更好一点呢？这个可以有，就是final 关键字。\n\nfinal 修饰变量时，初衷是告诉编译器：这个变量生而不变，可以可劲儿优化。Java 编译器在 1.5 以前的版本的确优化得很努力，以至于都优化错了。\n\n当然了，在 1.5 以后 Java 内存模型对 final 类型变量的重排进行了约束。现在只要我们提供正确构造函数没有“逸出”，就不会出问题了。\n\n“逸出”有点抽象，我们还是举个例子吧，在下面例子中，在构造函数里面将 this 赋值给了全局变量 global.obj，这就是“逸出”，线程通过 global.obj 读取 x 是有可能读到 0 的。因此我们一定要避免“逸出”。\n```\nfinal int x;\n// 错误的构造函数\npublic FinalFieldExample() { \n  x = 3;\n  y = 4;\n  // 此处就是讲 this 逸出，\n  global.obj = this;\n}\n```\n\n<br><br>\nHappens-Before 规则最初是在一篇叫做Time, Clocks, and the Ordering of Events in a Distributed System的论文中提出来的，在这篇论文中，Happens-Before 的语义是一种因果关系。在现实世界里，如果 A 事件是导致 B 事件的起因，那么 A 事件一定是先于（Happens-Before）B 事件发生的，这个就是 Happens-Before 语义的现实理解。\n\n在 Java 语言里面，Happens-Before 的语义本质上是一种可见性，A Happens-Before B 意味着 A 事件对 B 事件来说是可见的，无论 A 事件和 B 事件是否发生在同一个线程里。例如 A 事件发生在线程 1 上，B 事件发生在线程 2 上，Happens-Before 规则保证线程 2 上也能看到 A 事件的发生。\n\n\n\n\n\n\n\n\n\n\n\n## 三、互斥锁\n### 原子性问题该如何解决？\n原子性问题的源头是线程切换，如果能够禁用线程切换那不就能解决这个问题了吗？而操作系统做线程切换是依赖 CPU 中断的，所以禁止 CPU 发生中断就能够禁止线程切换。\n\n在早期单核 CPU 时代，这个方案的确是可行的，而且也有很多应用案例，但是并不适合多核场景。这里我们以 32 位 CPU 上执行 long 型变量的写操作为例来说明这个问题，long 型变量是 64 位，在 32 位 CPU 上执行写操作会被拆分成两次写操作（写高 32 位和写低 32 位，如下图所示）。\n![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2ae28a57f908415a8fd299c3fb554ceb~tplv-k3u1fbpfcp-zoom-1.image)\n在单核 CPU 场景下，同一时刻只有一个线程执行，禁止 CPU 中断，意味着操作系统不会重新调度线程，也就是禁止了线程切换，获得 CPU 使用权的线程就可以不间断地执行，所以两次写操作一定是：要么都被执行，要么都没有被执行，具有原子性。\n\n但是在多核场景下，同一时刻，有可能有两个线程同时在执行，一个线程执行在 CPU-1 上，一个线程执行在 CPU-2 上，此时禁止 CPU 中断，只能保证 CPU 上的线程连续执行，并不能保证同一时刻只有一个线程执行，如果这两个线程同时写 long 型变量高 32 位的话，那就有可能出现我们开头提及的诡异 Bug 了。\n\n**“同一时刻只有一个线程执行”这个条件非常重要，我们称之为互斥**。如果我们能够保证对共享变量的修改是互斥的，那么，无论是单核 CPU 还是多核 CPU，就都能保证原子性了。\n\n### 简易锁模型\n![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f4bbd5ca8d814a4bbcf141d503262eed~tplv-k3u1fbpfcp-zoom-1.image)\n我们把一段需要互斥执行的代码称为**临界区**。\n\n### 改进后的锁模型\n![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a56cf01cec5548a7b2d4def261321773~tplv-k3u1fbpfcp-zoom-1.image)\n在现实世界里，锁和锁要保护的资源是有对应关系的，比如你用你家的锁保护你家的东西，我用我家的锁保护我家的东西。在并发编程世界里，锁和资源也应该有这个关系。\n\n首先，我们要把临界区要保护的资源标注出来，如图中临界区里增加了一个元素：受保护的资源 R；其次，我们要保护资源 R 就得为它创建一把锁 LR；最后，针对这把锁 LR，我们还需在进出临界区时添上加锁操作和解锁操作。另外，在锁 LR 和受保护资源之间，我特地用一条线做了关联，这个关联关系非常重要。很多并发 Bug 的出现都是因为把它忽略了，然后就出现了类似锁自家门来保护他家资产的事情，这样的 Bug 非常不好诊断，因为潜意识里我们认为已经正确加锁了。\n\n### Java 语言提供的锁技术：synchronized\n```\nclass X {\n  // 修饰非静态方法\n  synchronized void foo() {\n    // 临界区\n  }\n  // 修饰静态方法\n  synchronized static void bar() {\n    // 临界区\n  }\n  // 修饰代码块\n  Object obj = new Object()；\n  void baz() {\n    synchronized(obj) {\n      // 临界区\n    }\n  }\n}  \n```\n当修饰静态方法的时候，锁定的是当前类的 Class 对象，在上面的例子中就是 Class X；<br>\n当修饰非静态方法的时候，锁定的是当前实例对象 this。\n\n对于上面的例子，synchronized 修饰静态方法相当于:\n```\nclass X {\n  // 修饰静态方法\n  synchronized(X.class) static void bar() {\n    // 临界区\n  }\n}\n```\n修饰非静态方法，相当于：\n```\nclass X {\n  // 修饰非静态方法\n  synchronized(this) void foo() {\n    // 临界区\n  }\n}\n```\n\n### 锁和受保护资源的关系\n受保护资源和锁之间的关联关系非常重要，他们的关系是怎样的呢？一个合理的关系是：**受保护资源和锁之间的关联关系是 N:1 的关系**。还拿前面球赛门票的管理来类比，就是一个座位，我们只能用一张票来保护，如果多发了重复的票，那就要打架了。现实世界里，我们可以用多把锁来保护同一个资源，但在并发领域是不行的，并发领域的锁和现实世界的锁不是完全匹配的。不过倒是可以用同一把锁来保护多个资源，这个对应到现实世界就是我们所谓的“包场”了。\n\n上面那个例子我稍作改动，把 value 改成静态变量，把 addOne() 方法改成静态方法，此时 get() 方法和 addOne() 方法是否存在并发问题呢？\n```\nclass SafeCalc {\n  static long value = 0L;\n  synchronized long get() {\n    return value;\n  }\n  synchronized static void addOne() {\n    value += 1;\n  }\n}\n```\n如果你仔细观察，就会发现改动后的代码是用两个锁保护一个资源。这个受保护的资源就是静态变量 value，两个锁分别是 this 和 SafeCalc.class。我们可以用下面这幅图来形象描述这个关系。由于临界区 get() 和 addOne() 是用两个锁保护的，因此这两个临界区没有互斥关系，临界区 addOne() 对 value 的修改对临界区 get() 也没有可见性保证，这就导致并发问题了。\n![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/bc56380a0ce74c779b5f49beced0c8a8~tplv-k3u1fbpfcp-zoom-1.image)\n\n### 保护没有关联关系的多个资源\n例如，银行业务中有针对账户余额（余额是一种资源）的取款操作，也有针对账户密码（密码也是一种资源）的更改操作，我们可以为账户余额和账户密码分配不同的锁来解决并发问题。\n相关的示例代码如下，账户类 Account 有两个成员变量，分别是账户余额 balance 和账户密码 password。取款 withdraw() 和查看余额 getBalance() 操作会访问账户余额 balance，我们创建一个 final 对象 balLock 作为锁（类比球赛门票）；而更改密码 updatePassword() 和查看密码 getPassword() 操作会修改账户密码 password，我们创建一个 final 对象 pwLock 作为锁（类比电影票）。不同的资源用不同的锁保护，各自管各自的，很简单。\n```\nclass Account {\n  // 锁：保护账户余额\n  private final Object balLock\n    = new Object();\n  // 账户余额  \n  private Integer balance;\n  // 锁：保护账户密码\n  private final Object pwLock\n    = new Object();\n  // 账户密码\n  private String password;\n \n  // 取款\n  void withdraw(Integer amt) {\n    synchronized(balLock) {\n      if (this.balance > amt){\n        this.balance -= amt;\n      }\n    }\n  } \n  // 查看余额\n  Integer getBalance() {\n    synchronized(balLock) {\n      return balance;\n    }\n  }\n \n  // 更改密码\n  void updatePassword(String pw){\n    synchronized(pwLock) {\n      this.password = pw;\n    }\n  } \n  // 查看密码\n  String getPassword() {\n    synchronized(pwLock) {\n      return password;\n    }\n  }\n}\n```\n当然，我们也可以用一把互斥锁来保护多个资源，例如我们可以用 this 这一把锁来管理账户类里所有的资源：账户余额和用户密码。具体实现很简单，示例程序中所有的方法都增加同步关键字 synchronized 就可以了。\n\n但是用一把锁有个问题，就是性能太差，会导致取款、查看余额、修改密码、查看密码这四个操作都是串行的。而我们用两把锁，取款和修改密码是可以并行的。用不同的锁对受保护资源进行精细化管理，能够提升性能。这种锁还有个名字，叫细粒度锁。\n\n### 保护有关联关系的多个资源\n如果多个资源是有关联关系的，那这个问题就有点复杂了。例如银行业务里面的转账操作，账户 A 减少 100 元，账户 B 增加 100 元。这两个账户就是有关联关系的。那对于像转账这种有关联关系的操作，我们应该怎么去解决呢？先把这个问题代码化。我们声明了个账户类：Account，该类有一个成员变量余额：balance，还有一个用于转账的方法：transfer()，然后怎么保证转账操作 transfer() 没有并发问题呢？\n```\nclass Account {\n  private int balance;\n  // 转账\n  void transfer(\n      Account target, int amt){\n    if (this.balance > amt) {\n      this.balance -= amt;\n      target.balance += amt;\n    }\n  } \n}\n```\n相信你的直觉会告诉你这样的解决方案：用户 synchronized 关键字修饰一下 transfer() 方法就可以了，于是你很快就完成了相关的代码，如下所示。\n```\nclass Account {\n  private int balance;\n  // 转账\n  synchronized void transfer(\n      Account target, int amt){\n    if (this.balance > amt) {\n      this.balance -= amt;\n      target.balance += amt;\n    }\n  } \n}\n```\n在这段代码中，临界区内有两个资源，分别是转出账户的余额 this.balance 和转入账户的余额 target.balance，并且用的是一把锁 this，符合我们前面提到的，多个资源可以用一把锁来保护，这看上去完全正确呀。真的是这样吗？可惜，这个方案仅仅是看似正确，为什么呢？\n\n问题就出在 this 这把锁上，this 这把锁可以保护自己的余额 this.balance，却保护不了别人的余额 target.balance，就像你不能用自家的锁来保护别人家的资产，也不能用自己的票来保护别人的座位一样。\n![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/65fb2026c702434a9751379bd4b87613~tplv-k3u1fbpfcp-zoom-1.image)\n\n下面我们具体分析一下，假设有 A、B、C 三个账户，余额都是 200 元，我们用两个线程分别执行两个转账操作：账户 A 转给账户 B 100 元，账户 B 转给账户 C 100 元，最后我们期望的结果应该是账户 A 的余额是 100 元，账户 B 的余额是 200 元， 账户 C 的余额是 300 元。\n\n我们假设线程 1 执行账户 A 转账户 B 的操作，线程 2 执行账户 B 转账户 C 的操作。这两个线程分别在两颗 CPU 上同时执行，那它们是互斥的吗？我们期望是，但实际上并不是。因为线程 1 锁定的是账户 A 的实例（A.this），而线程 2 锁定的是账户 B 的实例（B.this），所以这两个线程可以同时进入临界区 transfer()。同时进入临界区的结果是什么呢？线程 1 和线程 2 都会读到账户 B 的余额为 200，导致最终账户 B 的余额可能是 300（线程 1 后于线程 2 写 B.balance，线程 2 写的 B.balance 值被线程 1 覆盖），可能是 100（线程 1 先于线程 2 写 B.balance，线程 1 写的 B.balance 值被线程 2 覆盖），就是不可能是 200。\n![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/35d46aec2bdd4c659748351fb73e48f0~tplv-k3u1fbpfcp-zoom-1.image)\n\n### 使用锁的正确姿势\n**锁能覆盖所有受保护资源。**\n\n在上面的例子中，this 是对象级别的锁，所以 A 对象和 B 对象都有自己的锁，如何让 A 对象和 B 对象共享一把锁呢？\n\n稍微开动脑筋，你会发现其实方案还挺多的，比如可以让所有对象都持有一个唯一性的对象，这个对象在创建 Account 时传入。方案有了，完成代码就简单了。示例代码如下，我们把 Account 默认构造函数变为 private，同时增加一个带 Object lock 参数的构造函数，创建 Account 对象时，传入相同的 lock，这样所有的 Account 对象都会共享这个 lock 了。\n```\nclass Account {\n  private Object lock；\n  private int balance;\n  private Account();\n  // 创建 Account 时传入同一个 lock 对象\n  public Account(Object lock) {\n    this.lock = lock;\n  } \n  // 转账\n  void transfer(Account target, int amt){\n    // 此处检查所有对象共享的锁\n    synchronized(lock) {\n      if (this.balance > amt) {\n        this.balance -= amt;\n        target.balance += amt;\n      }\n    }\n  }\n}\n```\n这个办法确实能解决问题，但是有点小瑕疵，它要求在创建 Account 对象的时候必须传入同一个对象，如果创建 Account 对象时，传入的 lock 不是同一个对象，那可就惨了，会出现锁自家门来保护他家资产的荒唐事。在真实的项目场景中，创建 Account 对象的代码很可能分散在多个工程中，传入共享的 lock 真的很难。\n\n所以，上面的方案缺乏实践的可行性，我们需要更好的方案。还真有，就是用 Account.class 作为共享的锁。Account.class 是所有 Account 对象共享的，而且这个对象是 Java 虚拟机在加载 Account 类的时候创建的，所以我们不用担心它的唯一性。使用 Account.class 作为共享的锁，我们就无需在创建 Account 对象时传入了，代码更简单。\n```\nclass Account {\n  private int balance;\n  // 转账\n  void transfer(Account target, int amt){\n    synchronized(Account.class) {\n      if (this.balance > amt) {\n        this.balance -= amt;\n        target.balance += amt;\n      }\n    }\n  } \n}\n```\n下面这幅图很直观地展示了我们是如何使用共享的锁 Account.class 来保护不同对象的临界区的。\n![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d2a8fddb53054ce799ae68252d850088~tplv-k3u1fbpfcp-zoom-1.image)\n\n“原子性”的本质是什么？其实不是不可分割，不可分割只是外在表现，其本质是多个资源间有一致性的要求，**操作的中间状态对外不可见**。例如，在 32 位的机器上写 long 型变量有中间状态（只写了 64 位中的 32 位），在银行转账的操作中也有中间状态（账户 A 减少了 100，账户 B 还没来得及发生变化）。所以**解决原子性问题，是要保证中间状态对外不可见**。", "user_name": "奥兰治的威廉", "description": "", "got_view_count": 1312, "category_name": "阅读", "ctime": 1457483895}
{"tag_name": "Android", "concern_user_count": 240175, "user_id": "272334612346296", "title": "仿MultiType打造ListView多类型列表", "mark_content": "*地址：https://github.com/stevenwsg/MultiTypeListViewAdapter*\n\n\n# 1、介绍\n第一次见到MultiType时，真的被惊艳到了，没想到多类型列表可以写的这么简洁，解耦。之前有幸曾维护过一个有15种类型构成的ListView, 实在难以恭维，单个Adapter超过三千多行，各类型ViewHolder 插入其中。虽然ListView多类型Adapter 很好理解，重点就getTypeCount()，getViewType,getView()这三个方法, 但是这样写总感觉怪怪的， 如果项目组来个年轻人没用过ListView ，新增一种类型而忘了给 getTypeCount()方法加1，就要出线上事故，增加维护成本。\n\n![image](https://i.loli.net/2020/08/09/YqEFw96ZJAbSKpD.png)\n\n最近感悟到，在日常的业务开发中，觉得不爽，不合理的地方想想有没有更好的解决方式，多思考， 而不是一直在搬砖堆业务。 就MultiType而言，原理大家基本上看一下度能够理解，并不是很深奥的东西。 但是提出这个想法的人却比较少，并且在RecyclerVeiw 出现之后提出， 从Android 1.0时代，列表都是用ListView实现的， 大家实现多类型列表都是那三个方法， 为什么没有更简洁的方案提出来那（可能有些公司有大佬提出来没有开源），值得思考。\n\n\n\n从去年开始一直想写关于ListView实现多类型列表的实现方式，一直拖到现在，一个原因是菜，一个原因是懒。之前工作太忙了。 趁着前段时间不太忙，把这个想法完善了一下。 \n\n\n了解MultiType原理的同学，理解接下来要说的其实问题不大， 不了解的同学其实可以看看我这篇， [RecyclerView多类型列表实现—— MultiType分析](https://juejin.im/post/6844904152108122126)， 简单的来说就是维护一个映射表，实现ViewType类型，Bean数据，ViewHolder的映射。\n\n回忆一下MultiType的实现：\n![image](https://user-gold-cdn.xitu.io/2020/5/9/171f93bfcfab7a41?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)\n\n对应的映射表：  \n\n\nViewType | Java Bean Class | Linker | ItemViewBinder\n---|---|---|---\n0 | C1 | L1|binder_1\n1 | C2 | L2|binder_2_1\n2 | C2 | L2|binder_2_2\n3 | C2 | L2|binder_2_3\n4 | C2 | L3|binder_3_1\n\n此次MultiTypeListViewAdapter的实现：\n\n![image](https://i.loli.net/2020/08/09/aOTm583lYrVivt6.png)\n对应的映射表：  \n\n\nViewType | Java Bean Class | ViewHolder\n---|---|---|---\n0 | C0 | viewHolder0\n1 | C1 | viewHolder1\n2 | C2 | viewHolder2\n3 | C3 | viewHolder3\n4 | C4 | viewHolder4\n\n可以看出此次实现的MultiTypeListViewAdapter相比MultiType只实现了一对一映射， 而没有实现一对多映射，如果有相关需求的话，可以考虑在数据层解决这个问题，即多个JavaBean绑定同一个ViewHolder。\n\n\n\n如果你想对老项目中的多类型ListView进行整理或者小范围重构的话，可以试试这个方案， 对代码改动量和迁移量是比较小的。大范围重构可能就考虑RecyclerView了。\n\n# 2、 使用\n\n用法比较简洁， 和MultiType的用法其实是一样的\n\n### 1、创建数据实体\n\n```\ndata class TextItem(val text : String)\n```\n### 2、创建ViewHolder\n\n```\nclass TextViewHolder : BaseViewHolder<TextItem>() {\n\n    private var text: TextView? = null\n\n    override fun getLayoutId(): Int {\n        return R.layout.item_text //返回VH的布局文件\n    }\n\n    override fun onBindViewHolder(rootView: View) {\n        text = rootView.findViewById(R.id.text) //绑定View\n    }\n\n    override fun render(item: TextItem, position: Int) {\n        text?.text = item.text //渲染数据和设置点击事件等\n    }\n}\n```\n\n### 3、Adapter绑定ViewHolder,注入数据\n\n\n```\nclass MainActivity : AppCompatActivity() {\n\n    private var mList: MutableList<Any>? = null\n    private var mListView: ListView? = null\n    private var adapter: MultiTypeListViewAdapter? = null\n\n    override fun onCreate(savedInstanceState: Bundle?) {\n        super.onCreate(savedInstanceState)\n        setContentView(R.layout.activity_main)\n        initData();\n        initAdapter();\n\n        mListView = findViewById(R.id.listview)\n        mListView?.adapter = adapter\n    }\n\n    private fun initData() {\n        mList = ArrayList()\n        for (i in 1..100) { //添加各种类型的数据\n            mList?.add(ImageItem(R.mipmap.ic_launcher))\n            mList?.add(RichItem(\"小艾大人赛高\", R.drawable.ic_launcher_foreground))\n            mList?.add(TextItem(\"没有什么能够阻挡，你对自由的向往~\"))\n        }\n    }\n\n    //注册ViewHolder\n    private fun initAdapter() { //绑定各个类型的VH和数据，填充映射表\n        adapter = MultiTypeListViewAdapter(this, mList)\n        adapter?.register(RichItem::class.java, RichTextViewHolder())\n        adapter?.register(ImageItem::class.java, ImageViewHolder())\n        adapter?.register(TextItem::class.java, TextViewHolder())\n    }\n}\n```\n  实现效果  \n  \n![image](https://i.loli.net/2020/08/09/BfMw3CAV4U2Sbl1.png)\n\n# 3、原理\n\n原理其实就是将getTypeCount()，getViewType,getView()这三个方法封装起来，帮助开发者避免这三个方法， 具体的实现方式就是维护这个映射表。\n\nViewType | Java Bean Class | ViewHolder\n---|---|---|---\n0 | C0 | viewHolder0\n1 | C1 | viewHolder1\n2 | C2 | viewHolder2\n3 | C3 | viewHolder3\n4 | C4 | viewHolder4\n\n怎么映射那，下面就开始上代码：  \n这个是项目结构，代码量很少， 大家如果感兴趣的话， 可以下载下来看看，不大只有四个类  \n\n\n![image](https://i.loli.net/2020/08/09/izbagGRA9h5JrZm.png)\n\n\n### 1、TypePool\n\n```\ninterface TypePool {\n    fun <T> register(clazz: Class<out T>, holder: BaseViewHolder<T>)\n    fun unregister(clazz: Class<*>)\n    fun size(): Int //类型数目\n    fun indexOf(clazz: Class<*>): Int //Class对应的positon\n    fun getBaseViewHolder(index: Int): BaseViewHolder<*>\n}\n```\n\n2、MultiTypePool\n\n\n```\npublic class MultiTypePool : TypePool {\n    private val classes: MutableList<Class<*>>\n    private val holders: MutableList<BaseViewHolder<*>>\n\n    constructor() { //维护上面所说的映射表\n        classes = ArrayList()\n        holders = ArrayList()\n    }\n\n    constructor(initialCapacity: Int) {\n        classes = ArrayList(initialCapacity)\n        holders = ArrayList(initialCapacity)\n    }\n\n    //注册和解绑其实都是对上述映射表的操作\n    override fun <T> register(\n        clazz: Class<out T>,\n        holder: BaseViewHolder<T>\n    ) {\n        classes.add(clazz)\n        holders.add(holder)\n    }\n\n    override fun unregister(clazz: Class<*>) {\n        val postion = indexOf(clazz)\n        classes.remove(clazz)\n        holders.removeAt(postion)\n    }\n\n    override fun size(): Int { // 一共多少个类型的VH\n        return classes.size\n    }\n\n    override fun indexOf(clazz: Class<*>): Int { //对应的postion\n        return classes.indexOf(clazz)\n    }\n\n    override fun getBaseViewHolder(index: Int): BaseViewHolder<*> {\n        return holders[index]\n    }\n}\n```\n### 3、BaseViewHolder\n\n就是普通的ViewHolder, 约定俗成的实现以下方法， 可以看出并没有像MultiType在做一层代理，减少理解成本， 和平时的使用其实是一样的\n\n```\npublic abstract class BaseViewHolder<T> {\n\n    protected var adapter: MultiTypeListViewAdapter? = null\n\n    // 获取布局id\n    abstract fun getLayoutId(): Int\n    abstract fun onBindViewHolder(rootView: View) // 绑定View\n    abstract fun render(item: T, position: Int) // 渲染数据\n}\n```\n#### 4、MultiTypeListViewAdapter\n\n```\npublic class MultiTypeListViewAdapter extends BaseAdapter {\n\n    private static final String TAG = \"MultiTypeListViewAdapter\";\n    private List<?> items;\n    private TypePool typePool;\n    private LayoutInflater inflater;\n\n    // 下面这些方法，和ListView普通Adapter写法一样\n    public MultiTypeListViewAdapter(Context context) {\n        this(context, Collections.emptyList());\n    }\n\n    public MultiTypeListViewAdapter(Context context, List<?> items) {\n        this(context, items, new MultiTypePool());\n    }\n\n    public MultiTypeListViewAdapter(Context context, List<?> items, int initialCapacity) {\n        this(context, items, new MultiTypePool(initialCapacity));\n    }\n\n    public MultiTypeListViewAdapter(Context context, List<?> items, TypePool pool) {\n        this.items = items;\n        this.typePool = pool;\n        inflater = (LayoutInflater) context.getSystemService(Context.LAYOUT_INFLATER_SERVICE);\n    }\n\n    public void setItems(List<?> items) {\n        this.items = items;\n    }\n\n    public List<?> getItems() {\n        return items;\n    }\n\n    public <T> void register(Class<? extends T> clazz, BaseViewHolder<T> holder) {\n        typePool.register(clazz, holder);\n        holder.setAdapter(this); // 将Adapter注入VH中， 方便后面VH调用Adapter或者Activity的方法， 同时需要注意回收\n    }\n\n\n    @Override\n    public int getCount() {\n        return items.size();\n    }\n\n    @Override\n    public Object getItem(int position) {\n        return items.get(position);\n    }\n\n    @Override\n    public long getItemId(int position) {\n        return position;\n    }\n\n    @Override\n    public View getView(int position, View convertView, ViewGroup parent) {\n        BaseViewHolder viewHolder;\n        int viewType = getItemViewType(position);\n//        if (convertView == null) {\n//        viewHolder = typePool.getBaseViewHolder(viewType);\n//       convertView = inflater.inflate(viewHolder.getLayoutId(), parent, false);\n//        viewHolder.onBindViewHolder(convertView);\n//\n//            convertView.setTag(viewHolder);\n//        } else {\n//            viewHolder = typePool.getBaseViewHolder(viewType);\n//        }\n\n// 这块的VH 复用还是有点问题， 写出来还是想找大家看看有没有好的方式解决这个\n\n        // 下面这块是VH不复用的方式\n        viewHolder = typePool.getBaseViewHolder(viewType); //拿到相应的ViewHolder\n        convertView = inflater.inflate(viewHolder.getLayoutId(), parent, false); //初始化布局\n        viewHolder.onBindViewHolder(convertView); //ViewHolder绑定布局\n    \n        viewHolder.render(getItem(position), position); //ViewHolder渲染数据\n        return convertView;\n    }\n\n    @Override\n    public int getViewTypeCount() { // 就是返回映射表的行数量\n        return typePool.size();\n    }\n\n    @Override\n    public int getItemViewType(int position) { // 返回该用第几行的类型\n        return typePool.indexOf(items.get(position).getClass());\n    }\n}\n```\n目前这个getView()方法中的VH是没有复用的， 不推荐这么做，但是复用版写的代码复用的有点问题，想让大家看看改怎么修改，这也是开源嘛， 逃（为自己的菜找原因）。\n\n#### 4、总结\n大家日常写列表可能已经不考虑ListView了，都使用RecyclerView了。虽然这篇文章讲的是ListView实现的多类型列表，也是近期来的一些思考，分享出来。感兴趣的同学可以下载源码看看。\n\nGitHub地址：https://github.com/stevenwsg/MultiTypeListViewAdapter\n", "user_name": "沉默王贰", "description": "人缺的是选择的勇气，对于选择的后果无法承担的恐惧", "got_view_count": 2824, "category_name": "Android", "ctime": 1461266353}
{"tag_name": "Java", "concern_user_count": 252044, "user_id": "2814346130098919", "title": "这篇关于Spring之SSM框架的笔记你真得看看，写的非常详细了", "mark_content": "## 什么是AOP\n\nAOP是Aspect Oriented Programming的缩写，意思为面向切面编程，是通过预编译的方法和运行期动态代理实现程序的统一维护的一种技术\n\nAOP是OOP（面向对象）的延续，是软件开发中的一个热点，也是Spring框架中的一个重要内容，是函数式编程的一种衍生范型。利用AOP可以对业务逻辑的各个部分进行隔离，从而使得业务逻辑各部分之间的耦合度降低，提高程序的可重用性，同时提高了开发的效率。\n\n## AOP的作用及其优势\n\n## 作用\n\n在程序运行期间，在不修改源码的情况下对方法进行功能增强\n\n## 优势\n\n减少重复代码，提高开发效率，并且便于维护\n\n## AOP的底层实现\n\n实际上，在AOP的底层是通过Spring提供的动态代理技术实现的。在运行期间，Spring通过动态代理技术动态生成代理对象，代理对象方法执行时进行增强功能的介入，在去调用目标对象的方法，从而完成功能的增强。\n\n## AOP的动态代理技术\n\n## 常用的动态代理技术：\n\n*   JDK代理：基于接口的动态代理技术\n*   cglib:基于父类的动态代理技术\n\n## AOP相关概念\n\nSpring的AOP实现底层就是对动态代理的代码进行了封装，封装后我们只需要对关注的部分进行代码编写，并通过配置的方式完成指定目标的方法增强。\n\n## 相关术语\n\n*   Target（目标对象）：代理的目标对象\n*   Proxy（代理）：一个被AOP织入增强后，就产生一个结果代理类\n*   Joinpoint（连接点）：所谓连接点是指那些被拦截到的点。在spring中，这些点指的是方法，因为spring只支持方法类型的连接点\n*   Pointcut（切入点）：所谓切入点是指我们要对哪些Joinpoint进行拦截定义\n*   Advice（通知/增强）：所谓通知是指拦截到Joinpoint之后所要做的事情就是通知\n*   Aspect（切面）：是切入点和通知（引介）的结合\n*   Weaving（织入）：是指把增强应用到目标对象来创建新的代理对象的过程。Spring采用动态代理织入，而AspectJ采用编译期织入和类装载期织入\n\n## AOP开发的明确事项\n\n## 需要编写的内容\n\n*   编写核心业务代码（目标类的目标方法）\n*   编写切面类，切面中有通知（增强功能的方法）\n*   在配置文件中织入关系，即将哪些通知与哪些连接点进行结合\n\n## AOP技术实现的内容\n\nSpring框架监控切入点方法的执行。一旦切入点方法被运行，使用代理机制，动态创建目标对象的代理对象，根据通知类别，在代理对象的对应位置，将通知对应的功能织入，完成完整的代码逻辑运行。\n\n## AOP底层使用哪种代理方式\n\n在spring中，框架会根据目标类是否实现了接口来决定采用哪种动态代理的方式\n\n## 基于XML的AOP开发\n\n## 快速入门\n\n1.  导入AOP相关的坐标\n\n```\n <dependency>\n                   <groupId>org.springframework</groupId>\n                   <artifactId>spring-context</artifactId>\n                   <version>5.2.5.RELEASE</version>\n               </dependency>\n       <dependency>\n                   <groupId>org.aspectj</groupId>\n                   <artifactId>aspectjweaver</artifactId>\n                   <version>1.8.4</version>\n               </dependency>\n               <dependency>\n                   <groupId>junit</groupId>\n                   <artifactId>junit</artifactId>\n                   <version>4.12</version>\n               </dependency>\n\n```\n\n2.  创建目标接口和目标类（内部有切点）\n\n```\n public interface TargetInterface {\n           void save();\n}\n\n```\n\n```\n public class Target implements TargetInterface {\n           @Override\n           public void save() {\n               System.out.println(\"意大利炮准备就绪！\");\n           }\n}\n\n```\n\n3.  创建切面类（内部有增强方法）\n\n```\n public class MyAspect {\n\n           public void before(){\n               System.out.println(\"我是前置方法。。。。。。。\");\n           }\n}\n\n```\n\n4.  将目标类和切面类的对象创建权交给spring\n\n```\n \t\t\t<!--目标对象-->\n           <bean id=\"target\" class=\"zyh.com.aop.Target\"></bean>\n\n           <!--切面对象-->\n           <bean id=\"myAspect\" class=\"zyh.com.aop.MyAspect\"></bean>\n\n```\n\n5.  在applicationContext.xml中配置织入关系\n\n```\n  \t\t<!--配置织入：告诉spring框架 哪些方法（切点）需要进行哪些增强（前置，后置...)-->\n           <aop:config>\n               <!--声明切面-->\n               <aop:aspect ref=\"myAspect\">\n                   <!--切面：切点+通知 当访问save方法时，会通过myAspect中的before方法进行前置增强-->\n                   <aop:before method=\"before\" pointcut=\"execution(public void zyh.com.aop.Target.save())\"/>\n               </aop:aspect>\n           </aop:config>\n\n```\n\n6.  测试代码\n\n```\n\t   @RunWith(SpringJUnit4ClassRunner.class)\n       @ContextConfiguration(\"classpath:applicationContext.xml\")\n       public class AopTest {\n           @Autowired\n           @Qualifier(\"target\")\n           private TargetInterface target;\n\n           @Test\n           public void  t1(){\n               target.save();\n           }\n       }\n\n```\n\n## 切点表达式的写法\n\n表达式语法：excution([修饰符] 返回值类型 包名.类名.方法名(参数))\n\n*   访问修饰符可以省略\n*   返回值类型、包名、类名、方法名可以使用*代表任意\n*   包名与类名之间一个点，代表当前包下的类，两个点…表示当前包及其子包下的类\n*   参数列表可以使用两个…表示任意个数，任意类型的参数列表\n\n## 通知类型\n\n*   前置通知： aop:before 切入点方法之前执行\n\n*   后置通知:aop:after-returning 切入点方法之后执行\n\n*   环绕通知：aop:around 切入点方法之前和之后都执行\n    //ProceedingJoinPoint:正在执行的连接点====切点\n    public Object around(ProceedingJoinPoint pjp)throws Throwble{\n    System.out.println(“环绕前增强”);\n    Object proceed = pjp.proceed();//切点方法\n    System.out.println(“环绕后增强”);\n    return proceed;\n    }\n\n*   异常抛出通知：aop:throwing 指定增强方法出现异常时执行\n\n*   最终通知：aop:after 无论增强方法是否有异常都执行\n\n## 基于注解的AOP开发\n\n## 快速入门\n\n1.  创建目标接口和目标类（内部有切点）\n2.  创建切面类（内部有增强方法）\n3.  将目标类和切面类的创建权交给spring\n\n```\n\t   @Component(\"target\")\n       public class Target implements TargetInterface {\n           @Override\n           public void save() {\n               System.out.println(\"意大利炮准备就绪！\");\n           }\n       }\n\n```\n\n```\n\t   @Component(\"myAspect\")\n       public class MyAspect {\n\n           public void before(){\n               System.out.println(\"我是前置方法。。。。。。。\");\n           }\n       }\n\n```\n\n4.  在切面类中使用注解配置织入关系\n\n```\n\t   @Component(\"myAspect\")\n       @Aspect//标注当前MyAspect是一个切面类\n       public class MyAspect {\n\n           @Before(value = \"execution(* zyh.com.anno.*.*(..))\")\n           public void before(){\n               System.out.println(\"我是前置方法。。。。。。。\");\n           }\n       }\n\n```\n\n5.  在配置文件中开启组件扫描和AOP的自动代理\n\n```\n   <?xml version=\"1.0\" encoding=\"UTF-8\"?>\n       <beans xmlns=\"http://www.springframework.org/schema/beans\"\n              xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n              xmlns:aop=\"http://www.springframework.org/schema/aop\"\n              xmlns:context=\"http://www.springframework.org/schema/context\"\n              xsi:schemaLocation=\"\n              http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\n              http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop.xsd\n              http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd\n       \">\n           <!--组件扫描-->\n           <context:component-scan base-package=\"zyh.com.anno\"/>\n           <!--aop自动代理-->\n           <aop:aspectj-autoproxy/>\n\n       </beans>\n\n```\n\n6.  测试\n\n```\n @RunWith(SpringJUnit4ClassRunner.class)\n       @ContextConfiguration(\"classpath:applicationContext-anno.xml\")\n       public class AnnoTest {\n           @Autowired\n           @Qualifier(\"target\")\n           private TargetInterface target;\n\n           @Test\n           public void  t1(){\n               target.save();\n           }\n       }\n```\n## 最后\n感谢你看到这里，看完有什么的不懂的可以在评论区问我，觉得文章对你有帮助的话记得给我点个赞，每天都会分享java相关技术文章或行业资讯，欢迎大家关注和转发文章！\n", "user_name": "程序员匡胤", "description": "多年一线架构师经验，和你分享工作中的难题趣事", "got_view_count": 1553, "category_name": "后端", "ctime": 1457483880}
{"tag_name": "后端", "concern_user_count": 364361, "user_id": "641770521628487", "title": "冷饭新炒：理解Snowflake算法的实现原理", "mark_content": "## 前提\n\n`Snowflake`（雪花）是`Twitter`开源的高性能`ID`生成算法（服务）。\n\n![](https://throwable-blog-1256189093.cos.ap-guangzhou.myqcloud.com/202008/s-f-a-g-1.png)\n\n上图是`Snowflake`的`Github`仓库，`master`分支中的`REAEMDE`文件中提示：初始版本于`2010`年发布，基于`Apache Thrift`，早于`Finagle`（这里的`Finagle`是`Twitter`上用于`RPC`服务的构建模块）发布，而`Twitter`内部使用的`Snowflake`是一个完全重写的程序，在很大程度上依靠`Twitter`上的现有基础架构来运行。\n\n而`2010`年发布的初版`Snowflake`源码是使用`Scala`语言编写的，归档于`scala_28`分支。换言之，**大家目前使用的`Snowflake`算法原版或者改良版已经是十年前（当前是`2020`年）的产物，不得不说这个算法确实比较厉害**。`scala_28`分支中有介绍该算法的动机和要求，这里简单摘录一下：\n\n**动机：**\n\n- `Cassandra`中没有生成顺序`ID`的工具，`Twitter`由使用`MySQL`转向使用`Cassandra`的时候需要一种新的方式来生成`ID`（印证了架构不是设计出来，而是基于业务场景迭代出来）。\n\n**要求：**\n\n- 高性能：每秒每个进程至少产生`10K`个`ID`，加上网络延迟响应速度要在`2ms`内。\n- 顺序性：具备按照时间的自增趋势，可以直接排序。\n- 紧凑性：保持生成的`ID`的长度在`64 bit`或更短。\n- 高可用：`ID`生成方案需要和存储服务一样高可用。\n\n下面就`Snowflake`的源码分析一下他的实现原理。\n\n<!-- more -->\n\n## Snowflake方案简述\n\n`Snowflake`在初版设计方案是：\n\n- 时间：`41 bit`长度，使用毫秒级别精度，带有一个自定义`epoch`，那么可以使用大概`69`年。\n- 可配置的机器`ID`：`10 bit`长度，可以满足`1024`个机器使用。\n- 序列号：`12 bit`长度，可以在`4096`个数字中随机取值，从而避免单个机器在`1 ms`内生成重复的序列号。\n\n![](https://throwable-blog-1256189093.cos.ap-guangzhou.myqcloud.com/202008/s-f-a-g-2.png)\n\n但是在实际源码实现中，`Snowflake`把`10 bit`的可配置的机器`ID`拆分为`5 bit`的`Worker ID`（这个可以理解为原来的机器`ID`）和`5 bit`的`Data Center ID`（数据中心`ID`），详情见`IdWorker.scala`：\n\n![](https://throwable-blog-1256189093.cos.ap-guangzhou.myqcloud.com/202008/s-f-a-g-3.png)\n\n也就是说，支持配置最多`32`个机器`ID`和最多`32`个数据中心`ID`：\n\n![](https://throwable-blog-1256189093.cos.ap-guangzhou.myqcloud.com/202008/s-f-a-g-4.png)\n\n由于算法是`Scala`语言编写，是依赖于`JVM`的语言，返回的`ID`值为`Long`类型，也就是`64 bit`的整数，原来的算法生成序列中只使用了`63 bit`的长度，要返回的是无符号数，所以在高位补一个`0`（占用`1 bit`），那么加起来整个`ID`的长度就是`64 bit`：\n\n![](https://throwable-blog-1256189093.cos.ap-guangzhou.myqcloud.com/202008/s-f-a-g-5.png)\n\n其中：\n\n- `41 bit`毫秒级别时间戳的取值范围是：`[0, 2^41 - 1]` => `0 ~ 2199023255551`，一共`2199023255552`个数字。\n- `5 bit`机器`ID`的取值范围是：`[0, 2^5 - 1]` => `0 ~ 31`，一共`32`个数字。\n- `5 bit`数据中心`ID`的取值范围是：`[0, 2^5 - 1]` => `0 ~ 31`，一共`32`个数字。\n- `12 bit`序列号的取值范围是：`[0, 2^12 - 1]` => `0 ~ 4095`，一共`4096`个数字。\n\n那么理论上可以生成`2199023255552 * 32 * 32 * 4096`个完全不同的`ID`值。\n\n`Snowflake`算法还有一个明显的特征：**依赖于系统时钟**。`41 bit`长度毫秒级别的时间来源于系统时间戳，所以必须保证系统时间是向前递进，不能发生**时钟回拨**（通说来说就是不能在同一个时刻产生多个相同的时间戳或者产生了过去的时间戳）。一旦发生时钟回拨，`Snowflake`会拒绝生成下一个`ID`。\n\n## 位运算知识补充\n\n`Snowflake`算法中使用了大量的位运算。由于整数的补码才是在计算机中的存储形式，`Java`或者`Scala`中的整型都使用补码表示，这里稍微提一下原码和补码的知识。\n\n- 原码用于阅读，补码用于计算。\n- 正数的补码与其原码相同。\n- 负数的补码是除最高位其他所有位取反，然后加`1`（反码加`1`），而负数的补码还原为原码也是使用这个方式。\n- `+0`的原码是`0000 0000`，而`-0`的原码是`1000 0000`，补码只有一个`0`值，用`0000 0000`表示，这一点很重要，补码的`0`没有二义性。\n\n简单来看就是这样：\n\n```shell\n* [+ 11] 原码 = [0000 1011] 补码 = [0000 1011]\n* [- 11] 原码 = [1000 1011] 补码 = [1111 0101]\n\n* [- 11]的补码计算过程： \n        原码                  1000 1011\n        除了最高位其他位取反   1111 0100\n        加1                   1111 0101  （补码） \n```\n\n使用原码、反码在计算的时候得到的不一定是准确的值，而使用补码的时候计算结果才是正确的，记住这个结论即可，这里不在举例。由于`Snowflake`的`ID`生成方案中，除了最高位，其他四个部分都是无符号整数，所以四个部分的整数**使用补码进行位运算的效率会比较高，也只有这样才能满足Snowflake高性能设计的初衷**。`Snowflake`算法中使用了几种位运算：异或（`^`）、按位与（`&`）、按位或（`|`）和带符号左移（`<<`）。\n\n### 异或\n\n异或的运算规则是：`0^0=0` `0^1=1` `1^0=1` `1^1=0`，也就是位不同则结果为1，位相同则结果为0。主要作用是：\n\n- 特定位翻转，也就是一个数和`N`个位都为`1`的数进行异或操作，这对应的`N`个位都会翻转，例如`0100 & 1111`，结果就是`1011`。\n- 与`0`项异或，则结果和原来的值一致。\n- 两数的值交互：`a=a^b` `b=b^a` `a=a^b`，这三个操作完成之后，`a`和`b`的值完成交换。 \n\n这里推演一下最后一条：\n\n```shell\n* [+ 11] 原码 = [0000 1011] 补码 = [0000 1011] a\n* [- 11] 原码 = [1000 1011] 补码 = [1111 0101] b\n\na=a^b          0000 1011\n               1111 0101\n               ---------^\n               1111 1110\nb=b^a          1111 0101\n               ---------^\n               0000 1011  （十进制数：11） b\na=a^b          1111 1110\n               ---------^\n               1111 0101  （十进制数：-11） a \n```\n\n### 按位与\n\n按位与的运算规则是：`0&0=0` `0&1=0` `1&0=0` `1&1=1`，只有对应的位都为1的时候计算结果才是1，其他情况的计算结果都是0。主要作用是：\n\n- 清零，如果想把一个数清零，那么和所有位为`0`的数进行按位与即可。\n- 取一个数中的指定位，例如要取`X`中的低`4`位，只需要和`zzzz...1111`进行按位与即可，例如取`1111 0110`的低`4`位，则`11110110 & 00001111`即可得到`00000110`。\n\n### 按位或\n\n按位与的运算规则是：`0|0=0` `0|1=1` `1|0=1` `1|1=1`，只要有其中一个位存在1则计算结果是1，只有两个位同时为0的情况下计算结果才是0。主要作用是：\n\n- 对一个数的部分位赋值为`1`，只需要和对应位全为`0`的数做按位或操作就行，例如`1011 0000`如果低`4`位想全部赋值为`1`，那么`10110000 | 00001111`即可得到`1011 1111`。\n\n### 带符号左移\n\n带符号左移的运算符是`<<`，一般格式是：`M << n`。作用如下：\n\n- `M`的二进制数（补码）向左移动`n`位。\n- 左边（高位）移出部分直接舍弃，右边（低位）移入部分全部补`0`。\n- 移位结果：相当于`M`的值乘以`2`的`n`次方，并且0、正、负数通用。\n- 移动的位数超过了该类型的最大位数，那么编译器会对移动的位数取模，例如`int`移位`33`位，实际上只移动了`33 % 2 = 1`位。\n\n推演过程如下（假设`n = 2`）：\n\n```shell\n* [+ 11] 原码 = [0000 1011] 补码 = [0000 1011]\n* [- 11] 原码 = [1000 1011] 补码 = [1111 0101]\n\n* [+ 11 << 2]的计算过程\n      补码          0000 1011\n      左移2位       0000 1011  \n      舍高补低      0010 1100\n      十进制数    2^2 + 2^3 + 2^5 = 44\n\n* [- 11 << 2]的计算过程\n      补码          1111 0101\n      左移2位       1111 0101  \n      舍高补低      1101 0100 \n      原码          1010 1100 （补码除最高位其他所有位取反再加1）\n      十进制数    - (2^2 + 2^3 + 2^5) = -44\n```\n\n可以写个`main`方法验证一下：\n\n```java\npublic static void main(String[] args) {\n      System.out.println(-11 << 2); // -44\n      System.out.println(11 << 2);  // 44\n}\n```\n\n### 组合技巧\n\n利用上面提到的三个位运算符，相互组合可以实现一些高效的计算方案。\n\n**计算n个bit能表示的最大数值：**\n\n`Snowflake`算法中有这样的代码：\n\n```java\n// 机器ID的位长度\nprivate val workerIdBits = 5L;\n// 最大机器ID -> 31\nprivate val maxWorkerId = -1L ^ (-1L << workerIdBits);\n```\n\n这里的算子是`-1L ^ (-1L << 5L)`，整理运算符的顺序，再使用`64 bit`的二进制数推演计算过程如下：\n\n```shell\n* [-1] 的补码         11111111 11111111 11111111 11111111 11111111 11111111 11111111 11111111\n  左移5位             11111111 11111111 11111111 11111111 11111111 11111111 11111111 11100000\n  [-1] 的补码         11111111 11111111 11111111 11111111 11111111 11111111 11111111 11111111\n  异或                ----------------------------------------------------------------------- ^ \n  结果的补码          00000000 00000000 00000000 00000000 00000000 00000000 00000000 00011111  （十进制数 2^0 + 2^1 + 2^2 + 2^3 + 2^4 = 31）\n```\n\n这样就能计算出`5 bit`能表示的最大数值`n`，`n`为整数并且`0 <= n <= 31`，即`0、1、2、3...31`。`Worker ID`和`Data Center ID`部分的最大值就是使用这种组合运算得出的。\n\n**用固定位的最大值作为Mask避免溢出：**\n\n`Snowflake`算法中有这样的代码：\n\n```java\nvar sequence = 0L\n......\nprivate val sequenceBits = 12L\n// 这里得到的是sequence的最大值4095\nprivate val sequenceMask = -1L ^ (-1L << sequenceBits)\n......\nsequence = (sequence + 1) & sequenceMask\n```\n\n最后这个算子其实就是`sequence = (sequence + 1) & 4095`，假设`sequence`当前值为`4095`，推演一下计算过程：\n\n```shell\n* [4095] 的补码                 00000000 00000000 00000000 00000000 00000000 00000000 00000111 11111111\n  [sequence + 1] 的补码         00000000 00000000 00000000 00000000 00000000 00000000 00001000 00000000\n  按位与                        ----------------------------------------------------------------------- &\n  计算结果                      00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000  （十进制数：0）\n```\n\n可以编写一个`main`方法验证一下：\n\n```java\npublic static void main(String[] args) {\n    int mask = 4095;\n    System.out.println(0 & mask); // 0\n    System.out.println(1 & mask); // 1\n    System.out.println(2 & mask); // 2\n    System.out.println(4095 & mask); // 4095\n    System.out.println(4096 & mask); // 0\n    System.out.println(4097 & mask); // 1\n}\n```\n\n也就是`x = (x + 1) & (-1L ^ (-1L << N))`能保证最终得到的`x`值不会超过`N`，这是利用了按位与中的\"取指定位\"的特性。\n\n## Snowflake算法实现源码分析\n\n`Snowflake`虽然用`Scala`语言编写，语法其实和`Java`差不多，当成`Java`代码这样阅读就行，下面阅读代码的时候会跳过一些日志记录和度量统计的逻辑。先看`IdWorker.scala`的属性值：\n\n```java\n// 定义基准纪元值，这个值是北京时间2010-11-04 09:42:54，估计就是2010年初版提交代码时候定义的一个时间戳\nval twepoch = 1288834974657L\n\n// 初始化序列号为0\nvar sequence = 0L //TODO after 2.8 make this a constructor param with a default of 0\n\n// 机器ID的最大位长度为5\nprivate val workerIdBits = 5L\n\n// 数据中心ID的最大位长度为5\nprivate val datacenterIdBits = 5L\n\n// 最大的机器ID值，十进制数为为31\nprivate val maxWorkerId = -1L ^ (-1L << workerIdBits)\n\n// 最大的数据中心ID值，十进制数为为31\nprivate val maxDatacenterId = -1L ^ (-1L << datacenterIdBits)\n\n// 序列号的最大位长度为12\nprivate val sequenceBits = 12L\n\n// 机器ID需要左移的位数12\nprivate val workerIdShift = sequenceBits\n\n// 数据中心ID需要左移的位数 = 12 + 5\nprivate val datacenterIdShift = sequenceBits + workerIdBits\n\n// 时间戳需要左移的位数 = 12 + 5 + 5\nprivate val timestampLeftShift = sequenceBits + workerIdBits + datacenterIdBits\n\n// 序列号的掩码，十进制数为4095\nprivate val sequenceMask = -1L ^ (-1L << sequenceBits)\n\n// 初始化上一个时间戳快照值为-1\nprivate var lastTimestamp = -1L\n\n// 下面的代码块为参数校验和初始化日志打印，这里不做分析\nif (workerId > maxWorkerId || workerId < 0) {\nexceptionCounter.incr(1)\nthrow new IllegalArgumentException(\"worker Id can't be greater than %d or less than 0\".format(maxWorkerId))\n}\n\nif (datacenterId > maxDatacenterId || datacenterId < 0) {\nexceptionCounter.incr(1)\nthrow new IllegalArgumentException(\"datacenter Id can't be greater than %d or less than 0\".format(maxDatacenterId))\n}\n\nlog.info(\"worker starting. timestamp left shift %d, datacenter id bits %d, worker id bits %d, sequence bits %d, workerid %d\",\ntimestampLeftShift, datacenterIdBits, workerIdBits, sequenceBits, workerId)\n```\n\n![](https://throwable-blog-1256189093.cos.ap-guangzhou.myqcloud.com/202008/s-f-a-g-8.png)\n\n接着看算法的核心代码逻辑：\n\n```java\n// 同步方法，其实就是protected synchronized long nextId(){ ...... }\nprotected[snowflake] def nextId(): Long = synchronized {\n    // 获取系统时间戳（毫秒）\n    var timestamp = timeGen()\n    // 高并发场景，同一毫秒内生成多个ID\n    if (lastTimestamp == timestamp) {\n        // 确保sequence + 1之后不会溢出，最大值为4095，其实也就是保证1毫秒内最多生成4096个ID值\n        sequence = (sequence + 1) & sequenceMask\n        // 如果sequence溢出则变为0，说明1毫秒内并发生成的ID数量超过了4096个，这个时候同1毫秒的第4097个生成的ID必须等待下一毫秒\n        if (sequence == 0) {\n            // 死循环等待下一个毫秒值，直到比lastTimestamp大\n            timestamp = tilNextMillis(lastTimestamp)\n        }\n    } else {\n        // 低并发场景，不同毫秒中生成ID\n        // 不同毫秒的情况下，由于外层方法保证了timestamp大于或者小于lastTimestamp，而小于的情况是发生了时钟回拨，下面会抛出异常，所以不用考虑\n        // 也就是只需要考虑一种情况：timestamp > lastTimestamp，也就是当前生成的ID所在的毫秒数比上一个ID大\n        // 所以如果时间戳部分增大，可以确定整数值一定变大，所以序列号其实可以不用计算，这里直接赋值为0\n        sequence = 0\n    }\n    // 获取到的时间戳比上一个保存的时间戳小，说明时钟回拨，这种情况下直接抛出异常，拒绝生成ID\n    // 个人认为，这个方法应该可以提前到var timestamp = timeGen()这段代码之后\n    if (timestamp < lastTimestamp) {\n      exceptionCounter.incr(1)\n      log.error(\"clock is moving backwards.  Rejecting requests until %d.\", lastTimestamp);\n      throw new InvalidSystemClock(\"Clock moved backwards.  Refusing to generate id for %d milliseconds\".format(lastTimestamp - timestamp));\n    }\n    // lastTimestamp保存当前时间戳，作为方法下次被调用的上一个时间戳的快照\n    lastTimestamp = timestamp\n    // 度量统计，生成的ID计数器加1\n    genCounter.incr()\n    // X = (系统时间戳 - 自定义的纪元值) 然后左移22位\n    // Y = (数据中心ID左移17位)\n    // Z = (机器ID左移12位)\n    // 最后ID = X | Y | Z | 计算出来的序列号sequence\n    ((timestamp - twepoch) << timestampLeftShift) |\n      (datacenterId << datacenterIdShift) |\n      (workerId << workerIdShift) | \n      sequence\n}\n\n// 辅助方法：获取系统当前的时间戳（毫秒）\nprotected def timeGen(): Long = System.currentTimeMillis()\n\n// 辅助方法：获取系统当前的时间戳（毫秒），用死循环保证比传入的lastTimestamp大，也就是获取下一个比lastTimestamp大的毫秒数\nprotected def tilNextMillis(lastTimestamp: Long): Long = {\n    var timestamp = timeGen()\n    while (timestamp <= lastTimestamp) {\n      timestamp = timeGen()\n    }\n    timestamp\n}\n```\n\n最后一段逻辑的位操作比较多，但是如果熟练使用位运算操作符，其实逻辑并不复杂，这里可以画个图推演一下：\n\n![](https://throwable-blog-1256189093.cos.ap-guangzhou.myqcloud.com/202008/s-f-a-g-9.png)\n\n四个部分的整数完成左移之后，由于空缺的低位都会补充了`0`，基于按位或的特性，所有低位只要存在`1`，那么对应的位就会填充为`1`，由于四个部分的位不会越界分配，所以这里的本质就是：**四个部分左移完毕后最终的数字进行加法计算**。\n\n## Snowflake算法改良\n\n`Snowflake`算法有几个比较大的问题：\n\n- 低并发场景会产生连续偶数，原因是低并发场景系统时钟总是走到下一个毫秒值，导致序列号重置为`0`。\n- 依赖系统时钟，时钟回拨会拒绝生成新的`ID`（直接抛出异常）。\n- `Woker ID`和`Data Center ID`的管理比较麻烦，特别是同一个服务的不同集群节点需要保证每个节点的`Woker ID`和`Data Center ID`组合唯一。\n\n这三个问题美团开源的`Leaf`提供了解决思路，下图截取自`com.sankuai.inf.leaf.snowflake.SnowflakeIDGenImpl`：\n\n![](https://throwable-blog-1256189093.cos.ap-guangzhou.myqcloud.com/202008/s-f-a-g-7.png)\n\n对应的解决思路是（不进行深入的源码分析，有兴趣可以阅读以下`Leaf`的源码）：\n\n- 序列号生成添加随机源，会稍微减少同一个毫秒内能产生的最大`ID`数量。\n- 时钟回拨则进行一定期限的等待。\n- 使用`Zookeeper`缓存和管理`Woker ID`和`Data Center ID`。\n\n`Woker ID`和`Data Center ID`的配置是极其重要的，对于同一个服务（例如支付服务）集群的多个节点，必须配置不同的机器`ID`和数据中心`ID`或者同样的数据中心`ID`和不同的机器`ID`（**简单说就是确保`Woker ID`和`Data Center ID`的组合全局唯一**），否则在高并发的场景下，在系统时钟一致的情况下，很容易在多个节点产生相同的`ID`值，所以一般的部署架构如下：\n\n![](https://throwable-blog-1256189093.cos.ap-guangzhou.myqcloud.com/202008/s-f-a-g-6.png)\n\n管理这两个`ID`的方式有很多种，或者像`Leaf`这样的开源框架引入分布式缓存进行管理，再如笔者所在的创业小团队生产服务比较少，直接把`Woker ID`和`Data Center ID`硬编码在服务启动脚本中，然后把所有服务使用的`Woker ID`和`Data Center ID`统一登记在团队内部知识库中。\n\n## 自实现简化版Snowflake\n\n如果完全不考虑性能的话，也不考虑时钟回拨、序列号生成等等问题，其实可以把`Snowflake`的位运算和异常处理部分全部去掉，使用`Long.toBinaryString()`方法结合字符串按照`Snowflake`算法思路拼接出`64 bit`的二进制数，再通过`Long.parseLong()`方法转化为`Long`类型。编写一个`main`方法如下：\n\n```java\npublic class Main {\n\n    private static final String HIGH = \"0\";\n\n    /**\n     * 2020-08-01 00:00:00\n     */\n    private static final long EPOCH = 1596211200000L;\n\n    public static void main(String[] args) {\n        long workerId = 1L;\n        long dataCenterId = 1L;\n        long seq = 4095;\n        String timestampString = leftPadding(Long.toBinaryString(System.currentTimeMillis() - EPOCH), 41);\n        String workerIdString = leftPadding(Long.toBinaryString(workerId), 5);\n        String dataCenterIdString = leftPadding(Long.toBinaryString(dataCenterId), 5);\n        String seqString = leftPadding(Long.toBinaryString(seq), 12);\n        String value = HIGH + timestampString + workerIdString + dataCenterIdString + seqString;\n        long num = Long.parseLong(value, 2);\n        System.out.println(num);   // 某个时刻输出为3125927076831231\n    }\n\n    private static String leftPadding(String value, int maxLength) {\n        int diff = maxLength - value.length();\n        StringBuilder builder = new StringBuilder();\n        for (int i = 0; i < diff; i++) {\n            builder.append(\"0\");\n        }\n        builder.append(value);\n        return builder.toString();\n    }\n}\n```\n\n然后把代码规范一下，编写出一个简版`Snowflake`算法实现的工程化代码：\n\n```java\n// 主键生成器接口\npublic interface PrimaryKeyGenerator {\n\n    long generate();\n}\n\n// 简易Snowflake实现\npublic class SimpleSnowflake implements PrimaryKeyGenerator {\n\n    private static final String HIGH = \"0\";\n    private static final long MAX_WORKER_ID = 31;\n    private static final long MIN_WORKER_ID = 0;\n\n    private static final long MAX_DC_ID = 31;\n    private static final long MIN_DC_ID = 0;\n\n    private static final long MAX_SEQUENCE = 4095;\n\n    /**\n     * 机器ID\n     */\n    private final long workerId;\n\n    /**\n     * 数据中心ID\n     */\n    private final long dataCenterId;\n\n    /**\n     * 基准纪元值\n     */\n    private final long epoch;\n\n    private long sequence = 0L;\n    private long lastTimestamp = -1L;\n\n    public SimpleSnowflake(long workerId, long dataCenterId, long epoch) {\n        this.workerId = workerId;\n        this.dataCenterId = dataCenterId;\n        this.epoch = epoch;\n        checkArgs();\n    }\n\n    private void checkArgs() {\n        if (!(MIN_WORKER_ID <= workerId && workerId <= MAX_WORKER_ID)) {\n            throw new IllegalArgumentException(\"Worker id must be in [0,31]\");\n        }\n        if (!(MIN_DC_ID <= dataCenterId && dataCenterId <= MAX_DC_ID)) {\n            throw new IllegalArgumentException(\"Data center id must be in [0,31]\");\n        }\n    }\n\n    @Override\n    public synchronized long generate() {\n        long timestamp = System.currentTimeMillis();\n        // 时钟回拨\n        if (timestamp < lastTimestamp) {\n            throw new IllegalStateException(\"Clock moved backwards\");\n        }\n        // 同一毫秒内并发\n        if (lastTimestamp == timestamp) {\n            sequence = sequence + 1;\n            if (sequence == MAX_SEQUENCE) {\n                timestamp = untilNextMillis(lastTimestamp);\n                sequence = 0L;\n            }\n        } else {\n            // 下一毫秒重置sequence为0\n            sequence = 0L;\n        }\n        lastTimestamp = timestamp;\n        // 41位时间戳字符串，不够位数左边补\"0\"\n        String timestampString = leftPadding(Long.toBinaryString(timestamp - epoch), 41);\n        // 5位机器ID字符串，不够位数左边补\"0\"\n        String workerIdString = leftPadding(Long.toBinaryString(workerId), 5);\n        // 5位数据中心ID字符串，不够位数左边补\"0\"\n        String dataCenterIdString = leftPadding(Long.toBinaryString(dataCenterId), 5);\n        // 12位序列号字符串，不够位数左边补\"0\"\n        String seqString = leftPadding(Long.toBinaryString(sequence), 12);\n        String value = HIGH + timestampString + workerIdString + dataCenterIdString + seqString;\n        return Long.parseLong(value, 2);\n    }\n\n    private long untilNextMillis(long lastTimestamp) {\n        long timestamp;\n        do {\n            timestamp = System.currentTimeMillis();\n        } while (timestamp <= lastTimestamp);\n        return timestamp;\n    }\n\n    private static String leftPadding(String value, int maxLength) {\n        int diff = maxLength - value.length();\n        StringBuilder builder = new StringBuilder();\n        for (int i = 0; i < diff; i++) {\n            builder.append(\"0\");\n        }\n        builder.append(value);\n        return builder.toString();\n    }\n\n    public static void main(String[] args) {\n        long epoch = LocalDateTime.of(1970, 1, 1, 0, 0, 0, 0)\n                .toInstant(ZoneOffset.of(\"+8\")).toEpochMilli();\n        PrimaryKeyGenerator generator = new SimpleSnowflake(1L, 1L, epoch);\n        for (int i = 0; i < 5; i++) {\n            System.out.println(String.format(\"第%s个生成的ID: %d\", i + 1, generator.generate()));\n        }\n    }\n}\n\n// 某个时刻输出如下\n第1个生成的ID: 6698247966366502912\n第2个生成的ID: 6698248027448152064\n第3个生成的ID: 6698248032162549760\n第4个生成的ID: 6698248033076908032\n第5个生成的ID: 6698248033827688448\n```\n\n通过字符串拼接的写法虽然运行效率低，但是可读性会比较高，工程化处理后的代码可以在实例化时候直接指定`Worker ID`和`Data Center ID`等值，并且这个简易的`Snowflake`实现没有第三方库依赖，拷贝下来可以直接运行。上面的方法使用字符串拼接看起来比较低端，其实最后那部分的按位或，**可以完全转化为加法**：\n\n```java\npublic class Main {\n    \n    /**\n     * 2020-08-01 00:00:00\n     */\n    private static final long EPOCH = 1596211200000L;\n\n    public static void main(String[] args) {\n        long workerId = 1L;\n        long dataCenterId = 1L;\n        long seq = 4095;\n        long timestampDiff = System.currentTimeMillis() - EPOCH;\n        long num = (long) (timestampDiff * Math.pow(2, 22)) + (long) (dataCenterId * Math.pow(2, 17)) + (long) (workerId * Math.pow(2, 12)) + seq;\n        System.out.println(num);   // 某个时刻输出为3248473482862591\n    }\n}\n```\n\n这样看起来整个算法都变得简单，不过这里涉及到指数运算和加法运算，效率会比较低。\n\n## 小结\n\n`Snowflake`算法是以高性能为核心目标的算法，基于这一点目的巧妙地大量使用位运算，这篇文章已经把`Snowflake`中应用到的位运算和具体源码实现彻底分析清楚。最后，基于`Twitter`官方的`Snowflake`算法源码，修订出了一版`Java`实现版本，并且应用前面提到的改良方式，修复了低并发场景下只产生偶数的问题，**并且已经应用于生产环境一段时间**，代码仓库如下（代码没有任何第三方库依赖，拷贝出来就直接可用）：\n\n- `Github`：`https://github.com/zjcscut/framework-mesh/tree/master/java-snowflake`\n\n参考资料：\n\n- [美团Leaf源码](https://github.com/Meituan-Dianping/Leaf)\n- [Twitter Snowflake](https://github.com/twitter-archive/snowflake/blob/scala_28/src/main/scala/com/twitter/service/snowflake/IdWorker.scala)\n\n（本文完 c-3-d e-a-20200809 封面图来源于国漫《灵笼》）", "user_name": "Throwable", "description": "创业小团队架构师。公众号：Throwable（id：throwable-doge），实战派，只分享原创，不卖课", "got_view_count": 61292, "category_name": "后端", "ctime": 1457483880}
{"tag_name": "flexbox", "concern_user_count": 18287, "user_id": "1521379825693816", "title": "【CSS基础】Flex布局（包含flex-grow和flex-shrink的详细计算方式）", "mark_content": "## 参考\n\n- [Flex 布局教程：语法篇](http://www.ruanyifeng.com/blog/2015/07/flex-grammar.html)\n- [Flex 布局教程：实例篇](http://www.ruanyifeng.com/blog/2015/07/flex-examples.html)\n- [详解 flex-grow 与 flex-shrink](https://zhuanlan.zhihu.com/p/24372279/)\n- [Flex 布局调试工具](http://works.kexiaolong.top/flexible-box-display/)\n\n## 介绍\n\n传统的布局方案，基于盒模型，依赖`display`属性、`position`属性和`float`属性。其对于某些特殊的布局（如垂直居中），实现起来比较麻烦。\n\n在 2009 年，W3C 提出了一种新的布局方案——**Flex 布局**（Flexible Box 布局，弹性盒子布局），其相比于传统的布局方案，更为灵活和简便。目前，Flex 布局已经得到了所有浏览器的支持。\n\n将元素的`display`属性设置为`flex`或`inline-flex`后，即可开启 Flex 布局：\n\n```less\n// 块级元素\n.block-box {\n  display: flex;\n}\n\n// 行内元素\n.inline-box {\n  display: inline-flex;\n}\n```\n\n同时，该元素会自动成为 Flex 容器，简称**容器**。且容器的所有子元素会自动成为 Flex 容器成员，简称**项目**。项目的`float`、`clear`、`vertical-align`属性将失效。\n\n容器中默认存在两根轴：**主轴**和**侧轴**。主轴和侧轴互相垂直，类似于平面坐标系中的 x 轴和 y 轴。项目将自动沿着主轴方向排列，排满时将沿侧轴方向堆砌，即在侧轴方向上换行（前提是容器`flex-wrap`属性不为`nowrap`）。\n\n## 调试\n\n可使用[Flex 布局在线调试工具](http://works.kexiaolong.top/flexible-box-display/)来快速配置 Flex 布局和查看 Flex 布局效果：\n\n对于该工具的介绍请见[此文](https://juejin.im/post/6857741687347740679/)。\n\n## 容器的属性\n\n### flex-direction\n\n`flex-direction`属性决定主轴的方向，进而决定项目的排列方向，其值可能为：\n\n```less\n.container {\n  // 主轴方向从左向右→（默认值）\n  flex-direction: row;\n\n  // 主轴方向从右向左←\n  flex-direction: row-reverse;\n\n  // 主轴方向从上向下↓\n  flex-direction: column;\n\n  // 主轴方向从下向上↑\n  flex-direction: column-reverse;\n}\n```\n\n### flex-wrap\n\n`flex-wrap`属性决定侧轴的方向，进而决定项目的换行方向，其值可能为：\n\n```less\n.container {\n  // 侧轴无方向（默认值）\n  // 相当于不换行\n  flex-wrap: nowrap;\n\n  // 主轴方向水平时，侧轴方向从上向下↓\n  // 主轴方向竖直时，侧轴方向从左向右→\n  // 相当于顺序换行\n  flex-wrap: wrap;\n\n  // 主轴方向水平时，侧轴方向从下向上↑\n  // 主轴方向竖直时，侧轴方向从右向左←\n  // 相当于逆序换行\n  flex-wrap: wrap-reverse;\n}\n```\n\n### flex-flow\n\n`flex-flow`属性是`flex-direction`属性和`flex-wrap`属性的简写形式，其值可能为：\n\n```less\n.container {\n  // 主轴方向从左向右，侧轴无方向（默认值）\n  // 即项目排列方向→，不换行\n  flex-flow: row nowrap;\n\n  // 主轴方向从左向右，侧轴方向从上向下\n  // 即项目排列方向→，换行方向↓，与现代书写方向相同\n  flex-flow: row wrap;\n\n  // 主轴方向从左向右，侧轴方向从下向上\n  // 即项目排列方向→，换行方向↑\n  flex-flow: row wrap-reverse;\n\n  // 主轴方向从右向左，侧轴无方向\n  // 即项目排列方向←，不换行\n  flex-flow: row-reverse nowrap;\n\n  // 主轴方向从右向左，侧轴方向从上向下\n  // 即项目排列方向←，换行方向↓\n  flex-flow: row-reverse wrap;\n\n  // 主轴方向从右向左，侧轴方向从下向上\n  // 即项目排列方向←，换行方向↑\n  flex-flow: row-reverse wrap-reverse;\n\n  // 主轴方向从上向下，侧轴无方向\n  // 即项目排列方向↓，不换行\n  flex-flow: column nowrap;\n\n  // 主轴方向从上向下，侧轴方向从左向右\n  // 即项目排列方向↓，换行方向→\n  flex-flow: column wrap;\n\n  // 主轴方向从上向下，侧轴方向从右向左\n  // 即项目排列方向↓，换行方向←，与中国古代书写方向相同\n  flex-flow: column wrap-reverse;\n\n  // 主轴方向从下向上，侧轴无方向\n  // 即项目排列方向↑，不换行\n  flex-flow: column-reverse nowrap;\n\n  // 主轴方向从下向上，侧轴方向从左向右\n  // 即项目排列方向↑，换行方向→\n  flex-flow: column-reverse wrap;\n\n  // 主轴方向从下向上，侧轴方向从右向左\n  // 即项目排列方向↑，换行方向←\n  flex-flow: column-reverse wrap-reverse;\n}\n```\n\n可基于以下配置对`flex-flow`的值进行修改，查看其不同值的对应效果，以验证上述规律：\n\n```less\n.container {\n  width: 200px;\n  height: 200px;\n  flex-flow: <flex-direction> | <flex-wrap>;\n  .item-1,\n  .item-2,\n  .item-3 {\n    width: 100px;\n    height: 100px;\n  }\n}\n```\n\n### justify-content\n\n`justify-content`属性决定了项目沿主轴方向的对齐方式，其值可能为：\n\n```less\n.container {\n  // 主轴方向上，起点对齐（默认值）\n  justify-content: flex-start;\n\n  // 主轴方向上，终点对齐\n  justify-content: flex-end;\n\n  // 主轴方向上，居中对齐\n  justify-content: center;\n\n  // 主轴方向上，项目之间空隙相等\n  justify-content: space-between;\n\n  // 主轴方向上，项目两侧空隙相等\n  justify-content: space-around;\n}\n```\n\n### align-content\n\n`align-content`属性决定了项目沿侧轴方向的对齐方式（如果项目只有一行，则该属性无效），其值可能为：\n\n```less\n.container {\n  // 如果项目height未设置或为auto\n  // 项目拉伸至占满侧轴（默认值）\n  align-content: stretch;\n\n  // 侧轴方向上，起点对齐\n  align-content: flex-start;\n\n  // 侧轴方向上，终点对齐\n  align-content: flex-end;\n\n  // 侧轴方向上，居中对齐\n  align-content: center;\n\n  // 侧轴方向上，项目之间空隙相等\n  align-content: space-between;\n\n  // 侧轴方向上，项目两侧空隙相等\n  align-content: space-around;\n}\n```\n\n### place-content\n\n`place-content`属性是`align-content`属性和`justify-content`属性的简写形式，其可能值见[此文](https://developer.mozilla.org/zh-CN/docs/Web/CSS/place-content/)。\n\n```less\n.container {\n  place-content: <align-content> | <justify-content>;\n}\n```\n\n### align-items\n\n`align-items`属性决定了同一行项目沿侧轴方向的对齐方式，即项目在主轴方向上的垂直对齐方式，其值可能为：\n\n```less\n.container {\n  // 如果项目height未设置或为auto\n  // 则拉伸至占满该行（默认值）\n  align-items: stretch;\n\n  // 侧轴上，起点对齐\n  align-items: flex-start;\n\n  // 侧轴上，终点对齐\n  align-items: flex-end;\n\n  // 侧轴上，居中对齐\n  align-items: center;\n\n  // 侧轴上，基线对齐\n  align-items: baseline;\n}\n```\n\n## 项目的属性\n\n### order\n\n`order`属性决定了项目沿主轴方向的排列顺序，其值可能为：\n\n```less\n.item {\n  // 数值越小，项目排列越靠前（默认值为1）\n  order: <integer>;\n}\n```\n\n### align-self\n\n`align-self`属性会覆盖容器的`align-items`属性，其值可能为：\n\n```less\n.item {\n  // 继承容器的align-items属性（默认值）\n  align-self: auto;\n\n  align-items: stretch;\n\n  align-items: flex-start;\n\n  align-items: flex-end;\n\n  align-items: center;\n\n  align-items: baseline;\n}\n```\n\n### flex-basis\n\n`flex-basis`属性会覆盖项目的`width`属性（如果主轴方向为水平）或`height`属性（如果主轴方向为垂直），下文中的`flex-grow`和`flex-shrink`都基于`flex-basis`进行计算，其值可能为：\n\n```less\n.item {\n  // 设置为与width或height相同的值（默认值）\n  flex-basis: auto;\n\n  flex-basis: <length>;\n}\n```\n\n### flex-grow\n\n`flex-grow`属性决定了项目沿主轴方向的伸长系数，只在容器有剩余空间时有效，其值可能为：\n\n```less\n.item {\n  // （默认值为0）\n  flex-grow: <number>;\n}\n```\n\n关于`flex-grow`属性的计算过程为：\n\n1. `flex-grow`属性小于等于`0`的项目不受影响，不会伸长。\n2. 对剩余项目的`flex-grow`属性进行求和，将结果记为`sum`。\n3. 分以下情况进行讨论。\n\n#### sum ≥ 1 时\n\n```less\n.container {\n  display: flex;\n  width: 800px;\n  .item1 {\n    flex-basis: 50px;\n  }\n  .item2 {\n    flex-basis: 100px;\n    flex-grow: 1;\n  }\n  .item3 {\n    flex-basis: 150px;\n    flex-grow: 3;\n  }\n  .item4 {\n    flex-basis: 200px;\n    flex-grow: 6;\n  }\n}\n```\n\n计算过程：\n\n1. 计算剩余宽度：`剩余宽度 = 容器宽度 - 项目总宽度`，所以：\n   - `剩余宽度 = 800px - 500px = 300px`。\n2. 计算各项目权重占比：`权重 = <flex-grow>`，所以：\n   - `总权重 = sum = 1 + 3 + 6 = 10`。\n   - `项目2权重 = 1`，`项目2权重占比 = 1 / 10 = 0.1`。\n   - `项目3权重 = 3`，`项目3权重占比 = 3 / 10 = 0.3`。\n   - `项目4权重 = 6`，`项目4权重占比 = 6 / 10 = 0.6`。\n3. 计算各项目伸长宽度：`伸长宽度 = 权重占比 * 剩余宽度`，所以：\n   - `项目2伸长宽度 = 0.1 * 300px = 30px`。\n   - `项目3伸长宽度 = 0.3 * 300px = 90px`。\n   - `项目4伸长宽度 = 0.6 * 300px = 180px`。\n4. 计算各项目伸长后宽度：`伸长后宽度 = <flex-basis> + 伸长宽度`，所以：\n   - `项目2伸长后宽度 = 100px + 30px = 130px`。\n   - `项目3伸长后宽度 = 150px + 90px = 240px`。\n   - `项目4伸长后宽度 = 200px + 180px = 380px`。\n\n#### sum < 1 时\n\n计算过程基本与`sum > 1`时的情况相同，但在第 3 步中，各项目的伸长宽度为`sum * 权重占比 * 剩余宽度`。\n\n### flex-shrink\n\n`flex-shrink`属性决定了项目沿主轴方向的缩短系数，只在容器空间发生溢出时有效，其值可能为：\n\n```less\n.item {\n  // （默认值为1）\n  flex-shrink: <number>;\n}\n```\n\n关于`flex-shrink`属性的计算过程为：\n\n1. `flex-shrink`属性小于等于`0`的项目不受影响，不会缩短。\n2. 对剩余项目的`flex-shrink`属性进行求和，将结果记为`sum`。\n3. 分以下情况进行讨论。\n\n#### sum ≥ 1 时\n\n```less\n.container {\n  display: flex;\n  width: 800px;\n  .item1 {\n    flex-basis: 100px;\n  }\n  .item2 {\n    flex-basis: 200px;\n    flex-shrink: 6;\n  }\n  .item3 {\n    flex-basis: 300px;\n    flex-shrink: 3;\n  }\n  .item4 {\n    flex-basis: 400px;\n    flex-shrink: 1;\n  }\n}\n```\n\n计算过程：\n\n1. 计算溢出宽度：`溢出宽度 = 项目总宽度 - 容器宽度`，所以：\n   - `溢出宽度 = 800px - 1000px = 200px`。\n2. 计算各项目权重占比：`权重 = <flex-shrink> * <flex-basis>`，所以：\n   - `总权重 = 1200 + 900 + 400 = 2500`。\n   - `项目2权重 = 1200`，`项目2权重占比 = 1200 / 2500 = 0.48`。\n   - `项目3权重 = 900`，`项目3权重占比 = 900 / 2500 = 0.36`。\n   - `项目4权重 = 400`，`项目4权重占比 = 400 / 2500 = 0.16`。\n3. 计算各项目缩短宽度：`缩短宽度 = 权重占比 * 溢出宽度`，所以：\n   - `项目2伸长宽度 = 0.48 * 200px = 96px`。\n   - `项目3伸长宽度 = 0.36 * 200px = 72px`。\n   - `项目4伸长宽度 = 0.16 * 200px = 32px`。\n4. 计算各项目缩短后宽度：`缩短后宽度 = 原始宽度 - 缩短宽度`，所以：\n   - `项目2缩短后宽度 = 200px - 96px = 104px`。\n   - `项目3缩短后宽度 = 300px - 72px = 228px`。\n   - `项目4缩短后宽度 = 400px - 32px = 368px`。\n\n#### sum < 1 时\n\n计算过程基本与`sum > 1`时的情况相同，但在第 3 步中，各项目的缩短宽度为`sum * 权重占比 * 溢出宽度`。\n\n### flex\n\n`flex`属性是`flex-grow`属性、`flex-shrink`和`flex-basis`属性的简写形式，其值可能为：\n\n```less\n.item {\n  // 相当于flex:0 0 auto;\n  flex: none;\n\n  // 相当于flex:1 1 auto;\n  flex: auto;\n\n  flex: <flex-grow> <flex-shrink> <flex-basis>;\n}\n```\n", "user_name": "柯柯likeke", "description": "南京，研二，WebGIS", "got_view_count": 562, "category_name": "前端", "ctime": 1457483942}
{"tag_name": "Ant Design", "concern_user_count": 5546, "user_id": "2717648473042333", "title": "渐进式的formItem（基于antd的Form）", "mark_content": "在日常用`antd`写表单项时，大多数人是这样写的：\n\n![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8e5878c1705c473399990bf737bfd78b~tplv-k3u1fbpfcp-zoom-1.image)\n\n老实说，`antd4`的`Form`要比`antd3`的好用很多，但在实际的业务场景中，还是会因为充斥着大量的`Form.Item`。\n\n拿上面的图来说，`placeholder`和`require`都差不多，所以我们是不是能再抽象一层。\n\n答案肯定是能的。那么方案有哪一些呢：\n\n1. 借助于业界的一些方案，如[formily](https://zhuanlan.zhihu.com/uform/)、[form-render](https://zhuanlan.zhihu.com/p/91292415)。它们是先自己实现了一套，然后去适配不同的UI，如`antd`、`fusion`（飞冰的那一套），你也可以基于它提供的核心库去扩展自己的UI。\n2. 基于`antd`本身再去做封装一个大而全的Form方案\n3. 渐进式的用一个组件来代替`Form.Item`。\n\n个人不太喜欢2的方案，因为这样一来，将来如果要适配`fusion`，或者其他UI时，那么基本上之前的代码是废了，何必呢？\n\n所以我个人的选择是3，它的意思是，我写一个`Field`组件，能和`Form.Item`共存，这样一来，老代码可以渐进式的修改，新代码可以直接使用。\n\n![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/af3e2029d4f04419a28093ad311aae95~tplv-k3u1fbpfcp-zoom-1.image)\n\n那么问题来了，`Field`组件要如何封装？其实这个完全可以参考formily的API。\n\n```js\nexport interface FieldProps extends Omit<FormItemProps, 'children'> {\n  name: string; // 后端的字段key\n  label: ReactText;  // label\n  required?: boolean; // 是否必须，没有考虑动态\n  disabled?: boolean; // 禁用，同样这里也没有考虑动态的\n  placeholder?: boolean;  // 如果是文本则显示'请输入xx'，xx为上面的label值，不然就是请选择\n  hidden?: boolean;  // 针对那种<input type=\"hidden\" />\n  description?: ReactElement; // 描述说明\n  component?: 'input' | 'textarea' | 'select' | 'radio' | 'custom'; // 当然在实际业务中肯定会更多，因为是渐进式的，所以可以考虑一步步地封装\n  enum?: Array<{ label: React.ReactNode; value: string | number | boolean }>; // 针对component类型为`select`和`radio`\n  node?: ReactElement; // 针对component类型为`custom`\n  componentProps?: { // 组件属性\n    placeholder?: string;\n    disabled?: boolean;\n    [key: string]: any;\n  };\n}\n```\n\n其实这个`Field`组件不难实现，它的难点在于`context`这一块的值得特殊处理一下，不然你`render`的`Form.Item`是拿不到`labelAlign`、`labelCol`、`wrapperCol`这些值的。\n\n```js\nimport { FormContextProps, FormContext } from 'antd/lib/form/context';\n\n<FormContext.Consumer key=\"label\">\n  {(contextProps: FormContextProps) => {\n    // return ...\n  }}\n</FormContext.Consumer>\n```\n\n另外还有就是在实现description功能的时候，也着实难受，要`Form.Item`嵌套`Form.Item`，布局那一块有点无力吐嘈。\n\n有了`Field`组件，`Submit`和`Reset`组件自然呼之而出了。那么下一步，我们要考虑，配置式的`FormRender`组件。\n\n所谓的配置，无非就是个`json`。但这里要考虑的东西有点多了：\n\n1. 简单地动态化要怎么实现？\n2. 如果将来想做可视化，那么方案是怎样的？\n\n在上面设计的`Field`组件里面，我考虑了可视化的方案，但是它只能满足简单的场景，一旦复杂了，就gg了。那么有没有办法在它上面扩展呢，其实是可以的。加上两个字段（这个参考了之前同事写的代码）：\n\n- shouldUpdate: Form.Item里面的shouldUpdate\n- render: 渲染函数，接收form属性，我们就可以根据不同的情况，渲染不同的组件了。\n\n基本上是没啥问题了，但事实上，比如说实现Item组件显不显示，固然用render可以做，但更优雅的是通过一个表达式来做，譬如这样的：\n\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3a1110bc54994958a28e38b1b9332eb3~tplv-k3u1fbpfcp-zoom-1.image)\n\n参考来源是：`form-render`。它的是`ui-hidden`功能。核心代码是这一段：\n\n```jsx\n// 计算单个表达式的hidden值\nconst calcHidden = (hiddenString, rootValue, formData) => {\n  if (!rootValue || typeof rootValue !== 'object') {\n    return false;\n  }\n  // 支持四种基本运算符\n  const operators = ['==', '!=', '>', '<'];\n  try {\n    const op = operators.find(op => hiddenString.indexOf(op) > -1);\n    const [key, value] = hiddenString.split(op).map(item => item.trim());\n    let left = rootValue[key];\n    // feature: 允许从 formData 取值\n    if (key.substring(0, 9) === 'formData.' && formData) {\n      const subKey = key.substring(9);\n      left = getExpressionValue(formData, subKey);\n    }\n    const right = parseString(value);\n    return parseString(`\"${String(left)}\"${op}\"${String(right)}\"`);\n  } catch (e) {\n    console.error(e);\n  }\n  return false;\n};\n\n// Remove all window valid api\n// For safety jest-* variable will throw error\nexport function safeEval(code) {\n  let safeContextStr = '';\n  if (typeof window !== 'undefined') {\n    const windowContextAttr = Object.getOwnPropertyNames(window).filter(\n      isValidVariableName\n    );\n    for (let i = 0, len = windowContextAttr.length; i < len; i++) {\n      safeContextStr += `var ${windowContextAttr[i]} = undefined;`;\n    }\n  }\n  return Function(`${safeContextStr} \"use strict\";  ${code}`)();\n}\n// 代替eval的函数\nexport const parseString = string => safeEval(`return (${string})`);  \n```\n\n`parse`那一块的逻辑感觉有点粗糙，但可以用，于是乎给抄了过来。\n\n简单做一下总结，就是我们在平常写代码的时候，还是要多思考，看看能否让代码变得更简洁，通过渐进式的方案来改革代码，而非一蹴而就。", "user_name": "henryzp", "description": "", "got_view_count": 6720, "category_name": "前端", "ctime": 1457483942}
{"tag_name": "Java", "concern_user_count": 252044, "user_id": "2796746683483751", "title": "Java8中你可能不知道的一些地方之Stream实战二", "mark_content": "<h2 data-tool=\"mdnice编辑器\" style=\"margin-top: 30px; margin-bottom: 15px; padding: 0px; font-weight: bold; color: black; font-size: 22px; display: block; border-bottom: 4px solid #40B8FA;\"><span class=\"prefix\" style=\"display: flex; width: 20px; height: 20px; background-size: 20px 20px; background-image: url(https://my-wechat.mdnice.com/fullstack-1.png); margin-bottom: -22px;\"></span><span class=\"content\" style=\"display: flex; color: #40B8FA; font-size: 20px; margin-left: 25px;\">流的终止操作</span><span class=\"suffix\" style=\"display: flex; box-sizing: border-box; width: 200px; height: 10px; border-top-left-radius: 20px; background: RGBA(64, 184, 250, .5); color: rgb(255, 255, 255); font-size: 16px; letter-spacing: 0.544px; justify-content: flex-end; float: right; margin-top: -10px; box-sizing: border-box !important; overflow-wrap: break-word !important;\"></span></h2>\n<p data-tool=\"mdnice编辑器\" style=\"padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: #2b2b2b; margin: 10px 0px; letter-spacing: 2px; font-size: 14px; word-spacing: 2px;\">终止操作会从流的流水线生成结果。其结果是任何不是流的值，比如常见的List、 Integer，甚 至void等结果。对于流的终止操作，分为以下三类:</p>\n<figure data-tool=\"mdnice编辑器\" style=\"margin: 0; margin-top: 10px; margin-bottom: 10px; display: flex; flex-direction: column; justify-content: center; align-items: center;\"><img src=\"https://cushier.coding.net/p/picture/d/picture/git/raw/master/20200810161612.png\" alt style=\"max-width: 100%; border-radius: 6px; display: block; margin: 20px auto; object-fit: contain; box-shadow: 2px 4px 7px #999;\"></figure>\n<h2 data-tool=\"mdnice编辑器\" style=\"margin-top: 30px; margin-bottom: 15px; padding: 0px; font-weight: bold; color: black; font-size: 22px; display: block; border-bottom: 4px solid #40B8FA;\"><span class=\"prefix\" style=\"display: flex; width: 20px; height: 20px; background-size: 20px 20px; background-image: url(https://my-wechat.mdnice.com/fullstack-1.png); margin-bottom: -22px;\"></span><span class=\"content\" style=\"display: flex; color: #40B8FA; font-size: 20px; margin-left: 25px;\">查找与匹配</span><span class=\"suffix\" style=\"display: flex; box-sizing: border-box; width: 200px; height: 10px; border-top-left-radius: 20px; background: RGBA(64, 184, 250, .5); color: rgb(255, 255, 255); font-size: 16px; letter-spacing: 0.544px; justify-content: flex-end; float: right; margin-top: -10px; box-sizing: border-box !important; overflow-wrap: break-word !important;\"></span></h2>\n<ul data-tool=\"mdnice编辑器\" style=\"margin-top: 8px; margin-bottom: 8px; padding-left: 25px; font-size: 15px; color: #595959; list-style-type: circle;\">\n<li><section style=\"margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; font-size: 14px; font-weight: normal; color: #595959;\">筛选有效订单 匹配是否全部为已支付订单</section></li></ul>\n<pre class=\"custom\" data-tool=\"mdnice编辑器\" style=\"margin-top: 10px; margin-bottom: 10px;\"><code class=\"hljs\" style=\"overflow-x: auto; padding: 16px; color: #abb2bf; background: #282c34; display: -webkit-box; font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; border-radius: 0px; font-size: 12px; -webkit-overflow-scrolling: touch; letter-spacing: 0px;\">&nbsp;<span class=\"hljs-comment\" style=\"color: #5c6370; font-style: italic; line-height: 26px;\">//&nbsp;筛选有效订单&nbsp;匹配是否全部为已支付订单</span><br>System.out.println(<span class=\"hljs-string\" style=\"color: #98c379; line-height: 26px;\">\"allMatch匹配结果:\"</span>&nbsp;+&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ordersList.stream()<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;.filter((order)&nbsp;-&gt;&nbsp;order.getIsValid()&nbsp;==&nbsp;<span class=\"hljs-number\" style=\"color: #d19a66; line-height: 26px;\">1</span>)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;.allMatch((o)&nbsp;-&gt;&nbsp;o.getStatus()&nbsp;!=&nbsp;<span class=\"hljs-number\" style=\"color: #d19a66; line-height: 26px;\">0</span>)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;);<br></code></pre>\n<ul data-tool=\"mdnice编辑器\" style=\"margin-top: 8px; margin-bottom: 8px; padding-left: 25px; font-size: 15px; color: #595959; list-style-type: circle;\">\n<li><section style=\"margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; font-size: 14px; font-weight: normal; color: #595959;\">筛选有效订单 匹配是否存在未支付订单</section></li></ul>\n<pre class=\"custom\" data-tool=\"mdnice编辑器\" style=\"margin-top: 10px; margin-bottom: 10px;\"><code class=\"hljs\" style=\"overflow-x: auto; padding: 16px; color: #abb2bf; background: #282c34; display: -webkit-box; font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; border-radius: 0px; font-size: 12px; -webkit-overflow-scrolling: touch; letter-spacing: 0px;\"><span class=\"hljs-comment\" style=\"color: #5c6370; font-style: italic; line-height: 26px;\">//&nbsp;筛选有效订单&nbsp;匹配是否存在未支付订单</span><br>System.out.println(<span class=\"hljs-string\" style=\"color: #98c379; line-height: 26px;\">\"anyMatch匹配结果:\"</span>&nbsp;+&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ordersList.stream()<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;.filter((order)&nbsp;-&gt;&nbsp;order.getIsValid()&nbsp;==&nbsp;<span class=\"hljs-number\" style=\"color: #d19a66; line-height: 26px;\">1</span>)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;.anyMatch((o)&nbsp;-&gt;&nbsp;o.getStatus()&nbsp;==&nbsp;<span class=\"hljs-number\" style=\"color: #d19a66; line-height: 26px;\">0</span>)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;);<br></code></pre>\n<ul data-tool=\"mdnice编辑器\" style=\"margin-top: 8px; margin-bottom: 8px; padding-left: 25px; font-size: 15px; color: #595959; list-style-type: circle;\">\n<li><section style=\"margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; font-size: 14px; font-weight: normal; color: #595959;\">筛选有效订单 全部未完成订单</section></li></ul>\n<pre class=\"custom\" data-tool=\"mdnice编辑器\" style=\"margin-top: 10px; margin-bottom: 10px;\"><code class=\"hljs\" style=\"overflow-x: auto; padding: 16px; color: #abb2bf; background: #282c34; display: -webkit-box; font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; border-radius: 0px; font-size: 12px; -webkit-overflow-scrolling: touch; letter-spacing: 0px;\"><span class=\"hljs-comment\" style=\"color: #5c6370; font-style: italic; line-height: 26px;\">//&nbsp;筛选有效订单&nbsp;全部未完成订单</span><br>System.out.println(<span class=\"hljs-string\" style=\"color: #98c379; line-height: 26px;\">\"noneMatch匹配结果:\"</span>&nbsp;+&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ordersList.stream()<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;.filter((order)&nbsp;-&gt;&nbsp;order.getIsValid()&nbsp;==&nbsp;<span class=\"hljs-number\" style=\"color: #d19a66; line-height: 26px;\">1</span>)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;.noneMatch((o)&nbsp;-&gt;&nbsp;o.getStatus()&nbsp;==&nbsp;<span class=\"hljs-number\" style=\"color: #d19a66; line-height: 26px;\">5</span>)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;);<br></code></pre>\n<ul data-tool=\"mdnice编辑器\" style=\"margin-top: 8px; margin-bottom: 8px; padding-left: 25px; font-size: 15px; color: #595959; list-style-type: circle;\">\n<li><section style=\"margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; font-size: 14px; font-weight: normal; color: #595959;\">筛选有效订单 返回第一条订单</section></li></ul>\n<pre class=\"custom\" data-tool=\"mdnice编辑器\" style=\"margin-top: 10px; margin-bottom: 10px;\"><code class=\"hljs\" style=\"overflow-x: auto; padding: 16px; color: #abb2bf; background: #282c34; display: -webkit-box; font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; border-radius: 0px; font-size: 12px; -webkit-overflow-scrolling: touch; letter-spacing: 0px;\">&nbsp;&nbsp;<span class=\"hljs-comment\" style=\"color: #5c6370; font-style: italic; line-height: 26px;\">//&nbsp;筛选有效订单&nbsp;返回第一条订单</span><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println(<span class=\"hljs-string\" style=\"color: #98c379; line-height: 26px;\">\"findAny匹配结果:\"</span>+<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ordersList.stream()<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;.filter((order)&nbsp;-&gt;&nbsp;order.getIsValid()&nbsp;==&nbsp;<span class=\"hljs-number\" style=\"color: #d19a66; line-height: 26px;\">1</span>)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;.findAny()<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;.get()<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;);<br></code></pre>\n<ul data-tool=\"mdnice编辑器\" style=\"margin-top: 8px; margin-bottom: 8px; padding-left: 25px; font-size: 15px; color: #595959; list-style-type: circle;\">\n<li><section style=\"margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; font-size: 14px; font-weight: normal; color: #595959;\">筛选所有有效订单 返回订单总数</section></li></ul>\n<pre class=\"custom\" data-tool=\"mdnice编辑器\" style=\"margin-top: 10px; margin-bottom: 10px;\"><code class=\"hljs\" style=\"overflow-x: auto; padding: 16px; color: #abb2bf; background: #282c34; display: -webkit-box; font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; border-radius: 0px; font-size: 12px; -webkit-overflow-scrolling: touch; letter-spacing: 0px;\"><span class=\"hljs-comment\" style=\"color: #5c6370; font-style: italic; line-height: 26px;\">//&nbsp;&nbsp;筛选所有有效订单&nbsp;返回订单总数</span><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println(<span class=\"hljs-string\" style=\"color: #98c379; line-height: 26px;\">\"count结果:\"</span>&nbsp;+&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ordersList.stream()<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;.filter((order)&nbsp;-&gt;&nbsp;order.getIsValid()&nbsp;==&nbsp;<span class=\"hljs-number\" style=\"color: #d19a66; line-height: 26px;\">1</span>)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;.count()<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;);<br></code></pre>\n<ul data-tool=\"mdnice编辑器\" style=\"margin-top: 8px; margin-bottom: 8px; padding-left: 25px; font-size: 15px; color: #595959; list-style-type: circle;\">\n<li><section style=\"margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; font-size: 14px; font-weight: normal; color: #595959;\">筛选有效订单 返回金额最大订单金额</section></li></ul>\n<pre class=\"custom\" data-tool=\"mdnice编辑器\" style=\"margin-top: 10px; margin-bottom: 10px;\"><code class=\"hljs\" style=\"overflow-x: auto; padding: 16px; color: #abb2bf; background: #282c34; display: -webkit-box; font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; border-radius: 0px; font-size: 12px; -webkit-overflow-scrolling: touch; letter-spacing: 0px;\"><span class=\"hljs-comment\" style=\"color: #5c6370; font-style: italic; line-height: 26px;\">//&nbsp;筛选有效订单&nbsp;返回金额最大订单金额</span><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println(<span class=\"hljs-string\" style=\"color: #98c379; line-height: 26px;\">\"订单金额最大值:\"</span>&nbsp;+&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ordersList.stream()<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;.filter((order)&nbsp;-&gt;&nbsp;order.getIsValid()&nbsp;==&nbsp;<span class=\"hljs-number\" style=\"color: #d19a66; line-height: 26px;\">1</span>)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;.map(Order::getTotal)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;.max(Double::compare)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;.get()<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;);<br></code></pre>\n<ul data-tool=\"mdnice编辑器\" style=\"margin-top: 8px; margin-bottom: 8px; padding-left: 25px; font-size: 15px; color: #595959; list-style-type: circle;\">\n<li><section style=\"margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; font-size: 14px; font-weight: normal; color: #595959;\">筛选有效订单 返回金额最小订单金额</section></li></ul>\n<pre class=\"custom\" data-tool=\"mdnice编辑器\" style=\"margin-top: 10px; margin-bottom: 10px;\"><code class=\"hljs\" style=\"overflow-x: auto; padding: 16px; color: #abb2bf; background: #282c34; display: -webkit-box; font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; border-radius: 0px; font-size: 12px; -webkit-overflow-scrolling: touch; letter-spacing: 0px;\"><span class=\"hljs-comment\" style=\"color: #5c6370; font-style: italic; line-height: 26px;\">//&nbsp;筛选有效订单&nbsp;返回金额最小订单金额</span><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println(<span class=\"hljs-string\" style=\"color: #98c379; line-height: 26px;\">\"订单金额最小值:\"</span>&nbsp;+&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ordersList.stream()<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;.filter((order)&nbsp;-&gt;&nbsp;order.getIsValid()&nbsp;==&nbsp;<span class=\"hljs-number\" style=\"color: #d19a66; line-height: 26px;\">1</span>)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;.map(Order::getTotal)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;.min(Double::compare)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;.get()<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;);<br></code></pre>\n<h2 data-tool=\"mdnice编辑器\" style=\"margin-top: 30px; margin-bottom: 15px; padding: 0px; font-weight: bold; color: black; font-size: 22px; display: block; border-bottom: 4px solid #40B8FA;\"><span class=\"prefix\" style=\"display: flex; width: 20px; height: 20px; background-size: 20px 20px; background-image: url(https://my-wechat.mdnice.com/fullstack-1.png); margin-bottom: -22px;\"></span><span class=\"content\" style=\"display: flex; color: #40B8FA; font-size: 20px; margin-left: 25px;\">归约&amp;收集</span><span class=\"suffix\" style=\"display: flex; box-sizing: border-box; width: 200px; height: 10px; border-top-left-radius: 20px; background: RGBA(64, 184, 250, .5); color: rgb(255, 255, 255); font-size: 16px; letter-spacing: 0.544px; justify-content: flex-end; float: right; margin-top: -10px; box-sizing: border-box !important; overflow-wrap: break-word !important;\"></span></h2>\n<h3 data-tool=\"mdnice编辑器\" style=\"padding: 0px; color: black; font-size: 17px; font-weight: bold; text-align: center; position: relative; margin-top: 20px; margin-bottom: 20px;\"><span class=\"prefix\" style=\"display: none;\"></span><span class=\"content\" style=\"border-bottom: 2px solid RGBA(79, 177, 249, .65); color: #2b2b2b; padding-bottom: 2px;\"><span style=\"width: 30px; height: 30px; display: block; background-image: url(https://my-wechat.mdnice.com/fullstack-2.png); background-position: center; background-size: 30px; margin: auto; opacity: 1; background-repeat: no-repeat; margin-bottom: -8px;\"></span>1 归约</span><span class=\"suffix\" style=\"display: none;\"></span></h3>\n<p data-tool=\"mdnice编辑器\" style=\"padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: #2b2b2b; margin: 10px 0px; letter-spacing: 2px; font-size: 14px; word-spacing: 2px;\">将流中元素反复结合起来，得到一个值的操作</p>\n<ul data-tool=\"mdnice编辑器\" style=\"margin-top: 8px; margin-bottom: 8px; padding-left: 25px; font-size: 15px; color: #595959; list-style-type: circle;\">\n<li><section style=\"margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; font-size: 14px; font-weight: normal; color: #595959;\">计算有效订单总金额</section></li></ul>\n<pre class=\"custom\" data-tool=\"mdnice编辑器\" style=\"margin-top: 10px; margin-bottom: 10px;\"><code class=\"hljs\" style=\"overflow-x: auto; padding: 16px; color: #abb2bf; background: #282c34; display: -webkit-box; font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; border-radius: 0px; font-size: 12px; -webkit-overflow-scrolling: touch; letter-spacing: 0px;\"><span class=\"hljs-comment\" style=\"color: #5c6370; font-style: italic; line-height: 26px;\">//&nbsp;计算有效订单总金额</span><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println(<span class=\"hljs-string\" style=\"color: #98c379; line-height: 26px;\">\"有效订单总金额:\"</span>&nbsp;+&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ordersList.stream()<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;.filter((order)&nbsp;-&gt;&nbsp;order.getIsValid()&nbsp;==&nbsp;<span class=\"hljs-number\" style=\"color: #d19a66; line-height: 26px;\">1</span>)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;.map(Order::getTotal)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;.reduce(Double::sum)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;.get()<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;);<br></code></pre>\n<h3 data-tool=\"mdnice编辑器\" style=\"padding: 0px; color: black; font-size: 17px; font-weight: bold; text-align: center; position: relative; margin-top: 20px; margin-bottom: 20px;\"><span class=\"prefix\" style=\"display: none;\"></span><span class=\"content\" style=\"border-bottom: 2px solid RGBA(79, 177, 249, .65); color: #2b2b2b; padding-bottom: 2px;\"><span style=\"width: 30px; height: 30px; display: block; background-image: url(https://my-wechat.mdnice.com/fullstack-2.png); background-position: center; background-size: 30px; margin: auto; opacity: 1; background-repeat: no-repeat; margin-bottom: -8px;\"></span>2 Collector数据收集</span><span class=\"suffix\" style=\"display: none;\"></span></h3>\n<p data-tool=\"mdnice编辑器\" style=\"padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: #2b2b2b; margin: 10px 0px; letter-spacing: 2px; font-size: 14px; word-spacing: 2px;\">将流转换为其他形式，coollect 方法作为终端操作， 接收一个Collector接口的实现，用于给Stream中元素做汇总的方法。最常用的方法，把流中所有元素收集到一个 List, Set 或 Collection中。</p>\n<h3 data-tool=\"mdnice编辑器\" style=\"padding: 0px; color: black; font-size: 17px; font-weight: bold; text-align: center; position: relative; margin-top: 20px; margin-bottom: 20px;\"><span class=\"prefix\" style=\"display: none;\"></span><span class=\"content\" style=\"border-bottom: 2px solid RGBA(79, 177, 249, .65); color: #2b2b2b; padding-bottom: 2px;\"><span style=\"width: 30px; height: 30px; display: block; background-image: url(https://my-wechat.mdnice.com/fullstack-2.png); background-position: center; background-size: 30px; margin: auto; opacity: 1; background-repeat: no-repeat; margin-bottom: -8px;\"></span>3 集合收集</span><span class=\"suffix\" style=\"display: none;\"></span></h3>\n<p data-tool=\"mdnice编辑器\" style=\"padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: #2b2b2b; margin: 10px 0px; letter-spacing: 2px; font-size: 14px; word-spacing: 2px;\">常用集合收集方法 toList、toSet、toCollection、toMap等</p>\n<ul data-tool=\"mdnice编辑器\" style=\"margin-top: 8px; margin-bottom: 8px; padding-left: 25px; font-size: 15px; color: #595959; list-style-type: circle;\">\n<li><section style=\"margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; font-size: 14px; font-weight: normal; color: #595959;\">筛选所有有效订单 并收集订单列表</section></li></ul>\n<pre class=\"custom\" data-tool=\"mdnice编辑器\" style=\"margin-top: 10px; margin-bottom: 10px;\"><code class=\"hljs\" style=\"overflow-x: auto; padding: 16px; color: #abb2bf; background: #282c34; display: -webkit-box; font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; border-radius: 0px; font-size: 12px; -webkit-overflow-scrolling: touch; letter-spacing: 0px;\"><span class=\"hljs-comment\" style=\"color: #5c6370; font-style: italic; line-height: 26px;\">//&nbsp;筛选所有有效订单并收集订单列表</span><br>ordersList.stream()<br>&nbsp;&nbsp;&nbsp;&nbsp;.filter((order)&nbsp;-&gt;&nbsp;order.getIsValid()&nbsp;==&nbsp;<span class=\"hljs-number\" style=\"color: #d19a66; line-height: 26px;\">1</span>)<br>&nbsp;&nbsp;&nbsp;&nbsp;.collect(Collectors.toList())<br>&nbsp;&nbsp;&nbsp;&nbsp;.forEach(System.out::println);<br></code></pre>\n<ul data-tool=\"mdnice编辑器\" style=\"margin-top: 8px; margin-bottom: 8px; padding-left: 25px; font-size: 15px; color: #595959; list-style-type: circle;\">\n<li><section style=\"margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; font-size: 14px; font-weight: normal; color: #595959;\">筛选所有有效订单并收集订单号与订单金额</section></li></ul>\n<pre class=\"custom\" data-tool=\"mdnice编辑器\" style=\"margin-top: 10px; margin-bottom: 10px;\"><code class=\"hljs\" style=\"overflow-x: auto; padding: 16px; color: #abb2bf; background: #282c34; display: -webkit-box; font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; border-radius: 0px; font-size: 12px; -webkit-overflow-scrolling: touch; letter-spacing: 0px;\"><span class=\"hljs-comment\" style=\"color: #5c6370; font-style: italic; line-height: 26px;\">//&nbsp;筛选所有有效订单&nbsp;并收集订单号&nbsp;与&nbsp;订单金额</span><br>Map&lt;String,Double&gt;&nbsp;map=ordersList.stream().filter((order)&nbsp;-&gt;&nbsp;order.getIsValid()&nbsp;==&nbsp;<span class=\"hljs-number\" style=\"color: #d19a66; line-height: 26px;\">1</span>).<br>&nbsp;&nbsp;&nbsp;&nbsp;collect(Collectors.toMap(Order::getOrderNo,&nbsp;Order::getTotal));<br><span class=\"hljs-comment\" style=\"color: #5c6370; font-style: italic; line-height: 26px;\">//&nbsp;java8&nbsp;下对map进行遍历操作&nbsp;如果&nbsp;Map的Key重复,会报错</span><br>map.forEach((k,v)-&gt;{<br>&nbsp;&nbsp;&nbsp;&nbsp;System.out.println(<span class=\"hljs-string\" style=\"color: #98c379; line-height: 26px;\">\"k:\"</span>+k+<span class=\"hljs-string\" style=\"color: #98c379; line-height: 26px;\">\":v:\"</span>+v);<br>});<br></code></pre>\n", "user_name": "同一片蓝天下", "description": "一个呆萌の小小程序员", "got_view_count": 2080, "category_name": "后端", "ctime": 1457483880}
{"tag_name": "Go", "concern_user_count": 75376, "user_id": "3087084382347271", "title": "使用Go实现GoF的23种设计模式（一）", "mark_content": "## 前言\n\n从1995年GoF提出23种**设计模式**到现在，25年过去了，设计模式依旧是软件领域的热门话题。在当下，如果你不会一点设计模式，都不好意思说自己是一个合格的程序员。设计模式通常被定义为：\n\n> 设计模式（Design Pattern）是一套被反复使用、多数人知晓的、经过分类编目的、代码设计经验的总结，使用设计模式是为了可重用代码、让代码更容易被他人理解并且保证代码可靠性。\n\n从定义上看，**设计模式其实是一种经验的总结，是针对特定问题的简洁而优雅的解决方案**。既然是经验总结，那么学习设计模式最直接的好处就在于可以站在巨人的肩膀上解决软件开发过程中的一些特定问题。然而，学习设计模式的最高境界是习得其中解决问题所用到的思想，当你把它们的本质思想吃透了，也就能做到**即使已经忘掉某个设计模式的名称和结构，也能在解决特定问题时信手拈来**。\n\n好的东西有人吹捧，当然也会招黑。设计模式被抨击主要因为以下两点：\n\n1、*设计模式会增加代码量，把程序逻辑变得复杂*。这一点是不可避免的，但是我们并不能仅仅只考虑开发阶段的成本。最简单的程序当然是一个函数从头写到尾，但是这样后期的维护成本会变得非常大；而设计模式虽然增加了一点开发成本，但是能让人们写出可复用、可维护性高的程序。引用《软件设计的哲学》里的概念，前者就是**战术编程**，后者就是**战略编程**，我们应该**对战术编程Say No**！（请移步[《一步步降低软件复杂性》](https://www.yrunz.com/archives/一步步降低软件复杂性)）\n\n2、*滥用设计模式*。这是初学者最容易犯的错误，当学到一个模式时，恨不得在所有的代码都用上，从而在不该使用模式的地方刻意地使用了模式，导致了程序变得异常复杂。其实每个设计模式都有几个关键要素：**适用场景**、**解决方法**、**优缺点**。模式并不是万能药，它只有在特定的问题上才能显现出效果。所以，在使用一个模式前，先问问自己，当前的这个场景适用这个模式吗？\n\n《设计模式》一书的副标题是“可复用面向对象软件的基础”，但并不意味着只有面向对象语言才能使用设计模式。模式只是一种解决特定问题的思想，跟语言无关。就像Go语言一样，它并非是像C++和Java一样的面向对象语言，但是设计模式同样适用。本系列文章将使用Go语言来实现GoF提出的23种设计模式，按照**创建型模式**（Creational Pattern）、**结构型模式**（Structural Pattern）和**行为型模式**（Behavioral Pattern）三种类别进行组织，文本主要介绍其中的创建型模式。\n\n## 单例模式（Singleton Pattern）\n\n![单例模式结构](https://tva1.sinaimg.cn/large/007S8ZIlgy1ghky3yanabj318q0iwnpd.jpg)\n\n### 简述\n\n单例模式算是23中设计模式里最简单的一个了，它主要用于**保证一个类仅有一个实例，并提供一个访问它的全局访问点**。\n\n在程序设计中，有一些对象通常我们只需要一个共享的实例，比如线程池、全局缓存、对象池等，这种场景下就适合使用单例模式。\n\n但是，并非所有全局唯一的场景都适合使用单例模式。比如，考虑需要统计一个API调用的情况，有两个指标，成功调用次数和失败调用次数。这两个指标都是全局唯一的，所以有人可能会将其建模成两个单例`SuccessApiMetric`和`FailApiMetric`。按照这个思路，随着指标数量的增多，你会发现代码里类的定义会越来越多，也越来越臃肿。这也是单例模式最常见的误用场景，更好的方法是将两个指标设计成一个对象`ApiMetric`下的两个实例`ApiMetic success`和`ApiMetic fail`。\n\n*如何判断一个对象是否应该被建模成单例？*\n\n通常，被建模成单例的对象都有“**中心点**”的含义，比如线程池就是管理所有线程的中心。所以，在判断一个对象是否适合单例模式时，先思考下，这个对象是一个中心点吗？\n\n### Go实现\n\n在对某个对象实现单例模式时，有两个点必须要注意：（1）**限制调用者直接实例化该对象**；（2）**为该对象的单例提供一个全局唯一的访问方法**。\n\n对于C++/Java而言，只需把类的构造函数设计成私有的，并提供一个`static`方法去访问该类点唯一实例即可。但对于Go语言来说，即没有构造函数的概念，也没有`static`方法，所以需要另寻出路。\n\n我们可以利用Go语言`package`的访问规则来实现，将单例结构体设计成首字母小写，就能限定其访问范围只在当前package下，模拟了C++/Java中的私有构造函数；再在当前`package`下实现一个首字母大写的访问函数，就相当于`static`方法的作用了。\n\n在实际开发中，我们经常会遇到需要频繁创建和销毁的对象。频繁的创建和销毁一则消耗CPU，二则内存的利用率也不高，通常我们都会使用对象池技术来进行优化。考虑我们需要实现一个消息对象池，因为是全局的中心点，管理所有的Message实例，所以将其实现成单例，实现代码如下：\n\n```go\npackage msgpool\n...\n// 消息池\ntype messagePool struct {\n\tpool *sync.Pool\n}\n// 消息池单例\nvar msgPool = &messagePool{\n\t// 如果消息池里没有消息，则新建一个Count值为0的Message实例\n\tpool: &sync.Pool{New: func() interface{} { return &Message{Count: 0} }},\n}\n// 访问消息池单例的唯一方法\nfunc Instance() *messagePool {\n\treturn msgPool\n}\n// 往消息池里添加消息\nfunc (m *messagePool) AddMsg(msg *Message) {\n\tm.pool.Put(msg)\n}\n// 从消息池里获取消息\nfunc (m *messagePool) GetMsg() *Message {\n\treturn m.pool.Get().(*Message)\n}\n...\n```\n\n测试代码如下：\n\n```go\npackage test\n...\nfunc TestMessagePool(t *testing.T) {\n\tmsg0 := msgpool.Instance().GetMsg()\n\tif msg0.Count != 0 {\n\t\tt.Errorf(\"expect msg count %d, but actual %d.\", 0, msg0.Count)\n\t}\n\tmsg0.Count = 1\n\tmsgpool.Instance().AddMsg(msg0)\n\tmsg1 := msgpool.Instance().GetMsg()\n\tif msg1.Count != 1 {\n\t\tt.Errorf(\"expect msg count %d, but actual %d.\", 1, msg1.Count)\n\t}\n}\n// 运行结果\n=== RUN   TestMessagePool\n--- PASS: TestMessagePool (0.00s)\nPASS\n```\n\n以上的单例模式就是典型的“**饿汉模式**”，实例在系统加载的时候就已经完成了初始化。对应地，还有一种“**懒汉模式**”，只有等到对象被使用的时候，才会去初始化它，从而一定程度上节省了内存。众所周知，“懒汉模式”会带来线程安全问题，可以通过**普通加锁**，或者更高效的**双重检验锁**来优化。对于“懒汉模式”，Go语言有一个更优雅的实现方式，那就是利用`sync.Once`，它有一个`Do`方法，其入参是一个方法，Go语言会保证仅仅只调用一次该方法。\n\n```go\n// 单例模式的“懒汉模式”实现\npackage msgpool\n...\nvar once = &sync.Once{}\n// 消息池单例，在首次调用时初始化\nvar msgPool *messagePool\n// 全局唯一获取消息池pool到方法\nfunc Instance() *messagePool {\n\t// 在匿名函数中实现初始化逻辑，Go语言保证只会调用一次\n\tonce.Do(func() {\n\t\tmsgPool = &messagePool{\n\t\t\t// 如果消息池里没有消息，则新建一个Count值为0的Message实例\n\t\t\tpool: &sync.Pool{New: func() interface{} { return &Message{Count: 0} }},\n\t\t}\n\t})\n\treturn msgPool\n}\n...\n```\n\n## 建造者模式（Builder Pattern）\n\n![建造者模式结构](https://tva1.sinaimg.cn/large/007S8ZIlgy1ghky4kprezj319e0kuu0x.jpg)\n\n### 简述\n\n在程序设计中，我们会经常遇到一些复杂的对象，其中有很多成员属性，甚至嵌套着多个复杂的对象。这种情况下，创建这个复杂对象就会变得很繁琐。对于C++/Java而言，最常见的表现就是构造函数有着长长的参数列表：\n\n```java\nMyObject obj = new MyObject(param1, param2, param3, param4, param5, param6, ...)\n```\n\n而对于Go语言来说，最常见的表现就是多层的嵌套实例化：\n\n```go\nobj := &MyObject{\n  Field1: &Field1 {\n    Param1: &Param1 {\n      Val: 0,\n    },\n    Param2: &Param2 {\n      Val: 1,\n    },\n    ...\n  },\n  Field2: &Field2 {\n    Param3: &Param3 {\n      Val: 2,\n    },\n    ...\n  },\n  ...\n}\n```\n\n上述的对象创建方法有两个明显的缺点：（1）**对对象使用者不友好**，使用者在创建对象时需要知道的细节太多；（2）**代码可读性很差**。\n\n*针对这种对象成员较多，创建对象逻辑较为繁琐的场景，就适合使用建造者模式来进行优化。*\n\n建造者模式的作用有如下几个：\n\n1、封装复杂对象的创建过程，使对象使用者不感知复杂的创建逻辑。\n\n2、可以一步步按照顺序对成员进行赋值，或者创建嵌套对象，并最终完成目标对象的创建。\n\n3、对多个对象复用同样的对象创建逻辑。\n\n其中，第1和第2点比较常用，下面对建造者模式的实现也主要是针对这两点进行示例。\n\n### Go实现\n\n考虑如下的一个`Message`结构体，其主要有`Header`和`Body`组成：\n\n```go\npackage msg\n...\ntype Message struct {\n\tHeader *Header\n\tBody   *Body\n}\ntype Header struct {\n\tSrcAddr  string\n\tSrcPort  uint64\n\tDestAddr string\n\tDestPort uint64\n\tItems    map[string]string\n}\ntype Body struct {\n\tItems []string\n}\n...\n```\n\n如果按照直接的对象创建方式，创建逻辑应该是这样的：\n\n```go\n// 多层的嵌套实例化\nmessage := msg.Message{\n\tHeader: &msg.Header{\n\t\tSrcAddr:  \"192.168.0.1\",\n\t\tSrcPort:  1234,\n\t\tDestAddr: \"192.168.0.2\",\n\t\tDestPort: 8080,\n\t\tItems:    make(map[string]string),\n\t},\n\tBody:   &msg.Body{\n\t\tItems: make([]string, 0),\n\t},\n}\n// 需要知道对象的实现细节\nmessage.Header.Items[\"contents\"] = \"application/json\"\nmessage.Body.Items = append(message.Body.Items, \"record1\")\nmessage.Body.Items = append(message.Body.Items, \"record2\")\n```\n\n虽然`Message`结构体嵌套的层次不多，但是从其创建的代码来看，确实存在**对对象使用者不友好**和**代码可读性差**的缺点。下面我们引入建造者模式对代码进行重构：\n\n```go\npackage msg\n...\n// Message对象的Builder对象\ntype builder struct {\n\tonce *sync.Once\n\tmsg *Message\n}\n// 返回Builder对象\nfunc Builder() *builder {\n\treturn &builder{\n\t\tonce: &sync.Once{},\n\t\tmsg: &Message{Header: &Header{}, Body: &Body{}},\n\t}\n}\n// 以下是对Message成员对构建方法\nfunc (b *builder) WithSrcAddr(srcAddr string) *builder {\n\tb.msg.Header.SrcAddr = srcAddr\n\treturn b\n}\nfunc (b *builder) WithSrcPort(srcPort uint64) *builder {\n\tb.msg.Header.SrcPort = srcPort\n\treturn b\n}\nfunc (b *builder) WithDestAddr(destAddr string) *builder {\n\tb.msg.Header.DestAddr = destAddr\n\treturn b\n}\nfunc (b *builder) WithDestPort(destPort uint64) *builder {\n\tb.msg.Header.DestPort = destPort\n\treturn b\n}\nfunc (b *builder) WithHeaderItem(key, value string) *builder {\n  // 保证map只初始化一次\n\tb.once.Do(func() {\n\t\tb.msg.Header.Items = make(map[string]string)\n\t})\n\tb.msg.Header.Items[key] = value\n\treturn b\n}\nfunc (b *builder) WithBodyItem(record string) *builder {\n\tb.msg.Body.Items = append(b.msg.Body.Items, record)\n\treturn b\n}\n// 创建Message对象，在最后一步调用\nfunc (b *builder) Build() *Message {\n\treturn b.msg\n}\n```\n\n测试代码如下：\n\n```go\npackage test\n...\nfunc TestMessageBuilder(t *testing.T) {\n  // 使用消息建造者进行对象创建\n\tmessage := msg.Builder().\n\t\tWithSrcAddr(\"192.168.0.1\").\n\t\tWithSrcPort(1234).\n\t\tWithDestAddr(\"192.168.0.2\").\n\t\tWithDestPort(8080).\n\t\tWithHeaderItem(\"contents\", \"application/json\").\n\t\tWithBodyItem(\"record1\").\n\t\tWithBodyItem(\"record2\").\n\t\tBuild()\n\tif message.Header.SrcAddr != \"192.168.0.1\" {\n\t\tt.Errorf(\"expect src address 192.168.0.1, but actual %s.\", message.Header.SrcAddr)\n\t}\n\tif message.Body.Items[0] != \"record1\" {\n\t\tt.Errorf(\"expect body item0 record1, but actual %s.\", message.Body.Items[0])\n\t}\n}\n// 运行结果\n=== RUN   TestMessageBuilder\n--- PASS: TestMessageBuilder (0.00s)\nPASS\n```\n\n从测试代码可知，使用建造者模式来进行对象创建，使用者不再需要知道对象具体的实现细节，代码可读性也更好。\n\n## 工厂方法模式（Factory Method Pattern）\n\n![工厂方法模式结构](https://tva1.sinaimg.cn/large/007S8ZIlgy1ghkpq8hayrj31cm0sskjm.jpg)\n\n### 简述\n\n 工厂方法模式跟上一节讨论的建造者模式类似，都是**将对象创建的逻辑封装起来，为使用者提供一个简单易用的对象创建接口**。两者在应用场景上稍有区别，建造者模式更常用于需要传递多个参数来进行实例化的场景。\n\n使用工厂方法来创建对象主要有两个好处：\n\n1、**代码可读性更好**。相比于使用C++/Java中的构造函数，或者Go中的`{}`来创建对象，工厂方法因为可以通过函数名来表达代码含义，从而具备更好的可读性。比如，使用工厂方法`productA := CreateProductA()`创建一个`ProductA`对象，比直接使用`productA := ProductA{}`的可读性要好。\n\n2、**与使用者代码解耦**。很多情况下，对象的创建往往是一个容易变化的点，通过工厂方法来封装对象的创建过程，可以在创建逻辑变更时，避免**霰弹式修改**。\n\n工厂方法模式也有两种实现方式：（1）提供一个工厂对象，通过调用工厂对象的工厂方法来创建产品对象；（2）将工厂方法集成到产品对象中（C++/Java中对象的`static`方法，Go中同一`package`下的函数）\n\n### Go实现\n\n考虑有一个事件对象`Event`，分别有两种有效的时间类型`Start`和`End`：\n\n```go\npackage event\n...\ntype Type uint8\n// 事件类型定义\nconst (\n\tStart Type = iota\n\tEnd\n)\n// 事件抽象接口\ntype Event interface {\n\tEventType() Type\n\tContent() string\n}\n// 开始事件，实现了Event接口\ntype StartEvent struct{\n\tcontent string\n}\n...\n// 结束事件，实现了Event接口\ntype EndEvent struct{\n\tcontent string\n}\n...\n```\n\n1、按照第一种实现方式，为`Event`提供一个工厂对象，具体代码如下：\n\n```go\npackage event\n...\n// 事件工厂对象\ntype Factory struct{}\n// 更具事件类型创建具体事件\nfunc (e *Factory) Create(etype Type) Event {\n\tswitch etype {\n\tcase Start:\n\t\treturn &StartEvent{\n\t\t\tcontent: \"this is start event\",\n\t\t}\n\tcase End:\n\t\treturn &EndEvent{\n\t\t\tcontent: \"this is end event\",\n\t\t}\n\tdefault:\n\t\treturn nil\n\t}\n}\n```\n\n测试代码如下：\n\n```go\npackage test\n...\nfunc TestEventFactory(t *testing.T) {\n\tfactory := event.Factory{}\n\te := factory.Create(event.Start)\n\tif e.EventType() != event.Start {\n\t\tt.Errorf(\"expect event.Start, but actual %v.\", e.EventType())\n\t}\n\te = factory.Create(event.End)\n\tif e.EventType() != event.End {\n\t\tt.Errorf(\"expect event.End, but actual %v.\", e.EventType())\n\t}\n}\n// 运行结果\n=== RUN   TestEventFactory\n--- PASS: TestEventFactory (0.00s)\nPASS\n```\n\n2、按照第二种实现方式，分别给`Start`和`End`类型的`Event`单独提供一个工厂方法，代码如下：\n\n```go\npackage event\n...\n// Start类型Event的工厂方法\nfunc OfStart() Event {\n\treturn &StartEvent{\n\t\tcontent: \"this is start event\",\n\t}\n}\n// End类型Event的工厂方法\nfunc OfEnd() Event {\n\treturn &EndEvent{\n\t\tcontent: \"this is end event\",\n\t}\n}\n```\n\n测试代码如下：\n\n```go\npackage event\n...\nfunc TestEvent(t *testing.T) {\n\te := event.OfStart()\n\tif e.EventType() != event.Start {\n\t\tt.Errorf(\"expect event.Start, but actual %v.\", e.EventType())\n\t}\n\te = event.OfEnd()\n\tif e.EventType() != event.End {\n\t\tt.Errorf(\"expect event.End, but actual %v.\", e.EventType())\n\t}\n}\n// 运行结果\n=== RUN   TestEvent\n--- PASS: TestEvent (0.00s)\nPASS\n```\n\n## 抽象工厂模式（Abstract Factory Pattern）\n\n![抽象工厂模式结构](https://tva1.sinaimg.cn/large/007S8ZIlgy1ghkxo5tf5ij31ak0om4qq.jpg)\n\n### 简述\n\n在工厂方法模式中，我们通过一个工厂对象来创建一个产品族，具体创建哪个产品，则通过`swtich-case`的方式去判断。这也意味着该产品组上，每新增一类产品对象，都必须修改原来工厂对象的代码；而且随着产品的不断增多，工厂对象的职责也越来越重，违反了**单一职责原则**。\n\n抽象工厂模式通过给工厂类新增一个抽象层解决了该问题，如上图所示，`FactoryA`和`FactoryB`都实现·抽象工厂接口，分别用于创建`ProductA`和`ProductB`。如果后续新增了`ProductC`，只需新增一个`FactoryC`即可，无需修改原有的代码；因为每个工厂只负责创建一个产品，因此也遵循了**单一职责原则**。\n\n### Go实现\n\n考虑需要如下一个插件架构风格的消息处理系统，`pipeline`是消息处理的管道，其中包含了`input`、`filter`和`output`三个插件。我们需要实现根据配置来创建`pipeline` ，加载插件过程的实现非常适合使用工厂模式，其中`input`、`filter`和`output`三类插件的创建使用抽象工厂模式，而`pipeline`的创建则使用工厂方法模式。\n\n![抽象工厂模式示例](https://tva1.sinaimg.cn/large/007S8ZIlgy1ghkw23e4r3j31bs0nge82.jpg)\n\n各类插件和`pipeline`的接口定义如下：\n\n```go\npackage plugin\n...\n// 插件抽象接口定义\ntype Plugin interface {}\n// 输入插件，用于接收消息\ntype Input interface {\n\tPlugin\n\tReceive() string\n}\n// 过滤插件，用于处理消息\ntype Filter interface {\n\tPlugin\n\tProcess(msg string) string\n}\n// 输出插件，用于发送消息\ntype Output interface {\n\tPlugin\n\tSend(msg string)\n}\n```\n\n```go\npackage pipeline\n...\n// 消息管道的定义\ntype Pipeline struct {\n\tinput  plugin.Input\n\tfilter plugin.Filter\n\toutput plugin.Output\n}\n// 一个消息的处理流程为 input -> filter -> output\nfunc (p *Pipeline) Exec() {\n\tmsg := p.input.Receive()\n\tmsg = p.filter.Process(msg)\n\tp.output.Send(msg)\n}\n```\n\n接着，我们定义`input`、`filter`、`output`三类插件接口的具体实现：\n\n```go\npackage plugin\n...\n// input插件名称与类型的映射关系，主要用于通过反射创建input对象\nvar inputNames = make(map[string]reflect.Type)\n// Hello input插件，接收“Hello World”消息\ntype HelloInput struct {}\n\nfunc (h *HelloInput) Receive() string {\n\treturn \"Hello World\"\n}\n// 初始化input插件映射关系表\nfunc init() {\n\tinputNames[\"hello\"] = reflect.TypeOf(HelloInput{})\n}\n```\n\n```go\npackage plugin\n...\n// filter插件名称与类型的映射关系，主要用于通过反射创建filter对象\nvar filterNames = make(map[string]reflect.Type)\n// Upper filter插件，将消息全部字母转成大写\ntype UpperFilter struct {}\n\nfunc (u *UpperFilter) Process(msg string) string {\n\treturn strings.ToUpper(msg)\n}\n// 初始化filter插件映射关系表\nfunc init() {\n\tfilterNames[\"upper\"] = reflect.TypeOf(UpperFilter{})\n}\n```\n\n```go\npackage plugin\n...\n// output插件名称与类型的映射关系，主要用于通过反射创建output对象\nvar outputNames = make(map[string]reflect.Type)\n// Console output插件，将消息输出到控制台上\ntype ConsoleOutput struct {}\n\nfunc (c *ConsoleOutput) Send(msg string) {\n\tfmt.Println(msg)\n}\n// 初始化output插件映射关系表\nfunc init() {\n\toutputNames[\"console\"] = reflect.TypeOf(ConsoleOutput{})\n}\n```\n\n然后，我们定义插件抽象工厂接口，以及对应插件的工厂实现：\n\n```go\npackage plugin\n...\n// 插件抽象工厂接口\ntype Factory interface {\n\tCreate(conf Config) Plugin\n}\n// input插件工厂对象，实现Factory接口\ntype InputFactory struct{}\n// 读取配置，通过反射机制进行对象实例化\nfunc (i *InputFactory) Create(conf Config) Plugin {\n\tt, _ := inputNames[conf.Name]\n\treturn reflect.New(t).Interface().(Plugin)\n}\n// filter和output插件工厂实现类似\ntype FilterFactory struct{}\nfunc (f *FilterFactory) Create(conf Config) Plugin {\n\tt, _ := filterNames[conf.Name]\n\treturn reflect.New(t).Interface().(Plugin)\n}\ntype OutputFactory struct{}\nfunc (o *OutputFactory) Create(conf Config) Plugin {\n\tt, _ := outputNames[conf.Name]\n\treturn reflect.New(t).Interface().(Plugin)\n}\n```\n\n最后定义`pipeline`的工厂方法，调用`plugin.Factory`抽象工厂完成pipelien对象的实例化：\n\n```go\npackage pipeline\n...\n// 保存用于创建Plugin的工厂实例，其中map的key为插件类型，value为抽象工厂接口\nvar pluginFactories = make(map[plugin.Type]plugin.Factory)\n// 根据plugin.Type返回对应Plugin类型的工厂实例\nfunc factoryOf(t plugin.Type) plugin.Factory {\n\tfactory, _ := pluginFactories[t]\n\treturn factory\n}\n// pipeline工厂方法，根据配置创建一个Pipeline实例\nfunc Of(conf Config) *Pipeline {\n\tp := &Pipeline{}\n\tp.input = factoryOf(plugin.InputType).Create(conf.Input).(plugin.Input)\n\tp.filter = factoryOf(plugin.FilterType).Create(conf.Filter).(plugin.Filter)\n\tp.output = factoryOf(plugin.OutputType).Create(conf.Output).(plugin.Output)\n\treturn p\n}\n// 初始化插件工厂对象\nfunc init() {\n\tpluginFactories[plugin.InputType] = &plugin.InputFactory{}\n\tpluginFactories[plugin.FilterType] = &plugin.FilterFactory{}\n\tpluginFactories[plugin.OutputType] = &plugin.OutputFactory{}\n}\n```\n\n测试代码如下：\n\n```go\npackage test\n...\nfunc TestPipeline(t *testing.T) {\n  // 其中pipeline.DefaultConfig()的配置内容见【抽象工厂模式示例图】\n  // 消息处理流程为 HelloInput -> UpperFilter -> ConsoleOutput\n\tp := pipeline.Of(pipeline.DefaultConfig())\n\tp.Exec()\n}\n// 运行结果\n=== RUN   TestPipeline\nHELLO WORLD\n--- PASS: TestPipeline (0.00s)\nPASS\n```\n\n## 原型模式（Prototype Pattern）\n\n![原型模式结构](https://tva1.sinaimg.cn/large/007S8ZIlgy1ghky39ichjj319u0gqhdt.jpg)\n\n### 简述\n\n原型模式主要解决对象复制的问题，它的核心就是`clone()`方法，返回`Prototype`对象的复制品。在程序设计过程中，往往会遇到有一些场景需要大量相同的对象，如果不使用原型模式，那么我们可能会这样进行对象的创建：*新创建一个相同对象的实例，然后遍历原始对象的所有成员变量， 并将成员变量值复制到新对象中*。这种方法的缺点很明显，那就是使用者必须知道对象的实现细节，导致代码之间的耦合。另外，对象很有可能存在除了对象本身以外不可见的变量，这种情况下该方法就行不通了。\n\n对于这种情况，更好的方法就是使用原型模式，将复制逻辑委托给对象本身，这样，上述两个问题也都迎刃而解了。\n\n### Go实现\n\n还是以建造者模式一节中的`Message`作为例子，现在设计一个`Prototype`抽象接口：\n\n```go\npackage prototype\n...\n// 原型复制抽象接口\ntype Prototype interface {\n\tclone() Prototype\n}\n\ntype Message struct {\n\tHeader *Header\n\tBody   *Body\n}\n\nfunc (m *Message) clone() Prototype {\n\tmsg := *m\n\treturn &msg\n}\n```\n\n测试代码如下：\n\n```go\npackage test\n...\nfunc TestPrototype(t *testing.T) {\n\tmessage := msg.Builder().\n\t\tWithSrcAddr(\"192.168.0.1\").\n\t\tWithSrcPort(1234).\n\t\tWithDestAddr(\"192.168.0.2\").\n\t\tWithDestPort(8080).\n\t\tWithHeaderItem(\"contents\", \"application/json\").\n\t\tWithBodyItem(\"record1\").\n\t\tWithBodyItem(\"record2\").\n\t\tBuild()\n  // 复制一份消息\n\tnewMessage := message.Clone().(*msg.Message)\n\tif newMessage.Header.SrcAddr != message.Header.SrcAddr {\n\t\tt.Errorf(\"Clone Message failed.\")\n\t}\n\tif newMessage.Body.Items[0] != message.Body.Items[0] {\n\t\tt.Errorf(\"Clone Message failed.\")\n\t}\n}\n// 运行结果\n=== RUN   TestPrototype\n--- PASS: TestPrototype (0.00s)\nPASS\n```\n\n## 总结\n\n本文主要介绍了GoF的23种设计模式中的5种创建型模式，创建型模式的目的都是**提供一个简单的接口，让对象的创建过程与使用者解耦**。其中，**单例模式**主要用于保证一个类仅有一个实例，并提供一个访问它的全局访问点；**建造者模式**主要解决需要创建对象时需要传入多个参数，或者对初始化顺序有要求的场景；**工厂方法模式**通过提供一个工厂对象或者工厂方法，为使用者隐藏了对象创建的细节；**抽象工厂模式**是对工厂方法模式的优化，通过为工厂对象新增一个抽象层，让工厂对象遵循单一职责原则，也避免了霰弹式修改；**原型模式**则让对象复制更加简单。\n\n下一篇文章，将介绍23种设计模式中的7种**结构型模式**（Structural Pattern），及其Go语言的实现。\n\n![](https://tva1.sinaimg.cn/large/006tNbRwly1g9l3eygwe4j30im0lk763.jpg)\n\n", "user_name": "元闰子", "description": "Java、OOP、DDD、重构| 个人博客 www.yrunz.com | 微信公众号 yuanrunzi", "got_view_count": 4183, "category_name": "后端", "ctime": 1457483880}
{"tag_name": "前端", "concern_user_count": 455667, "user_id": "289926798645575", "title": "JavaScript中的map()和forEach()有什么区别？", "mark_content": "> 来源：[https://medium.com/better-programming](https://medium.com/better-programming/what-is-the-difference-between-map-and-foreach-in-javascript-9bc49afa2703)  \n> 作者：Moon  \n> 翻译：公众号《前端全栈开发者》\n\nJavaScript中一些最受欢迎的功能可能是map和forEach。从ECMAScript 5（简称es5）开始，它们就开始存在了。\n\n在本文中，我将讨论它们之间的主要区别，并向你展示其用法的一些示例。\n\n## 阅读之前\n\n基本上，在JavaScript中遍历对象取决于对象是否可迭代。默认情况下，数组是可迭代的。`map` 和 `forEach` 包含在`Array.prototype` 中，因此我们无需考虑可迭代性。如果你想进一步学习，我推荐你看看什么是JavaScript中的可迭代对象！\n\n## 什么是map()和forEach()？\n\n`map` 和 `forEach` 是数组中的帮助器方法，可以轻松地在数组上循环。我们曾经像下面这样循环遍历一个数组，没有任何辅助函数。\n\n```javascript\nvar array = ['1', '2', '3'];\nfor (var i = 0; i < array.length; i += 1) {\n  console.log(Number(array[i]));\n}\n// 1\n// 2\n// 3\n```\n\n自JavaScript时代开始以来，就一直存在 `for` 循环。它包含3个表达式：初始值，条件和最终表达式。\n\n这是循环数组的经典方法。从ECMAScript 5开始，新功能似乎使我们更加快乐。\n\n### map\n\n`map` 的作用与 `for` 循环完全相同，只是 `map` 会创建一个新数组，其结果是在调用数组中的每个元素上调用提供的函数。\n\n它需要两个参数：一个是稍后在调用 `map` 或 `forEach` 时调用的回调函数，另一个是回调函数被调用时使用的名为 `thisArg` 的上下文变量。\n\n```javascript\nconst arr = ['1', '2', '3'];\n// 回调函数接受3个参数\n// 数组的当前值作为第一个参数\n// 当前值在数组中的位置作为第二个参数\n// 原始源数组作为第三个参数\nconst cb = (str, i, origin) => {\n  console.log(`${i}: ${Number(str)} / ${origin}`);\n};\narr.map(cb);\n// 0: 1 / 1,2,3\n// 1: 2 / 1,2,3\n// 2: 3 / 1,2,3\n```\n\n回调函数可以如下使用。\n\n```javascript\narr.map((str) => { console.log(Number(str)); })\n```\n\n`map` 的结果不等于原始数组。\n\n```javascript\nconst arr = [1];\nconst new_arr = arr.map(d => d);\n\narr === new_arr; // false\n```\n\n你还可以将对象作为 `thisArg` 传递到map。\n\n```javascript\nconst obj = { name: 'Jane' };\n\n[1].map(function() {\n  // { name: 'Jane' }\n  console.dir(this);\n}, obj);\n\n[1].map(() => {\n  // window\n  console.dir(this);\n}, obj);\n```\n\n对象 `obj` 成为 `map` 的 `thisArg`。但是箭头回调函数无法将 `obj` 作为其 `thisArg`。\n\n这是因为箭头函数与正常函数不同。\n\n### forEach\n\n`forEach` 是数组的另一个循环函数，但 `map` 和 `forEach` 在使用中有所不同。`map` 和 `forEach` 可以使用两个参数——回调函数和 `thisArg`，它们用作其 `this`。\n\n```javascript\nconst arr = ['1', '2', '3'];\n// 回调函数接受3个参数\n// 数组的当前值作为第一个参数\n// 当前值在数组中的位置作为第二个参数\n// 原始源数组作为第三个参数\nconst cb = (str, i, origin) => {\n  console.log(`${i}: ${Number(str)} / ${origin}`);\n};\narr.forEach(cb);\n// 0: 1 / 1,2,3\n// 1: 2 / 1,2,3\n// 2: 3 / 1,2,3\n```\n\n那有什么不同？\n\n`map` 返回其原始数组的新数组，但是 `forEach` 却没有。但是它们都确保了原始对象的不变性。\n\n```javascript\n[1,2,3].map(d => d + 1); // [2, 3, 4];\n[1,2,3].forEach(d => d + 1); // undefined;\n```\n\n如果更改数组内的值，`forEach` 不能确保数组的不变性。这个方法只有在你不接触里面的任何值时，才能保证不变性。\n\n```javascript\n[{a: 1, b: 2}, {a: 10, b: 20}].forEach((obj) => obj.a += 1);\n// [{a: 2, b: 2}, {a: 11, b: 21}]\n// 数组已更改！\n```\n\n## 何时使用map()和forEach()？\n\n由于它们之间的主要区别在于是否有返回值，所以你会希望使用 `map` 来制作一个新的数组，而使用 `forEach` 只是为了映射到数组上。\n\n这是一个简单的例子。\n\n```javascript\nconst people = [\n  { name: 'Josh', whatCanDo: 'painting' },\n  { name: 'Lay', whatCanDo: 'security' },\n  { name: 'Ralph', whatCanDo: 'cleaning' }\n];\n\nfunction makeWorkers(people) {\n  return people.map((person) => {\n    const { name, whatCanDo } = person;\n    return <li key={name}>My name is {name}, I can do {whatCanDo}</li>\n  });\n}\n\n<ul>makeWorkers(people)</ul>\n```\n\n比如在React中，`map` 是非常常用的制作元素的方法，因为 `map` 在对原数组的数据进行操作后，会创建并返回一个新的数组。\n\n```javascript\nconst mySubjectId = ['154', '773', '245'];\n\nfunction countSubjects(subjects) {\n  let cnt = 0;\n  \n  subjects.forEach(subject => {\n    if (mySubjectId.includes(subject.id)) {\n      cnt += 1;\n    }\n  });\n  \n  return cnt;\n}\n\ncountSubjects([\n  { id: '223', teacher: 'Mark' },\n  { id: '154', teacher: 'Linda' }\n]);\n// 1\n```\n\n另一方面，当你想对数据进行某些操作而不创建新数组时，`forEach` 很有用。顺便说一句，可以使用 `filter` 重构示例。\n\n```javascript\nsubjects.filter(subject => mySubjectId.includes(subject.id)).length;\n```\n\n**综上所述，我建议你在创建一个新的数组时使用map，当你不需要制作一个新的数组，而是要对数据做一些事情时，就使用forEach。**\n\n## 速度比较\n\n有些帖子提到 `map` 比 `forEach` 快。所以，我很好奇这是不是真的。我找到了这个对比结果。\n\n![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d603d8032807415f898db78b88dc8dd3~tplv-k3u1fbpfcp-zoom-1.image)\n\n![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/79644926bbce4bae840cd39245a54010~tplv-k3u1fbpfcp-zoom-1.image)\n\n该代码看起来非常相似，但结果却相反。有些测试说 `forEach` 更快，有些说 `map` 更快。也许你在告诉自己 `map/forEach` 比其他的快，你可能是对的。老实说，我不确定。我认为在现代Web开发中，可读性比 `map` 和 `forEach` 之间的速度重要得多。\n\n但可以肯定的是——两者都比JavaScript内置的 `for` 循环慢。\n\n\n\n\n", "user_name": "杜尼卜", "description": "Web全栈开发、持续学习者，关注公众号第一时间接收最新文章", "got_view_count": 281906, "category_name": "前端", "ctime": 1457483942}
{"tag_name": "JavaScript", "concern_user_count": 343215, "user_id": "3597257776829127", "title": "面试一定会考的css布局单位 🌲 🎁 ❄️", "mark_content": "# CSS长度单位知多少 \n\n大部分前端开发者都有靠 `px` 和 `%` 闯天下的经历，后来发现 `vw` `vh` `calc` 也是真香，尤其遇到PC端的布局适配场景堪称神器，所以把CSS的尺寸单位都拉出来看一看，在这之前要先搞明白几个概念，比如px到底是绝对单位还是相对单位？\n\n## 先了解几个概念\n\n### 分辨率\n我们把一张图片无限放大会看到很多小格子，通常把他们叫做像素格，如果有一张图片分辨率是`500*500`那说明这张图片横向和纵向都是500个像素格。对应到设备屏幕上，屏幕上的格子我们叫它像素点，比如iPhone6的分辨率是`1334*750`，说明iPhone6的屏幕上有`1334*750`个像素点。我们通常说的分辨率指的是用户设定的桌面分辨率，这和物理分辨率是有差别的，通常桌面分辨率等于物理分辨率的时候显示效果是最佳的，如果你愿意当然可以把一块`1280*768`的屏幕分辨率调成`640*384`。\n\n### 屏幕尺寸\n屏幕尺寸一般用英寸表示，英寸是长度单位不是面积单位，我们常说的某设备屏幕是5英寸指的是对角线长度是5英寸，1英寸等于2.54cm。在屏幕尺寸确定的情况下分辨率越高屏幕越清晰。\n\n### 设备像素（物理像素）\n设备像素也叫物理像素，具体指设备屏幕上的物理像素点，屏幕控制显示的最小单位，由设备屏幕决定，单位pt，设备出厂的时候设备像素就已经确定了，且永远不会改变。\n\n### 设备独立像素（DIP）\n设备独立像素是一种被程序所控制的虚拟像素，在Web开发中对应CSS像素，我们把物理像素重新排列，以固定数量的物理像素点来表示一个设备独立像素，一个设备独立像素对应CSS中的1px。\n\n> 一个单位的设备独立像素（也就是1px）表示N个物理像素，如果固定用一个设备独立像素表示一个物理像素会带来什么问题呢，假设有两块5英寸的屏幕，一块的分别率是`500*500`，另一块的分别率是`1000*1000`，因为设备独立像素和物理像素是一比一的关系当把250px的盒子渲染到屏幕上时，在`500*500`的屏幕盒子占宽度的二分之一，到了`1000*1000`的屏幕就只占到四分之一，这是完全不同的用户体验。因此我们在物理像素上抽象一个逻辑层，以固定数量的物理像素来表示一个设备独立像素，重新构成页面渲染的像素点。至于多少个物理像素对应一个设备独立像素就需要引入另外一个概念设备像素比(DPR)后面会讲到。\n\n### 设备像素比（DPR）\n设备像素比 = 物理像素 / 设备独立像素 （可以通过JS来获取设备像素比 window.devicePixelRatio）\n\n设备像素比主要用来告诉屏幕1设备独立像素（也就是CSS里的1px）对应在显示器上渲染几个物理像素，当前设备的设备像素比可以用`window.devicePixelRatio`命令查看得到，如果DPR为2，即1设备独立像素包含2个物理像素。这样我们用CSS设置的1px，不论在什么设备上显示的都是1px，但是这个1px对应的物理像素是不确定的。\n\nDPR并不是开发者控制的，是厂商决定的，这里要引入另外一个概念屏幕像素密度(PPI)后面会讲到，每个固定范围内的PPI会对应一个固定的DPR值（如下表），这也导致了CSS设置的100px在不同屏幕上显示的物理长度会有细微差距。**总的来说屏幕像素密度(PPI)越大，设备独立像素对应的物理像素越多，屏幕越清晰。**\n\n以iPhone6为例，厂商给出的分辨率(也就是物理像素)是`1334*750`，DPR是2，我们可以计算得到它的设备独立像素是`667*375`，也就是Chrome手机模拟器显示的`667*375`。iPhoneX分辨率是`2436*1125`，DPR是3，设备独立像素是`812*375`。\n\n> 我们在PC浏览器上按 `Ctrl + 加号` 键，改变的就是设备像素比（DPR），可以`console.log(window.devicePixelRatio)`看一下，DPR变大了，一个设备独立像素(CSS的px)对应的物理像素变多了，所以视觉上页面变大了。\n\n### 屏幕像素密度（PPI）\n屏幕像素密度 = 物理像素 / 屏幕尺寸\n\n屏幕像素密度（PPI）指的是每英寸屏幕所拥有的物理像素数量，屏幕像素密度强调的是每英寸有多少像素点。是衡量设备清晰度的关节指标，乔布斯定义PPI300以上称为视网膜级别，Retina视网膜设备的DPR是2或者3，在开发的过程中就用到了2倍图或者3倍图。下面表格列出了PPI和DPR之间的大致关系。 \n\n|        |       |      |      |      |\n| -------| ----- | ---- | ---- | ---- |\n| PPI 区间 | 120-160 | 160-240 | 240-320 | 320+ |\n| DPR 值 | 0.75 | 1 | 1.5 | 2 |\n\n### 打印机（DPI）\n打印机的墨点，不多做介绍。\n\n\n## CSS长度单位\nCSS中长度单位分为两类 **绝对单位**、**相对单位**，看下W3C对绝对单位和相对单位的定义。\n> **绝对单位：**绝对长度单位是一个固定的值，它反应一个真实的物理尺寸。   \n**相对单位：**相对长度单位中的相对二字，表明了其长度单位会随着它的参考值的变化而变化，不是固定的。\n\n### 绝对单位\n\n  - in（英寸）\n  - cm（厘米）\n  - mm（毫米）\n  - pt（points）\n  - pc（Picas）\n\n1in = 2.54cm = 25.4 mm = 72pt = 6pc\n\n绝对单位是固定不变的，有一个固定的物理长度，相互之间有清晰的换算关系，最终在页面渲染时会转换成px，绝对单位常用在印刷打印方向。\n\n对前端开发者来说绝对单位用的最多的也就是mm和cm了，做打印表单业务的时候把页面宽度设置成210mm，这样用户的预览体验和真实打印效果最接近。\n\n\n### 相对单位\n\n  - px 像素\n  - vw 视窗宽度\n  - vh 视窗高度\n  - vmin 取视窗宽高较小值\n  - vmax 取视窗宽高较大值\n  - ex 元素内字符x的高度\n  - ch 元素内数字0的宽度\n  - em 元素字体高度\n  - rem 根元素fontSize\n  - % 百分比\n\n<span style=\"background: pink; padding: 5px\">px</span>   \npx是相对单位，因为1px在不同设备上渲染的物理像素数量不一致，不同设备上一个物理像素的大小也不一致。为保证阅读体验一致，CSS的px 相对 物理像素 是动态的，px和物理像素之间的关系根据设备像素比（DPR）确定。\n\n有了对上文概念的认识，再来理解CSS的px就容易许多了，我们以 iPhone3gs（480x320）和 4s（960x640）来举例，他俩屏幕尺寸都是3.5英寸，分辨率差了一倍，如果DPR为1在4s上面渲染出来元素会偏小，就像下面这张图所示。但在实际渲染中4s的DPR为2，也就意味着1px会渲染两个物理像素，元素放大了且页面看起来会更加清晰。同时在头像区域就需要提供2倍图，把资源命名成带@2x格式，使用的时候iOS会自己识别，如果不提供2倍图使用1倍图就会放大一倍显示，必然失真。\n\n![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c05118edf6d344d1a37a21bd41c7d9df~tplv-k3u1fbpfcp-zoom-1.image)\n\n\n<span style=\"background: pink; padding: 5px\">vw</span>   \n视窗宽度，1vw表示视窗宽度的1%，响应单位，物理长度会随视窗宽度变化而变化。\n\n<span style=\"background: pink; padding: 5px\">vh</span>   \n视窗高度，1vh表示视窗高度的1%，响应单位，物理长度会随视窗高度变化而变化。\n\n<span style=\"background: pink; padding: 5px\">vmin</span>   \nvmin取视窗宽度高度两者更小者，1vmin表示视窗宽度高度两者更小者的1%。\n\n<span style=\"background: pink; padding: 5px\">vmax</span>   \nvmax取视窗宽度高度两者更大者，1vmax表示视窗宽度高度两者更大者的1%。\n\nvw、vh、vmin、vmax 这几个单位还是比较实用的，当做一些PC的响应式布局时经常会用到%，但%是基于父元素的，极端情况下父元素可能没有撑开，这时候就得一层一层的去检查，撑开相应的父级，或者做宽高都是100%屏幕的大屏展示系统这种情况用vw、vh都是很合适的。\n\n<span style=\"background: pink; padding: 5px\">ex</span>   \nex表示元素内字符x的高度，一个小写字母，比如“d”，它会有一部分高出来，ex不包括高出来的这一部分的。\n\n<span style=\"background: pink; padding: 5px\">ch</span>   \nch表示元素内数字0的宽度\n\n<span style=\"background: pink; padding: 5px\">em</span>   \nem表示当前元素font-size的大小，现代所有的浏览器中，都会有一个默认值，即1em = 16px。\n\n值得注意的一点是影响em变化的因素只有font-size，而影响 ex、ch 变化的因素除font-size外还有font-family，因为font-family的改变也会使得x或者0字符的大小发生变化。\n\nem有继承的特性也就是级联效果，如果当前元素未设置font-size它会继承父元素的font-size，看下面的效果：\n```\n<div style=\"font-size: 12px\">\n  font-size：12px\n  <div style=\"font-size: 1.2em\">\n    font-size：12 * 1.2 = 14.4px\n    <div style=\"font-size: 1.2em\">\n      font-size：12 * 1.2 * 1.2 = 17.28px\n    </div>\n  </div>\n</div>\n```\n\n举一个实际项目中的例子，之前搞富文本编辑器需要控制字体大小，我定义了四种规格分别是 Small、Normal、Large、Huge，父级容器font-size默认是Normal规格设置为16px，剩下的分别是Small0.8em、Large1.2em、Huge1.8em，这样我们调整了父容器的font-size值之后其他规格的字体都会跟着发生变化。\n\n<span style=\"background: pink; padding: 5px\">rem</span>   \nrem（root em），相对根元素的font-size是动态的，和当前元素无关，当浏览器解析HTML元素时，会将页面渲染成一个树形结构，`<html>`节点是最外层的父元素（根节点），rem表示html节点的font-size大小，当根元素未设置font-size值时，默认取16px。\n\n> 有一个特别的伪类 :root 可以直接选中根节点html，和通过html选择器选中html节点没有任何区别\n\n\n## rem如何使用\nrem只是开发者工具箱中的一个工具并不是万能的，一般使用在移动端的响应式布局上，常用来设置字体大小以及部分容器的宽高，边框则用px，容器的布局有时用百分比也能很好解决，rem并不是万能的。\n\n移动端在开始布局之前需要先设置meta标签，来指定默认的缩放比，以及是否允许用户缩放。\n```\n<meta name=\"viewport\" content=\"width=device-width, initial-scale=1, minimum-scale=1, maximum-scale=1.0, user-scalable=no, viewport-fit=cover\">\n```\n  - **content=\"width=device-width**  内容的宽度设置为设备宽度\n  - **user-scalable=no\"**  是否允许用户进行缩放\n  - **initial-scale=1**  设置页面的初始缩放值\n  - **minimum-scale=1**  允许用户的最小缩放值\n  - **maximum-scale=1**  允许用户的最大缩放值\n\n\n### 设置基准值法\n设计师一般以iPhone6的二倍图出设计稿，那么设计稿的宽度就是750px，我们设置根的font-size值为 (clientWidth ÷ 7.5)px 此时可以得到下面两个式子：\n> (clientWidth ÷ 7.5)px = 1rem   \n750px ÷ 7.5 = 100px   \n\n- clientWidth是设备宽度，是一个动态的值，不管 `clientWidth ÷ 7.5` 的具体值是多少，因为设置给了根的font-size，所以都是1rem的值；\n- 因为布局是响应式的，容器的宽度占比应该保持一致，设计稿的宽度是750px，100px占设计稿的7.5分之一，在真机上也应该占7.5分之一，也就是1rem；\n\n根据上面两条规则可以得出结论设计稿的100px等于整机的1rem，在做开发的时候量出设计稿中元素的尺寸再除以100，就是css中应该设置的rem值。\n\n根font-size的设置可以用到vw `font-size: calc(100vw/7.5)`，不支持vw的设备可以配合 `document.documentElement.style.fontSize = document.documentElement.clientWidth / 7.5 + 'px'`。\n\n### 手淘flexible法\nflexible是手机淘宝团队的开源解决方案，原理大致就是以设计稿为基准，将设计稿的宽度平分为10份，把一份的宽度设置为根font-size的大小，这样1rem在真机上的宽度和设计稿十分之一的宽度占比一致，感觉上很像vw，同时flexible还支持动态生成meta标签。\n\n\n\n[flexible具体的解决方案看这篇](https://github.com/beipiaoyu2011/flexible)\n\n\n\n\n\n\n", "user_name": "船长_", "description": "浑然不知", "got_view_count": 38236, "category_name": "阅读", "ctime": 1457483895}
{"tag_name": "CSS", "concern_user_count": 258450, "user_id": "1257497033714477", "title": "CSS水平垂直居中回顾总结", "mark_content": "<section id=\"nice\" data-tool=\"mdnice编辑器\" data-website=\"https://www.mdnice.com\" style=\"font-size: 16px; padding: 0 10px; word-spacing: 0px; word-break: break-word; word-wrap: break-word; text-align: left; line-height: 1.25; color: #2b2b2b; font-family: Optima-Regular, Optima, PingFangTC-Light, PingFangSC-light, PingFangTC-light; letter-spacing: 2px; background-image: linear-gradient(90deg, rgba(50, 0, 0, 0.04) 3%, rgba(0, 0, 0, 0) 3%), linear-gradient(360deg, rgba(50, 0, 0, 0.04) 3%, rgba(0, 0, 0, 0) 3%); background-size: 20px 20px; background-position: center center;\"><h2 data-tool=\"mdnice编辑器\" style=\"margin-top: 30px; margin-bottom: 15px; padding: 0px; font-weight: bold; color: black; font-size: 22px; display: block; border-bottom: 4px solid #40B8FA;\"><span class=\"prefix\" style=\"display: flex; width: 20px; height: 20px; background-size: 20px 20px; background-image: url(https://my-wechat.mdnice.com/fullstack-1.png); margin-bottom: -22px;\"></span><span class=\"content\" style=\"display: flex; color: #40B8FA; font-size: 20px; margin-left: 25px;\">前言</span><span class=\"suffix\" style=\"display: flex; box-sizing: border-box; width: 200px; height: 10px; border-top-left-radius: 20px; background: RGBA(64, 184, 250, .5); color: rgb(255, 255, 255); font-size: 16px; letter-spacing: 0.544px; justify-content: flex-end; float: right; margin-top: -10px; box-sizing: border-box !important; overflow-wrap: break-word !important;\"></span></h2>\n<p data-tool=\"mdnice编辑器\" style=\"padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: #2b2b2b; margin: 10px 0px; letter-spacing: 2px; font-size: 14px; word-spacing: 2px;\">用了一段时间的 material-ui，都很少自己动手写原生的样式了。但html, css, js 始终是前端的三大基础，这周突然想到 CSS水平居中方案，因为用多了 <code style=\"font-size: 14px; word-wrap: break-word; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #3594F7; background: RGBA(59, 170, 250, .1); padding: 0 2px; border-radius: 2px; height: 21px; line-height: 22px;\">flex</code> 和 <code style=\"font-size: 14px; word-wrap: break-word; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #3594F7; background: RGBA(59, 170, 250, .1); padding: 0 2px; border-radius: 2px; height: 21px; line-height: 22px;\">margin: auto</code>等这类方案解决，在回顾还有还有几种方案可以解决，于是打算温故知新，重新打下代码，写下该文作为笔记。</p>\n<p data-tool=\"mdnice编辑器\" style=\"padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: #2b2b2b; margin: 10px 0px; letter-spacing: 2px; font-size: 14px; word-spacing: 2px;\">html 代码</p>\n<pre class=\"custom\" data-tool=\"mdnice编辑器\" style=\"margin-top: 10px; margin-bottom: 10px;\"><code class=\"hljs\" style=\"overflow-x: auto; padding: 16px; color: #383a42; background: #fafafa; display: -webkit-box; font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; border-radius: 0px; font-size: 12px; -webkit-overflow-scrolling: touch; letter-spacing: 0px;\"><span class=\"hljs-tag\" style=\"line-height: 26px;\">&lt;<span class=\"hljs-name\" style=\"color: #e45649; line-height: 26px;\">div</span>&nbsp;<span class=\"hljs-attr\" style=\"color: #986801; line-height: 26px;\">class</span>=<span class=\"hljs-string\" style=\"color: #50a14f; line-height: 26px;\">\"parent\"</span>&gt;</span><br>&nbsp;&nbsp;<span class=\"hljs-tag\" style=\"line-height: 26px;\">&lt;<span class=\"hljs-name\" style=\"color: #e45649; line-height: 26px;\">div</span>&nbsp;<span class=\"hljs-attr\" style=\"color: #986801; line-height: 26px;\">class</span>=<span class=\"hljs-string\" style=\"color: #50a14f; line-height: 26px;\">\"child\"</span>&gt;</span><span class=\"hljs-tag\" style=\"line-height: 26px;\">&lt;/<span class=\"hljs-name\" style=\"color: #e45649; line-height: 26px;\">div</span>&gt;</span><br><span class=\"hljs-tag\" style=\"line-height: 26px;\">&lt;/<span class=\"hljs-name\" style=\"color: #e45649; line-height: 26px;\">div</span>&gt;</span><br></code></pre>\n<p data-tool=\"mdnice编辑器\" style=\"padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: #2b2b2b; margin: 10px 0px; letter-spacing: 2px; font-size: 14px; word-spacing: 2px;\">css 代码</p>\n<pre class=\"custom\" data-tool=\"mdnice编辑器\" style=\"margin-top: 10px; margin-bottom: 10px;\"><code class=\"hljs\" style=\"overflow-x: auto; padding: 16px; color: #383a42; background: #fafafa; display: -webkit-box; font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; border-radius: 0px; font-size: 12px; -webkit-overflow-scrolling: touch; letter-spacing: 0px;\"><span class=\"hljs-selector-class\" style=\"color: #986801; line-height: 26px;\">.parent</span>&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;<span class=\"hljs-attribute\" style=\"color: #50a14f; line-height: 26px;\">width</span>:&nbsp;<span class=\"hljs-number\" style=\"color: #986801; line-height: 26px;\">300px</span>;<br>&nbsp;&nbsp;&nbsp;&nbsp;<span class=\"hljs-attribute\" style=\"color: #50a14f; line-height: 26px;\">height</span>:&nbsp;<span class=\"hljs-number\" style=\"color: #986801; line-height: 26px;\">300px</span>;<br>&nbsp;&nbsp;&nbsp;&nbsp;<span class=\"hljs-attribute\" style=\"color: #50a14f; line-height: 26px;\">background-color</span>:&nbsp;blue;<br>}<br><span class=\"hljs-selector-class\" style=\"color: #986801; line-height: 26px;\">.child</span>&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;<span class=\"hljs-attribute\" style=\"color: #50a14f; line-height: 26px;\">width</span>:&nbsp;<span class=\"hljs-number\" style=\"color: #986801; line-height: 26px;\">100px</span>;<br>&nbsp;&nbsp;&nbsp;&nbsp;<span class=\"hljs-attribute\" style=\"color: #50a14f; line-height: 26px;\">height</span>:&nbsp;<span class=\"hljs-number\" style=\"color: #986801; line-height: 26px;\">100px</span>;<br>&nbsp;&nbsp;&nbsp;&nbsp;<span class=\"hljs-attribute\" style=\"color: #50a14f; line-height: 26px;\">background-color</span>:&nbsp;red;<br>}<br></code></pre>\n<p data-tool=\"mdnice编辑器\" style=\"padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: #2b2b2b; margin: 10px 0px; letter-spacing: 2px; font-size: 14px; word-spacing: 2px;\">下面代码基于上述代码增加，不会再重复写。要实现的效果是让子元素在父元素中水平垂直居中\n<img src=\"https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1d9ccfcd90a64bd58de3cf3e972c5981~tplv-k3u1fbpfcp-zoom-1.image\" alt style=\"max-width: 100%; border-radius: 6px; display: block; margin: 20px auto; object-fit: contain; box-shadow: 2px 4px 7px #999;\"></p>\n<h2 data-tool=\"mdnice编辑器\" style=\"margin-top: 30px; margin-bottom: 15px; padding: 0px; font-weight: bold; color: black; font-size: 22px; display: block; border-bottom: 4px solid #40B8FA;\"><span class=\"prefix\" style=\"display: flex; width: 20px; height: 20px; background-size: 20px 20px; background-image: url(https://my-wechat.mdnice.com/fullstack-1.png); margin-bottom: -22px;\"></span><span class=\"content\" style=\"display: flex; color: #40B8FA; font-size: 20px; margin-left: 25px;\">一、flex 布局</span><span class=\"suffix\" style=\"display: flex; box-sizing: border-box; width: 200px; height: 10px; border-top-left-radius: 20px; background: RGBA(64, 184, 250, .5); color: rgb(255, 255, 255); font-size: 16px; letter-spacing: 0.544px; justify-content: flex-end; float: right; margin-top: -10px; box-sizing: border-box !important; overflow-wrap: break-word !important;\"></span></h2>\n<pre class=\"custom\" data-tool=\"mdnice编辑器\" style=\"margin-top: 10px; margin-bottom: 10px;\"><code class=\"hljs\" style=\"overflow-x: auto; padding: 16px; color: #383a42; background: #fafafa; display: -webkit-box; font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; border-radius: 0px; font-size: 12px; -webkit-overflow-scrolling: touch; letter-spacing: 0px;\"><span class=\"hljs-selector-class\" style=\"color: #986801; line-height: 26px;\">.parent</span>&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;<span class=\"hljs-attribute\" style=\"color: #50a14f; line-height: 26px;\">display</span>:&nbsp;flex;<br>&nbsp;&nbsp;&nbsp;&nbsp;<span class=\"hljs-attribute\" style=\"color: #50a14f; line-height: 26px;\">justify-content</span>:&nbsp;center;<br>&nbsp;&nbsp;&nbsp;&nbsp;<span class=\"hljs-attribute\" style=\"color: #50a14f; line-height: 26px;\">align-items</span>:&nbsp;center;<br>}<br></code></pre>\n<p data-tool=\"mdnice编辑器\" style=\"padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: #2b2b2b; margin: 10px 0px; letter-spacing: 2px; font-size: 14px; word-spacing: 2px;\">这是最经典的用法了，不过，也可以有另一种写法实现：</p>\n<pre class=\"custom\" data-tool=\"mdnice编辑器\" style=\"margin-top: 10px; margin-bottom: 10px;\"><code class=\"hljs\" style=\"overflow-x: auto; padding: 16px; color: #383a42; background: #fafafa; display: -webkit-box; font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; border-radius: 0px; font-size: 12px; -webkit-overflow-scrolling: touch; letter-spacing: 0px;\">.parent&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;display:&nbsp;flex;<br>}<br>.child&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;align-self:&nbsp;center;<br>&nbsp;&nbsp;&nbsp;&nbsp;margin:&nbsp;auto;<br>}<br></code></pre>\n<h2 data-tool=\"mdnice编辑器\" style=\"margin-top: 30px; margin-bottom: 15px; padding: 0px; font-weight: bold; color: black; font-size: 22px; display: block; border-bottom: 4px solid #40B8FA;\"><span class=\"prefix\" style=\"display: flex; width: 20px; height: 20px; background-size: 20px 20px; background-image: url(https://my-wechat.mdnice.com/fullstack-1.png); margin-bottom: -22px;\"></span><span class=\"content\" style=\"display: flex; color: #40B8FA; font-size: 20px; margin-left: 25px;\">二、absolute + 负 margin</span><span class=\"suffix\" style=\"display: flex; box-sizing: border-box; width: 200px; height: 10px; border-top-left-radius: 20px; background: RGBA(64, 184, 250, .5); color: rgb(255, 255, 255); font-size: 16px; letter-spacing: 0.544px; justify-content: flex-end; float: right; margin-top: -10px; box-sizing: border-box !important; overflow-wrap: break-word !important;\"></span></h2>\n<p data-tool=\"mdnice编辑器\" style=\"padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: #2b2b2b; margin: 10px 0px; letter-spacing: 2px; font-size: 14px; word-spacing: 2px;\">该方法适用于知道固定宽高的情况。</p>\n<pre class=\"custom\" data-tool=\"mdnice编辑器\" style=\"margin-top: 10px; margin-bottom: 10px;\"><code class=\"hljs\" style=\"overflow-x: auto; padding: 16px; color: #383a42; background: #fafafa; display: -webkit-box; font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; border-radius: 0px; font-size: 12px; -webkit-overflow-scrolling: touch; letter-spacing: 0px;\"><span class=\"hljs-selector-class\" style=\"color: #986801; line-height: 26px;\">.parent</span>&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;<span class=\"hljs-attribute\" style=\"color: #50a14f; line-height: 26px;\">position</span>:&nbsp;relative;<br>}<br><span class=\"hljs-selector-class\" style=\"color: #986801; line-height: 26px;\">.child</span>&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;<span class=\"hljs-attribute\" style=\"color: #50a14f; line-height: 26px;\">position</span>:&nbsp;absolute;<br>&nbsp;&nbsp;&nbsp;&nbsp;<span class=\"hljs-attribute\" style=\"color: #50a14f; line-height: 26px;\">top</span>:&nbsp;<span class=\"hljs-number\" style=\"color: #986801; line-height: 26px;\">50%</span>;<br>&nbsp;&nbsp;&nbsp;&nbsp;<span class=\"hljs-attribute\" style=\"color: #50a14f; line-height: 26px;\">left</span>:&nbsp;<span class=\"hljs-number\" style=\"color: #986801; line-height: 26px;\">50%</span>;<br>&nbsp;&nbsp;&nbsp;&nbsp;<span class=\"hljs-attribute\" style=\"color: #50a14f; line-height: 26px;\">margin-top</span>:&nbsp;-<span class=\"hljs-number\" style=\"color: #986801; line-height: 26px;\">50px</span>;<br>&nbsp;&nbsp;&nbsp;&nbsp;<span class=\"hljs-attribute\" style=\"color: #50a14f; line-height: 26px;\">margin-left</span>:&nbsp;-<span class=\"hljs-number\" style=\"color: #986801; line-height: 26px;\">50px</span>;<br>}<br></code></pre>\n<h2 data-tool=\"mdnice编辑器\" style=\"margin-top: 30px; margin-bottom: 15px; padding: 0px; font-weight: bold; color: black; font-size: 22px; display: block; border-bottom: 4px solid #40B8FA;\"><span class=\"prefix\" style=\"display: flex; width: 20px; height: 20px; background-size: 20px 20px; background-image: url(https://my-wechat.mdnice.com/fullstack-1.png); margin-bottom: -22px;\"></span><span class=\"content\" style=\"display: flex; color: #40B8FA; font-size: 20px; margin-left: 25px;\">三、absolute + transform</span><span class=\"suffix\" style=\"display: flex; box-sizing: border-box; width: 200px; height: 10px; border-top-left-radius: 20px; background: RGBA(64, 184, 250, .5); color: rgb(255, 255, 255); font-size: 16px; letter-spacing: 0.544px; justify-content: flex-end; float: right; margin-top: -10px; box-sizing: border-box !important; overflow-wrap: break-word !important;\"></span></h2>\n<pre class=\"custom\" data-tool=\"mdnice编辑器\" style=\"margin-top: 10px; margin-bottom: 10px;\"><code class=\"hljs\" style=\"overflow-x: auto; padding: 16px; color: #383a42; background: #fafafa; display: -webkit-box; font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; border-radius: 0px; font-size: 12px; -webkit-overflow-scrolling: touch; letter-spacing: 0px;\"><span class=\"hljs-selector-class\" style=\"color: #986801; line-height: 26px;\">.parent</span>&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;<span class=\"hljs-attribute\" style=\"color: #50a14f; line-height: 26px;\">position</span>:&nbsp;relative;<br>}<br><span class=\"hljs-selector-class\" style=\"color: #986801; line-height: 26px;\">.child</span>&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;<span class=\"hljs-attribute\" style=\"color: #50a14f; line-height: 26px;\">position</span>:&nbsp;absolute;<br>&nbsp;&nbsp;&nbsp;&nbsp;<span class=\"hljs-attribute\" style=\"color: #50a14f; line-height: 26px;\">top</span>:&nbsp;<span class=\"hljs-number\" style=\"color: #986801; line-height: 26px;\">50%</span>;<br>&nbsp;&nbsp;&nbsp;&nbsp;<span class=\"hljs-attribute\" style=\"color: #50a14f; line-height: 26px;\">left</span>:&nbsp;<span class=\"hljs-number\" style=\"color: #986801; line-height: 26px;\">50%</span>;<br>&nbsp;&nbsp;&nbsp;&nbsp;<span class=\"hljs-attribute\" style=\"color: #50a14f; line-height: 26px;\">transform</span>:&nbsp;<span class=\"hljs-built_in\" style=\"color: #c18401; line-height: 26px;\">translate</span>(-50%,&nbsp;-50%);<br>}<br></code></pre>\n<h2 data-tool=\"mdnice编辑器\" style=\"margin-top: 30px; margin-bottom: 15px; padding: 0px; font-weight: bold; color: black; font-size: 22px; display: block; border-bottom: 4px solid #40B8FA;\"><span class=\"prefix\" style=\"display: flex; width: 20px; height: 20px; background-size: 20px 20px; background-image: url(https://my-wechat.mdnice.com/fullstack-1.png); margin-bottom: -22px;\"></span><span class=\"content\" style=\"display: flex; color: #40B8FA; font-size: 20px; margin-left: 25px;\">四、absolute + margin auto</span><span class=\"suffix\" style=\"display: flex; box-sizing: border-box; width: 200px; height: 10px; border-top-left-radius: 20px; background: RGBA(64, 184, 250, .5); color: rgb(255, 255, 255); font-size: 16px; letter-spacing: 0.544px; justify-content: flex-end; float: right; margin-top: -10px; box-sizing: border-box !important; overflow-wrap: break-word !important;\"></span></h2>\n<pre class=\"custom\" data-tool=\"mdnice编辑器\" style=\"margin-top: 10px; margin-bottom: 10px;\"><code class=\"hljs\" style=\"overflow-x: auto; padding: 16px; color: #383a42; background: #fafafa; display: -webkit-box; font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; border-radius: 0px; font-size: 12px; -webkit-overflow-scrolling: touch; letter-spacing: 0px;\"><span class=\"hljs-selector-class\" style=\"color: #986801; line-height: 26px;\">.parent</span>&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;<span class=\"hljs-attribute\" style=\"color: #50a14f; line-height: 26px;\">position</span>:&nbsp;relative;<br>}<br><span class=\"hljs-selector-class\" style=\"color: #986801; line-height: 26px;\">.child</span>&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;<span class=\"hljs-attribute\" style=\"color: #50a14f; line-height: 26px;\">position</span>:&nbsp;absolute;<br>&nbsp;&nbsp;&nbsp;&nbsp;<span class=\"hljs-attribute\" style=\"color: #50a14f; line-height: 26px;\">top</span>:&nbsp;<span class=\"hljs-number\" style=\"color: #986801; line-height: 26px;\">0</span>;<br>&nbsp;&nbsp;&nbsp;&nbsp;<span class=\"hljs-attribute\" style=\"color: #50a14f; line-height: 26px;\">left</span>:&nbsp;<span class=\"hljs-number\" style=\"color: #986801; line-height: 26px;\">0</span>;<br>&nbsp;&nbsp;&nbsp;&nbsp;<span class=\"hljs-attribute\" style=\"color: #50a14f; line-height: 26px;\">right</span>:&nbsp;<span class=\"hljs-number\" style=\"color: #986801; line-height: 26px;\">0</span>;<br>&nbsp;&nbsp;&nbsp;&nbsp;<span class=\"hljs-attribute\" style=\"color: #50a14f; line-height: 26px;\">bottom</span>:&nbsp;<span class=\"hljs-number\" style=\"color: #986801; line-height: 26px;\">0</span>;<br>&nbsp;&nbsp;&nbsp;&nbsp;<span class=\"hljs-attribute\" style=\"color: #50a14f; line-height: 26px;\">margin</span>:&nbsp;auto;<br>}<br></code></pre>\n<h2 data-tool=\"mdnice编辑器\" style=\"margin-top: 30px; margin-bottom: 15px; padding: 0px; font-weight: bold; color: black; font-size: 22px; display: block; border-bottom: 4px solid #40B8FA;\"><span class=\"prefix\" style=\"display: flex; width: 20px; height: 20px; background-size: 20px 20px; background-image: url(https://my-wechat.mdnice.com/fullstack-1.png); margin-bottom: -22px;\"></span><span class=\"content\" style=\"display: flex; color: #40B8FA; font-size: 20px; margin-left: 25px;\">五、absolute + calc</span><span class=\"suffix\" style=\"display: flex; box-sizing: border-box; width: 200px; height: 10px; border-top-left-radius: 20px; background: RGBA(64, 184, 250, .5); color: rgb(255, 255, 255); font-size: 16px; letter-spacing: 0.544px; justify-content: flex-end; float: right; margin-top: -10px; box-sizing: border-box !important; overflow-wrap: break-word !important;\"></span></h2>\n<p data-tool=\"mdnice编辑器\" style=\"padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: #2b2b2b; margin: 10px 0px; letter-spacing: 2px; font-size: 14px; word-spacing: 2px;\">该方法适用于知道固定宽高的情况。</p>\n<pre class=\"custom\" data-tool=\"mdnice编辑器\" style=\"margin-top: 10px; margin-bottom: 10px;\"><code class=\"hljs\" style=\"overflow-x: auto; padding: 16px; color: #383a42; background: #fafafa; display: -webkit-box; font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; border-radius: 0px; font-size: 12px; -webkit-overflow-scrolling: touch; letter-spacing: 0px;\"><span class=\"hljs-selector-class\" style=\"color: #986801; line-height: 26px;\">.parent</span>&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;<span class=\"hljs-attribute\" style=\"color: #50a14f; line-height: 26px;\">position</span>:&nbsp;relative;<br>}<br><span class=\"hljs-selector-class\" style=\"color: #986801; line-height: 26px;\">.child</span>&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;<span class=\"hljs-attribute\" style=\"color: #50a14f; line-height: 26px;\">position</span>:&nbsp;absolute;<br>&nbsp;&nbsp;&nbsp;&nbsp;<span class=\"hljs-attribute\" style=\"color: #50a14f; line-height: 26px;\">top</span>:&nbsp;<span class=\"hljs-built_in\" style=\"color: #c18401; line-height: 26px;\">calc</span>(50%&nbsp;-&nbsp;50px);<br>&nbsp;&nbsp;&nbsp;&nbsp;<span class=\"hljs-attribute\" style=\"color: #50a14f; line-height: 26px;\">left</span>:&nbsp;<span class=\"hljs-built_in\" style=\"color: #c18401; line-height: 26px;\">calc</span>(50%&nbsp;-&nbsp;50px);<br>}<br></code></pre>\n<h2 data-tool=\"mdnice编辑器\" style=\"margin-top: 30px; margin-bottom: 15px; padding: 0px; font-weight: bold; color: black; font-size: 22px; display: block; border-bottom: 4px solid #40B8FA;\"><span class=\"prefix\" style=\"display: flex; width: 20px; height: 20px; background-size: 20px 20px; background-image: url(https://my-wechat.mdnice.com/fullstack-1.png); margin-bottom: -22px;\"></span><span class=\"content\" style=\"display: flex; color: #40B8FA; font-size: 20px; margin-left: 25px;\">六、text-align + vertical-align</span><span class=\"suffix\" style=\"display: flex; box-sizing: border-box; width: 200px; height: 10px; border-top-left-radius: 20px; background: RGBA(64, 184, 250, .5); color: rgb(255, 255, 255); font-size: 16px; letter-spacing: 0.544px; justify-content: flex-end; float: right; margin-top: -10px; box-sizing: border-box !important; overflow-wrap: break-word !important;\"></span></h2>\n<pre class=\"custom\" data-tool=\"mdnice编辑器\" style=\"margin-top: 10px; margin-bottom: 10px;\"><code class=\"hljs\" style=\"overflow-x: auto; padding: 16px; color: #383a42; background: #fafafa; display: -webkit-box; font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; border-radius: 0px; font-size: 12px; -webkit-overflow-scrolling: touch; letter-spacing: 0px;\"><span class=\"hljs-selector-class\" style=\"color: #986801; line-height: 26px;\">.parent</span>&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;<span class=\"hljs-attribute\" style=\"color: #50a14f; line-height: 26px;\">text-align</span>:&nbsp;center;<br>&nbsp;&nbsp;&nbsp;&nbsp;<span class=\"hljs-attribute\" style=\"color: #50a14f; line-height: 26px;\">line-height</span>:&nbsp;<span class=\"hljs-number\" style=\"color: #986801; line-height: 26px;\">300px</span>;&nbsp;<span class=\"hljs-comment\" style=\"color: #a0a1a7; font-style: italic; line-height: 26px;\">/*&nbsp;等于&nbsp;parent&nbsp;的&nbsp;height&nbsp;*/</span><br>}<br><span class=\"hljs-selector-class\" style=\"color: #986801; line-height: 26px;\">.child</span>&nbsp;{<br>&nbsp;&nbsp;&nbsp;<span class=\"hljs-attribute\" style=\"color: #50a14f; line-height: 26px;\">display</span>:&nbsp;inline-block;<br>&nbsp;&nbsp;&nbsp;<span class=\"hljs-attribute\" style=\"color: #50a14f; line-height: 26px;\">vertical-align</span>:&nbsp;middle;<br>&nbsp;&nbsp;&nbsp;<span class=\"hljs-attribute\" style=\"color: #50a14f; line-height: 26px;\">line-height</span>:&nbsp;initial;&nbsp;<span class=\"hljs-comment\" style=\"color: #a0a1a7; font-style: italic; line-height: 26px;\">/*&nbsp;这样&nbsp;child&nbsp;内的文字就不会超出跑到下面&nbsp;*/</span><br>}<br></code></pre>\n<h2 data-tool=\"mdnice编辑器\" style=\"margin-top: 30px; margin-bottom: 15px; padding: 0px; font-weight: bold; color: black; font-size: 22px; display: block; border-bottom: 4px solid #40B8FA;\"><span class=\"prefix\" style=\"display: flex; width: 20px; height: 20px; background-size: 20px 20px; background-image: url(https://my-wechat.mdnice.com/fullstack-1.png); margin-bottom: -22px;\"></span><span class=\"content\" style=\"display: flex; color: #40B8FA; font-size: 20px; margin-left: 25px;\">七、table-cell</span><span class=\"suffix\" style=\"display: flex; box-sizing: border-box; width: 200px; height: 10px; border-top-left-radius: 20px; background: RGBA(64, 184, 250, .5); color: rgb(255, 255, 255); font-size: 16px; letter-spacing: 0.544px; justify-content: flex-end; float: right; margin-top: -10px; box-sizing: border-box !important; overflow-wrap: break-word !important;\"></span></h2>\n<pre class=\"custom\" data-tool=\"mdnice编辑器\" style=\"margin-top: 10px; margin-bottom: 10px;\"><code class=\"hljs\" style=\"overflow-x: auto; padding: 16px; color: #383a42; background: #fafafa; display: -webkit-box; font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; border-radius: 0px; font-size: 12px; -webkit-overflow-scrolling: touch; letter-spacing: 0px;\"><span class=\"hljs-selector-class\" style=\"color: #986801; line-height: 26px;\">.parent</span>&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;<span class=\"hljs-attribute\" style=\"color: #50a14f; line-height: 26px;\">display</span>:&nbsp;table-cell;<br>&nbsp;&nbsp;&nbsp;&nbsp;<span class=\"hljs-attribute\" style=\"color: #50a14f; line-height: 26px;\">text-align</span>:&nbsp;center;<br>&nbsp;&nbsp;&nbsp;&nbsp;<span class=\"hljs-attribute\" style=\"color: #50a14f; line-height: 26px;\">vertical-align</span>:&nbsp;middle;<br>}<br><span class=\"hljs-selector-class\" style=\"color: #986801; line-height: 26px;\">.child</span>&nbsp;{<br>&nbsp;&nbsp;&nbsp;<span class=\"hljs-attribute\" style=\"color: #50a14f; line-height: 26px;\">display</span>:&nbsp;inline-block;<br>}<br></code></pre>\n<h2 data-tool=\"mdnice编辑器\" style=\"margin-top: 30px; margin-bottom: 15px; padding: 0px; font-weight: bold; color: black; font-size: 22px; display: block; border-bottom: 4px solid #40B8FA;\"><span class=\"prefix\" style=\"display: flex; width: 20px; height: 20px; background-size: 20px 20px; background-image: url(https://my-wechat.mdnice.com/fullstack-1.png); margin-bottom: -22px;\"></span><span class=\"content\" style=\"display: flex; color: #40B8FA; font-size: 20px; margin-left: 25px;\">八、Grid</span><span class=\"suffix\" style=\"display: flex; box-sizing: border-box; width: 200px; height: 10px; border-top-left-radius: 20px; background: RGBA(64, 184, 250, .5); color: rgb(255, 255, 255); font-size: 16px; letter-spacing: 0.544px; justify-content: flex-end; float: right; margin-top: -10px; box-sizing: border-box !important; overflow-wrap: break-word !important;\"></span></h2>\n<pre class=\"custom\" data-tool=\"mdnice编辑器\" style=\"margin-top: 10px; margin-bottom: 10px;\"><code class=\"hljs\" style=\"overflow-x: auto; padding: 16px; color: #383a42; background: #fafafa; display: -webkit-box; font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; border-radius: 0px; font-size: 12px; -webkit-overflow-scrolling: touch; letter-spacing: 0px;\"><span class=\"hljs-selector-class\" style=\"color: #986801; line-height: 26px;\">.parent</span>&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;<span class=\"hljs-attribute\" style=\"color: #50a14f; line-height: 26px;\">display</span>:&nbsp;grid;<br>}<br><span class=\"hljs-selector-class\" style=\"color: #986801; line-height: 26px;\">.child</span>&nbsp;{<br>&nbsp;&nbsp;&nbsp;<span class=\"hljs-attribute\" style=\"color: #50a14f; line-height: 26px;\">align-self</span>:&nbsp;center;<br>&nbsp;&nbsp;&nbsp;<span class=\"hljs-attribute\" style=\"color: #50a14f; line-height: 26px;\">justify-self</span>:&nbsp;center;<br>}<br></code></pre>\n<h2 data-tool=\"mdnice编辑器\" style=\"margin-top: 30px; margin-bottom: 15px; padding: 0px; font-weight: bold; color: black; font-size: 22px; display: block; border-bottom: 4px solid #40B8FA;\"><span class=\"prefix\" style=\"display: flex; width: 20px; height: 20px; background-size: 20px 20px; background-image: url(https://my-wechat.mdnice.com/fullstack-1.png); margin-bottom: -22px;\"></span><span class=\"content\" style=\"display: flex; color: #40B8FA; font-size: 20px; margin-left: 25px;\">九、writing-mode</span><span class=\"suffix\" style=\"display: flex; box-sizing: border-box; width: 200px; height: 10px; border-top-left-radius: 20px; background: RGBA(64, 184, 250, .5); color: rgb(255, 255, 255); font-size: 16px; letter-spacing: 0.544px; justify-content: flex-end; float: right; margin-top: -10px; box-sizing: border-box !important; overflow-wrap: break-word !important;\"></span></h2>\n<pre class=\"custom\" data-tool=\"mdnice编辑器\" style=\"margin-top: 10px; margin-bottom: 10px;\"><code class=\"hljs\" style=\"overflow-x: auto; padding: 16px; color: #383a42; background: #fafafa; display: -webkit-box; font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; border-radius: 0px; font-size: 12px; -webkit-overflow-scrolling: touch; letter-spacing: 0px;\"><span class=\"hljs-selector-class\" style=\"color: #986801; line-height: 26px;\">.parent</span>&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;<span class=\"hljs-attribute\" style=\"color: #50a14f; line-height: 26px;\">writing-mode</span>:&nbsp;vertical-lr;<br>&nbsp;&nbsp;&nbsp;&nbsp;<span class=\"hljs-attribute\" style=\"color: #50a14f; line-height: 26px;\">text-align</span>:&nbsp;center;<br>}<br><span class=\"hljs-selector-class\" style=\"color: #986801; line-height: 26px;\">.child</span>&nbsp;{<br>&nbsp;&nbsp;&nbsp;<span class=\"hljs-attribute\" style=\"color: #50a14f; line-height: 26px;\">writing-mode</span>:&nbsp;horizontal-tb;<br>&nbsp;&nbsp;&nbsp;<span class=\"hljs-attribute\" style=\"color: #50a14f; line-height: 26px;\">display</span>:&nbsp;inline-block;<br>&nbsp;&nbsp;&nbsp;<span class=\"hljs-attribute\" style=\"color: #50a14f; line-height: 26px;\">margin</span>:&nbsp;<span class=\"hljs-number\" style=\"color: #986801; line-height: 26px;\">0</span>&nbsp;<span class=\"hljs-built_in\" style=\"color: #c18401; line-height: 26px;\">calc</span>(50%&nbsp;-&nbsp;50px);<br>}<br></code></pre>\n<br data-tool=\"mdnice编辑器\">\n<ul data-tool=\"mdnice编辑器\" style=\"margin-top: 8px; margin-bottom: 8px; padding-left: 25px; font-size: 15px; color: #595959; list-style-type: circle;\">\n<li><section style=\"margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; font-size: 14px; font-weight: normal; color: #595959;\">ps： <a href=\"https://github.com/Jacky-Summer/personal-blog\" style=\"text-decoration: none; word-wrap: break-word; color: #40B8FA; font-weight: normal; border-bottom: 1px solid #3BAAFA;\">个人技术博文Github仓库</a>，觉得不错的话欢迎star，给我一点鼓励吧~</section></li></ul>\n</section>", "user_name": "JackySummer", "description": "前端路上，不停努力", "got_view_count": 25603, "category_name": "前端", "ctime": 1457483942}
{"tag_name": "Vue.js", "concern_user_count": 263220, "user_id": "3298190611191576", "title": "报告老板，我们的H5页面在iOS11系统上白屏了！", "mark_content": "<section id=\"nice\" data-tool=\"mdnice编辑器\" data-website=\"https://www.mdnice.com\" style=\"font-size: 16px; color: black; padding: 0 10px; line-height: 1.6; word-spacing: 0px; letter-spacing: 0px; word-break: break-word; word-wrap: break-word; text-align: left; font-family: Optima-Regular, Optima, PingFangSC-light, PingFangTC-light, 'PingFang SC', Cambria, Cochin, Georgia, Times, 'Times New Roman', serif;\"><p data-tool=\"mdnice编辑器\" style=\"font-size: 16px; padding-top: 8px; padding-bottom: 8px; margin: 0; line-height: 26px; color: black;\">时间回到一周前，当时刚开发完公司A项目的一个新的版本，等待着测试完成就进行发布。此时的我也准备从连续多日的紧张开发状态中走出来，以为可以稍稍放松一下。而那时的我还不知道，<strong style=\"font-weight: bold; color: black;\">我即将面临一个强大的Bug选手，更不知道我要跟这个Bug来来回回进行多次的搏斗</strong>。当然，我们能看到这篇文章也就说明了我最终解决了这个Bug，而且这个过程也是相当的精彩的。什么？你不相信，那就让我来带你进入这个“跌宕起伏”的经历中吧。</p>\n<p data-tool=\"mdnice编辑器\" style=\"font-size: 16px; padding-top: 8px; padding-bottom: 8px; margin: 0; line-height: 26px; color: black;\"><strong style=\"font-weight: bold; color: black;\">友情提示</strong>：接下来的文章也许有一点长，但是希望你能够坚持读下去。我相信我在解决这个Bug的过程中的一些思路会给你带来一些思考。<strong style=\"font-weight: bold; color: black;\">当然也希望你在这个过程中能够像我一样学习到一些新的知识，为以后排查类似的Bug积累一些经验</strong>。好啦，话不多说，让我们开始吧。</p>\n<h2 data-tool=\"mdnice编辑器\" style=\"margin-top: 30px; margin-bottom: 15px; padding: 0px; font-weight: bold; color: black; border-bottom: 2px solid rgb(239, 112, 96); font-size: 1.3em;\"><span class=\"prefix\" style=\"display: none;\"></span><span class=\"content\" style=\"display: inline-block; font-weight: bold; background: rgb(239, 112, 96); color: #ffffff; padding: 3px 10px 1px; border-top-right-radius: 3px; border-top-left-radius: 3px; margin-right: 3px;\">项目介绍</span><span class=\"suffix\"></span><span style=\"display: inline-block; vertical-align: bottom; border-bottom: 36px solid #efebe9; border-right: 20px solid transparent;\"> </span></h2>\n<p data-tool=\"mdnice编辑器\" style=\"font-size: 16px; padding-top: 8px; padding-bottom: 8px; margin: 0; line-height: 26px; color: black;\">先来简单介绍一下A项目，这是一个基于<code style=\"font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: rgb(239, 112, 96);\">Vue</code>框架的项目，项目使用的也是<code style=\"font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: rgb(239, 112, 96);\">Vue CLI</code>这个开发工具。这个项目是需要集成在别的APP中的，也就是页面需要在APP中进浏览和操作。这个项目在我接手之前已经开发过一段时间了。<strong style=\"font-weight: bold; color: black;\">所以项目中的一些依赖库和工具库版本相对比较低，这也给我后续的调试以及解决Bug的过程增加了一些困难。</strong></p>\n<h2 data-tool=\"mdnice编辑器\" style=\"margin-top: 30px; margin-bottom: 15px; padding: 0px; font-weight: bold; color: black; border-bottom: 2px solid rgb(239, 112, 96); font-size: 1.3em;\"><span class=\"prefix\" style=\"display: none;\"></span><span class=\"content\" style=\"display: inline-block; font-weight: bold; background: rgb(239, 112, 96); color: #ffffff; padding: 3px 10px 1px; border-top-right-radius: 3px; border-top-left-radius: 3px; margin-right: 3px;\">BUG初现</span><span class=\"suffix\"></span><span style=\"display: inline-block; vertical-align: bottom; border-bottom: 36px solid #efebe9; border-right: 20px solid transparent;\"> </span></h2>\n<p data-tool=\"mdnice编辑器\" style=\"font-size: 16px; padding-top: 8px; padding-bottom: 8px; margin: 0; line-height: 26px; color: black;\">当时开发完成之后，就交给我们这边的测试和另一个城市的相关同学去验收这次开发的功能。在我们这边一切都很正常，测试这边也没有反馈有什么问题。但是在另一个城市的同学小C的iPhone手机上却发现了<strong style=\"font-weight: bold; color: black;\">白屏</strong>，打开页面之后什么内容也没有。</p>\n<p data-tool=\"mdnice编辑器\" style=\"font-size: 16px; padding-top: 8px; padding-bottom: 8px; margin: 0; line-height: 26px; color: black;\">发现了这个问题之后，我再次跟我们这边的测试同学确认了一下，看看我们这边测试的iOS系统的iPhone手机有没有这个问题。经过测试的测试，发现我们这边的几台iPhone手机都没有问题。然后就问了小C他使用的测试手机的系统版本是多少，当时感觉应该跟<code style=\"font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: rgb(239, 112, 96);\">iOS</code>的系统版本有关系。</p>\n<p data-tool=\"mdnice编辑器\" style=\"font-size: 16px; padding-top: 8px; padding-bottom: 8px; margin: 0; line-height: 26px; color: black;\">小C反馈说他的iPhone是<code style=\"font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: rgb(239, 112, 96);\">6S Plus</code>，然后系统的版本是<code style=\"font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: rgb(239, 112, 96);\">11.1.2</code>。我问了我们这边测试使用的iPhone版本都是多少，测试反馈说系统的版本都是<code style=\"font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: rgb(239, 112, 96);\">12</code>以上的。所以到这里，<strong style=\"font-weight: bold; color: black;\">我确定了这个白屏Bug的出现肯定跟iPhone手机的系统有关系</strong>。</p>\n<h2 data-tool=\"mdnice编辑器\" style=\"margin-top: 30px; margin-bottom: 15px; padding: 0px; font-weight: bold; color: black; border-bottom: 2px solid rgb(239, 112, 96); font-size: 1.3em;\"><span class=\"prefix\" style=\"display: none;\"></span><span class=\"content\" style=\"display: inline-block; font-weight: bold; background: rgb(239, 112, 96); color: #ffffff; padding: 3px 10px 1px; border-top-right-radius: 3px; border-top-left-radius: 3px; margin-right: 3px;\">重现BUG之路</span><span class=\"suffix\"></span><span style=\"display: inline-block; vertical-align: bottom; border-bottom: 36px solid #efebe9; border-right: 20px solid transparent;\"> </span></h2>\n<p data-tool=\"mdnice编辑器\" style=\"font-size: 16px; padding-top: 8px; padding-bottom: 8px; margin: 0; line-height: 26px; color: black;\">虽然确定了问题出现的环境，但是因为我身边没有系统是<code style=\"font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: rgb(239, 112, 96);\">11</code>的iPhone手机，所以想让这个问题重现就变成了一个难题。询问了身边的同事，大家的系统版本也都普遍高于<code style=\"font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: rgb(239, 112, 96);\">12</code>，所以借用别人的手机进行调试这个方法暂时也不可行。</p>\n<p data-tool=\"mdnice编辑器\" style=\"font-size: 16px; padding-top: 8px; padding-bottom: 8px; margin: 0; line-height: 26px; color: black;\">在平时的开发中，如果网页在<code style=\"font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: rgb(239, 112, 96);\">iOS</code>系统的APP中有一些问题的话，我们一般都会通过<code style=\"font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: rgb(239, 112, 96);\">Safari</code>浏览器进行调试。但是因为这次出现问题的iPhone手机不在我这里，并且我这边也没有相同系统的手机。所以想通过真机进行调试就不太可能了。那怎么办呢？这个问题肯定是要解决的，<strong style=\"font-weight: bold; color: black;\">我也相信办法总比困难多</strong>。</p>\n<p data-tool=\"mdnice编辑器\" style=\"font-size: 16px; padding-top: 8px; padding-bottom: 8px; margin: 0; line-height: 26px; color: black;\">想要进行调试，最简单的办法就是让我有一个系统是<code style=\"font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: rgb(239, 112, 96);\">11</code>的iPhone手机。所以我就搜索看看有没有什么办法可以给iPhone手机安装<code style=\"font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: rgb(239, 112, 96);\">11</code>的系统。一搜索还真的有，过程也不算是很复杂。但是其中有一个步骤是需要到一些论坛或者第三方的助手网站下载跟自己手机型号相匹配的<code style=\"font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: rgb(239, 112, 96);\">iOS</code>系统，这个步骤让我有点感觉不安全。<strong style=\"font-weight: bold; color: black;\">毕竟不是官方的，不能够保证安全性。而且也未必有版本是<code style=\"font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: rgb(239, 112, 96);\">11</code>的系统。所以这个方案就暂时作罢</strong>。</p>\n<p data-tool=\"mdnice编辑器\" style=\"font-size: 16px; padding-top: 8px; padding-bottom: 8px; margin: 0; line-height: 26px; color: black;\">在我搜索的过程中，我发现有网友说可以使用<code style=\"font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: rgb(239, 112, 96);\">Xcode</code>安装相应系统版本的iPhone<code style=\"font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: rgb(239, 112, 96);\">模拟器</code>来进行调试。哎，你说我怎么没有想到这个办法呢？这确实是一个不错的办法。因为之前跟公司的同事学习过<code style=\"font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: rgb(239, 112, 96);\">Swift</code>，也了解过<code style=\"font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: rgb(239, 112, 96);\">Xcode</code>的一些操作。<strong style=\"font-weight: bold; color: black;\">突然感慨，真是技多不压身，你不知道你什么时候就会用上你学过的知识。所以有条件的话，还是多学习一些知识</strong>。额，有点跑题了。</p>\n<h2 data-tool=\"mdnice编辑器\" style=\"margin-top: 30px; margin-bottom: 15px; padding: 0px; font-weight: bold; color: black; border-bottom: 2px solid rgb(239, 112, 96); font-size: 1.3em;\"><span class=\"prefix\" style=\"display: none;\"></span><span class=\"content\" style=\"display: inline-block; font-weight: bold; background: rgb(239, 112, 96); color: #ffffff; padding: 3px 10px 1px; border-top-right-radius: 3px; border-top-left-radius: 3px; margin-right: 3px;\">安装Xcode</span><span class=\"suffix\"></span><span style=\"display: inline-block; vertical-align: bottom; border-bottom: 36px solid #efebe9; border-right: 20px solid transparent;\"> </span></h2>\n<p data-tool=\"mdnice编辑器\" style=\"font-size: 16px; padding-top: 8px; padding-bottom: 8px; margin: 0; line-height: 26px; color: black;\">我打开公司的电脑，开始安装<code style=\"font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: rgb(239, 112, 96);\">Xcode</code>，但是发现公司的电脑系统版本太低，安装<code style=\"font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: rgb(239, 112, 96);\">Xcode</code>需要升级系统，所以没办法，先升级系统吧。因为升级的时间比较长，我想到自己家中的Mac电脑上是有安装过<code style=\"font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: rgb(239, 112, 96);\">Xcode</code>，所以决定先回家。留下公司的电脑慢慢升级。</p>\n<p data-tool=\"mdnice编辑器\" style=\"font-size: 16px; padding-top: 8px; padding-bottom: 8px; margin: 0; line-height: 26px; color: black;\">回到家，二话不说就开始准备调试，但是发现我的<code style=\"font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: rgb(239, 112, 96);\">Xcode</code>上面的iPhone模拟器的系统版本也都是<code style=\"font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: rgb(239, 112, 96);\">12</code>以上的，查了一下资料，<code style=\"font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: rgb(239, 112, 96);\">Xcode</code>是可以安装不同系统版本的模拟器的，于是我就安装了系统版本是<code style=\"font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: rgb(239, 112, 96);\">11</code>的模拟器。这个过程需要我们打开<code style=\"font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: rgb(239, 112, 96);\">Xcode</code>的偏好设置，然后在<code style=\"font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: rgb(239, 112, 96);\">Components</code>选项中，选择下载你要安装的对应系统版本的模拟器。</p>\n<figure data-tool=\"mdnice编辑器\" style=\"margin: 0; margin-top: 10px; margin-bottom: 10px; display: flex; flex-direction: column; justify-content: center; align-items: center;\"><img src=\"https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c03cf83e3a4245e3bb47c1c2bc5e86e6~tplv-k3u1fbpfcp-zoom-1.image\" alt=\"安装iOS11的模拟器\" style=\"display: block; margin: 0 auto; max-width: 100%;\"><figcaption style=\"margin-top: 5px; text-align: center; color: #888; font-size: 14px;\">安装iOS11的模拟器</figcaption></figure>\n<p data-tool=\"mdnice编辑器\" style=\"font-size: 16px; padding-top: 8px; padding-bottom: 8px; margin: 0; line-height: 26px; color: black;\">安装成功之后，运行<code style=\"font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: rgb(239, 112, 96);\">iPhone 6S Plus</code>模拟器，使用模拟器的<code style=\"font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: rgb(239, 112, 96);\">Safari</code>打开h5的页面地址，果然是白屏。</p>\n<figure data-tool=\"mdnice编辑器\" style=\"margin: 0; margin-top: 10px; margin-bottom: 10px; display: flex; flex-direction: column; justify-content: center; align-items: center;\"><img src=\"https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/50eebf0410254238a682489453e77b07~tplv-k3u1fbpfcp-zoom-1.image\" alt=\"iPhone 6S Plus模拟器出现白屏\" style=\"display: block; margin: 0 auto; max-width: 100%;\"><figcaption style=\"margin-top: 5px; text-align: center; color: #888; font-size: 14px;\">iPhone 6S Plus模拟器出现白屏</figcaption></figure>\n<p data-tool=\"mdnice编辑器\" style=\"font-size: 16px; padding-top: 8px; padding-bottom: 8px; margin: 0; line-height: 26px; color: black;\">小样，终于把这个问题给复现了，这样就距离解决这个Bug不远了。我打开<code style=\"font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: rgb(239, 112, 96);\">Mac</code>的<code style=\"font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: rgb(239, 112, 96);\">Safari</code>浏览器，进入开发者模式，发现了如下所示的报错</p>\n<figure data-tool=\"mdnice编辑器\" style=\"margin: 0; margin-top: 10px; margin-bottom: 10px; display: flex; flex-direction: column; justify-content: center; align-items: center;\"><img src=\"https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0ce6212e095e422296ad921d9ae0531b~tplv-k3u1fbpfcp-zoom-1.image\" alt=\"Safari浏览器控制台的报错\" style=\"display: block; margin: 0 auto; max-width: 100%;\"><figcaption style=\"margin-top: 5px; text-align: center; color: #888; font-size: 14px;\">Safari浏览器控制台的报错</figcaption></figure>\n<p data-tool=\"mdnice编辑器\" style=\"font-size: 16px; padding-top: 8px; padding-bottom: 8px; margin: 0; line-height: 26px; color: black;\">我搜索了一下这个错误，发现是因为项目中使用了<code style=\"font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: rgb(239, 112, 96);\">...</code>ES6扩展运算符，然后<code style=\"font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: rgb(239, 112, 96);\">iOS 11</code>系统不支持这个这个运算符。这么容易就找到问题了，开心。想到这个问题还是比较好解决的，可以通过使用<code style=\"font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: rgb(239, 112, 96);\">Babel</code>的一些插件，很容易就可以将这个问题解决掉。然后我就开心的睡觉去了，心想这个问题也不是什么大问题，明天处理一下就好了。</p>\n<h2 data-tool=\"mdnice编辑器\" style=\"margin-top: 30px; margin-bottom: 15px; padding: 0px; font-weight: bold; color: black; border-bottom: 2px solid rgb(239, 112, 96); font-size: 1.3em;\"><span class=\"prefix\" style=\"display: none;\"></span><span class=\"content\" style=\"display: inline-block; font-weight: bold; background: rgb(239, 112, 96); color: #ffffff; padding: 3px 10px 1px; border-top-right-radius: 3px; border-top-left-radius: 3px; margin-right: 3px;\">安装Safari Technology Preview</span><span class=\"suffix\"></span><span style=\"display: inline-block; vertical-align: bottom; border-bottom: 36px solid #efebe9; border-right: 20px solid transparent;\"> </span></h2>\n<p data-tool=\"mdnice编辑器\" style=\"font-size: 16px; padding-top: 8px; padding-bottom: 8px; margin: 0; line-height: 26px; color: black;\">第二天到公司，我就在项目中的<code style=\"font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: rgb(239, 112, 96);\">babel</code>的配置文件中添加了相应的插件</p>\n<pre class=\"custom\" data-tool=\"mdnice编辑器\" style=\"margin-top: 10px; margin-bottom: 10px;\"><code class=\"hljs\" style=\"overflow-x: auto; padding: 16px; color: #333; background: #f8f8f8; display: -webkit-box; font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; border-radius: 0px; font-size: 12px; -webkit-overflow-scrolling: touch;\">{<br>&nbsp;&nbsp;...&nbsp;&nbsp;<span class=\"hljs-comment\" style=\"color: #998; font-style: italic; line-height: 26px;\">//&nbsp;省略原来的配置内容</span><br>&nbsp;&nbsp;<span class=\"hljs-string\" style=\"color: #d14; line-height: 26px;\">\"plugins\"</span>:&nbsp;[<span class=\"hljs-string\" style=\"color: #d14; line-height: 26px;\">\"@babel/plugin-proposal-object-rest-spread\"</span>]<br>}<br></code></pre>\n<p data-tool=\"mdnice编辑器\" style=\"font-size: 16px; padding-top: 8px; padding-bottom: 8px; margin: 0; line-height: 26px; color: black;\">然后发布到测试环境中。告诉了小C同学再次测试一下，我也在等着解决这个Bug的好消息。但是，<strong style=\"font-weight: bold; color: black;\">出现的却不是好消息</strong>，小C给我回复说还是不可以。什么，不可能呀，我就马上用公司的电脑再次进行测试。当我用公司电脑的<code style=\"font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: rgb(239, 112, 96);\">Safari</code>调试系统是<code style=\"font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: rgb(239, 112, 96);\">iOS 11</code>的<code style=\"font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: rgb(239, 112, 96);\">iPhone 6S PLus</code>模拟器的时候，却发现出现了下面这个情况：<code style=\"font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: rgb(239, 112, 96);\">审核警告：“data-custom”太新，无法在此检查的页面上运行</code></p>\n<figure data-tool=\"mdnice编辑器\" style=\"margin: 0; margin-top: 10px; margin-bottom: 10px; display: flex; flex-direction: column; justify-content: center; align-items: center;\"><img src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f647bd72d4b045119438f7a77fb3f020~tplv-k3u1fbpfcp-zoom-1.image\" alt=\"审核警告：“data-custom”太新，无法在此检查的页面上运行\" style=\"display: block; margin: 0 auto; max-width: 100%;\"><figcaption style=\"margin-top: 5px; text-align: center; color: #888; font-size: 14px;\">审核警告：“data-custom”太新，无法在此检查的页面上运行</figcaption></figure>\n<p data-tool=\"mdnice编辑器\" style=\"font-size: 16px; padding-top: 8px; padding-bottom: 8px; margin: 0; line-height: 26px; color: black;\">我就又搜索了一下为什么会出现这个问题，终于让我找到了<a href=\"https://stackoverflow.com/questions/60963057/safari-web-inspector-is-only-showing-sources-console-and-audit\" style=\"text-decoration: none; word-wrap: break-word; font-weight: bold; color: rgb(239, 112, 96); border-bottom: 1px solid rgb(239, 112, 96);\">答案</a>，<code style=\"font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: rgb(239, 112, 96);\">Safari</code>浏览器的<code style=\"font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: rgb(239, 112, 96);\">Web Inspector</code>工程师也说这是一个Bug，不过他们已经修复了，在下个发布的版本中就可以正常使用新的<code style=\"font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: rgb(239, 112, 96);\">Safari</code>浏览器去调试比较老的<code style=\"font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: rgb(239, 112, 96);\">iOS</code>系统的模拟器了。知道现在这个版本的<code style=\"font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: rgb(239, 112, 96);\">Safari</code>调试不了模拟的<code style=\"font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: rgb(239, 112, 96);\">iOS 11</code>系统的页面。我有点沮丧，总不能我现在回家把我的电脑拿过来吧😂？当我想着该如何解决的时候，我发现了上面那个回答中提到了<code style=\"font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: rgb(239, 112, 96);\">Safari Technology Preview</code>，<strong style=\"font-weight: bold; color: black;\"><code style=\"font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: rgb(239, 112, 96);\">Safari</code>技术预览</strong>。</p>\n<figure data-tool=\"mdnice编辑器\" style=\"margin: 0; margin-top: 10px; margin-bottom: 10px; display: flex; flex-direction: column; justify-content: center; align-items: center;\"><img src=\"https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/796b2863243144fbb8c052e42bf11ccc~tplv-k3u1fbpfcp-zoom-1.image\" alt=\"stackoverflow上面Safari浏览器的Web检查器的开发者的回复\" style=\"display: block; margin: 0 auto; max-width: 100%;\"><figcaption style=\"margin-top: 5px; text-align: center; color: #888; font-size: 14px;\">stackoverflow上面Safari浏览器的Web检查器的开发者的回复</figcaption></figure>\n<p data-tool=\"mdnice编辑器\" style=\"font-size: 16px; padding-top: 8px; padding-bottom: 8px; margin: 0; line-height: 26px; color: black;\">我看这个名字感觉有点希望，然后就搜索了一下<code style=\"font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: rgb(239, 112, 96);\">Safari Technology Preview</code>是什么。然后就发现它相对于<code style=\"font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: rgb(239, 112, 96);\">Safari</code>就跟<code style=\"font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: rgb(239, 112, 96);\">Chromium</code>相对于<code style=\"font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: rgb(239, 112, 96);\">Chrome</code>是一样，都相当于是开发版本的浏览器。</p>\n<figure data-tool=\"mdnice编辑器\" style=\"margin: 0; margin-top: 10px; margin-bottom: 10px; display: flex; flex-direction: column; justify-content: center; align-items: center;\"><img src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6d995cb398e24c3ba5c791fd095e014d~tplv-k3u1fbpfcp-zoom-1.image\" alt=\"Safari Technology Preview\" style=\"display: block; margin: 0 auto; max-width: 100%;\"><figcaption style=\"margin-top: 5px; text-align: center; color: #888; font-size: 14px;\">Safari Technology Preview</figcaption></figure>\n<p data-tool=\"mdnice编辑器\" style=\"font-size: 16px; padding-top: 8px; padding-bottom: 8px; margin: 0; line-height: 26px; color: black;\">这时，我觉得可以使用<code style=\"font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: rgb(239, 112, 96);\">Safari Technology Preview</code>进行调试。所以就下载了<code style=\"font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: rgb(239, 112, 96);\">Safari Technology Preview</code>，当我打开<code style=\"font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: rgb(239, 112, 96);\">Safari Technology Preview</code>然后进入开发者模式后，发现确实可以调试<code style=\"font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: rgb(239, 112, 96);\">iOS 11</code>系统的页面。然后我就看了一下为什么还是白屏的问题。发现出现的错误还是上次的问题：</p>\n<figure data-tool=\"mdnice编辑器\" style=\"margin: 0; margin-top: 10px; margin-bottom: 10px; display: flex; flex-direction: column; justify-content: center; align-items: center;\"><img src=\"https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2e9e410c697d416792cede8e0d0fbde4~tplv-k3u1fbpfcp-zoom-1.image\" alt=\"SyntaxError: Unexpected token '...'. Expected a property name.\" style=\"display: block; margin: 0 auto; max-width: 100%;\"><figcaption style=\"margin-top: 5px; text-align: center; color: #888; font-size: 14px;\">SyntaxError: Unexpected token '...'. Expected a property name.</figcaption></figure>\n<p data-tool=\"mdnice编辑器\" style=\"font-size: 16px; padding-top: 8px; padding-bottom: 8px; margin: 0; line-height: 26px; color: black;\">也就是说这个问题还没有解决掉，因为打包后的代码是没有<code style=\"font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: rgb(239, 112, 96);\">SourceMap</code>的，所以要想看更详细的报错信息，需要在本地进行调试。本地的环境中是有<code style=\"font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: rgb(239, 112, 96);\">SourceMap</code>的，可以定位到更详细的错误信息，我在本地运行了项目，然后我打开了控制台的错误详情，发现是使用的一个第三方的库出现了问题。</p>\n<figure data-tool=\"mdnice编辑器\" style=\"margin: 0; margin-top: 10px; margin-bottom: 10px; display: flex; flex-direction: column; justify-content: center; align-items: center;\"><img src=\"https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2e4bb62c4f434aa08811027c4ef571d5~tplv-k3u1fbpfcp-zoom-1.image\" alt=\"找到了出现问题的使用的第三方库\" style=\"display: block; margin: 0 auto; max-width: 100%;\"><figcaption style=\"margin-top: 5px; text-align: center; color: #888; font-size: 14px;\">找到了出现问题的使用的第三方库</figcaption></figure>\n<p data-tool=\"mdnice编辑器\" style=\"font-size: 16px; padding-top: 8px; padding-bottom: 8px; margin: 0; line-height: 26px; color: black;\">那么到这里为止，可以说明上面我们使用的<code style=\"font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: rgb(239, 112, 96);\">Babel</code>插件没有处理这个第三方的库，所以现在我们的问题就变成了：<strong style=\"font-weight: bold; color: black;\">如何解决第三方库中出现的<code style=\"font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: rgb(239, 112, 96);\">...</code>扩展运算符没有被编译为ES5语法的问题</strong>。</p>\n<h2 data-tool=\"mdnice编辑器\" style=\"margin-top: 30px; margin-bottom: 15px; padding: 0px; font-weight: bold; color: black; border-bottom: 2px solid rgb(239, 112, 96); font-size: 1.3em;\"><span class=\"prefix\" style=\"display: none;\"></span><span class=\"content\" style=\"display: inline-block; font-weight: bold; background: rgb(239, 112, 96); color: #ffffff; padding: 3px 10px 1px; border-top-right-radius: 3px; border-top-left-radius: 3px; margin-right: 3px;\">将第三方库中的ES6语法进行编译</span><span class=\"suffix\"></span><span style=\"display: inline-block; vertical-align: bottom; border-bottom: 36px solid #efebe9; border-right: 20px solid transparent;\"> </span></h2>\n<h3 data-tool=\"mdnice编辑器\" style=\"margin-top: 30px; margin-bottom: 15px; padding: 0px; font-weight: bold; color: black; font-size: 20px;\"><span class=\"prefix\" style=\"display: none;\"></span><span class=\"content\">查看Vue CLI中相关的配置方法</span><span class=\"suffix\" style=\"display: none;\"></span></h3>\n<p data-tool=\"mdnice编辑器\" style=\"font-size: 16px; padding-top: 8px; padding-bottom: 8px; margin: 0; line-height: 26px; color: black;\">这时我又仔细的看了一下<code style=\"font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: rgb(239, 112, 96);\">Vue CLI</code>的相关文档，发现确实在<strong style=\"font-weight: bold; color: black;\">浏览器的兼容性</strong>这个章节中，提到了一些处理的方法。原来我们在项目中写的代码默认会帮我们转换为ES5的语法的，但是如果项目中依赖的第三方库需要<code style=\"font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: rgb(239, 112, 96);\">polyfill</code>的话，那需要我们手动进行配置。<strong style=\"font-weight: bold; color: black;\">一看到这里，我感觉黎明就要来了</strong>。</p>\n<figure data-tool=\"mdnice编辑器\" style=\"margin: 0; margin-top: 10px; margin-bottom: 10px; display: flex; flex-direction: column; justify-content: center; align-items: center;\"><img src=\"https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f75c115e1ded4d398212975e434c8a4d~tplv-k3u1fbpfcp-zoom-1.image\" alt=\"Vue CLI浏览器兼容性\" style=\"display: block; margin: 0 auto; max-width: 100%;\"><figcaption style=\"margin-top: 5px; text-align: center; color: #888; font-size: 14px;\">Vue CLI浏览器兼容性</figcaption></figure>\n<p data-tool=\"mdnice编辑器\" style=\"font-size: 16px; padding-top: 8px; padding-bottom: 8px; margin: 0; line-height: 26px; color: black;\">我就开始尝试这三种方法。我发现第一种方法是比较简单的，也很好配置。于是我就尝试了第一种方法。在项目的<code style=\"font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: rgb(239, 112, 96);\">vue.config.js</code>中添加如下的配置：</p>\n<pre class=\"custom\" data-tool=\"mdnice编辑器\" style=\"margin-top: 10px; margin-bottom: 10px;\"><code class=\"hljs\" style=\"overflow-x: auto; padding: 16px; color: #333; background: #f8f8f8; display: -webkit-box; font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; border-radius: 0px; font-size: 12px; -webkit-overflow-scrolling: touch;\">...&nbsp;&nbsp;<span class=\"hljs-comment\" style=\"color: #998; font-style: italic; line-height: 26px;\">//&nbsp;省略的配置</span><br>transpileDependencies:&nbsp;[<br>&nbsp;&nbsp;<span class=\"hljs-string\" style=\"color: #d14; line-height: 26px;\">'module-name/library-name'</span>&nbsp;<span class=\"hljs-comment\" style=\"color: #998; font-style: italic; line-height: 26px;\">//&nbsp;出现问题的那个库</span><br>],<br>...&nbsp;&nbsp;<span class=\"hljs-comment\" style=\"color: #998; font-style: italic; line-height: 26px;\">//&nbsp;省略的配置</span><br></code></pre>\n<p data-tool=\"mdnice编辑器\" style=\"font-size: 16px; padding-top: 8px; padding-bottom: 8px; margin: 0; line-height: 26px; color: black;\">重新运行项目，当我将要为即将到来的成功欢呼鼓掌时，控制台突然报告了如下的错误：\n<code style=\"font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: rgb(239, 112, 96);\">Uncaught TypeError: Cannot assign to read only property 'exports' of object '#&lt;Object&gt;'</code></p>\n<figure data-tool=\"mdnice编辑器\" style=\"margin: 0; margin-top: 10px; margin-bottom: 10px; display: flex; flex-direction: column; justify-content: center; align-items: center;\"><img src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b7f9a5fd297b49bdbb7bff03686ea703~tplv-k3u1fbpfcp-zoom-1.image\" alt=\"Uncaught TypeError: Cannot assign to read only property ...\" style=\"display: block; margin: 0 auto; max-width: 100%;\"><figcaption style=\"margin-top: 5px; text-align: center; color: #888; font-size: 14px;\">Uncaught TypeError: Cannot assign to read only property ...</figcaption></figure>\n<p data-tool=\"mdnice编辑器\" style=\"font-size: 16px; padding-top: 8px; padding-bottom: 8px; margin: 0; line-height: 26px; color: black;\">这个报错是在<code style=\"font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: rgb(239, 112, 96);\">Chrome</code>浏览器的控制台出现的，因为项目在本地重新运行之后会首先打开<code style=\"font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: rgb(239, 112, 96);\">Chrome</code>浏览器。真是的，一个问题还没有解决，又出来了一个新的问题。然后再次查询资料后发现，原来是因为这个第三方的库是一个<code style=\"font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: rgb(239, 112, 96);\">CommonJS</code>类型的库，而<code style=\"font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: rgb(239, 112, 96);\">Babel</code>默认处理的是<code style=\"font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: rgb(239, 112, 96);\">ES6</code>的<code style=\"font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: rgb(239, 112, 96);\">module</code>类型的库，所以这里就又出现了新的问题。</p>\n<figure data-tool=\"mdnice编辑器\" style=\"margin: 0; margin-top: 10px; margin-bottom: 10px; display: flex; flex-direction: column; justify-content: center; align-items: center;\"><img src=\"https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a1b1176fc2cc40429ec04a7780a24b5d~tplv-k3u1fbpfcp-zoom-1.image\" alt=\"https://github.com/webpack/webpack/issues/4039 sokra的回复\" style=\"display: block; margin: 0 auto; max-width: 100%;\"><figcaption style=\"margin-top: 5px; text-align: center; color: #888; font-size: 14px;\">https://github.com/webpack/webpack/issues/4039 sokra的回复</figcaption></figure>\n<p data-tool=\"mdnice编辑器\" style=\"font-size: 16px; padding-top: 8px; padding-bottom: 8px; margin: 0; line-height: 26px; color: black;\">第一种方法遇到了阻碍，先暂停一下。我准备继续尝试下面两种方法。<strong style=\"font-weight: bold; color: black;\">但是因为后面两种方法对原来的项目改动有点大，所以我直接通过<code style=\"font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: rgb(239, 112, 96);\">Vue CLI</code>创建了一个新的项目，在<code style=\"font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: rgb(239, 112, 96);\">package.json</code>中加入项目中使用的那个第三方包的依赖，使用公司的包管理工具安装了依赖</strong>。然后运行项目，打开控制台确实发现了相同的错误。但是打开详情以后，发现出错的路径跟我原来项目不一致。然后我这次抱着试一试的心态，继续使用了第一种方法尝试看看可不可以。然后复制了出错路径的包名称，在<code style=\"font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: rgb(239, 112, 96);\">vue.config.js</code>文件中的对应位置添加了如下的配置代码：</p>\n<pre class=\"custom\" data-tool=\"mdnice编辑器\" style=\"margin-top: 10px; margin-bottom: 10px;\"><code class=\"hljs\" style=\"overflow-x: auto; padding: 16px; color: #333; background: #f8f8f8; display: -webkit-box; font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; border-radius: 0px; font-size: 12px; -webkit-overflow-scrolling: touch;\">...&nbsp;&nbsp;<span class=\"hljs-comment\" style=\"color: #998; font-style: italic; line-height: 26px;\">//&nbsp;省略的配置</span><br>transpileDependencies:&nbsp;[<br>&nbsp;&nbsp;<span class=\"hljs-string\" style=\"color: #d14; line-height: 26px;\">'module-name-new/library-name-new'</span>&nbsp;<span class=\"hljs-comment\" style=\"color: #998; font-style: italic; line-height: 26px;\">//&nbsp;出现问题的那个库</span><br>],<br>...&nbsp;&nbsp;<span class=\"hljs-comment\" style=\"color: #998; font-style: italic; line-height: 26px;\">//&nbsp;省略的配置</span><br></code></pre>\n<p data-tool=\"mdnice编辑器\" style=\"font-size: 16px; padding-top: 8px; padding-bottom: 8px; margin: 0; line-height: 26px; color: black;\">然后重新运行项目，发现居然可以了。<strong style=\"font-weight: bold; color: black;\">啊，居然可以了</strong>。为什么我在原来的项目中这样却不可以呢？<strong style=\"font-weight: bold; color: black;\">我看了一下原来项目的依赖以及现在新的测试项目的依赖，发现它们的<code style=\"font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: rgb(239, 112, 96);\">vue</code>, <code style=\"font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: rgb(239, 112, 96);\">babel</code>版本差了好多</strong>。我猜测可能是因为这个原因。但是现在肯定不可以贸然升级这些依赖的版本，因为为了解决这个问题再次带来新的问题就得不偿失了。</p>\n<p data-tool=\"mdnice编辑器\" style=\"font-size: 16px; padding-top: 8px; padding-bottom: 8px; margin: 0; line-height: 26px; color: black;\"><strong style=\"font-weight: bold; color: black;\">还有一个问题就是为什么同样的第三方库，在原来的项目中和现在的项目中报错的路径不一样。而且看着像是使用了两个不一样的第三方库</strong>。这里先留个悬念，我会在后面的文章中进行解释。</p>\n<p data-tool=\"mdnice编辑器\" style=\"font-size: 16px; padding-top: 8px; padding-bottom: 8px; margin: 0; line-height: 26px; color: black;\">接下来，我开始在测试项目中继续尝试剩下的两种方法，对于第二种方法，因为老项目中使用的<code style=\"font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: rgb(239, 112, 96);\">presets</code>是没有<code style=\"font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: rgb(239, 112, 96);\">polyfills</code>这个配置选项的，到现在为止出问题的这个第三方库我不知道除了这个<code style=\"font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: rgb(239, 112, 96);\">...</code>对象扩展操作符之外还有没有别的依赖。所以这个方法我暂时也放弃了。</p>\n<p data-tool=\"mdnice编辑器\" style=\"font-size: 16px; padding-top: 8px; padding-bottom: 8px; margin: 0; line-height: 26px; color: black;\">对于第三个方法，我觉得可以尝试，首先我将测试项目中的一些关键依赖进行了手动降级，然后按照上面的第三个方法的步骤在测试项目中使用。但是发现测试项目运行之后，提示需要安装<code style=\"font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: rgb(239, 112, 96);\">core-js</code>，安装<code style=\"font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: rgb(239, 112, 96);\">core-js</code>之后还报错，再次提示需要安装<code style=\"font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: rgb(239, 112, 96);\">es.module.regex.match</code>等等很多依赖，继续查资料，发现需要把配置中的 <code style=\"font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: rgb(239, 112, 96);\">useBuiltIns</code>修改，但是因为我接手的这个项目是老项目，依赖比较多，不确定修改<code style=\"font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: rgb(239, 112, 96);\">useBuiltIns</code>这个配置选项后会不会出现新的问题。所以也不敢贸然修改这个配置选项，所以也暂时放弃了这个方法。</p>\n<p data-tool=\"mdnice编辑器\" style=\"font-size: 16px; padding-top: 8px; padding-bottom: 8px; margin: 0; line-height: 26px; color: black;\">我后来想了一下，对于<code style=\"font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: rgb(239, 112, 96);\">...</code>扩展运算符来说，这是一个新的语法。是不能够通过一些<code style=\"font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: rgb(239, 112, 96);\">polyfills</code>去解决的。需要<code style=\"font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: rgb(239, 112, 96);\">Babel</code>对这个语法进行编译，然后才可以在低版本的系统中使用，所以解决的办法还是要让<code style=\"font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: rgb(239, 112, 96);\">Babel</code>对这个库再次进行编译。</p>\n<h2 data-tool=\"mdnice编辑器\" style=\"margin-top: 30px; margin-bottom: 15px; padding: 0px; font-weight: bold; color: black; border-bottom: 2px solid rgb(239, 112, 96); font-size: 1.3em;\"><span class=\"prefix\" style=\"display: none;\"></span><span class=\"content\" style=\"display: inline-block; font-weight: bold; background: rgb(239, 112, 96); color: #ffffff; padding: 3px 10px 1px; border-top-right-radius: 3px; border-top-left-radius: 3px; margin-right: 3px;\">寻找新的突破口</span><span class=\"suffix\"></span><span style=\"display: inline-block; vertical-align: bottom; border-bottom: 36px solid #efebe9; border-right: 20px solid transparent;\"> </span></h2>\n<p data-tool=\"mdnice编辑器\" style=\"font-size: 16px; padding-top: 8px; padding-bottom: 8px; margin: 0; line-height: 26px; color: black;\">当进行到了这里的时候，似乎没有了出路。一时间我感觉我要被这个Bug打败了，我似乎听到了它无情的嘲笑，“<strong style=\"font-weight: bold; color: black;\">小伙子，是不是被我折磨的没有脾气啦；放弃吧，你是没办法打倒我的。哈哈哈。。。</strong>”</p>\n<figure data-tool=\"mdnice编辑器\" style=\"margin: 0; margin-top: 10px; margin-bottom: 10px; display: flex; flex-direction: column; justify-content: center; align-items: center;\"><img src=\"https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c13cf426415d40dbbcdcd2f5f646c9e2~tplv-k3u1fbpfcp-zoom-1.image\" alt=\"Photo by sebastiaan stam on Unsplash\" style=\"display: block; margin: 0 auto; max-width: 100%;\"><figcaption style=\"margin-top: 5px; text-align: center; color: #888; font-size: 14px;\">Photo by sebastiaan stam on Unsplash</figcaption></figure>\n<p data-tool=\"mdnice编辑器\" style=\"font-size: 16px; padding-top: 8px; padding-bottom: 8px; margin: 0; line-height: 26px; color: black;\">但是，它看错我了，Bug越是难解决，我对它就越有兴趣。所以我决定好好理一下思路，准备再次扬帆起航。</p>\n<p data-tool=\"mdnice编辑器\" style=\"font-size: 16px; padding-top: 8px; padding-bottom: 8px; margin: 0; line-height: 26px; color: black;\">我发现第一种办法其实是起作用的，只不过是因为一个是<code style=\"font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: rgb(239, 112, 96);\">CommonJS</code>类型的，一个需要是<code style=\"font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: rgb(239, 112, 96);\">ES6 module</code>类型的。所以我决定从这个地方入手，于是我决定查查相关的资料，看看<code style=\"font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: rgb(239, 112, 96);\">Babel</code>有没有办法可以即能够处理<code style=\"font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: rgb(239, 112, 96);\">CommonJS</code>模块，又能够处理<code style=\"font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: rgb(239, 112, 96);\">ES6 module</code>模块呢？<strong style=\"font-weight: bold; color: black;\">终于，功夫不负有心人，我发现了<code style=\"font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: rgb(239, 112, 96);\">Babel</code>里面有这么一个配置<code style=\"font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: rgb(239, 112, 96);\">sourceType</code>，如果把<code style=\"font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: rgb(239, 112, 96);\">sourceType</code>设置为<code style=\"font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: rgb(239, 112, 96);\">unambiguous</code>就可以解决这个问题</strong>。</p>\n<figure data-tool=\"mdnice编辑器\" style=\"margin: 0; margin-top: 10px; margin-bottom: 10px; display: flex; flex-direction: column; justify-content: center; align-items: center;\"><img src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0f87ca1a2c444c49aaad528895929bf3~tplv-k3u1fbpfcp-zoom-1.image\" alt=\"https://babeljs.io/docs/en/options#sourcetype\" style=\"display: block; margin: 0 auto; max-width: 100%;\"><figcaption style=\"margin-top: 5px; text-align: center; color: #888; font-size: 14px;\">https://babeljs.io/docs/en/options#sourcetype</figcaption></figure>\n<p data-tool=\"mdnice编辑器\" style=\"font-size: 16px; padding-top: 8px; padding-bottom: 8px; margin: 0; line-height: 26px; color: black;\">这样<code style=\"font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: rgb(239, 112, 96);\">Babel</code>就会根据模块文件中有没有<code style=\"font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: rgb(239, 112, 96);\">import/export</code>来决定使用哪种解析模块的方式。于是我再次使用了第一种方法，在<code style=\"font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: rgb(239, 112, 96);\">vue.config.js</code>中添加了<code style=\"font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: rgb(239, 112, 96);\">transpileDependencies</code>选项的配置，然后在项目中的<code style=\"font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: rgb(239, 112, 96);\">Babel</code>配置文件中添加了如下的配置：</p>\n<pre class=\"custom\" data-tool=\"mdnice编辑器\" style=\"margin-top: 10px; margin-bottom: 10px;\"><code class=\"hljs\" style=\"overflow-x: auto; padding: 16px; color: #333; background: #f8f8f8; display: -webkit-box; font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; border-radius: 0px; font-size: 12px; -webkit-overflow-scrolling: touch;\"><span class=\"hljs-built_in\" style=\"color: #0086b3; line-height: 26px;\">module</span>.exports&nbsp;=&nbsp;{<br>&nbsp;&nbsp;...&nbsp;&nbsp;<span class=\"hljs-comment\" style=\"color: #998; font-style: italic; line-height: 26px;\">//&nbsp;省略的配置</span><br>&nbsp;&nbsp;sourceType:&nbsp;<span class=\"hljs-string\" style=\"color: #d14; line-height: 26px;\">'unambiguous'</span>,<br>&nbsp;&nbsp;...&nbsp;&nbsp;<span class=\"hljs-comment\" style=\"color: #998; font-style: italic; line-height: 26px;\">//&nbsp;省略的配置</span><br>};<br></code></pre>\n<p data-tool=\"mdnice编辑器\" style=\"font-size: 16px; padding-top: 8px; padding-bottom: 8px; margin: 0; line-height: 26px; color: black;\">发现的确可以，<strong style=\"font-weight: bold; color: black;\">这一刻成功的喜悦再次降临</strong>。然后我再次打包，再次把代码部署到测试环境，赶忙让小C同学再次测试一下，发现的确可以。欧耶，终于解决这个问题了。我终于可以松一口气了，哈哈哈。。。小样，这怎么会难得到我呢？</p>\n<p data-tool=\"mdnice编辑器\" style=\"font-size: 16px; padding-top: 8px; padding-bottom: 8px; margin: 0; line-height: 26px; color: black;\">但是，当我仔细阅读将这个选项设置为<code style=\"font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: rgb(239, 112, 96);\">unambiguous</code>时，我发现了一些问题。因为这样的话会有一些风险，因为就算不使用<code style=\"font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: rgb(239, 112, 96);\">import/export</code>语句的这些模块也可能是完全有效的<code style=\"font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: rgb(239, 112, 96);\">ES6 module</code>，所以这样的话就有可能会出现一些意外的情况。<strong style=\"font-weight: bold; color: black;\">怎么办，我似乎在一不留神的时候又被Bug卡住了脖子</strong>。</p>\n<figure data-tool=\"mdnice编辑器\" style=\"margin: 0; margin-top: 10px; margin-bottom: 10px; display: flex; flex-direction: column; justify-content: center; align-items: center;\"><img src=\"https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c191633378c54e1292043e096e4464f7~tplv-k3u1fbpfcp-zoom-1.image\" alt=\"https://babeljs.io/docs/en/options#sourcetype\" style=\"display: block; margin: 0 auto; max-width: 100%;\"><figcaption style=\"margin-top: 5px; text-align: center; color: #888; font-size: 14px;\">https://babeljs.io/docs/en/options#sourcetype</figcaption></figure>\n<p data-tool=\"mdnice编辑器\" style=\"font-size: 16px; padding-top: 8px; padding-bottom: 8px; margin: 0; line-height: 26px; color: black;\">我觉得老天总是给我开玩笑，当我从一个坑里跳出来，以为没有危险的时候。前面突然又多出来一个坑，我一不留心就又掉了进去。我感觉既然都走到了这里，肯定要继续走下去，一定有办法可以优化我现在遇到的问题。我就很仔细的再次看了一下<code style=\"font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: rgb(239, 112, 96);\">Babel</code>的配置说明文档，这个时候就心想如果我对<code style=\"font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: rgb(239, 112, 96);\">Babel</code>再熟悉一些就好了。<strong style=\"font-weight: bold; color: black;\">没关系，继续努力</strong>。终于，我似乎看到了什么了不得的配置选项。</p>\n<figure data-tool=\"mdnice编辑器\" style=\"margin: 0; margin-top: 10px; margin-bottom: 10px; display: flex; flex-direction: column; justify-content: center; align-items: center;\"><img src=\"https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/61bb29fd27234b15af0947596a70ab90~tplv-k3u1fbpfcp-zoom-1.image\" alt=\"https://babeljs.io/docs/en/options#overrides\" style=\"display: block; margin: 0 auto; max-width: 100%;\"><figcaption style=\"margin-top: 5px; text-align: center; color: #888; font-size: 14px;\">https://babeljs.io/docs/en/options#overrides</figcaption></figure>\n<p data-tool=\"mdnice编辑器\" style=\"font-size: 16px; padding-top: 8px; padding-bottom: 8px; margin: 0; line-height: 26px; color: black;\">我在<code style=\"font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: rgb(239, 112, 96);\">Config Merging options</code>里发现了<code style=\"font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: rgb(239, 112, 96);\">overrides</code>选项，这个配置选项不正是我需要的吗？我可以利用这个配置选项将我需要的第三方包使用<code style=\"font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: rgb(239, 112, 96);\">unambiguous</code>的处理方式，然后其他的第三方库都按照之前的方式处理不就可以了。哈哈哈，我真是个天才，我心里这样对自己说😂。</p>\n<figure data-tool=\"mdnice编辑器\" style=\"margin: 0; margin-top: 10px; margin-bottom: 10px; display: flex; flex-direction: column; justify-content: center; align-items: center;\"><img src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b6c4691b0e9b418a811e3f97b7d32899~tplv-k3u1fbpfcp-zoom-1.image\" alt=\"Photo by bruce mars on Unsplash\" style=\"display: block; margin: 0 auto; max-width: 100%;\"><figcaption style=\"margin-top: 5px; text-align: center; color: #888; font-size: 14px;\">Photo by bruce mars on Unsplash</figcaption></figure>\n<p data-tool=\"mdnice编辑器\" style=\"font-size: 16px; padding-top: 8px; padding-bottom: 8px; margin: 0; line-height: 26px; color: black;\">所以只需要在项目的<code style=\"font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: rgb(239, 112, 96);\">babel.config.js</code>中写下如下的配置就可以了：</p>\n<pre class=\"custom\" data-tool=\"mdnice编辑器\" style=\"margin-top: 10px; margin-bottom: 10px;\"><code class=\"hljs\" style=\"overflow-x: auto; padding: 16px; color: #333; background: #f8f8f8; display: -webkit-box; font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; border-radius: 0px; font-size: 12px; -webkit-overflow-scrolling: touch;\"><span class=\"hljs-built_in\" style=\"color: #0086b3; line-height: 26px;\">module</span>.exports&nbsp;=&nbsp;{<br>&nbsp;&nbsp;...&nbsp;&nbsp;<span class=\"hljs-comment\" style=\"color: #998; font-style: italic; line-height: 26px;\">//&nbsp;省略的配置</span><br>&nbsp;&nbsp;overrides:&nbsp;[<br>&nbsp;&nbsp;&nbsp;&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class=\"hljs-attr\" style=\"line-height: 26px;\">include</span>:&nbsp;<span class=\"hljs-string\" style=\"color: #d14; line-height: 26px;\">'./node_modules/module-name/library-name/name.common.js'</span>,&nbsp;&nbsp;<span class=\"hljs-comment\" style=\"color: #998; font-style: italic; line-height: 26px;\">//&nbsp;使用的第三方库</span><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;sourceType:&nbsp;<span class=\"hljs-string\" style=\"color: #d14; line-height: 26px;\">'unambiguous'</span><br>&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;],<br>&nbsp;&nbsp;...&nbsp;&nbsp;<span class=\"hljs-comment\" style=\"color: #998; font-style: italic; line-height: 26px;\">//&nbsp;省略的配置</span><br>};<br></code></pre>\n<p data-tool=\"mdnice编辑器\" style=\"font-size: 16px; padding-top: 8px; padding-bottom: 8px; margin: 0; line-height: 26px; color: black;\">对了，还有一件事情还没有说，那就是上文提到的关于为什么使用公司自己的包管理工具下载下来的<code style=\"font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: rgb(239, 112, 96);\">node_modules</code>包的名称跟使用官方的<code style=\"font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: rgb(239, 112, 96);\">npm</code>包管理工具下载的包的名称不一致的问题。原因是公司使用的包管理工具是<a href=\"https://github.com/cnpm/cnpm\" style=\"text-decoration: none; word-wrap: break-word; font-weight: bold; color: rgb(239, 112, 96); border-bottom: 1px solid rgb(239, 112, 96);\"><code style=\"font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: rgb(239, 112, 96);\">cnpm</code></a>的一个修改版本。又因为<code style=\"font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: rgb(239, 112, 96);\">cnpm</code>为了提高下载的速度，使用了<a href=\"https://github.com/cnpm/npminstall\" style=\"text-decoration: none; word-wrap: break-word; font-weight: bold; color: rgb(239, 112, 96); border-bottom: 1px solid rgb(239, 112, 96);\"><code style=\"font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: rgb(239, 112, 96);\">cnpm/npminstall</code></a>，所以才会出现下载的包名比较混乱的情况，详情可以看<a href=\"https://www.zhihu.com/question/53341824/answer/134683829\" style=\"text-decoration: none; word-wrap: break-word; font-weight: bold; color: rgb(239, 112, 96); border-bottom: 1px solid rgb(239, 112, 96);\">这里</a>。</p>\n<p data-tool=\"mdnice编辑器\" style=\"font-size: 16px; padding-top: 8px; padding-bottom: 8px; margin: 0; line-height: 26px; color: black;\">到此完结撒花，总结一下：<strong style=\"font-weight: bold; color: black;\">出现白屏的原因是因为使用的第三方库的包中使用了<code style=\"font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: rgb(239, 112, 96);\">...</code>扩展运算符，然后因为第三方的包默认是没有被<code style=\"font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: rgb(239, 112, 96);\">Babel</code>处理过的，所以在不支持<code style=\"font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: rgb(239, 112, 96);\">...</code>的<code style=\"font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: rgb(239, 112, 96);\">iOS 11</code>系统上就出现了白屏。解决的方式就是通过给<code style=\"font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: rgb(239, 112, 96);\">vue.config.js</code>的配置文件中<code style=\"font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: rgb(239, 112, 96);\">transpileDependencies</code>配置选项中添加上出问题的包的名称就可以了</strong>。当然如果项目比较老，可能还需要像文章上面写的那样的处理方式。</p>\n<p data-tool=\"mdnice编辑器\" style=\"font-size: 16px; padding-top: 8px; padding-bottom: 8px; margin: 0; line-height: 26px; color: black;\">解决这个Bug过程就像是升级打怪一样，<strong style=\"font-weight: bold; color: black;\">不断失败，不断尝试，只要不放弃，终有成功的那一天</strong>。如果你坚持看到了这里，那说明你也很棒呀。在当今这个信息爆炸的时代里，能够坚持看完一篇很长的文章已经很不错了。</p>\n<p data-tool=\"mdnice编辑器\" style=\"font-size: 16px; padding-top: 8px; padding-bottom: 8px; margin: 0; line-height: 26px; color: black;\"><strong style=\"font-weight: bold; color: black;\">一点反思与思考</strong>：这个过程中我也发现了自己对<code style=\"font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: rgb(239, 112, 96);\">Babel</code>和<code style=\"font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: rgb(239, 112, 96);\">Vue CLI</code>其实没有那么熟练，如果我对它们比较熟练的话，那我解决这个Bug应该会花费更少的时间。当然，现在把它们学习好也不算晚。<strong style=\"font-weight: bold; color: black;\">要抱着学习的态度，这次解决这个Bug的过程，就是我以后解决其它类似Bug的经验。还有在解决Bug的这个过程中要有耐心，当然在尝试之后也要学会放弃错误的方向</strong>。</p>\n<p data-tool=\"mdnice编辑器\" style=\"font-size: 16px; padding-top: 8px; padding-bottom: 8px; margin: 0; line-height: 26px; color: black;\">写这篇文章也花费了我不少的时间，如果你有所收获或者感悟，不妨<strong style=\"font-weight: bold; color: black;\">点赞，转发，收藏</strong>走一波，这个要求应该不算过分吧😂？</p>\n<p data-tool=\"mdnice编辑器\" style=\"font-size: 16px; padding-top: 8px; padding-bottom: 8px; margin: 0; line-height: 26px; color: black;\">如果你对本篇文章有什么意见和建议，都可以直接在文章下面留言，也可以在<a href=\"https://github.com/dreamapplehappy/blog/issues/11\" style=\"text-decoration: none; word-wrap: break-word; font-weight: bold; color: rgb(239, 112, 96); border-bottom: 1px solid rgb(239, 112, 96);\">这里</a>提出来。也欢迎大家关注我的公众号<strong style=\"font-weight: bold; color: black;\">关山不难越</strong>，学习更多实用的前端知识，让我们一起努力进步吧。</p>\n</section>", "user_name": "dreamappleapple", "description": "心之所向 所向披靡，微信公众号「关山不难越」", "got_view_count": 53883, "category_name": "前端", "ctime": 1457483942}
{"tag_name": "程序员", "concern_user_count": 238890, "user_id": "413072061127479", "title": "❤️ Say Goodbye and Welcome 月影 ❤️", "mark_content": "> 抱歉很久没有和大家聊天了，今天北京天气很好，我坐在办公室定神儿看了会儿窗外，想起了那时还年轻的我和几个朋友搭伙儿开始搞掘金的时候的样子，觉得今天有必要和大家很正式地说两句\n\n## Goodbye 掘友们\n\n我记得有很多人问我怎么做好社区，其实很简单，和这个社区里的每一个用户交朋友，让他们觉得你在他们身边、理解他们、支持他们，就可以了。我们当下身处的世界是被数据、算法、舆论、意识形态挤压的世界，因此一个社区往往最重要的定位是大家可以卸下身上的包袱，来这里和懂自己的人说说话。\n\n从这一点上，我认为掘金做到了，谢谢每一位掘友，这是你们赐予这个产品的礼物。\n\n## Goodbye 伙伴们\n\n其实我一直没有完全放下，就是掘金的很多事情没有做好，起码没有做到让我认为的好。很幸运，也非常非常感恩，在一段时间的沉寂后，掘金迎来了两个重要的变化：\n\n1. **掘金进行了一次技术上彻底的重构，感谢参与其中的所有人**。当然这个重构只是技术层面的，所以很多功能不完善，这里请掘友给团队伙伴们一点耐心，大家会全力支持。\n2. **一位非常合适且非常优秀的新的站长 [@十年踪迹](https://juejin.im/user/712139263189303)（月影）**。当然，可能这位新朋友不会再称呼自己是“站长”，没关系，接下里的掘金就交给你了，虽然这里还很小还不够好，但是这里用户都很棒。\n\n还有就是那些陪伴掘金到今天的团队伙伴们，我们一起经历了许多无法复制的事情，无论未来怎样，感谢你们的付出，这是你们赐予这个产品的礼物。\n\n## Never say Goodbye to 开发者\n\n无论我在哪里，我都会持续地、永远地、坚定地关注软件和开发者，这是 21 世纪留给人类的最重要的文化产物。开发者在我心中从没有改变过它的身份，这个时代的艺术家。如果这个世纪要迎来一场文艺复兴，我希望它属于所有的开发者！\n\n\n```\n我会经常回来的 ❤️\nMing, 2020-08-04\n```", "user_name": "阴明", "description": "子非猿，安知掘金之乐也", "got_view_count": 1638530, "category_name": "代码人生", "ctime": 1553759544}
{"tag_name": "Java", "concern_user_count": 252044, "user_id": "8451822195837", "title": "技术人的成长", "mark_content": "# 摘要\n最近和朋友，同事交流了一些关于技术人如何成长的话题。为什么聊到这个话题，因为程序员这个职业发展真的很快，2、3年的时间，相同起点的人可能就会被拉开很大差距，所以技术人一定要持续学习，保证一定的成长速度，才能跟上技术的更新和不断拍来的后浪。\n\n# 成长体系\n## 喜欢与擅长\n职业成长体系总是会提到2个维度，喜欢的、擅长的。做你擅长的可以保证你的职业底线，做你喜欢的可以触碰到你人生上限。\n\n大部分人都是平庸的，所以不要整天纠结做喜欢的还是擅长的，因为其实大多数人既没有热爱的，也没有特长，一辈子得工作几十年，你能把从事的职业持续做好，做到擅长，就会慢慢喜欢上他。\n\n程序员是份不赖的工作，收入尚可，人际关系简单，上限还挺高。虽然从业人数慢慢趋于饱和，导致竞争加剧，但是人生不是只有工作，社会人总是会被各种各样的想法所左右，所以只要你能坚持学习，持续进步，你就能甩开普通人，在竞争中脱颖而出。\n\n## 阶段成长\n程序员的发展路线，1年入门，3年高工，5年资深，7年架构，10年外卖![在这里插入图片描述](https://img-blog.csdnimg.cn/20200809152209850.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0ZTMTM2MDQ3MjE3NA==,size_16,color_FFFFFF,t_70)\n描述的是一个快速成长的职业。当然10年外卖是个玩笑话，他背后的含义其实是10年后的技术岗位比较少了，所以技术人不断超出了技术的范畴，有些做了管理，有些转行到产品，售前，咨询。或者已经不在互联网行业，这很正常，世界本来就是丰富多彩。\n\n职业生涯的早期，我们能做的是追随，跟上步伐。职业中期，开始有了规划建设能力，有着强大的内心，能够自信的走出不一样的道路，而不必在乎其他人的看法。\n\n## 工作与生活\n我差不多是工作5年的时候领悟到工作和生活是分不开的。工作即生活，生活即工作。在那之前，我一直想树立一道墙，能够把工作和生活撕扯开。后来我发现，在现在这样的一个撸起袖子加油干的时代，工作会不断侵蚀你的生活，将你的大部分时间都占据，如果你还一直想着，\n- 等我找个下班早的工作，就有时间好好学习，提升技术了\n- 等我找个轻松的工作，就有时间谈恋爱\n- 等我不忙了，就要出去旅游，探索世界了\n\n你会发现1年过去了，你还是没能实现。因为你已经没有了生活的能力，被工作教育成了一个只会被动接受任务的人，而不会去主动规划自己的人生了。\n\n所以不妨考虑一下，如何像认真工作一样认真生活，如何像快乐生活一样快乐工作。\n# 如何去学\n我们有了自己的阶段成长目标，那么如何去学呢\n\n## 团队学习，教会他人\n学习的三步曲就是**复盘-总结-归纳**。\n通过复盘找到不会的，总结其中的知识点，然后归纳起来，不断的重复加强。一个人的学习总是孤单不可持续的，通过和同事组队，网上社群一起打卡学习，才能进步更快。\n\n教会他人才是真正掌握了某个知识点，技术人的知识点都是客观的，不存在只可意会，无法言传的说法。当你看懂一个知识点时，你可能只理解了2分，在实践中用了到了4分，总结归纳后6分，能把别人教会，你理解的才能达到8分。\n\n##  知识图谱\n技术人一定要构建自己的知识图谱，将点连成线，线连成面。\n比如这是我web后端的一个大的知识图谱，每个里面有这个知识点的图谱\n![在这里插入图片描述](https://img-blog.csdnimg.cn/202008091557406.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0ZTMTM2MDQ3MjE3NA==,size_16,color_FFFFFF,t_70)\n\n因为这样你的知识体系才是结构化的，结构化的知识才能快速搜索，这就好比文本搜索，不建立结构化的数据，你是无法快速搜索的。\n\n那么如何构建自己的知识图谱的？\n从小处着手，从日常积累开始。\n\n**bug都是有价值的**\n 每一个花费你较长时间解决的bug,都说明你某块知识点缺少。你可以通过请教他人或者stackoverflow解决掉这个bug,但是请一定花时间弄清楚它产生的原因，搞清楚来龙去脉，将这个知识点构建到你的知识图谱中\n\n**从扩展做起**\n你分配到一个需求，做一个任务调度。你可以使用公司封装好的任务框架快速实现需求，交付上线。但是这并不是结束，你需要考虑\n- 一个任务调度需要解决哪些问题\n- 不同业务场景下有哪些解决方案\n- 任务框架是如何解决这些问题\n- 业界还有哪些框架/技术方案来解决任务调度\n\n学会扩展学习，可以拓宽你的视野。\n\n**学习业界知识体系，完善你的图谱**\n上面提到的都是在工作中学习，但是工作中面对的场景毕竟有限。所以向他人学习，向业界学习。比如分布式如何做的，需要解决哪些问题，这样能够帮助你完善你的图谱。\n\n**关注公众号【方丈的寺院】，第一时间收到文章的更新，与方丈一起开始技术修行之路**\n\n![在这里插入图片描述](https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAxOS85LzMwLzE2ZDgyNjdiNmExZTBlYzA?x-oss-process=image/format,png)\n\n\n", "user_name": "方丈的寺院", "description": "技术之路很长，慢慢修行", "got_view_count": 65066, "category_name": "后端", "ctime": 1457483880}
{"tag_name": "HTML", "concern_user_count": 207875, "user_id": "2928754708973704", "title": "从输入url到页面完成加载发生了什么？", "mark_content": "先来个流程总述：\n\n - DNS解析：将域名解析成IP地址\n - TCP连接：TCP三次握手\n - 发送HTTP请求\n - 服务器处理请求并返回HTTP报文\n - 浏览器解析渲染页面\n - 连接结束：TCP四次挥手\n\n #### 1、DNS解析\n\n 在浏览器输入URL后，首先要经过域名解析。浏览器通过向 DNS 服务器发送域名，DNS 服务器查询到与域名相对应的 IP 地址，然后返回给浏览器，浏览器再将 IP 地址打在协议上，同时请求参数也会在协议搭载，然后一并发送给对应的服务器。\n\n\n```\n1.什么是URL\nURL（Uniform Resource Locator），统一资源定位符，用于定位互联网上资源，俗称网址。比如 http://www.w3school.com.cn/ht...，\n遵守以下的语法规则：\n`scheme://host.domain:port/path/filename`\n各部分解释如下：\nscheme：定义因特网服务的类型。常见的协议有 http、https、ftp、file，其中最常见的类型是 http，而 https 则是进行加密的网络传输。\nhost：定义域主机（http 的默认主机是 www）\ndomain：定义因特网域名，比如 w3school.com.cn\nport：定义主机上的端口号（http 的默认端口号是 80）\npath： 定义服务器上的路径（如果省略，则文档必须位于网站的根目录中）。\nfilename： 定义文档/资源的名称\n\n2. 什么是DNS\nDNS(domain name system，域名系统)：因特网上域名和IP地址相互映射的分布式数据库；简单理解就是域名与IP地址的对照表，因为域名（如：www.google.com）对于我们而言，更便于记忆，但是机器却不擅长这种表达方式，因此需要将域名转换为IP地址，以便于机器识别， 这便有了DNS。\n\n3. 根域名服务器\n根服务器是架设互联网的必须设施，管理互联网的主目录，全球共有13套根域名服务器\n\n4. 递归查询\n客户端主机向本地域名服务器的查询是递归查询；所谓递归查询：客户端主机查询的域名地址无法在本地域名服务器中找到，因此本地域名服务器就以DNS客户端的身份向其他根域名服务器发起请求，进行查询，而不是让客户端主机去一直查询；\n递归查询的结果要么是返回的IP地址，要么是报错，表示无法查询到地址；\n\n5. 迭代查询\n本地域名服务器向根服务器、顶级域名服务器和主机域名服务器发起的查询请求就是迭代的过程，如：本地域名服务器向根服务器发起查询请求，根服务器中会告诉本地域名服务器：”我这里没有你要找的内容，你去顶级域名服务器上找吧“，并将顶级域名服务器的地址返回给本地域名服务器，本地域名服务器接收到后，继续向顶级域名服务器发送请求；顶级域名服务器要么返回ip地址，要么告诉本地域名服务器下一步要向哪个权限域名服务器发送请求，直到找到ip地址或找不到ip返回报错信息，然后信息返回给客户端主机；\n下图给出了这两种查询的差别\n\n递归过程：主机→本地DNS服务器→其他DNS服务器（如：我要找一个苹果吃，找到了A，问A有没有，A说我帮你去找B，B可能有，果真B有，然后B将苹果给了A，A再将苹果给我，这就是递归）\n迭代过程：本地DNS服务器→根服务器，本地DNS服务器→顶级域名服务器，本地DNS服务器→权限域名服务器；（如：我要找一个苹果，找到了A，A说我也没有，B可能有，你去找B吧；我又找B，B说我也没有，你去找C吧，我又去找C，终于找到了苹果，这就是迭代的过程）\n```\n\n #### 2、TCP连接：TCP三次握手\n\n 在客户端发送数据之前会发起 TCP 三次握手用以同步客户端和服务端的序列号和确认号，并交换 TCP 窗口大小信息。\n ![在这里插入图片描述](https://user-gold-cdn.xitu.io/2020/4/12/1716dfdccbdd0461?w=707&h=559&f=png&s=229861)\n\n```\n 说明：\n    Ack：应答\n    Fin：结束; 结束会话\n    Seq： 一个数据段的第一个序列号\n    SYN： 同步; 表示开始会话请求\n```\n\n -  第一次握手：客户端A将标志位SYN置为1,随机产生一个值为seq=X（X的取值范围为=1234567）的数据包到服务器，客户端A进入SYN_SENT状态，等待服务端B确认（第一次握手，由浏览器发起，告诉服务器我要发送请求了）；\n -  第二次握手：服务端B收到数据包后由标志位SYN=1知道客户端A请求建立连接，服务端B将标志位SYN和ACK都置为1，ack=X+1，随机产生一个值seq=Y，并将该数据包发送给客户端A以确认连接请求，服务端B进入SYN_RCVD状态（第二次握手，由服务器发起，告诉浏览器我准备接受了，你赶紧发送吧）。\n -  第三次握手：客户端A收到确认后，检查ack是否为X+1，ACK是否为1，如果正确则将标志位ACK置为1，ack=Y+1，并将该数据包发送给服务端B，服务端B检查ack是否为Y+1，ACK是否为1，如果正确则连接建立成功，客户端A和服务端B进入ESTABLISHED状态，完成三次握手，随后客户端A与服务端B之间可以开始传输数据了（第三次握手，由浏览器发送，告诉服务器，我马上就发了，准备接受吧）。\n\n>**为什需要三次握手？**\n>计算机网络》第四版中讲“三次握手”的目的是“为了防止已失效的连接请求报文段突然又传送到了服务端，因而产生错误”。 书中的例子是这样的，“已失效的连接请求报文段”的产生在这样一种情况下：client发出的第一个连接请求报文段并没有丢失，而是在某个网络结点长时间的滞留了，以致延误到连接释放以后的某个时间才到达server。本来这是一个早已失效的报文段。但server收到此失效的连接请求报文段后，就误认为是client再次发出的一个新的连接请求。于是就向client发出确认报文段，同意建立连接。\n>假设不采用“三次握手”，那么只要server发出确认，新的连接就建立了。由于现在client并没有发出建立连接的请求，因此不会理睬server的确认，也不会向server发送数据。但server却以为新的运输连接已经建立，并一直等待client发来数据。这样，server的很多资源就白白浪费掉了。采用“三次握手”的办法可以防止上述现象发生。例如刚才那种情况，client不会向server的确认发出确认。server由于收不到确认，就知道client并没有要求建立连接。”。主要目的防止server端一直等待，浪费资源。\n\n #### 3、浏览器向web服务器发送HTTP请求\n\n TCP三次握手之后，开始发送HTTP请求报文至服务器（关于HTTP请求报文详解，我单独写了一篇☞[传送门](https://blog.csdn.net/qq_39735040/article/details/96749197)\n\n   HTTP请求报文格式：请求行+请求头+空行+消息体，请求行包括请求方式（GET/POST/DELETE/PUT）、请求资源路径（URL）、HTTP版本号；\n\n![](https://user-gold-cdn.xitu.io/2020/4/12/1716e626c50c96be?w=554&h=154&f=png&s=35651)\n\n #### 4、服务器处理请求并返回HTTP报文\n\n 服务器收到请求后会发出应答，即响应数据。HTTP响应与HTTP请求相似，\n     HTTP响应报文格式：状态行+响应头+空行+消息体，状态行包括HTTP版本号、状态码、状态说明。\n\n![](https://user-gold-cdn.xitu.io/2020/4/12/1716e6220b3d8c04?w=272&h=62&f=png&s=22988)\n\n #### 5、浏览器解析渲染页面\n\n 浏览器拿到响应文本后，解析HTML代码，请求js，css等资源，最后进行页面渲染，呈现给用户。页面渲染一般分为以下几个步骤：\n\n （1）根据HTML文件解析出DOM Tree\n\n（2）根据CSS解析出 CSSOM Tree(CSS规则树)\n\n（3）将 DOM Tree 和 CSSOM Tree合并，构建Render tree(渲染树)\n\n（4）reflow(重排)：根据Render tree进行节点信息计算（Layout）\n\n（5）repaint(重绘)：根据计算好的信息绘制整个页面（Painting）\n\n\n #### 6、TCP四次挥手。\n\n 当数据传输完毕，需要断开TCP连接，此时发起tcp四次挥手\n![](https://user-gold-cdn.xitu.io/2020/4/12/1716e7fa22920ea6?w=836&h=514&f=png&s=84908)\n 1、客户端向服务端发送报文，Fin、Ack、Seq，表示已经没有数据传输了。并进入 FIN_WAIT_1 状态。(由浏览器告诉服务器，我请求报文发送完了，你准备关闭吧)\n\n2、服务端向客户端发送报文，Ack、Seq，表示同意关闭请求。此时主机发起方进入 FIN_WAIT_2 状态。(由服务器告诉浏览器，我请求报文接受完了，我准备关闭了，你也准备吧)\n\n3、服务端向客户端发送报文段，Fin、Ack、Seq，请求关闭连接。并进入 LAST_ACK 状态。(由服务器告诉浏览器，我响应报文发送完了，你准备关闭吧)\n\n4、客户端向服务端发送报文段，Ack、Seq。然后进入等待 TIME_WAIT 状态。被动方收到发起方的报文段以后关闭连接。发起方等待一定时间未收到回复，则正常关闭。(由浏览器告诉服务器，我响应报文接受完了，我准备关闭了，你也准备吧)\n\n简单说就是：\n\n`1、A——>B ：A告诉B：“我发完了”；`\n\n`2、B——>A：B告诉A：“好的，我知道你发完了”`\n\n`3、B——>A：B告诉A：“我收完了”；`\n\n`4、A——>B：A告诉B：“好的，我知道你发收完了”`\n\n\n### 后话\n\n以上基本就是在地址栏从输入 URL 到页面加载显示发生的全过程，当然还有很多的细节没有写进去，不过这些知识对于前端来说已经足够了，有兴趣的小伙伴可以自行深究。\n", "user_name": "ouyang091X", "description": "code搬运工", "got_view_count": 225, "category_name": "前端", "ctime": 1457483942}
{"tag_name": "后端", "concern_user_count": 364361, "user_id": "1380642333405501", "title": "三万字，100张图，1个小时，带后端的同学整体了解 vue 前端架构", "mark_content": "最近写的文章很多，但是非常不爱发布文章了，直到我最近用 notion 搭建了我的博客，重新找回了写文章的初衷，近几年一直在致力于后端，这个教程是我以前闲着没事研究前端架构写的，这次整理博客全部迁移到 notion 上去，顺便整理合并，校对了一下，感兴趣的朋友可以预览一下,专业的前端同学可以不用看了，基于 vue2.0 完成这个教程已经是两年前了，对于专业的你们可能有些过时\n  \n我的 notion 线上 blog ： https://niubility.me   \n\n迁移是个体力活，感兴趣的同学，我可以出个教程，notion 可见即可得\n\n> 这个系列我全部采用了目前比较主流技术栈\n\n\n## 整体大纲的把握\n这个系列文章我尽量照顾前端的同学和后端的同学，不穿插讲述。尽量按照前端-后端-部署-运维来讲，当然中途涉及到**跨域**、**Rest**、**oAuth2.0**这种前后协调的还是无法避免捎带一笔。 \n\n比如:\n\n![](http://www.gitrue.com:9000/image/GA0cLD13AT)\n\n\n  \n  \n这种目录阅读可能对于只掌握 **前端**/**后端** 一种技术栈的同学，或只想去看**后端**/**前端**/**运维** 的同学看上去非常的难受、我会修改大纲避免这个问题,循序渐进的来。\n\n\n## 你会学到\n- 深入了解前后分离，了解常见架构\n\n- 前端后端项目的搭建与优化\n\n- 前端后端技术的选型\n\n- 开发过程中提升效率的小技巧\n\n- 不同场景下跨域的N种解决办法\n\n- 几个良好习惯提升 *debug* 的能力\n\n- 前端的 *Hybrid* 开发自己的 *APP*\n\n- 前端 *SPA* 模式的优化\n\n- 学会爬取我们想要的*资源*\n\n- 后端架构如何向微服务转型\n\n- 如何使用 *docker* 部署微服务\n\n- 如何维护项目的运转\n\n \n如何从零打造一个前后分离的互联网主流 *WEB* 项目、真心希望我能帮到你们。\n\n\n\n\n# Part 2 : 纵观WEB历史演变\n\n\n\n \n\n> 在校学习和几年工作工作中不知不觉经历了一半的 WEB 历史演变、对近几年的发展比较了解，结合经验聊聊 WEB 发展历史。\n\n**演变不易，但也是必然，因为为人始终要进步。**\n\n## WEB 的发展史\n\n\n\n### 一、开山鼻祖 - 石器时代\n\n#### 静态网站\n\n![](http://www.gitrue.com:9000/image/DokGcl5GXc)\n\n\n\n这是 *1997* 年 Apple 官网，那时的网站不如叫网页，像一张浮夸的彩色报纸，那时是纯粹的 *HTML* 时代，不管你是不是访问这个网页，每个页面都是在服务器上存在的。\n\n#### CGI技术\n随后技术性强一点的网站可能会通过 *CGI Perl* 运行一小段代码与数据库或文件系统进行交互。比如：\n\n![](http://www.gitrue.com:9000/image/hgDk1lLR8I)\n这是*1998* 年的 Google ，为了达到搜索条件，不可能用大量的人力去堆砌**静态页面**,所以使用这种方式“曲线救国”，但是 *CGI* 伸缩性不是太好：每个请求分配一个新的进程，不太安全(直接使用文件系统或者环境变量)，同时也没提供一种结构化的方式去构造动态应用程序。\n\n静态网站是最受搜索引擎欢迎的网站，因为它相对固定，所以网站 *SEO* 非常好做，我猜测这也是为什么现在的文档网站大部分都是静态网页的原因之一吧。\n\n>很可惜我没能亲眼看一看这样的时代\n\n \n\n### 二、前人种树 - 文明时代\n#### asp 和 jsp\n*2005* 年左右，先后出现了 微软的 *ASP* 和 *Java Server Pages [JSP]* 等技术,取代了 *CGI* ，增强了 *WEB* 与服务端的交互的安全性、用起来也更加简单，但随着各个公司WEB业务的复杂性，缺点也逐渐暴露出来：\n\n**1、技术单一，难以维护**\n\n![](http://www.gitrue.com:9000/image/7LvZ2jx4Br)\n\n \nJSP页面由HTML代码和嵌入其中的Java代码所组成,用一个比较常见的 *JSP* 代码段举例：\n\n```jsp\n\n<%@ page language=\"java\" contentType=\"text/html; charset=UTF-8\"\n    pageEncoding=\"UTF-8\"%>\n<%\nString path = request.getContextPath();\nString basePath = request.getScheme()+\"://\"+request.getServerName()+\":\"+request.getServerPort()+path+\"/\";\n%>\n    <%@ page import=\"com.zifangsky.OnlineFriend.model.article.ShowByPage\"%>\n<jsp:useBean id=\"showAllTitle\" type=\"com.zifangsky.OnlineFriend.model.article.ShowByPage\" scope=\"session\"/>\n```\n\n\n\n> JSP = HTML+Java\n\n上面的代码 HTML 中大量耦合了JAVA代码，通过JSP编译之后可以在客户端充当部分服务端的角色，这让我们难以搞清服务端的角色，以及增加调试的复杂度。业务稍微复杂一点，试想一下：HTML中掺杂了太多java代码，不论是开发还是维护都是一件痛苦的事情。\n\n**2、不不够灵活**\n JSP与Java Servlet一样，是在服务器端执行的，通常返回该客户端的就是一个HTML文本。我们每次的请求：获取的数据、内容的加载，都是服务器为我们返回染完成之后的 DOM，这也就使得我们开发网站的灵活度大打折扣，在这种情况下，同年：Ajax火了。\n\n\n\n\n####  AJAX 的出现\n为什么说 *2005* 年 ***Ajax*** 火了？因为 *Ajax* 技术并不是 *2005* 年出现的，他的雏形是 *1999* 年。\n\n1999年，微软公司发布IE5，第一次引入新功能：允许javascript脚本向服务器发起HTTP请求[这也就是今天万恶的 ***ActiveX*** 原型]。这个功能当时并没有引起注意，直到2004年Gmail发布和2005年Google Map发布，才引起广泛重视\n\n**Google做了什么事儿？**\n在 2005 年，Google 通过其 Google Suggest 使 AJAX 变得流行起来，他大概是这样的事情：\n\n![](http://www.gitrue.com:9000/image/uYxdJHLGI5)\n\n现在看来很常见的技术手段，当时迅速燃爆了技术圈，以此来实现：**异步交互**\n这样既能增加用户的体验，又能替代掉页面部分的服务端代码，从此， *AJAX* 成为脚本发起 *HTTP* 通信的代名词，次年 *W3C* 也在 *2006* 年发布了 *AJAX* 的国际标准\n\n**总结：**\n\n\n\n\n![](http://www.gitrue.com:9000/image/5ZqyDfHaZZ)\n\n随后各种 *JSP ASP* 的改良模板引擎、全新的交互方式也如雨后春笋一般涌现。并且以 *JAVA* 作为服务端也出现了如 Struts 、 Spring、Hibernate 的老一代框架、采用后端 *MVC* 的方式让构建 *WEB* 应用再一次更加健全, *WEB* 服务正在逐渐由石器时代走向文明时代。\n\n\n### 三、化繁为简 - 工业革命时代\n时光啊不断地飞逝，前端后端也出现了几个潮流。\n\n#### 前端发展\n\n**移动端**\n\n手机已经发展出了一些苗头，网页也区分了web和移动应用两种模式，但移动端限制于当时手机行业的技术，发展较慢。\n\n**Jquery的出现**\n\n出现了非常流行的JavaScript库：jquery，能够快速构建动态、美妙的web应用，完美的封装了Ajax，让开发者开发网页变得优雅。\n\n**SPA的雏形**\n\n![](http://www.gitrue.com:9000/image/bNVlylj3GY)\n\n\n随着文明时代 Ajax 正式提出，加上 CDN 开始大量用于静态资源存储，于是出现了  *SPA （Single Page Application 单页面应用）*，*Backbone EmberJS AngularJS* 这样一批前端框架随之出现，但以当时的配套技术来说，*SPA* 道路并不好走：例如 *SEO* 问题、*SPA* 过多的页面、复杂场景下 *VIEW* 的绑定等，都没有很好的处理。\n\n\n#### 后端发展\n\nStruts 、 Spring、Hibernate 经过几年的发展、SSM这个今天被我们说烂了的词、当时几乎成了当时 JAVA 服务端的 首要选型，我想这也是为什么很多公司、或外包公司依然维护这样一套架构的主要原因。\n\n**总结**\n这几年的飞速发展，为我们节约了大量的经历、降低了开发者和开发过程的门槛，极大提升了开发效率和迭代速度，我称之为**工业时代**\n\n\n**经历**\n\n说出来你可能不信：大三快结束时实习求得的第一份工作，一个人断断续续开发7、8个月，就是钻研这些自技术栈，独立开发出一款web应用 [微宝创业](http://www.weibaochuangye.com),惭愧的说：\n> 项目架构从文明时代 -> 走到最后的工业时代！不断的重构，不断的上线 ，拼命的学习，我很感谢当时老板对我的信任和同事对我的帮助。\n\n\n### 四、百家争鸣 - 技术大爆炸时代\n时光啊他一刻不停，直到今天 -- 技术只能用爆炸来形容。\n\n#### 前端爆炸\n\n![](http://www.gitrue.com:9000/image/2EtbPZzv2m)\n\n工业时代提出的 *SPA* 模型随着 *NODE* 的兴起、服务端、各种工具、容器的飞速发展、前端 *MVC MVVM* 模式逐渐清晰、前端涌现了相当一批优秀的开源项目：\n包管理： ***npm yarn*** \n打包：***grunt gulp***\n模块加载：***RequireJS SeaJs***\n框架：***VUE Angular React***\nhybrid ：***ionic weex react-native electron***\n预处理器：***less sass***\n数据可视化：***echarts hcharts***\n以及提升用户体验的动画，让我们更有“**面子**”\n\n甚至前端也可以使用 **Node** 来构建自己简单的服务端、正在逐渐摆脱“**客户端开发者**”的角色\n\n#### 后端爆炸\n \n ![](http://www.gitrue.com:9000/image/uPnNgkiTLk)\n\n\n**go** \n\n更适合面向服务器编程，以前你如果使用C或者C++做的那些事情，用Go来做很合适，例如、虚拟机处理、文件系统等，强如 docker Kubernetes（k8s）都是 GO 写的\n\n**python**\n\n像一门生物语言，目前看来更容易处理算法、人工智能、网络爬虫、运维方向\n\n**java**\n\n一款20多年的语言，不断的变强。涌现了很多高质量的库，几个有代表性的：\n\n*netty rebbitmq*：轻松实现消息队列\n*elasticSearch*： 轻松实现搜索引擎\n*spring-boot*：   面向配置，更加轻松的构建web服务端\n*spring-cloud、dubbo*：  轻松构建微服务\n\n以及即将迎来的  [**强悍的JAVA11**](https://zhuanlan.zhihu.com/p/38348775) \n\n> 还有 持续集成 云服务 devops 等运维相关\n\n**总结**\n\n*go* 和 *python* 的出现让我们服务端开发者能做更多的事情，比如自动化运维、写中间件。逐渐偏向全栈方向发展。而 JAVA 20多年来的生态圈子发展，能帮助我们写出更健壮的服务。以及狠狠向我们砸来的：人工智能、devops、云服务等技术，令我们眼花缭乱，**开源**成为了一种潮流，技术分享成了每个人都想做的事情，我称之为：**技术爆炸的时代**\n\n**经历**\n\n我近两年很烦恼：如何才能让前后端更加优雅的通信？\n\n曾经使用多种后端模板引擎直到完全摒弃，后到 node 做代理、渲染 + grunt 进行数处理，之后逐渐使用\n> vue + webpack ------>  Rest API \n\n这样如果不得不用 NODE 也只会成为 Rest 中的一员而不用经过 NODE 做繁琐的通信了。这种前后分离的方式达到了满意的效果，前端不必再管后端的事情，后端？写好自己的服务就好了。\n\n\n# Part 3 聊聊前后分离架构\n\n\n\n前后分离，一直是一个相当泛泛的问题，前后分离到底好不好？没有绝对的对，没有绝对的错，业界就这个问题已经激烈的探讨几年了.出现讨论的点在于：分离当然是好的,但是以什么样的服务需要进行前后拆分？拆分到什么粒度？前后端如何配合？\n![](http://www.gitrue.com:9000/image/HMGlXxJJIO)\n\n\n> 截图时间: 2018-08-30 - Github\n\n我们随意在 *Github* 输入**前后分离**关键字，看下搜索的结果: *1K* 的库 *11k* 的 *Issues* 足以说明前后分离的趋势，可以想象激烈程度，业界比较有名的讨论：[Web 前后端分离的意义大吗？](https://www.zhihu.com/question/28207685)，值得一提的是：前排对于这个问题讨论比较深刻的大部分都是**全栈工程师**。因为全栈对全局的了解相对比单纯做前端、后端全局观念更强一些，考虑的问题更多一些。\n\n## 筛简历引发的思考和分析\n![](http://www.gitrue.com:9000/image/vSQR2NOePr)\n---\n![](http://www.gitrue.com:9000/image/qmIFPTGY2G)\n---\n![](http://www.gitrue.com:9000/image/Uudz7xRt7C)\n---\n### 后端职位的怪圈\n\n在公司的简历库随手截几个局部的图，近两年面试过很多的 *1-3* 年 *java* 开发者，在筛选简历和面试过程中，也发现了几个问题：**相当多一部分** *javaer* 技术栈上总是多了那么个 *HTML* *ajax* *jquery* *bootstrap* *easyUi* ，看起来很唐突，如果面试提到了前端技术栈，基本没有能答的很好的，甚至有的人连 **原型链** 都不知道。**这也是大部分人对全栈的误解**，其实我是不太感冒这样的简历的，因为没有什么亮点，技术栈不是写的越多越好，总结起来：他们对前端的掌握很基础，勉强能胜任一些业务上的工作。那为什么这么多人都掌握一些前端技术呢？我分析可能有三点：\n\n### 思考原因：\n\n- 培训机构的兴起，机械化的教学\n\n- 求职者自身的兴趣\n\n- 一些公司的技术栈不全，对技术没有追求，大部分用的几年前的架构，前后业务耦合很大，市场缺口大\n\n### 分析\n因为我也维护过几个月的敏感项目，深有体会，只写服务端的人是无法胜任这项工作的， \n如果多数的 开发者 这样的简历，可以推测：现在的 **IT** 行业中前后端糅杂一起的架构还是存在、并且有一个量级，这导致他们**不得不**寻找一些懂得一点前端技术的人来开发项目，减少沟通的成本，加快项目的进度，这也就催生了很多所谓的 *web* 开发培训机构。\n> 你问我当年维护的开心吗？一会告诉你。\n\n## 什么是前后分离\n\n前后端分离并不是什么新鲜事，到处都是前后端分离的实践。然而一些历史项目在从一体化 Web 设计转向前后端分离的架构时，不可避免的会遇到各种各样的问题。由于层出不穷的问题，甚至会有团队质疑，一体化好好的，为什么要搞前后端分离？说到底，还是技术和思维方式没转变过来。\n\n一体化模式其实在上一开篇：[纵观历史演变](https://github.com/pkwenda/blog/issues/10) 中已经提到过了，不在赘述。\n\n前后分离看起来应该是这样的：\n\n![](http://www.gitrue.com:9000/image/1E5EdYLBJH)\n\n\n前后分离就是在**架构层次**上 构建项目或对现有的项目 **客户端** **服务端** 分离开，减少前后端代码的耦合度，大家一致认同的前后端分离的例子就是***SPA(Single-page application)*** ，所有用到的展现数据都是后端通过 **JSON** 但不仅限于 ***JSON*** 的方式提供的，前端只管展现,提供更好更绚的交互，后端只管提供更健壮的高可用服务。\n\n\n\n千万不要有先写项目，写完再重构的想法，项目初期能一步到位最好，何必再去重构，然后不得已抛弃一些已经写完的组件、库浪费人力呢？\n\n\n\n## 前后分离解决了什么问题\n### 每个人各尽其职\n好的开发者是可与不可求的，若寻找一个 **优秀的** *full_stack* 更是难，从校招进行培养也不太实际，招一个能力一般的程序员，技术驱动性比较差，甚至拖慢产品迭代。分离开来我们就可以专注于 **前端**、 **服务端** 领域去寻找专业的人才。\n\n### 解耦\n\n前端后端代码大量耦合代码看起来是这样的：\n\n![](http://www.gitrue.com:9000/image/Nk3N9JrHVg)\n\n看看简单例子吧：\n\n```js\n//(node端处理)\nif (is_weixin()) {\ninit([\n'api',\n'image',\n'xxx',\n'...',\n], function () {\n<%- doSomeGloble %>\n});\n} else {\n\n}\n//接收node端一些数据\nlet blogs = <%- blogs %>;\n\nlet users = <%- users %>;\n                     \n```\n\n这还不是 ***JAVA*** 模板 而是相对轻量、优雅的 *NODE* 的 *EJS* 渲染的，这还好，我见过更令人难受的代码，经常为了一个问题要回头看 N 多代码，这里就不写了。\n\n那么前后分离如何让它们解耦变得更清晰？后面会结合服务端统一补充。\n\n## 什么项目不适合前后分离\n\n### blog、文档\n你说你搭建一个*博客、 API 文档系统* 这种小项目，一个人就可以开发。搞了一个前后分离，需要分离部署。又增加了 **SEO** 的复杂度，增加了开发的周期、增加了用户部署的难度，何必呢？当然，如果只是技术实践的一种学习方式，还是欢迎的。\n\n\n## 前后分离带来的问题，如何解决？\n\n### 沟通成本问题\n\n> 前端妹子：哥，获取全部博客调哪个接口？\n\n> 哦，昨天不是发你文件了吗\n\n> 前端妹子：我找不到了😭\n\n> 哦，等下吃晚饭发你啊\n\n---\n> 前端妹子：哥，产品提出根据手机壳自动换主题的需求，你有接口吗？\n\n> ... 我看看...应该...没有！可能需要 Python 的老哥支持！你去找他要吧\n\n---\n> 前端妹子：哥，你根据 TAG 获取博客的接口写完了没？接口是啥？我好渲染数据啊\n\n> 没等等......\n\n---\n\n\n这显然是不规范的，我们期望的是前端后端先约定一个接口协议，后端没完成时，前端自己 *mock* 测试数据，前端找不到接口的时候，直接查看 *API* ，根据这个接口协议我们前后端统一编程，那么我们如何处理呢？\n\n\n\n**如何降低沟通成本？**\n 后端数据服务化，走统一的 **REST** 接口规范输出，降低前后端接口定义的沟通成本。避免“口头说明”的方式。\n \n **什么是 RESTful API ？**\n   所以RESTful API就是REST风格的API。 那么在什么场景下使用RESTful API呢？在当今的互联网应用的前端展示媒介很丰富。有手机、有平板电脑还有PC以及其他的展示媒介。那么这些前端接收到的用户请求统一由一个后台来处理并返回给不同的前端肯定是最科学和最经济的方式，RESTful API就是一套协议来规范多种形式的前端和同一个后台的交互方式。\n\n![](http://www.gitrue.com:9000/image/IwZGhdI8Jl)\n\n> 我通常用 *swagger* + *mock* 平台生成标准的 *RESTful API*，同时也支持扩展多个编程语言例如：*Go Python*\n\n\n### *SEO* 问题\n以 *vue* + *webpack* 的 *SPA* 为例，没有了后端模板返回的 *HTML*，前端渲染并不被搜索引擎的爬虫接纳。在日后实战 *SEO* 之前先通俗渲染呗爬虫识别的区别：\n\n> seo 本质是一个服务器向另一个服务器发起请求，解析请求内容。但一般来说搜索引擎是不回去执行请求到的 js 的。也就是说，如果一个单页应用，html 在服务器端还没有渲染部分数据数据，在浏览器才渲染出数据，而搜索引擎请求到的 html 是没有渲染数据的。 这样就很不利于内容被搜索引擎搜索到。 所以服务端渲染就是尽量在服务器发送到浏览器前 页面上就是有数据的。\n\n以博客为例简单聊聊:\n\n-  静态服务\n\n```html\n<div>我是正文1</div>\n<div>我是正文2</div>\n<div>我是正文3</div>\n```\n爬虫直接抓到 *html*   解析 - 生成索引\n\n- 传统后端渲染\n\n```\n @RequestMapping(\"/index\") \n    public String index(HttpServletRequest request,HttpServletResponse   response){ \n        return \"welcome\"; \n    } \n```\n\n这里就比较有意思了，比如我们打开的网址是:\n\n`http://host:port/index`\n实际充当 Controller 的是 服务端，服务端直接返回渲染好的网页给你，爬虫拿到的也是一样，所以 *SEO* 没啥太大的问题。\n\n- 前后分离 *SPA*\n\n```js\nlet blogs = [];\n\nthis.axios.get('/index, {})\n                .then(res => {\n                 blogs = res.data;    \n                })\n                .catch(err => {\n                    console.error(err);\n                });\n                \n             <!--前端模板渲染dom-->   \n <div  v-for=\"(item, index) in blogs\" :key=\"item\">               \n```\n\n同样我们输入\n`http://host:port/index`\n> 注意：SPA 通常有自己的路由策略，这也就是前端 *MVC* *MVVM* 中的 第一个 **M**\n\n![](http://www.gitrue.com:9000/image/LNpy9Htu0T)\n \n> 一个典型的 SPA 站点\n\n我们输入网址先到了这个页面，然后再去异步请求服务器，再由前端页面渲染，又是**单页面服务**如果我们不做任何处理，那么你将被各大搜索引擎抛弃。\n\n**如何解决？**\n\n> 只要做 SEO 的产品就要做服务端渲染,如果你对 SEO 需求有，但要求并不高，仅部分页面、可以曲线救国\n\n*nodejs* 出现之前有两种解决方式，一是做一动一静两套页面，服务器判断请求来自蜘蛛就呈现静态页，否则呈现动态页；二是服务器架设虚拟浏览器软件，请求过来了先让虚拟浏览器跑一遍，再将得到的静态页面返回给客户端。这两种方式在大型项目上都有性能问题。\n\n有了 *nodejs* 后主流做法是前后端同构方案，即一套代码在浏览器端和 *node* 端都可以运行，从而可以先在 *node* 端请求数据渲染模板，然后将渲染结果返回给浏览器最终呈现。感兴趣可以看看 \n[*Vue* 的SSR方案](https://ssr.vuejs.org/zh)\n[*Angular* 的SSR方案](https://www.angular.cn/guide/universal)\n\n\n如何更细致的研究 **SEO** 以后再说\n\n### 跨域\n由于采用前后端分离部署，自然不在一个端口，不在一个端口必然跨域，不过这对现在的技术手段来说完全不是问题\n\n***开发模式***\n为了更快更好的开发，*dev* 下一般采用 *node* 做代理层，解决跨域，几乎无障碍开发，而且可以轻松切换环境。\n\n***部署模式***\n部署一般不依托 *node* 进行部署，通常我们发布到 *HTTP* 服务器，与服务端进行通信，通常使用 *nginx* 进行正向代理。\n\n\n\n# Part4 前端了解多少？\n\n\n\n![](http://www.gitrue.com:9000/image/ZHReAU7RHu)\n\n\n\n## 技术栈的选择\n\n首先我们构建前端架构需要对前端生态圈有一切了解，并且最好带有一定的技术**前瞻性**，好的技术架构可能日后会方便的扩展，减少重构的次数，即使重构也不需要大动干戈，我通常选型技术栈会参考以下三点：\n\n### 一、提出自身业务的需求\n- SEO 是否非常重要？\n- 主要面向：移动端还是 pc 端？\n- 是否有开发 app 的规划？\n\n有了这样的问题我们可以带着问题去重点选型一些这写问题技术方案比较成熟的技术栈。\n\n### 二、自身是否成熟，文档是否友好\n> 这里举一个以前开发过程中实际遇到的，当时为了优化用户体验，节省开发效率 选型了一款 *MVVM* 轻量框架，可惜当时没有决定权，*CTO* 选型了 *avalon* \n\n当时之所以没有选择 backbone  ，主要是因为没有成熟的中文文档，考虑到团队的流动性和上手性暂时没做考虑，最终选择了 司徒正美的 avalon 当时来说还是比较前卫的，也有一些以去哪网为首的大公司都在用。我们当时用的时候 avalon2 刚出不久，直接用的 2.0，使用过程也出现了一点问题：文档离散，这一块那一块，存在后置性，生态少，扩展性价比不高 ，有时候遇到匪夷所思的 bug 寻找原因翻了几遍 demo 、文档 可能会找到答案，没有重点标识。当然就当时来说确实是给我们提升了部分开发效率，但是我可能当时更偏向 Angular 或 vue 的。因为他们有无以伦比的生态圈和各种问题的技术方案以以及完善的开发者文档，值得一提的是 avalon 的作者是兼职维护的，如果全栈运营的话，我相信远比现在更好，看一看 avalon 的源码也会对自己有不少的提升。对于生产的技术选型要更加谨慎。\n\n### 三、了解其生态系统 \n上文提到了生态系统，以我比较常用的 vue 来举例，vue 发展至今仅官方为我们提供了以 **vuex、 vue-router、 vue-loader、 vue-cli、 vuepress、 vue-devtools、 vue-ssr** 为首的 *89* 个开源项目，包括无数的 *vue* 相关的 *UI* 库，*vue* 插件 甚至是近两年淘宝提供的 *Hybrid* ： **weex** 的支持\n\n截止今天 *github* 开源的 与 *vue* 相关的项目多达 *167,752* 个，与 *angular* 相关的多达 *416,811* 个，与 *react* 相关的 多达 *594,272* 个。\n> 统计时间 2018-09-01\n\n我想有了这样的生态支持，完全可以满足我们中小项目的 *95%* 以上的需求，至于比较哪个更强是没有意义的 。\n\n因为比较熟悉让我斗胆私自选择 vue 作为我们的 *SPA* 主架构\n\n\n\n### 四、画出我们期望的前端基础架构模型\n\n**因为我们上一章选型了 Vue，如果只考虑前端我们最初的想法:技术栈大概是这样的：**\n\n![](http://www.gitrue.com:9000/image/h5Ya0WhZqZ)\n\n> 通过 node 和 webpack 的支持 把  vue 组件 *build* 打包成传统元素，发布到 *http* 服务中，请求后端服务。\n\n**随后可能是这样的：**\n\n![](http://www.gitrue.com:9000/image/epKtL5vuvm)\n\n> 随着目前主流第三方库的越来越多和技术的尝鲜、客户端的需求、或被动[不得不用]、或主动的去引用了 babel less sass *.loader 和 hybrid 等组件库。\n\n **再后来的技术栈需要我们根据真正踩坑之后才会逐步完善**\n\n可能是 *polyfill* *懒加载* *xss* *protobuf* 等 针对 **浏览器兼容**、**速度优化**、 **SEO** 、**通信协议** 等具体问题。所以，前期可以不用过多考虑，我们只要知道：这个问题我们是可以解决的，但是现在可以先不去考虑，有些同学，太过于“**完美主义**”以至于想法不错，但动起手来做了几天就不做了，**完美主义害死人**。\n\n\n## 了解 [Webpack](https://www.webpackjs.com/)\nWebPack 可以看做是模块打包机器，它可以分析你的项目结构，找到 JavaScript 模块以及其它的一些浏览器不能直接运行的拓展语言：Stylus、Scss、less、TypeScript、CoffeeScript 等，并将其转换和打包为合适的格式供浏览器使用。比较常用的还可以通过 webpack-dev-server 进行开发模式的**热更新** \n\n**WebPack 是一种模块化开发的方案**\n\n当 webpack 处理应用程序时，它会递归地构建一个依赖关系图(*dependency graph*)，其中包含应用程序需要的每个模块，然后将所有这些模块打包成一个或多个 bundle\n\n\n![](http://www.gitrue.com:9000/image/TXM4cAN7cu)\n\n*webpack* 通过 *loader* 可以支持各种语言和预处理器编写模块，最后打包为一个（或多个）浏览器可识别的 *JavaScript css * 文件\n\n目前支持的 [loader 列表](https://www.webpackjs.com/loaders/) \n\n## 了解 ES6\n\n![](http://www.gitrue.com:9000/image/WWjtS9nDDO)\n\n\n### 官方说法\n\nECMAScript 6（简称ES6）是于2015年6月正式发布的JavaScript语言的标准，正式名为ECMAScript 2015（ES2015）。它的目标是使得JavaScript语言可以用来编写复杂的大型应用程序.\n\n### 科普\n很多人总是搞不清楚 ES 这些东西，这里大白话讲讲：\n他们的先后顺序是：ES5、ES6(ES2015)、ES7、ES8\n\n> 在 2015 年 6 月 ES6 的第一个版本发布， 正式名称就是 《ECMAScript 2015 标准》（简称 ES2015）算是 2011 年 ECMAScript 5.1 之后的 6.0版本\n> 2016 年 6 月，小幅修订的《ECMAScript 2016 标准》（简称 ES2016）[因为改动小，其实他是 6.1 版本，但总有人愿意叫它 ES7 ，不标准的]\n> 2017 年 6 月发布 的《ECMAScript 2017 标准》（简称 ES2017） [因为改动小，其实他是 6.2 版本，但总有人愿意叫它 ES8 ，不标准的]\n\n就像 ***Kubernetes*** 人们开他起了一个 ***K8S*** 的名字 (*K* 和 *S* 中间有 8 个单词)，他是不标准的\n\n\n## 了解 Babel Traceur\n\n![](http://www.gitrue.com:9000/image/La8yS97yuJ)\n\nBabel、Traceur 是一个编译JavaScript的平台，它可以编译代码帮你达到以下目的：\n\n> JavaScript.next-to-JavaScript-of-today compiler\n\n**今天就使用未来的 JavaScript**\n\n截止发布日期 (2018-09-04) ，[没有一款完全支持ES6的JavaScript代理](http://kangax.github.io/compat-table/es6/)（无论是浏览器环境还是服务器环境），所以热衷于使用语言最新特性的开发者需要将ES6代码转译为ES5代码。\n\n让你能使用最新的JavaScript代码（ES6，ES7...），而不用管新标准是否被当前使用的浏览器完全支持； \n\n> ES7 作者完全没精力看 ，不过 Bable 逐渐替代了 Google 的 Traceur 成为主流了，我是个俗人，所以我选 Bable \n\n\n\n\n## 了解 [Sass](https://www.sass.hk/) [Less](http://lesscss.cn/) [Stylus](http://stylus-lang.com/)\n\n![](http://www.gitrue.com:9000/image/L42Jeqojhd)\n\n> Sass 是不是违反了中国的广告法了？？\n\nSass 、Stylus 和 Less 之类的预处理器是对原生CSS的拓展，它们允许你使用类似于variables, nesting, mixins, inheritance等不存在于CSS中的特性来写CSS，CSS预处理器可以这些特殊类型的语句转化为浏览器可识别的CSS语句。\n\n\n- **一张表格对比三语言**\n\n| 语言 | 实现 | 特性 | 赋值 | 缩进 |\n| --- | --- | --- | --- | --- |\n| Sass | Ruby | 变量$开头 | $var: value | 不需要 |\n| Less | JavaSript | 变量@开头 | @var: value | 不需要 |\n| Stylus | NodeJs | 不能使用@开头 | var:10 | 都可以 |\n \n\n\n你现在可能都已经熟悉了，上文讲 WebPack 讲过： webpack 里使用相关 loaders 进行配置就可以使用了，以下是常用的CSS 处理loaders:\n\nLess Loader\nSass Loader\nStylus Loader\n\n自己去找：[loader 列表](https://www.webpackjs.com/loaders/) \n\n> 像：哪种语言更好、使用的更多、更简单 容易引起争议的 博主不想讨论，看自己喜好\n\n\n## 了解 [Electron](https://electronjs.org/) \n\n![](http://www.gitrue.com:9000/image/91rSh78oFI)\n\n一个可以使用使用： JavaScript, HTML 和 CSS 构建跨平台的桌面应用的框架，也算 *hybrid* 的一种，主要场景是 PC 端，没啥好说的。\n\n> 值得一提的是 Visual Studio Code 、Atom、GIthub Desktop 都是基于此构建的，有时候按 CMD + option + i 有惊喜哦\n\n\n[基于 Electron 开发的APP列表](https://electronjs.org/apps)\n\n\n# Part5 快速构建规范的项目骨架 「VUE」\n\n\n\n\n## 初步搭建脚手架\n- **Tips**\n\n> 任何不错的开源项目都有 project-cli 脚手架、我们用它生成往往能**快速**配制出最佳的、理想的脚手架\n\n我通常使用 *cli* 生成项目骨架再在之基础上进行个人修改。\n\n### 什么是 CLI\n> 命令行界面（英语：command-line interface，缩写：CLI）是在图形用户界面得到普及之前使用最为广泛的用户界面，它通常不支持鼠标，用户通过键盘输入指令，计算机接收到指令后，予以执行。也有人称之为字符用户界面\n\n顾名思义  *XXX-CLI* 就是使用命令行生成的 *XXX* 程序。之前写过一款 基于 *nodeJs* 制作个性 *CLI* 的教程\n\n**[如何用node开发自己的cli工具并发布到NPM ](https://github.com/pkwenda/blog/issues/7)** ， 想详细了解制作流程的可以简单看看。\n\n### [vue-cli](https://cli.vuejs.org/zh/)\n\n![](http://www.gitrue.com:9000/image/O6K3FxiGwv)\n\n> 截止 2018-09-02 vue-cli 最新版本为 3.0\n\n*vue* 中文生态非常完善，我们直接去官网看看：\n\nhttps://cli.vuejs.org/zh/\n\n### vue-cli2 和 vue-cli3 的对比\n![](http://www.gitrue.com:9000/image/qUg4EhmtHi)\n\n> 很遗憾，*vue-cli-3* 是 *2018-08-11* 出来的，而我的论坛早在之前就着手搭建了 cli-3 耽误了我一些时间，后面也会提到\n\n#### 简单看看了看 *vue-cli3* 的新特性：\n\n- 可以生成 pwa\n- 支持 UI 界面勾勾选选就可以了\n- 兼容 cnpm 了\n- 搞了一套自己的 vue-cli-service 如下：\n\n![](http://www.gitrue.com:9000/image/zRBgzcD2NK)\n\n> 我这两天不忙的时候就在考虑项目兼容 *vli-3* 但是后来废了很多时间，效果依然不理想，我回滚了代码宣布放弃了。\n\n鉴于使用 *cli-3* 并没有对我的项目有性能上的提升，反而翻遍了我的很多成熟的基础架构，为时间成本考虑，我决定还是使用 cli-2 进行开发，大体目录结构都是一样的。\n\n\n### vue-cli 的安装\n安装前应注意前提条件，避免浪费不必要的时间。\n> *Vue CLI* 需要 *Node.js 8.9* 或更高版本 (推荐 *8.11.0+*)。(如果你用的和我一样 也是 *cli-2* 那么不需要如此新的 *nodeJs* )你可以使用 *nvm* 或 *nvm-windows* 在同一台电脑中管理多个 *Node* 版本。\n\n\n不将远离了，官网比我讲的好得多。\n\n可以使用 *yarn* 或 *npm* 来安装\n\n```\nnpm install -g @vue/cli\n# OR\nyarn global add @vue/cli\n```\n\n我用 NPM 来重新尝试一次 (对 npm 速度表示不理想的 可以尝试淘宝的 [CNPM](https://npm.taobao.org/) 不要过度依赖cnpm)：\n\n```\nlocalhost:~ Venda-GM$ sudo cnpm i @vue/cli -g\n```\n#### TIPS\n> *npm* 中 *install* 可以写成 i , -g 放哪都行 ，--save 可以写成 -S  , --save-dev 可以写成 -D\n\n![](http://www.gitrue.com:9000/image/CmoDalPGVy)\n\n看到这个画面，安装完成了。\n \n ![](http://www.gitrue.com:9000/image/KGjuW2qQpf)\n\n测试一下查看一下版本是不是正确，ok 创建项目：\n\n\n\n```\nvue create new-bee\n```\n### 拉取 2.x 模板 (旧版本)\n*Vue CLI 3* 和旧版使用了相同的 *vue* 命令，所以 *Vue CLI 2* (vue-cli) 被覆盖了。如果你仍然需要使用旧版本的 *vue init* 功能，你可以全局安装一个桥接工具：\n\n```\nnpm install -g @vue/cli-init\n```\n#### `vue init` 的运行效果将会跟 `vue-cli@2.x` 相同\n\n```\nvue init webpack my-project #这样来生成一个 *cli-2* 项目\n```\n\n### 使用 vue-cli-2 生成项目\n\n```shell\nvue init webpack new-bee\n```\n\n下面是我创建项目我所选的选项：\n \n![](http://www.gitrue.com:9000/image/nd8ZpEA8O3)\n\n\n稍微讲讲下面三个：\n\n- vue build 的方式 \n![](http://www.gitrue.com:9000/image/0zTzftalrV)\n> 推荐使用 运行时 + 编译时，通常需要 webpack 编译 .vue 模板。\n\n- 是否选择预先设定的Eslint\n![](http://www.gitrue.com:9000/image/0v0yl6tZvU)\n> 并是不每个人都适合的，有的要求过于严格，我自己有一套成熟的，[代码在这里](https://github.com/pkwenda/Blog/tree/master/effective_config) , 就用自己的了，当然可以基于它做一些删减。\n\n- 它要帮我们执行 install\n![](http://www.gitrue.com:9000/image/6q3Fr3dldZ)\n> 如果你有一个好的socket终端代理，可以用这个，否则可以选择 No 自己用 cnpm 执行\n\n\n\n### 初窥目录结构\n\n让我们来看看 vue-cli2 自动生成的项目目录，我打上标签，为可能不太理解的同学简单描述一下\n\n![](http://www.gitrue.com:9000/image/JPvEfX6vEx)\n\n\n \n\n\n\n这次我们重构的主要目的是规范、更适合多模块多人协作、而不是为了让它看起来更复杂，本文的项目结构、*esLint* 改良、等都是经过项目小组反复的推敲决定的，有一定的生产价值。\n \n\n\n#### 杞人忧天 ： 为 electron 做好准备\n\n\n*cli* 生成的项目 *src* 下面直接就是源码，但是为了考虑以后使用 *electron* 我们再用 *renderer* 包裹一下，规范一点。\n\n> 可以参考一下 [electron-vue ](https://github.com/SimulatedGREG/electron-vue) \n\n#### 兼容Electron的源码目录\n\n![](http://www.gitrue.com:9000/image/Altv98J4Ux)\n\n> tips: 上述截图 *github* 树形目录的插件是 [octotree](https://github.com/buunguyen/octotree) 也可以在谷歌商店直接搜索安装，看源码省去不少时间。\n\n* 先不建立 *electron* 的 *main* 文件夹 和 *index.ejs* 需要添加依赖，目前暂时用不到。\n\n别忘了改一下 *webpack* 相关的路径问题\n\n![](http://www.gitrue.com:9000/image/jOkGCszKi0)\n\n加上 *renderer* 的路径\n\n```javascript\n app: './renderer/src/main.js'\n```\n\n@ 的路径也要在 *webpack* 进行修改，否则会不找组件\n\n![](http://www.gitrue.com:9000/image/fbK6z3NP1w)\n需要改下 *webpack alias* [别名] 配置\n![](http://www.gitrue.com:9000/image/9jTwsiaJ0B)\n\n改之后的样子\n\n```\nalias: {\n      '@': resolve('renderer/src'),\n    }\n```\n\n#### 容器级的目录\n\n在 组件目录(*components*) 同级建立 **容器**(*container*) ：容器里面的各个模块分离开，这样可以使项目**模块**看起来更加清晰。如果十多人协作的项目又能很好地对工作区划分，合理的建立路由，避免不必要的冲突。\n\n> 以目前的[论坛项目](https://github.com/pkwenda/new-bee)为例\n\n![](http://www.gitrue.com:9000/image/eSAq3sGukf)\n \n\n#### 路由目录的调整规范\n\n在 /*router* 下为 */container/blog* 建立 *blog.js*\n\n```javascript\nconst Blog = () => import ( /* webpackChunkName: \"blog\" */ '@/container/blog/index')\n\n/*\n 所有container/blog目录下的路径都配置在此路由children下，避免混乱\n */\nlet routes = [{\n  path: '/blog',\n  name: 'blog',\n  component: Blog,\n  children: [{\n      path: 'blogdemo',\n      component: Blog\n    } \n  ]\n}]\n\n\nexport {\n  routes\n}\n\n// 注意 \n/* webpackChunkName: \"blog\" */ \n//是为了后面的路由懒加载，后面会讲，不懂没关系，现在可以忽略\n\n```\n\n- 自动生成的 *index.js* 主路由是这样的\n\n![](http://www.gitrue.com:9000/image/coaEdMVqML)\n\n- 缺点：\n\n太单一，我们不可能所有的路由都写在里面作为 *children* ，看起来非常混乱，开发调试很难处理，多人协作还很容易引起冲突。\n\n我们尝试将 *blog.js* 引过来\n\n先将 *blog.js* *export* 的路由引过来，起一个别名防止冲突\n\n```\nimport { routes as blogRoutes } from './blog'\n```\n\n因为可能有N多个路由模块，我们将 *routes* 拆分\n\n自动生成的是这样简单的：\n\n```\n//直接导出路由\nexport default new Router({\n  routes: [\n    {\n      path: '/',\n      name: 'HelloWorld',\n      component: HelloWorld\n    }\n  ]\n})\n```\n\n我们拆分成这样：\n\n```\n//定义基础路由\nlet route = [\n  {\n    path: '/',\n    name: 'HelloWorld',\n    component: HelloWorld\n  }\n]\n\n//以此类推可以方便的链接更多路由\nroute = route.concat(blogRoutes)\n\n//导出\nexport default new Router({\n  routes: route,\n  linkActiveClass: 'active'\n})\n```\n\n回过头来，我们为 blog/index.vue 添加一些内容，测试一下：\n\n```html\n<template>\n  <div class=\"Blog\">\n    <h1>{{ msg }}</h1>\n  </div>\n</template>\n\n<script>\nexport default {\n  name: \"Blog\",\n  data() {\n    return {\n      msg: \"Welcome to Your Blog Page\"\n    };\n  }\n};\n</script>\n```\n\n### 测试一下\n首先\n\n```\nnpm install\n```\n嫌慢可以使用淘宝的 cnpm 我以前的文章讲过\n\n```\nnpm run dev\n```\n按照提示在浏览器输入：http://localhost:8080/#/blog\n\n![](http://www.gitrue.com:9000/image/E8KvhAktGK)\n\n\n![](http://www.gitrue.com:9000/image/zrcDvwx3EO)\n\n*vue-cli2 webpack* 生成的项目是支持**热部署**的，所以很多配置不需要自己从零开始配置，这也是我希望大家使用 *CLI* 的原因，省去了一些时间。其他 login 等一些模块 按照这个模式写就可以了。\n\n### 谈谈 *eslint*\n个人觉得 *esLint* 不论是在个人项目还是团队协作中，都是有价值的，它可以让自己、团队的代码风格标准化。现在esLint 甚至可以预测你的代码是否可能会有问题。建议可以制定一些规则，开发时通过你的 IDE(集成环境) ： idea 、WebStorm、 vscode、 之类的插件配合检测，*eslint* 打包检测编译不通过的那种非常严格的初期还是不要尝试了。\n\n我当时参考 *airbnb* 调整的配置，经过一年多的项目实战逐渐调整，目前还算比较合理，[esLint配置规则代码在这里](https://github.com/pkwenda/Blog/tree/master/effective_config)。\n\n### [本章代码在这里](https://github.com/pkwenda/Blog/tree/master/code/web_project_course/start-vue-cli-2/new-bee)\n你甚至可以再 [commit](https://github.com/pkwenda/Blog/commits/master) 里看到本章循序渐进的改造过程\n\n![](http://www.gitrue.com:9000/image/WRw02sYfvC)\n \n\n\n\n\n# Part 6 打磨前端架构\n\n\n\n\n## axios\n\n使用了 vue 的你，发现 Vue 居然不能发请求，于是你 Google 了下，发现可以用 Vue-Resource。\n你去问别人 Vue-Resource 怎么样，他说不要用 Vue-Resource，因为 Vue-Resource 官方已经停止维护了，你应该用 Axios、或者 fetch。但是我们想拥抱 ES6 排除掉了 ES5的fetch（当然也有ES6-fetch），这里我们使用 Axios！\n\n### Tips\n\n 这里呢也科普一下：什么时候依赖需要放到 dependencies、什么时候依赖需要放到 devDependencies：\n>devDependencies：顾名思义，仅在开发（dev）模式下如：webpack.*、*.loader、eslint、babel、打包后部署时完全用不到的、仅在开发需要 编译、检测、转换 的放在这里。\ndependencies：例如：axios、chart、js-cookie、less、lodash、underscore等运行时的库或工具类等相关依赖我们要放在这里\n\n不过基本不用担心，官网都会提供 start 说明，但是我们要大概明白意思，不要机械般的 copy。\n\n### 引入 Axios\n\n- 直接玩最新的\n![](http://www.gitrue.com:9000/image/yAj2OFgAnp)\n\n>*2018-09-28* 截图 npmjs.com \n\n- 添加依赖\n\n```javascript\n\"dependencies\": {    \n    \"axios\": \"^0.18.0\"\n }\n```\n\n![](http://www.gitrue.com:9000/image/t1Uni8dXN2)\n\n> 基于上一章内容,别忘了重新 npm i 下载一下\n\n还记得我们自动生成的 vue 主页面脚本 main.js吗？\n\n### 封装axios\n\n我们在 `src/renderer/utils` 建立一个 `request.js` 在这个请求脚本中，对 Axios 做一些必要的封装，大概内容是用 拦截器 axios.interceptors 对请求和响应做些拦截，定义一下 API 的前缀，处理一些常见的 HTTP 状态码。\n\n- interceptors 文档\n\n![](http://www.gitrue.com:9000/image/HdxeeDV1WT)\n\n我尽可能的为大家写了详细的注释。 \n\n\n```javascript \n// src/renderer/utils/request.js\nimport axios from 'axios'\n\n//这里一般指后端项目API的前缀，例如 /baidu/*/*/1.api  /mi/*/*/2.api\nconst BASE_API = \"\"\n\nexport function axiosIntercept(Vue, router) {\n    const axiosIntercept = axios.create({\n        baseURL: BASE_API\n    })\n\n    //http request 拦截器 一般用来在请求前塞一些全局的配置、或开启一些 css 加载动画\n    axiosIntercept.interceptors.request.use(\n        (config) => {\n            // 判断是否存在token，如果存在的话，则每个http header都加上token\n            // if (store.getters.accessToken) {\n            //     console.log(store.getters.accessToken)\n            //     config.headers.Authorization = `token ${store.getters.accessToken}`;\n            // }\n\n            //todo:加载动画\n\n            //若有需求可以处理一下 post 亦或改变post传输格式\n            if (config.method === 'post') {\n\n            };\n\n            return config;\n        }, function (err) {\n            return Promise.reject(err);\n        });\n\n\n    //http response 拦截器 一般用来根据一些后端协议特殊返回值做一些处理，例如：权限方面、404... 或关闭一些 css 加载动画\n    axiosIntercept.interceptors.response.use(function (response) {\n        // todo: 暂停加载动画\n        return response;\n    }, function (err) {\n        //捕获异常\n        if (err.response) {\n            switch (err.response.status) {\n                case 401:\n                    // do something 这里我们写完后端做好约束再完善\n            }\n        }\n        return Promise.reject(err);\n    });\n    return axiosIntercept;\n}\n\n\n```\n\n大家还记得我们用 vue-cli 生成的 vue 主页脚本 main.js 吧，这里我们需要对 Axios 和 Vue 做一个耦合。\n\n```javascript \n// src/renderer/main.js\nimport axios from 'axios'\nimport { axiosIntercept } from './utils/request'\n\n// 将Axios扩展到Vue原型链中\nVue.prototype.$http = axiosIntercept(Vue)\n```\n这样我们在写业务逻辑，直接在 Vue 的上下文中 使用 this.$http 来发送请求。既实现了拦截、又实现了状态的共享。\n\n**知其然，知其所以然** \n\n- 这样做的意义在哪？\n\n> 节省代码量，让代码更加易读\n\n- 为什么？\n\n> 扩展到原型链，使 Axios 运行时共享 Vue 原型链的内容，减少了很多指代 Vue 的临时变量\n\n- 举个栗子\n\n传统情况\n\n```javascript\nimport axios from 'axios'\n\n\nnew Vue({\n  data: {\n    user: \"\"\n  },\n  created: function () {\n    //此时作用域在 Vue 上,缓存起来,要依赖此变量\n    let _this = this;\n    axios.get(\"/user/getUserInfo/\" + userName).then(res => {\n            if (res.data.code === 200) {\n                //此时作用域在axios上，拿不到vue绑定的值，只能借助刚才缓存的_this上下文\n                _this.data.user = res.data.user\n            }\n        });\n    }\n})\n\n```\n\n代理之后\n\n\n```javascript\n \n\n\nnew Vue({\n  data: {\n    user: \"\"\n  },\n  created: function () {\n    // axios 成为了 vue 的原型链一部分，共享vue状态。\n    \n    this.$http.get(\"/user/getUserInfo/\" + userName).then(res => {\n            if (res.data.code === 200) {\n                //注意，axios回调，应该尽量使用箭头函数，可以继承父类上下文，否则类似闭包，还是无法共享变量、\n                // 更优雅了一些\n                this.data.user = res.data.user\n            }\n        });\n    }\n})\n\n```\n\n> 不懂 prototype 可以翻翻我以前写的文章\n\n\n\n### proxy\n先简单弄一下，为前后分离打个小铺垫\n\n\n\n### webPack\n\n- webPack 的别名\n\n```javascript\nresolve: {\n    extensions: ['.js', '.vue', '.json'],\n    alias: {\n      '@': resolve('src/renderer'),\n    }\n  },\n```\n\n 为了使用起来更加优雅，可以为每个常用的目录都建立别名\n \n ```javascript\n resolve: {\n    extensions: ['.js', '.vue', '.json'],\n    alias: {\n      'vue$': 'vue/dist/vue.esm.js',\n      '@': resolve('src/renderer'),\n      'assets': resolve('src/renderer/assets'),\n      'components': resolve('src/renderer/components'),\n      'container': resolve('src/renderer/container'),\n      'utils': resolve('src/renderer/utils')\n    }\n  },\n ```\n\n\n### 生产和开发的跨域问题\n![](http://www.gitrue.com:9000/image/FmnXlXtCnK)\n\ndev 是开发时启动的指令\nbuild 是预发布时 webPack 打包的指令\n\n假设笔者只是一个前端，通常呢，在开发调试过程当中，无法避免需要与后端的同学进行 API 的对接，那也就难免会出现跨域问题。当然传统 javaWeb 不需要跨域，(ip 域 端口 任何一个不同皆为跨域) 在 DEV 模式调试中，我们都是尽量选择前端环境规避跨域问题，而不会去额外搭建 nginx 或更改后端代码。\n\n跨域只是针对 JavaScript 的，因为开发者认为浏览器上的脚本是不安全的。\n\n既然我们的 vue 项目是 node 全家桶，依靠 node、webPack 编译 我们直接配置 node 的 proxyTable 作为开发的代理器，这样最简单，依次配置，团队受益。\n\n\n\n\n#### cnode 掘金 社区 API 举例\n\nhttps://cnodejs.org/api\n上边cnode 的 API 是可以随意调用的，因为后端做了处理。\n\n看看掘金的：\nhttps://xiaoce-timeline-api-ms.juejin.im/v1/getListByLastTime?src=web&pageNum=1\n请求一下，不出意外浏览器做了跨域报警。\n![](http://www.gitrue.com:9000/image/3QhU14XFTF)\n\n哦，我们适配一下 node 代理\n\n官方例子在这：\nhttps://vuejs-templates.github.io/webpack/proxy.html\n\n扩展一下 proxyTable：\n\n```javascript\n\nproxyTable: [{\n      //拦截所有v1开头的xhr请求\n      context: ['/v1'], \n      target: \"https://xiaoce-timeline-api-ms.juejin.im\",\n      cookieDomainRewrite: {\n        // 不用cookie\n      },\n      changeOrigin: true,//重点，此处本地就会虚拟一个服务替我们接受或转发请求\n      secure: false\n    }],\n\n```\n\n再次发送请求。\n\n- 愉快的拿到了数据\n\n![](http://www.gitrue.com:9000/image/ryhYwQT89O)\n\n这样，前后分离的项目可以这样借助 swagger 测试接口，不需要骚扰任何人。实现自己的业务逻辑，简单实现一点。\n![](http://www.gitrue.com:9000/image/whDpNZImMv)\n\n代码:\n\n```javascript\n// blog/index.vue\n<template>\n  <div class=\"Blog\">\n    <h1>{{ msg }}</h1>\n  <div v-for=\"(blog,index) in blogList\" v-bind:key=\"index\">\n    <h3 >\n      <a :href=\"`https://juejin.im/book/`+blog.id\" >\n        <span>{{blog.title}}</span>\n      </a>\n      </h3>\n  </div>\n  </div>\n</template>\n\n<script>\nexport default {\n  name: \"Blog\",\n  data() {\n    return {\n      msg: \"掘金小册一览\",\n      blogList: []\n    };\n  },\n  created() {\n    this.getBlog();\n  },\n  methods: {\n    getBlog() {\n      this.$http.get(\"/v1/getListByLastTime?src=web&pageNum=1\").then(res => {\n        this.blogList = res.data.d;\n      });\n    }\n  }\n};\n</script>\n```\n\n\n#### 发布\n\n- 扫盲\n\n写完代码之后部署到线上，是不会在线上 clone 代码之后 Npm run dev 的😆，那样会有太多太多的垃圾依赖，为用户带来了灾难性的网络请求，通常借助webPack打包之后发布到服务器的web服务当中。\n\n运行\n\n```\n npm run build\n```\n\n![](http://www.gitrue.com:9000/image/GCxys1jfzU)\n\n打包目录是之前配置的webpack\n\n\n![](http://www.gitrue.com:9000/image/aqi8o2otzo)\n\n![](http://www.gitrue.com:9000/image/z87CykBv3r)\n\n\n好了，很多人直接双击 index.html 是不行的。\n>Tip: built files are meant to be served over an HTTP server.\n  Opening index.html over file:// won't work.\n  \n需要 http 服务启动，可以扔到本地或服务器的 nginx、apache、tomcat等容器测试，我通常使用 python 启动一个 http 服务来运行（脚本地址）、当然,自己 ide 支持 http 启动也可以。\n\n#### 生产中的跨域\n\n生产当中，因为前端后端必然不同端口，避免跨域，通常使用 nginx 的正向/反向代理作为跨域的手段。（并非负载均衡，两个概念）\n\n```\nserver {\n        listen       80;\n        server_name  localhost;\n \n        location ^~ /v1 {\n        proxy_pass              https://xiaoce-timeline-api-ms.juejin.im;#代理。\n        proxy_set_header        X-Real-IP $remote_addr;#转发客户端真实IP\n        proxy_set_header        X-Forwarded-For $proxy_add_x_forwarded_for;\n        proxy_set_header        Host $http_host;\n        }\n }       \n```\n\n简单配置一下就可以了，不多讲，前端同学了解一下就可以了，nginx 能干的事情还有很多。\n\n### API 的规范化\n你是否为了找某一个业务的接口头痛\n你是否还在使用全局搜索找自己的接口\n你是否某一个接口不同组件重复写了多次\n整理一下自己的接口吧，像上文的 router 一样整齐的划分吧。\n\n![](http://www.gitrue.com:9000/image/0nbBt8l1Tc)\n\n\n/renderer 下建立一个 api 的文件夹\n\n![](http://www.gitrue.com:9000/image/rYiDinlXNv)\n\nwebpack.base.conf.js 添加一条 api 的别名，方便我们日后大量调用\n\n\n```\n'api': resolve('src/renderer/api')\n```\n\n我们建立 /renderer/api/juejin.js\n\n```javascript\n\nimport axios from 'axios'\n\nlet Api = Function()\n\nApi.prototype = {\n    getBlog(page, fn) {\n        axios.get(`/v1/getListByLastTime?src=web&pageNum=${page}`).then(res => {\n            // if (res.data.code === 200) {\n            fn(res.data)\n            // }\n        }).error()\n    }\n}\nexport default new Api()\n\n\n```\n\n修改一下我们刚才 /blog/index.vue 的 Axios 请求：\n\n- 先引入 api\n\n```\nimport juejin from \"@/api/juejin\";\n```\n注掉之前离散的 axios ，使用从 api 中定义过的 XHR 请求数据。\n\n```javascript\ngetBlog() {\n      // this.$http.get(\"/v1/getListByLastTime?src=web&pageNum=1\").then(res => {\n      //   this.blogList = res.data.d;\n      // });\n      juejin.getBlog(\"1\", response => {\n        this.blogList = response.d;\n      });\n    }\n```\n\n![](http://www.gitrue.com:9000/image/NEEExyDHOY)\n\n\n# Part 7 快速构建网站布局\n\n\n\n \n本文为方便讲述重构去除了 Element、vux 库，用了最近比较火的 bulma 轻量、快捷、易读。\n\n![2018-11-22-15.58.03.gif](http://www.gitrue.com:9000/image/qNfc2oEEyR)\n\n> 项目截屏\n### Layout and Components\n\n![design_web_layout.png](http://www.gitrue.com:9000/image/mUiW85X1C5)\n\n#### Layout\n\n首先，似上图，我们思考把一个小型网站拆成三部分：页头(Header)、内容(Content)、页脚(Footer) 这几乎每个网站内都必须有的，通常把万年不变的：页头(Header)、页脚(Footer) 制作成 Layout 方便通用。\n\n#### Components\n\n\n再把内容(Content)根据业务进行拆分成 组件(Components)\n\n![1A8A610A-E0AF-4794-96B0-D38B0C39D585.jpg](http://www.gitrue.com:9000/image/YbKmDWEZ46)\n\n如上图：Header 和 Content ：Header其实没有拆分的必要，没有可以重用的组件，而 Conntent 是必须要拆分的布局元素。因为动态网站 Conntent 随着内容的变化而变化，内容多，可重用的东西的概率越高，需要把能重用的东西提炼出来\n\n1、节省代码、提高代码阅读性\n\n2、便于修改 （比如更新广告）\n\n\n## 开始写代码\n\n接着我们的 [第二章上传的源码](https://github.com/pkwenda/Blog/tree/master/code/web_project_course/2-complete_project/new-bee) 开始，基于它继续完善小网站布局和组件化。\n\n> 值得一提的是：本系列教程一章跟随一章并且每一章可以独立运行，章与章之间完美衔接，没有 “突然出现” 的代码段。不会给新手无从下手的感觉，如果那你对代码陌生，那你该认真翻翻往期文章了。你可以基于上一章逐步写代码，也可以下载本章简单预览代码。\n\n- 引入 bulma 样式 CDN \n\n```\nvim new-bee/index.html\n```\n\n```\n\n <!-- font -->\n  <link href=\"//cdn.bootcss.com/font-awesome/4.7.0/css/font-awesome.min.css\" rel=\"stylesheet\">\n  <!-- css -->\n  <link rel=\"stylesheet\" href=\"https://cdnjs.cloudflare.com/ajax/libs/bulma/0.6.0/css/bulma.min.css\">\n\n```\n\n- 新建 Layout 目录\n\n```\nvim new-bee/src/renderer/components/layout\n```\n\n- Layout 目录下建立 Header.vue 模板组件\n\n\n这个组件专门写头部的内容，最好配合栅格尽可能写出简单的响应式组件\n\n```html\n<template>\n\n    <div id=\"bee-header\"   element-loading-text=\"正在努力请求github...\" element-loading-background=\"rgba(0, 0, 0, 0.8)\">\n        <!-- 遮罩 -->\n        <div  :class=\"  loading ? `modal is-active` : `modal` \" style=\"background-color: #ffffff36\">\n                < img src=\"https://img.actd.tw/images/2018/11/17/ez-4-05f4bba41fef\" style=\"width: 300px\" alt=\"\">\n        </div>\n\n        <div class=\"is-underline \">\n    <div class=\"container\">\n      <nav class=\"navbar \">\n        <div class=\"navbar-brand\">\n          <a class=\"navbar-item\"   >\n            < img src=\"https://img.actd.tw/images/2018/11/17\" alt=\"Bulma: a modern CSS framework based on Flexbox\" width=\"92\" height=\"28\">\n          </a >\n          <div class=\"login-before is-hidden-mobile\" style=\"padding-top: 5px;\">\n            <a class=\"navbar-item is-hidden-desktop\" href=\" \" target=\"_blank\">\n              <span class=\"icon\" style=\"color: #333;\">\n                <i class=\"fa fa-lg fa-github is-size-2\"></i>\n              </span>\n            </a >\n          </div>\n          <div class=\"navbar-item is-hidden-desktop \">\n             <div class=\"field has-addons\"  ><div class=\"control\" ><input   type=\"input\" class=\"input\" name=\"email\" placeholder=\"搜索一下\" required=\"required\" style=\"height: 36.4px;width:130px\"><input   type=\"hidden\" name=\"redirect\" id=\"name\" value=\"/fr/#thanks\"></div><div class=\"control\"  ><input  type=\"submit\" class=\"button is-warning\" value=\"GO\"></div></div>\n          </div>\n           \n          <div class=\"navbar-burger burger\" data-target=\"navMenuDocumentation\" >\n            <span></span>\n            <span></span>\n            <span></span>\n          </div>\n        </div>\n\n        <div id=\"navMenuDocumentation\" class=\"navbar-menu\">\n          <div class=\"navbar-start\">\n            <div class=\"navbar-item has-dropdown is-hoverable\">\n              <a class=\"navbar-link  is-active\">\n                发现\n              </a >\n              <div class=\"navbar-dropdown \">\n                <a class=\"navbar-item \" type=\"收藏集\">\n                  收藏集\n                </a >\n                <a class=\"navbar-item\" type=\"徽章\">\n                  徽章\n                </a >\n                <a class=\"navbar-item \" type=\"排名\">\n                  排名\n                </a >\n                <a class=\"navbar-item \"  type=\"职场生活\">\n                  职场生活\n                </a >\n              </div>\n            </div>\n            <a class=\"navbar-item \" href=\"https://bulma.io/expo/\">\n              <!--<span class=\"bd-emoji\">⭐️</span>-->\n              专栏\n            </a >\n            <a class=\"navbar-item \" href=\"https://bulma.io/expo/\">\n              <!--<span class=\"bd-emoji\">⭐️</span>-->\n              聊天\n              <!-- 很多人不知道干什么。。。 -->\n            </a >\n            <a class=\"navbar-item \" href=\"https://bulma.io/expo/\">\n              <!--<span class=\"bd-emoji\">⭐️</span>-->\n              面经\n            </a >\n            <router-link class=\"navbar-item \" to=\"/book\">\n              <!--<span class=\"bd-emoji\">❤️</span>-->\n              书籍\n            </router-link>\n          </div>\n\n          <div class=\"navbar-end\">\n            <div class=\"login-before\" style=\"padding-top: 5px;\">\n              <!-- pc -->\n              <a class=\"navbar-item is-hidden-desktop-only\" href=\"https://github.com/pkwenda/my-bbs\" target=\"_blank\">\n                <span class=\"icon\" style=\"color: #333;\">\n                  <i class=\"fa fa-lg fa-github is-size-2\"></i>\n                </span>\n              </a >\n            </div>\n\n            <div class=\"navbar-item is-hidden-mobile \">\n               <div class=\"field has-addons\"  ><div class=\"control\" ><input   type=\"input\" class=\"input\" name=\"email\" placeholder=\"搜索一下\" required=\"required\" style=\"height: 36.4px;\"><input   type=\"hidden\" name=\"redirect\" id=\"name\" value=\"/fr/#thanks\"></div><div class=\"control\"  ><input  type=\"submit\" class=\"button is-warning\" value=\"GO\"></div></div>\n            </div>\n\n            <div class=\"navbar-item is-hidden-mobile \">\n              <!--<span class=\"icon is-medium\">-->\n              <i class=\"iconfont icon-tixing\"></i>\n              <!--</span>-->\n            </div>\n\n               \n            <div class=\"navbar-item has-dropdown is-hoverable\">\n              <a class=\"is-hidden-mobile\"  target=\"_blank\">          \n              < img src=\"https://avatars2.githubusercontent.com/u/14212375?s=400&u=dc515636befebfda36501309d1cdc087ee31d500&v=4\" class=\" header-avatar img-circle \"\n                                  style=\"margin-top: 10px\">\n              </a >\n              <div class=\"navbar-dropdown \">\n                <a class=\"navbar-item \" type=\"收藏集\">\n                  写文章\n                </a >\n                <a class=\"navbar-item\" type=\"徽章\">\n                  设置\n                </a >\n                <a class=\"navbar-item \" type=\"排名\">\n                  退出\n                </a >\n              </div>\n            </div>   \n            \n \n           \n            <div class=\"login-before\">\n              <div class=\"navbar-item\">\n                <div class=\"field is-grouped\">\n                 \n                  <p class=\"control\">\n                    <a class=\"button is-warning\"  v-show=\"!isLogin\"  >\n                      <strong>登录</strong>\n                    </a >\n\n                  </p >\n\n                </div>\n              </div>\n            </div>\n          </div>\n        </div>\n      </nav>\n    </div>\n  </div>\n    </div>\n</template>\n\n\n<script>\nexport default {\n  name: \"BeeHeader\",\n\n  data() {\n    return {\n      popupShow: false,\n      isLogin: false,\n      user: {},\n      loading: false,\n      userInfo: {}\n    };\n  },\n  created() {},\n  destroyed() {},\n  mounted() {},\n  methods: {}\n};\n</script>\n\n<style scoped>\n.img-circle {\n  -webkit-border-radius: 50%;\n  -moz-border-radius: 50%;\n  border-radius: 50%;\n}\n</style>\n\n```\n\n### 什么样式可以写在 .vue 文件中\n\n上文的比较熟悉的代码是让我们的头像变圆的代码段\n\n```\n<style scoped>\n.img-circle {\n  -webkit-border-radius: 50%;\n  -moz-border-radius: 50%;\n  border-radius: 50%;\n}\n```\n\n- 效果\n\n![-2018-11-22-18.45.39.png](http://www.gitrue.com:9000/image/OLflLsApEN)\n\n这里我偷了个懒，刚好可以说一说，对于如此通用的样式，局限在 .vue文件中，并且以 scoped 标示，宣判了它无法复用的事实，任何模块想用这个样式，都需要复制一份，显然是不规范的，我们通常还会建立通用的 css 文件进行管理，大型项目 css 管理规范将更加严格、规范的树级结构，具体就看 CTO 的想法了。\n\n\n### 根据喜好选择如何布局\n\n#### 按需引入\n\n```\nvim new-bee/src/renderer/components/HelloWorld.vue\n```\n\n```\n<template>\n    <div>\n   <Header></Header>\n     <!--<div class=\"container\"> </div>-->\n    </div>\n</template>\n\n<script>\nimport Header from \"@/components/layout/Header\";\nexport default {\n  name: \"NewBeeIndex\",\n  components: { Header },\n  data() {\n    return {};\n  },\n\n  destroyed() {},\n  mounted() {},\n  methods: {},\n  watch: {}\n};\n</script>\n```\n\n缺点是要一个一个引入，但优点是代码可读性高\n\n#### 全局引入\n\n- App 主入口\n\n```\nvim  new-bee/src/renderer/App.vue\n```\n\n- 引入\n\n```html\n<template>\n  <div id=\"app\">\n     <Header></Header>\n    <!-- < img src=\"./assets/logo.png\"> -->\n    <router-view/>\n  </div>\n</template>\n\n<script>\nimport Header from \"@/components/layout/Header\";\nexport default {\n  name: \"App\",\n  components: { Header }\n};\n</script>\n\n<style>\n</style>\n\n\n```\n- 查看效果\n\n![-2018-11-22-18.38.31.png](http://www.gitrue.com:9000/image/7ARqQ5O5rZ)\n\n\n基于 webpack 爸爸的热部署，我们无需刷新浏览器，webpack 偷偷用 ws 更新了我们的内容。似乎很完美，但是也许大家发现了一个问题，我们通过浏览器渲染出来的 dom 就可以看到：：\n\n[![-2018-11-22-19.08.58.md.png](http://www.gitrue.com:9000/image/kH0X0i6eMr)](https://img.actd.tw/image/TiN)\n\n\n\n我们在主 APP 入口引入了头部布局， App.vue 是紧临 <body> 元素的正文元素，而这个程序所有页面、子路由全部都是 App.vue 入口的子集，说明全局引入布局会存在如下问题：\n\n \n1、这个项目所有的项目都一定会带上 Header 组件渲染的内容 \n2、而且会影响在下期 《性能优化》中讲的 webpack 按需加载的性能。\n\n> 当然可以再 Header 组件上书写逻辑条件,过滤指定的路由，但会破坏项目的易读性，难以维护\n> \n>   我个人是比较推荐第一种：按需引入的方式。\n\n\n### 继续布局\n\n- 照猫画虎写好 Footer\n\n```\nvim new-bee/src/renderer/components/layout/Footer.vue\n```\n\n```\n<template>\n    <footer class=\"footer footer-light-medium \" style=\"padding-bottom: 20px;padding-top: 20px;\">\n    <div class=\"container\">\n        <div class=\"columns\">\n            <!-- Column -->\n            <div class=\"column is-4\">\n                <div class=\"mb-20\">\n                    < img class=\"small-footer-logo\" src=\"https://img.actd.tw/images/2018/11/17/\" alt=\"\">\n                    <div class=\"footer-description pt-10\">\n                        new bee 是一个为开发者提供的专注于技术分享的开源社区,所有源码均可在 github 上找到,希望对广大开发者有所帮助。\n                    </div>\n                </div>\n                <div>\n                    <span class=\"moto\">喜欢项目可以点赞支持  <a href=\"https://github.com/pkwenda/new-bee\" target=\"_blank\">\n                            <span class=\"icon\"><i class=\"fa fa-github\"></i></span>\n                        </a >.</span>\n                    <div class=\"social-links mt-20\">\n                         \n                        \n                    </div>\n                </div>\n            </div>\n            <!-- Column -->\n            <div class=\"column is-6 is-offset-2\">\n                <div class=\"columns\">\n                    <!-- Column -->\n                    <div class=\"column\">\n                        <ul class=\"footer-column\">\n                            <li class=\"column-header\">\n                                Links\n                            </li>\n                            <li class=\"column-item\"><a href=\"https://github.com/pkwenda/new-bee\">Home</a ></li>\n                            <li class=\"column-item\"><a href=\"https://cssninja.io/themes\">Blog</a ></li>\n                            <li class=\"column-item\"><a href=\"https://github.com/pkwenda/new-bee/wiki\">Wiki</a ></li>\n                        </ul>\n                    </div>\n                    <!-- Column -->\n                    <div class=\"column\">\n                        <ul class=\"footer-column\">\n                            <li class=\"column-header\">\n                                Ressources\n                            </li>\n                            <li class=\"column-item\"><a href=\"https://cssninja.io/help\">Help center</a ></li>\n                            <li class=\"column-item\"><a href=\"https://cssninja.io/blog\">Blog</a ></li>\n                            <li class=\"column-item\"><a href=\"https://cssninja.io/help/rules\">Rules</a ></li>\n                        </ul>\n                    </div>\n                    <!-- Column -->\n                    <div class=\"column\">\n                        <ul class=\"footer-column\">\n                            <li class=\"column-header\">\n                                Terms\n                            </li>\n                            <li class=\"column-item\"><a href=\"https://cssninja.io/help/terms/licenses/personal\">Personal</a ></li>\n                            <li class=\"column-item\"><a href=\"https://cssninja.io/help/terms/licenses/developer\">Developer</a ></li>\n                            <li class=\"column-item\"><a href=\"https://cssninja.io/help/terms/service\">Terms of Service</a ></li>\n                        </ul>\n                    </div>\n                </div>\n            </div>\n        </div>\n    </div>\n</footer>\n</template>\n\n\n<script>\nexport default {\n  name: \"Footer\",\n  data() {\n    return {};\n  },\n  created() {},\n  destroyed() {},\n  mounted() {\n\n  },\n  methods: {}\n};\n</script>\n\n```\n\n> 别忘了在 HelloWorld 引入一下\n\n- 看看效果\n\n![-2018-11-22-19.46.28.png](http://www.gitrue.com:9000/image/zPOvxAyyWi)\n\n\n- 看起来效果还不错，接下来是 Content（正文）部分\n\n```\nvim new-bee/src/renderer/components/layout/Content.vue\n```\n\n```\n<template>\n\n      <div class=\"container\" style=\"height:700px\">\n        <h1  >博客列表</h1>\n          <article class=\"column is-3\"   v-for=\"blog in blogs\" v-bind:key=\"blog\"> \n            <a   class=\"bd-article-image is-bootstrap\" >\n            <span class=\"bd-article-overlay\"></span>\n            <span class=\"bd-article-icon\">\n                <i class=\"fa fa-tag\"></i>\n            </span>\n            <strong class=\"bd-star-icon\" ><i class=\"fa fa-star\"></i> <span style=\"font-size: 1rem\">&nbsp;{{blog.commendCount}}</span></strong>\n            <strong class=\"bd-article-info\">\n                <span>\n                <time class=\"bd-article-date\" datetime=\"2017-10-09T00:00:00+00:00\">\n                    {{blog.tag}}\n                </time>\n                <strong class=\"bd-article-title\">\n                    {{blog.title}}\n                </strong>\n                </span>\n            </strong>\n            </a>\n        </article>\n      </div>\n</template>\n\n\n<script>\nlet article = { tag: \"java\", title: \"java\", commendCount: 0 };\nexport default {\n  name: \"Footer\",\n  data() {\n    return {\n      blogs: [\n        article,\n        article,\n        article,\n        article,\n        article,\n        article,\n        article,\n        article\n      ]\n    };\n  },\n  created() {},\n  destroyed() {},\n  mounted() {},\n  methods: {}\n};\n</script>\n\n<style scoped>\n.bd-article-image.is-bootstrap {\n  background-color: #6f5499;\n}\n.bd-article-image {\n  background-color: #00d1b2;\n  display: block;\n  height: 240px;\n  margin-left: auto;\n  margin-right: auto;\n  position: relative;\n  text-align: center;\n}\n\n.bd-star-icon {\n  font-size: 19.2px;\n  font-size: 1.2rem;\n  color: #0a0a0a;\n  opacity: 0.25;\n  bottom: 10px;\n  left: 30px;\n  position: absolute;\n  -webkit-box-align: center;\n  -ms-flex-align: center;\n  -webkit-align-items: center;\n  align-items: center;\n  display: -webkit-box;\n  display: -ms-flexbox;\n  display: -webkit-flex;\n  display: flex;\n  -webkit-box-pack: center;\n  -ms-flex-pack: center;\n  -webkit-justify-content: center;\n  justify-content: center;\n}\n.bd-article-icon,\n.bd-article-info {\n  bottom: 0;\n  left: 0;\n  position: absolute;\n  right: 0;\n  top: 0;\n  -webkit-box-align: center;\n  -ms-flex-align: center;\n  align-items: center;\n  display: -webkit-box;\n  display: -ms-flexbox;\n  display: flex;\n  -webkit-box-pack: center;\n  -ms-flex-pack: center;\n  justify-content: center;\n}\n.bd-article-info {\n  padding: 20px;\n}\na strong {\n  color: currentColor;\n}\n.bd-article-date {\n  color: rgba(0, 0, 0, 0.5);\n  display: block;\n}\n.bd-article-title {\n  color: white;\n  display: block;\n  font-size: 1.8rem;\n  font-weight: 700;\n  line-height: 1.25;\n  padding: 0 20px;\n}\n.bd-article-icon {\n  color: #0a0a0a;\n  opacity: 0.25;\n}\nh1 {\n  text-align: center;\n  font-size: 30px;\n}\n\n.column.is-3,\n.column.is-3-tablet {\n  -webkit-box-flex: 0;\n  -ms-flex: none;\n  flex: none;\n  width: 25%;\n  float: left;\n}\n</style>\n\n\n```\n\n- 看看效果\n[![-2018-11-22-22.31.22.md.png](http://www.gitrue.com:9000/image/bhU2ODG5eq)](https://img.actd.tw/image/9VP)\n\n- HelloWorld.vue 代码看起来是这样的\n\n[![-2018-11-22-19.52.42.png](http://www.gitrue.com:9000/image/rZnwH8GSKi)](https://img.actd.tw/image/380)\n\n还算看得过去，我们继续参照图二\n\n![design_web_layout.png](http://www.gitrue.com:9000/image/mUiW85X1C5)\n\n为 Content 制定 AD(广告) 组件。 \n\n\n```\nvim new-bee/src/renderer/components/common/AD.vue\n```\n\n```html\n\n<template>\n     \n             <div class=\"ad\"><h1>澳门XX赌场上线啦</h1></div>\n    \n</template>\n\n<script>\nexport default {\n  name: \"AD\",\n\n  data() {\n    return {};\n  },\n  destroyed() {},\n  mounted() {},\n  methods: {},\n  watch: {}\n};\n</script>\n <style   scoped>\n.ad {\n  width: 150px;\n  height: 180px;\n  background-color: #ececec;\n  position: fixed;\n  right: 30px;\n  top: 80px;\n}\n</style>\n \n```\n\n- 别忘了在 Content.vue 引入一下\n\n```html\n...\n<AD></AD>\n...\nimport AD from \"@/components/common/AD\";\nexport default {\n  name: \"Content\",\n  components: { AD },\n  ...\n  }\n```\n\n- 看下效果\n\n![2018-11-22-22.45.30.gif](http://www.gitrue.com:9000/image/1yIaneQlVL)\n\n- 对比一下我们之前 sketch 画的草图\n\n![design_web_layout.png](http://www.gitrue.com:9000/image/mUiW85X1C5)\n\n差不多完成了我们初步的构思\n\n\n\n\n# Part 8 前端性能优化\n\n\n\n## 本节橄榄\n\n- 前端需要了解的 docker 基础知识\n- 部署前端项目到本地/外网服务\n- 前端项目的 gZip 优化\n- 了解 CDN 的重要性\n- webpack 按需加载\n- 图片的相关优化\n- 如何分析项目依赖，方便针对性处理\n- 如何减小 webpack 打包大小/速度\n\n##  上线 \n\n我们通常在本地开发，本地环境和线上也并非完全一样，很多项目第一次上线几乎都会遇到本地开发无法复现的问题，可能是字体、样式的问题，也可能是webpack 编译的问题、甚至可能是本地的奇葩环境。所以  本地完美运行 ≠ 线上完美运行，我们需要 build 项目，模拟线上测试一下，看看是否可以完美运行，有问题可以方便及时作出调整。\n\n### 准备\n\n>为了避免本教程污染大家本地环境，推荐大家安装一个docker，后期运维也会根据 docker 展开。\n\n看到这个 Title ：《准备docker》，没接触过的前端不要怂，装一个，勇于跨出第一步，不学习就是等死「[点击这里了解 docker](http://www.docker-cn.com)」\n\n虽然 `tomcat nginx apache jboss jetty `等等等等都可以作为 http 服务，本章以最常见的 nginx 展开讲述：\n \n## 大白话介绍下 docker\n\ndocker 就是用更优雅的方法，做到了虚拟机的事情，并且做的更好，可编程管理集群。docker 启动容器，在容器内部运行你的环境，默认各个容器是互相隔离的，当然你可以通过 link network 关联容器，或者直接使用 docker-compose 编排，启动容器的前提是镜像，也类似与虚拟机的镜像，想跑容器，先得下载「pull」镜像。\n\n## 使用 docker\n\n也许很多人没用过，没用过也不讲怎么安装了，自己去看官网吧[中文官网](http://www.docker-cn.com)、[社区版下载](http://www.docker-cn.com/community-edition)、[中国镜像加速](http://www.docker-cn.com/registry-mirror)，windows 的话可能要开启虚拟化，linux 推荐 ubuntu， 有篇文章这样讲：[为了性能请不要在 centos中运行 Docker](https://www.linux-toys.com/?p=374) ， [查看翻译点这里]([](http://www.dockone.io/article/972))，几年前的文章了，现在怎么样有待考究。\n\n### 看下 images 状态\n\n```\ndocker images\n```\n\n![屏幕快照 2018-11-27 16.28.03.png](http://www.gitrue.com:9000/image/F1QaCXU55P)\n\n可以看到我已经有一些镜像了「我已经删除了nginx」\n\n\n### dockerHub 拉 Nginx 镜像 \n\n```\ndocker pull registry.docker-cn.com/library/nginx:latest\n```\n\n> 正常 docker pull nginx 即可，中间那段是中国镜像源\n\n![2018-11-27 16.28.54.gif](http://www.gitrue.com:9000/image/B8QAyVAzTo)\n\n\n![屏幕快照 2018-11-27 16.33.04.png](http://www.gitrue.com:9000/image/Zgypo7kaVi)\n\n\nok，我们成功 pull 下来了 Nginx 的镜像。默认存储的镜像名为： registry.docker-cn.com/library/nginx \n\n## 打包\n\n进入我们上一章源码的目录，build 一下进行发布。\n[上一章源码在这里](https://github.com/pkwenda/Blog/tree/master/code/web_project_course/3-layout/new-bee)\n \n```sh\nnpm run build\n```\n\n![2018-11-27 16.43.35.gif](http://www.gitrue.com:9000/image/qnfn26w0zm)\n\n\n### 启动 docker 容器\n\n\n```shell\ndocker run --name nginx -d -p 8888:80 -v /new-bee/dist:/usr/share/nginx/html  registry.docker-cn.com/library/nginx\n```\n\n![2018-11-27 16.55.18.gif](http://www.gitrue.com:9000/image/3moBJbU2AG)\n \n\n\n- 上调命令一些解释「不多讲，避免消化不良，自己探究」\n\n\n| CMD | 解释  |\n| --- | --- |\n| -d  | 守护进程运行 |\n| -p | 端口映射   8888 ：80 docker80端口映射到本机「宿主机」 |\n| -v | 挂载宿主机的一个目录  本机「宿主机」: docker容器 |\n| —name | 为容器命名 |\n\n### 测试一下\n\n```\nhttp://localhost:8888/#/\n```\n\n![2018-11-27 17.06.00.gif](http://www.gitrue.com:9000/image/ScN0E2S7bu)\n\n\n\n\n当然初次尝试 docker 你可能会有更多的疑问：\n\n- 你怎么知道需要将主目录挂载到： /usr/share/nginx/html ? \n- 能否/怎样 查看 Nginx 日志 ?  \n- 容器内的 nginx 能否自定义配置 ? \n-  ......\n\n这些小白问题本章简单讲讲，后面做自动运维的时候单独展开讲，可以关注[我的博客](https://github.com/pkwenda/Blog)\n\n\n## gZip\n\n我们可以通过 webpack 压缩脚本文件，上传到 http 服务器，浏览器浏览的时候，经过压缩的HTTP应答报文是由浏览器解压的，比起压缩，解压的速度是非常快的（只要数据正常，可以解压的话），所以不用担心浏览器用于解压的时间会降低用户体验。事实上，浏览器解压消耗的这点时间比起数据包因为网络拥堵而耽误的时间要少的多也可控的多。\n\n \n\n在浏览器发给服务器的HTTP请求报文中，使用Accept-Encoding字段标明自己支持的压缩格式，即自己可以解压哪几种压缩报文（gzip、zlib库提供的deflate）。服务器回复客户端的HTTP应答报文中，使用Content-Encoding字段标明该应答报文使用哪种压缩方式。\n \n\n### gZip 攻破 webpack、nginx\n\n像我这样屌丝的服务器一般都买 1M 的，大的资源文件 hold 不住，一个动辄 400K 的 vendar 文件这很蛋疼，不上 gZIp 很难受。\n\n打开 network 观察一下:\n\n![屏幕快照 2018-11-27 17.31.07.png](http://www.gitrue.com:9000/image/7Nvn7iygVC)\n\n它有 144K 这么大\n\n![屏幕快照 2018-11-27 17.54.58.png](http://www.gitrue.com:9000/image/nHCVuLqIPX)\n\n我们就以 webpack 打包的核心 vendor 为例，我们发现，客户端向服务端请求了 gZIp 资源 `Accept-Encoding: gzip, deflate`，但可惜服务端并没有给我们理想中的 `response - Content-Encoding: gzip` 的响应, 我们需要排查一下原因。\n\n- 首先看看 webpack 到底打没打出来打出来 gZip 呢？看看他的目录有没有 js 的 .gz 文件。\n\n![屏幕快照 2018-11-27 17.49.21.png](http://www.gitrue.com:9000/image/vCd9XNDIvd)\n\n很遗憾没有，只有一些压缩文件和用于定位的 map 文件，看来首先我们的打包就出现了问题。\n\n大家还记得当初构建项目我发的这张图吗？\n\n![屏幕快照 2018-11-27 17.36.24.png](http://www.gitrue.com:9000/image/mLo2tA6qwY)\n\n\n\n- package.json 项目描述文件\n\n\n打开看看 build 命令执行了哪个脚本？\n\n\n![屏幕快照 2018-11-27 17.42.22.png](http://www.gitrue.com:9000/image/euLLe5cPzl)\n\n打开 build.js 看看执行了哪些内容，难道是 vue-cli 没有为我们配置好webpack gZip 相关的配置吗？\n\n\n![屏幕快照 2018-11-27 17.43.47.png](http://www.gitrue.com:9000/image/vNUNofAy0q)\n \n\n\n我们发现没什么特别的，发现一个\n `const webpackConfig = require('./webpack.prod.conf')`\n 的依赖，大概就是字面意思（webpack生产配置）进去看看。\n \n![屏幕快照 2018-11-27 17.46.37.png](http://www.gitrue.com:9000/image/PkuQKiK82Z)\n \n\n\n哦，我们看到了，webpack 确实为我们配置了 gZip 相关配置。\n\n可是发现这个配置被这个判断包裹住了：\n\n```js\nif (config.build.productionGzip) {\n\n}\n```\n\n追踪下去\n\n```js\n    // Gzip off by default as many popular static hosts such as\n    // Surge or Netlify already gzip all static assets for you.\n    // Before setting to `true`, make sure to:\n    // npm install --save-dev compression-webpack-plugin\n    productionGzip: false,\n```\n\n我们的全部疑惑都被揭开了，开发者通过注释这样告诉我们他的理由，我简单翻译一下：\n\n \n![屏幕快照 2018-11-27 17.59.02.png](http://www.gitrue.com:9000/image/phapBcxGq5)\n \n\n首先下载一下依赖：\n\n```\n vim package.json\n \n \"devDependencies\": {\n    \"compression-webpack-plugin\": \"^1.1.12\",\n    }\n```\n\n然后 productionGzip 改成 true\n\n \n- 废话不多说打个包试试：\n\n```\nnpm run build\n```\n\n![屏幕快照 2018-11-27 18.14.11.png](http://www.gitrue.com:9000/image/B3n5P3f1uk)\n \n\n\n成功了，出现了 .zg 文件压缩包，但是 gZip 是需要服务端的支持的，服务器通过客户端请求的 `Accept-Encoding` 首部开判断返回哪种格式的脚本文件，然后由浏览器解压，我们拉下来的 nginx 镜像，nginx 是不会为我们默认配置 gZIp 服务端压缩的，我们去查看一下吧。\n\n\n### 进入 docker 主机\n\n```\n docker exec -it nginx /bin/bash\n```\n\n或者\n\n```\n docker exec -it nginx \"bash\"\n```\n\n\n![2018-11-27 18.30.57.gif](http://www.gitrue.com:9000/image/60fWqcc3tb)\n \n\n\n\n| CMD | 解释 |\n| --- | --- |\n| exec | 进入docker容器 |\n| -i  | -i: 以交互模式运行容器，通常与 -t 同时使用； |\n| -t | -t: 为容器重新分配一个伪输入终端，通常与 -i 同时使用； |\n| -it | -it  = -i -t |\n| “bash” 或 /bin/bash | /bin/bash的作用是因为docker后台必须运行一个进程，否则容器就会退出 |\n\n\n### 进入 nginx 主机的第一件事\n\n## nginx 在哪？？？\n\nLinux whereis 命令用于查找文件。\n\n该指令会在特定目录中查找符合条件的文件。这些文件应属于原始代码、二进制文件，或是帮助文件。\n\n该指令只能用于查找二进制文件、源代码文件和man手册页，一般文件的定位需使用 locate 命令。\n\n语法\n\n```shell\nwhereis [-bfmsu][-B <目录>...][-M <目录>...][-S <目录>...][文件...]\n```\n\n- 查看 nginx 位置\n\n```shell\nroot@e0017cab245f:/# whereis nginx\nnginx: /usr/sbin/nginx /usr/lib/nginx /etc/nginx /usr/share/nginx\n```\n\n\n![屏幕快照 2018-11-27 18.40.42.png](http://www.gitrue.com:9000/image/mB7Egq5aJi)\n\n- 我们在 /usr/share/nginx 找到了根目录 html/\n\n\n![屏幕快照 2018-11-27 18.41.52.png](http://www.gitrue.com:9000/image/LBJJSIznuK)\n\n- 我们在 /etc/nginx/ 找到了 nginx 配置文件\n\n> ps 中间件这么多，谁记得住呢，记不住自己看看就行了不是吗?\n\n\n- 查看一下 nginx 的配置\n\n![2018-11-27 18.45.36.gif](http://www.gitrue.com:9000/image/JcrJIahx8O)\n \n确实 gZip 真的没开启，被注掉了。\n\n我们打开 gZip 的注释，并且防止服务端对 css 偷懒，我们一步到位加上几行经典配置。\n\n```shell\ngzip on;\ngzip_min_length 1k;\ngzip_buffers 4 16k;\ngzip_comp_level 6;\ngzip_types application/javascript text/plain application/x-javascript text/css application/xml text/javascript application/json;\ngzip_vary on;\n    \n```\n\n[nginx配置](https://github.com/pkwenda/Blog/blob/master/code/web_project_course/4-optimizing/nginx/nginx.conf) 代码在这里\n\n### 如何修改 docker 内部的配置\n\n就目前来看，你有两种方法可以选择：\n\n- 直接 exec 容器进行修改，增加上述 gZip 代码段。缺点：若想重新基于镜像构建容器容器内的配置会丢失。（除非你 commit 镜像）\n- 独立出配置文件，一劳永逸。\n\n我们基于第二点在 new-bee/ 目录 同级 创建了一个目录 nginx/ 创建一个同名的 nginx.conf 文件。\n\n[nginx配置](https://github.com/pkwenda/Blog/blob/master/code/web_project_course/4-optimizing/nginx/nginx.conf) 代码在这里\n\n- 先停止 nginx 容器\n\n```shell\ndocker stop nginx\n```\n\n- 删除 nginx 容器\n\n```shell\ndocker rm nginx\n```\n\n- 重新构建 nginx 容器\n\n```shell\ndocker run --name nginx -d -p 8888:80 -v /new-bee/dist:/usr/share/nginx/html -v /nginx/nginx.conf:/etc/nginx/nginx.conf:ro registry.docker-cn.com/library/nginx\n```\n\n- 看看效果\n\n```\nhttp://localhost:8888/#/\n```\n\n\n为了避免浏览器加载刚才的 304 缓存，清除下浏览器缓存或进行隐身模式\n\n![屏幕快照 2018-11-27 22.32.22.png](http://www.gitrue.com:9000/image/yFe0F8LqXI)\n\n已经奏效了。\n\n\n- 看看大小压缩到多少\n\n\n![屏幕快照 2018-11-27 22.47.03.png](http://www.gitrue.com:9000/image/fw8oJeIJ3s)\n\n只有 50K 左右，压缩了 2/3 的大小，这对于大型项目来说，节省的不只是 100K ，甚至是更多，webpack 或者说 gz 等压缩算法，会将所有的大量重复的片段单独标记，所以重复的越多，压缩的越多，这对于现在带宽比金子贵的云服务来说是十分重要的。\n\n\n## CDN\n\n![屏幕快照 2018-11-27 22.50.16.png](http://www.gitrue.com:9000/image/UWVgxzDh84)\n \n\n大家注意到，有些能用 CDN 的我选择使用了 CDN，那么 CDN 对于线上服务来说到底有多重要呢?\n\n### 原理\n\n\n### 请求速度\n\n\n废话先不说给大家上个对比图 [测试地址](https://www.17ce.com/)\n\n- 这是我的 论坛 \n\n![屏幕快照 2018-11-27 23.40.31.png](http://www.gitrue.com:9000/image/ZFxpaQi9Q7)\n\n可以看到仅有几个地方还算不错，其余地方都是一塌糊涂\n\n- 这是淘宝\n\n![屏幕快照 2018-11-27 23.41.54.png](http://www.gitrue.com:9000/image/rfx1JQuo20)\n\n不用说了吧？不过还好，这部分我们资金不足败了也很正常，但大家可能也大概知道 CDN 的意义了，主要意义不是节省开源项目服务器带宽，而是全国各个节点的访问速度问题，也就解释了：我部署的项目访问速度还不错，你这里怎么这么慢，你网不好吧？CDN 来告诉你答案。\n\n### cookie\n\n我们还是拿实战的 [bbs论坛](https://github.com/pkwenda/new-bee) 举例子吧，查看网络状态：\n\n![33249096-90F2-4E73-A6E8-475DA49D38E7.png](http://www.gitrue.com:9000/image/vzXwT7C3YQ)\n\n**使用 CDN 的几点优势**\n\n- 访问快\n- 服务端压力小\n- webpack打包小且快（下面讲）\n \n客户端的 cookie 是绑定服务端 域名 的, 看上图，我们需要 XHR 请求携带 cookie 访问服务端获取对应权限，但试想一下：每一个 js、img、甚至是css 都携带垃圾的 cookie ，在大用户量下，服务端承受着不应该属于他的痛苦，这样的消耗是特别应该避免的，我们可以随便翻一翻任何一个成熟的网站，都会发现存在自己的 CDN 服务，这样既优化了中国不同地区的访问速度，同时也大大减小了服务端的开销。\n  \n\n\n### 节省 webpack 打包大小/速度\n\n很长时间前经历过公司前端 webpack 编译特别慢的问题，dev 模式下我们可以注掉开发范围外的 路由，但是 build 发布的时候似乎没法解决，使用了 Happypack 多线程打包还是不如人意，查阅资料读到了 [这篇文章](https://zhuanlan.zhihu.com/p/21748318) \n\n![屏幕快照 2018-11-27 23.50.06.png](http://www.gitrue.com:9000/image/GhUzOfu0yx)\n \n\n我们可以把能够 externals 调的排除掉，然后使用 webpack 的 webpack.DllPlugin 生成依赖库（这点很重要），大大减少便以速度，DllPlugin 本质上的做法和我们手动分离这些第三方库是一样的，但是对于包极多的应用来说，自动化明显加快了生产效率。 \n\n## 如何分析项目依赖\n\n### webpack-bundle-analyzer\n\n其实很多人都知道，可能刚入坑的同学不太了解，不管是 npm maven  都有自己一套以来分析工具，当然也都来源于第三方，这里为大家介绍 npm 的以来分析工具： [webpack-bundle-analyzer](https://www.npmjs.com/package/webpack-bundle-analyzer) ，他会在浏览器生成一个报表，直观的展示哪里大，哪里需要优化，以及预测 gZip 的大小，还是以 [实战项目](https://github.com/pkwenda/new-bee)为例：\n\n按照官方指引的配置，下载依赖，package.json 文件指定下 build 的脚本：\n\n```js\n\"analyz\": \"NODE_ENV=production npm_config_report=true npm run buildProd\",\n```\n\n运行一下：\n\n```js\nnpm run analyz\n```\n\n![2018-11-28 01.02.57.gif](http://www.gitrue.com:9000/image/ckDAw8RZgq)\n\n效果：\n\n![2018-11-28 01.06.27.gif](http://www.gitrue.com:9000/image/yDqybaf7md)\n\n分析：\n\n发现了问题，`static/` 静态文件下 hightlight 文件比较大，有钱可以考虑下 CDN，`node_modules/` 下 element-ui 饿了么组件比较大，（我比较懒，全局导入的，可以用哪个引入哪个避免全局打包问题）可以优化，然后无聊的同学没事儿点点玩玩吧。\n\n\n\n\n\n## webpack 按需加载 ： 一切皆模块\n\n当打包构建应用时，Javascript 包会变得非常大，影响页面加载。如果我们能把不同路由对应的组件分割成不同的代码块，然后当路由被访问的时候才加载对应组件，这样就更加高效了。 Webpack 的代码分割功能， 实现路由组件的懒加载.\n\n **[官方详细说明](https://webpack.docschina.org/guides/code-splitting)**\n\n官方说的挺详细了，这里就偷个懒不上代码了，给大家提供一种经典处理方式，我们不放在组件上，直接对路由进行拆分，具体可以看 [实战项目路由](https://github.com/pkwenda/new-bee/blob/master/bbs-vue/src/renderer/router/index.js) 的路由拆分\n\n会发现很多这种注释：\n\n```js\nconst Blog = () => import(/* webpackChunkName: \"blog\" */ '@/container/blog/Blog')\n```\n\n那么类似：\n\n```js\n/* webpackChunkName: \"blog\" */\n```\n\n不是白写的，他是配合 webpack 对项目各路由拆分的，我们可以看看 [实际项目加载情况](http://www.gitrue.com/)  ：\n\n![2018-11-28 00.41.32.gif](http://www.gitrue.com:9000/image/gBUiuO8kT9)\n \n\n这个 `blog.hash.js`\n\n不是我们写的，是 webpack 进行分割的，这样类似 vue 这样的单页面架构，不会加载某模块总是加载全部脚本，大大提升加载速度。\n\n\n\n## 图片处理\n\n本来不想讲的，简单说说吧，常用的也就那几种 svg 、base64、 或使用fastdfs组件类似 CDN 的服务。\n\n### base64\n\n简单来讲 base64 会减少你的 http 请求数量，要知道 XHR 可不是省油的灯，他会带来额外的处理请求和处理响应损耗，以表情为例，动辄几十个表情 http 请求似乎太智障了一些，通常采用 base64 处理，减少了 http 请求数量，但是增大了图片本身的体积，如果你用了webpack 且你的表情在本地，那么 webpack 可以帮你自动进行 base64 编码哦。\n\n### 压缩图片\n\n用户上传的图片可以通过压缩图片大小或质量减少带宽哦，通常使用 [GM](https://github.com/aheckmann/gm) 对用户上传的有必要大锁的图片 压缩成不同大小的，根据业务加载，比如头像，默认肯定不会请求原始图片，今日头条的正文，使用流量的情况下也会默认加载小图，这些都不是客户端能做到的，需要服务端压缩。\n\n\n## 结语\n\n当然这些知识万里长征的第一步，以后的优化之路茫茫多，能大概想起来的比如 ：Lazy-Load（优化首屏体验）、PWA（构建web APP）、服务端渲染（为了SEO）、骨架屏（提升用户体验），后端和服务端文章还没写， 1.0 版本就放这些吧，期待第二版填坑，下篇开始后端。\n\nSO  -  努力吧!\n \n博客归档地址：[https://github.com/pkwenda/blog](https://github.com/pkwenda/blog)\n\n博客实例地址：[https://github.com/pkwenda/new-bee](https://github.com/pkwenda/new-bee)\n\n", "user_name": "庄文达", "description": "don't know What should be said", "got_view_count": 104076, "category_name": "前端", "ctime": 1457483942}
{"tag_name": "数据分析", "concern_user_count": 16705, "user_id": "1838039172387262", "title": "沙龙回顾｜ClickHouse 在字节广告 DMP& CDP 的应用", "mark_content": "\n\n> 广告是支撑互联网高速发展的经济基石，也是很多互联网公司的重要收入来源。字节跳动的广告平台管理着 EB 量级的数据和服务着数以千万的商业用户，其中 ClickHouse 作为核心引擎支撑了海量数据在线分析的需求。<br><br>\n> 本次分享中，介绍了 ClickHouse 在字节跳动广告业务上的应用与实践，包含人群预估、数据分析、人群画像等多个场景。其中着重介绍了如何通过深度优化高效解决广告人群预估的问题，以及未来的迭代计划。<br><br>\n（文末附 ClickHouse 沙龙第三场：《ClickHouse 在实时场景的应用和优化》报名方式）\n\n# 沙龙视频\n\n### [ClickHouse 在字节广告 DMP& CDP 的应用](https://www.ixigua.com/6856602552218157580/)\n\n#### 讲师：董一峰 字节跳动 ClickHouse 研发工程师\n\n\n# 文字沉淀\n## 业务背景\n\n众所周知，广告是很多互联网公司的主要收入，对于字节跳动来说也是如此。那么，在字节跳动广告的 DMP&CDP 业务，乃至所有广告业务中，有哪些场景在使用 ClickHouse 呢？是在线服务还是离线统计的呢？应该说都有。\n\n可以从三个场景来讲：人群预估、人群画像和统计分析。\n\n**人群预估**主要是根据一定的圈选条件，确认命中的用户数目。在广告精准投放过程中，广告主需要知道当前选定的人群组合中大概会有多少人，用于辅助判断投放情况进而确定投放预算。因为是在线业务，一般要求计算的时间不能超过 5 秒。\n\n**人群画像**主要是对广告投放的用户群进行画像分析，也是在线的，同样对时间有一定的要求，因为是偏分析的场景，一般不能超过 20 秒，否则用户的体验就非常差了。\n\n**统计分析**的使用场景比较多，在线、离线都有，包括一些搜索词统计分析，广告、投放收入数据的分析等等，应用的方面很多。\n\n我今天主要分享的是人群预估，因为这是一个比较大的难点。而对于统计分析来说本身就是 ClickHouse 的强项。\n\n就如我之前说的，人群预估就是根据一定的圈选条件，确认命中的用户数目。比如下图中我们可以看到，在投放广告的时候，可以根据地域、性别、年龄、兴趣、首次激活时间等条件进行圈选。其本质就是集合的快速交并补计算。\n\n![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f77ce224b3154d7ea3d7371d9179f9bc~tplv-k3u1fbpfcp-zoom-1.image)\n\n举一个简单的例子，假设一个望远镜厂商想通过投放广告吸引用户购买。那么假设他想投给在北京的喜欢户外或者爬山的人。本质上来说，我们就是通过集合运算，把喜欢户外和喜欢爬山的人群求并集，然后与北京的人群求交集，也就是**北京**的喜欢**户外**或者**爬山**的人。\n\n这个结果就是我们想要投广告对应的的人群，而我们的目标就是能够快速地求这个人群对应的用户数。\n\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5e20332711934ce1909614fadb0f4fd5~tplv-k3u1fbpfcp-zoom-1.image)\n\n因此，我们假设平台的全量用户是 8 人，分别是从 uid1 到 uid8。其中北京共有 5 人，分别是 uid 1 到 uid5，对应集合 A；喜欢户外的是 uid1 和 4，对应集合 B；喜欢爬山的是 uid 1、3、5、6，对应集合 C。那么，我们想要投放广告的人数是 A 交上 B 和 C 的并集，uid 1、3、4、5 共 4 人。\n\n听起来就是集合运算，并不复杂。那么难点和挑战在哪里？主要是 3 个方面：\n\n1. 人群包数据量多，基数大。平台的用户数上亿，仅抖音的 DAU 就好几亿，抖音、头条对应的人群包在亿级别。整体的人群基数大，对应的标签也非常多。\n2. 计算复杂（单次计算可能包含几百上千个人群包），从之前的图我们可以看出，广告主可以设定一个非常复杂的圈选条件。\n3. 查询时长要求短（小于 5 s），其实如果页面上等待时间超过 1s，是有明显感知。如果超过 5 s，那么广告主的体验确实会非常不好。\n\n除了这个之外，人群权限计算的人群包还需要与其他数据 join 进行分析，这就意味着说我们不仅仅只出一个数，还有比较复杂的计算。我们的计算引擎必须要有一定的分析能力，能够进行复杂的分析计算。\n\n在使用 ClickHouse 之前我们也尝试了不少已有的系统，如 Druid、ES、Spark，甚至业务方还自研过一个系统。其中 Druid、ES、Spark 均不能很好的满足时间期望。自研的系统因为我们可以高度的定制化，性能上能够上来，但缺乏一定的灵活性。\n\n因此，通过对比我们选择了 ClickHouse。原因主要有两个方面\n\n- 第一是快，特别适用于大宽表的场景，这个是其他引擎所不能比拟的。\n- 第二是架构简单，我们可以很好地做很多定制化的开发，甚至去修改整个执行逻辑，这个我后面会提到，我们其实对于 ClickHouse 有比较大的改动。\n\n## 技术方案 V1\n\n那么首先是我们的第一版技术方案，这个技术方案的背景是，业务提出来希望能够尽快上线，时间比较紧。\n\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f8ca6f9b436b47a0bbbbfa96e335a641~tplv-k3u1fbpfcp-zoom-1.image)\n\n我们采用明细存储的方式，表有 2 列，分别是 tag_id 和 uid。每一个 tag_id 表示一个人群包，uid 是对应的用户 id。那么如果是一个比较大的人群包，可能需要用上亿行来表示。我们对 tag_id 建立了主键，因此可以快速的找出对应的用户 id 集合。集合的交集操作会转化为 in，并集为 or，补集为 not in 表示。\n\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ce7bcb7a53cd4a8092d0793f76754897~tplv-k3u1fbpfcp-zoom-1.image)\n\n我们看一个具体的例子。如果我们要求 A 交上 B 和 C 的并集。那么对应的 sql 就是如此。其中，交集是采用 in 子查询的方式。并集直接用 or 表示。其中，SELECT distinct uid FROM tag_uid_map WHERE (tag_id = B) OR (tag_id = C) 用来表示 B | C。SELECT count distinct(uid) FROM tag_uid_map WHERE tag_id = A 表示集合 A，uid IN 表示求交集计算。\n\n```\nA&(B|C)\nSELECT count distinct(uid)\nFROM tag_uid_map\nWHERE tag_id = A\nAND uid IN (\nSELECT distinct uid\nFROM tag_uid_map\nWHERE (tag_id = B) OR (tag_id = C)\n)\n```\n\n在这种情况下，我们想要快速的求出 sql 的结果，采用了 2 个优化方向：\n\n1. 因为 clickhouse 是分布式数据库，我们希望尽可能并行计算，减少节点之间数据传输，把计算下推下去，减少汇聚节点的计算压力。\n2. 因为最后要获取去重后的用户数，看看如何能够快速计算 count distinct。上一次分享也有人问字节是否在 count distinct 做过一些优化？我们也做了一些优化和尝试。\n\n![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/195acd2b1f7c4bde89c36f6c4bfd32d2~tplv-k3u1fbpfcp-zoom-1.image)\n\n我们继续看之前的场景， A 交上 B 和 C 的并集。我们有没有办法能够划分不同的区间进行并行计算呢？答案当然是有的。\n\n![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c80903210c344338b0da7ce9f2de158b~tplv-k3u1fbpfcp-zoom-1.image)\n\n如果我们把用户 id 按照奇数偶数分为 2 个区间，可以保证一个用户只会在一个区间内，因为用户的 id 要么是奇数要么是偶数，且区间之间用户 id 不重复。那么 A B C 也同样划分为奇偶两个区间。在这样的基础上，可以在区间内单独的计算子集合的结果最后对区间计算结果进行汇总。A 交上 B 和 C 的并集就等于 A*奇数集合 交上 B*奇数集合和 C*奇数集合的并集 并上 A*偶数集合 交上 B*偶数集合和 C*偶数集合的并集的结果。对于人群预估来说，我们更关心集合的数目。A 交上 B 和 C 的并集所对应用户的个数可以转化为，A*奇数集合 交上 B*奇数集合和 C*奇数集合的并集所对应用户的个数加上 A*偶数集合 交上 B*偶数集合和 C*偶数集合的并集的用户数。因此，通过把用户 id 划分到不同的集合，我们可以在每个集合上并行计算。最后只需要把每个集合的用户数做一次累加就可以，我们的计算方式就是这样的。\n\n以 A 交 B 为例：\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f298e01ec02e41618264c3b43f74b4bd~tplv-k3u1fbpfcp-zoom-1.image)\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/72d3d314583e402c8c9e6f60c4f18b3f~tplv-k3u1fbpfcp-zoom-1.image)\n\n我们在数据导入的时候按照用户 id 划分为 4 个区间，分别导入到 4 台不同的机器，保证每台机器上的用户不重复。这样在每一台机器计算完结果后，直接把结果进行汇总。同时，在人群预估的场景下，我们返回的是子区间 count distinct 结果，而不是对应的聚合函数中间状态。这样可以大大减少输的数据量。同时，最后只需要做一次累加，不需要把聚合函数中间状态进行 merge 后求去重后结果。实际场景的话我们划分的区间数可能要比机器数要多，这样才可能并行导入。\n\n因此，在 clickhouse 上的改动主要是两个：\n\n1. 导入的时候按照 uid 分片，实际中肯定不是按照奇偶来划分了\n2. 扩充了 sql 语法，并行计算，修改了引擎的执行逻辑。支持 count distinct 中间结果不做 merge 直接进行累加\n\n第二个优化是快速计算 count distinct，这里我们做过几个方向的尝试，比较通用的思路有两个：\n\n1. 优化 hash 函数，能够快速求出 hash 结果。\n2. 通过一些近似函数的方式，在允许一定的误差的情况下快速求出结算结果，比如 UniqHLL12/UniqCombined 等。\n\n其他还有一些思路偏探索，主要是精确算法下优化 hash 表的结构，减少 hash 冲突。\n\n随着上面的一系列优化后，第一版本的方案上线了。\n\n- 优点是基本能满足需求，大部分的查询都小于 5 s。\n- 缺点是当表达式非常复杂，特别是存在很多的交集和补集的时候，由于交集和补集需要用子查询来实现，SQL 会非常长，对用户很不友好，且不利于分析。\n- 其次，当人群包非常大且表达式复杂的时候查询容易超时。因为 in 和 not in 的操作是比较花费 cpu 资源的。\n\n随着数据量的不断增长 ClickHouse 在当前存储引擎的支持下也难以保证查询时间,而且这些大查询还会影响其他查询，因此我们觉得有必要做新一版的开发。\n\n## 技术方案 V2\n\n下面介绍一下我们的第二版方案。这个方案做了很多的优化，我们也已经对核心的技术方案申请了专利。\n\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/680b0976c4674ddfacef260493f92100~tplv-k3u1fbpfcp-zoom-1.image)\n\n我们认为，可以使用位图来进行计算，因为位图是一种逻辑上非常巧妙的描叙集合的方法。根据用户 id 的特性，我们准备采用性能最好的稀疏位图索引 RoaringBitmap 来表示一个标签对应的人群包。在这样的情况下，集合的计算可以转换到对应位图的计算。\n\n例如 A 交上 B 和 C 的并集可以转换为 RoaringBitmap 的计算\n\n![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e653a0180a7d4db6b147028e018021d0~tplv-k3u1fbpfcp-zoom-1.image)\n\nClickHouse 其实有引入 RoaringBitmap，但是是 32 位的 bitmap。而我们的用户规模用 32 位表示并不够，因此我们给 ClickHouse 引入了 Bitmap64 类型和一系列的相关计算函数。\n\n我们第二版本的表结构长这样，还是 2 列，但不需要明细存储。一列 tag_id 用来表示标签，另外用类型为 Bitmap64 的 uids 列表示标签所对应的用户 id。\n\n相比于第一个方案，tag_id 只需要存 1 个，会节省空间。另外，uids 用 RoaringBitmap 存储也会比原来的存储要节省不少空间。而集合的交并补也对应了 bitmap 的交并补计算。\n\n![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8ccc875380e74c3387a2b8fffa8d45cf~tplv-k3u1fbpfcp-zoom-1.image)\n\n![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2ab5ab73f89d435d8ffa3b9326c31c04~tplv-k3u1fbpfcp-zoom-1.image)\n\n如果我们要求 A 交上 B 和 C 的并集。对应的 sql 相比第一版本就要简单很多了。看右边，基本上从表达式就能对计算的内容一目了然，非常直观。相比于使用第一版本的建表和查询方式，使用 bitmap 有如下优势：\n\n1. 空间节省，没有冗余数据，RoaringBitmap 存储高效\n2. 计算高效\n3. Sql 直观，无需子查询，且具有更好的拓展性。\n\n光是用 RoaringBitmap 其实是不够的，我们花了 1-2 个礼拜快速做了一个 demo 出来，发现效果并不理想，与第一版本的差距不大。我们在这个基础上做了很多的优化，目标就是让整体计算尽可能得快，可以分为以下几个方面：\n\n1. 和第一版本的想法一样，尽可能的并行计算，减少数据传输\n2. 在数据层面进行优化\n3. 计算的优化\n4. 读取的优化\n5. 通过 cache 减少计算的数据量\n\n![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3d716c1a1b72464f84a9ac5e63a3863e~tplv-k3u1fbpfcp-zoom-1.image)\n\n首先是并行计算，相比于之前用子查询来表示交集和补集，采用 RoaringBitmap 来实现交集和补集要简单很多，这样使得我们的计算可以更加充分的并行，到线程粒度。这样，一方面我们可以更好的利用上多核的计算资源。另一方面，可以更好的控制查询使用的资源，避免一些大查询占用过多资源。如上图所示，我们把全量数据分成很多份，每台机器的每一个线程处理其中一部分的数据，得出对应的计算结果。最后将各线程直接合并。\n\n这个与 ClickHouse 默认的处理机制是不一样的，Clickhouse 在多线程读取的时候，读取的数据并不是固定的，哪个线程处理完了就去读新的数据，当处理速度跟不上的话也会降低线程数目。如果要实现每个线程固定读对应的数据，并在读取完成后完成计算，就需要修改整个读取和处理模型。\n\n![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a6cb971dc92a4c8fa45de7140ffa2524~tplv-k3u1fbpfcp-zoom-1.image)\n\n这个是我们的读取和处理模型，可以看到，数据在导入的时候被分成了若干份，每一份 uid 都是独立的。我们通过建立 input stream 去读取对应的数据，stream 的数量和数据分成的数量相等，并保证一个同一份数据只会进入一个 Stream。ParallelBitMapProcessor 构造一个线程池，从队列里面一次取 Stream 进行数据读取，当一个线程完全读完一个 Stream 之后，才会调用下一个 stream。\n\n![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/fcffcacc277c42bfbc37d6e7dadfb556~tplv-k3u1fbpfcp-zoom-1.image)\n\nClickHouse 整体的结构如上图所示，黑色的是原来 ClickHouse 的读取和执行流程，红色的是我们新增的，可以看到，基本上整个读取和执行流程都发生了变化，改动还是比较大的。\n\n![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/330f744216ae40f3b272e151d6d8c787~tplv-k3u1fbpfcp-zoom-1.image)\n\n在整个并行后我们发现效果并不是非常理想，相比于第一版本的提升并不明显，通过对 RoaringBitmap 底层原理的深入研究和对数据的分析，我们发现，原因是因为区间内的用户 id 过于离散。\n\n离散的原因有 2 点：\n\n1. uid 的生成并不是连续的。\n2. 由于数据按照一定规则均匀划分到不同的区间内，那么就会导致子区间内的数据比原始空间更加离线。\n\n那么为什么离散的情况下会导致计算效果并不理想，大家可能有疑问，RoaringBitmap 不就是用来存储稀疏的数据的吗？\n\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5d365308670f4715ab5855e665e3aab0~tplv-k3u1fbpfcp-zoom-1.image)\n\n原因跟 RoaringBitmap64 的实现有关，RoaringBitmap64 是由一系列 RoaringBitmap32 表示。实现方式有很多种，一种比较通用的做法用 map 存储，是把前 32 位存成 key，value 是 后 32 所对应的 RoaringBitmap32，RoaringBitmap32 的实现如图中所示。\n\n第一层称之为 Chunk（高 16 位），如果该取值范围内没有数据就不会创建 Chunk。\n\n第二层称之为 Container（低 16 位），会依据数据分布进行创建。\n\nRoaringBitmap32 使用两种容器结构： Array Container 和 Bitmap Container。Array Container 存放稀疏的数据，Bitmap Container 存放稠密的数据。若一个 Container 里面的元素数量小于 4096，就使用 Array Container；反之，就用 Bitmap 来存储值。\n\n当数据比较稀疏的时候，我们发现一个人群包对应的 RoaringBitmap64 由很多个 RoaringBitmap32 组成，每个 RoaringBitmap32 内部又由很多个 array container 组成。而对有序数组的交并补计算尽管也比较高效，但是相比于 bitmap 计算来说还是有明显的差异。这样导致计算性能提升不上去。因此我们就在想，能不能通过编码的方式，对区间内的数据进行编码，让数据更加集中，从而提升计算效率。事实上我们也是这么做的，我们实现了一种高效的编码，希望达到如下效果：\n\n- 编码后同一个区间内的用户相对集中\n- 不同区间的用户编码后同样在不同的区间内\n- 编码后同一个人群包同一个区间内的用户 id 相对集中\n\n通过编码，能够非常好地加速计算，计算速度提升 **1~2** 个量级\n\n当然，编码的过程是在引擎内部实现的，对用户是无感知的。当数据导入的时候，会自动完成编码。\n\n这块其实有一个比较大的工程量，有这几个问题需要解决：\n\n1. 编码相当于是一个额外的工作量，会对导入有一定影响。同时，如果要导出 uid，需要增加额外的解码过程。如何减少编、解码带来的额外的代价。\n2. 原来为了能够尽快导入数据，我们是采用并行导入的方式。增加了额外的编码环节是否会导致导入必须要串行来完成，并行导入如果都在写字典是否会导致数据产生冲突\n3. 主备之间如何高效同步字典，避免字典的同步不及时导致数据无法解码。有一些一致性的问题要处理。\n4. 字典如何高效管理、备份，避免丢失。\n\n![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c873565a035549ff9ddd87e530bc47cd~tplv-k3u1fbpfcp-zoom-1.image)\n\n除了数据通过编码优化分布性外，我们还从工程的角度对计算进行了优化。主要有下面 3 点：\n\n1. 通过一些指令集计算和汇编指令对计算进行加速，在我们实际测试中发现这个能够大大加快计算速度。\n2. 另外，我们 bitmap 的计算能够尽可能在原地完成，减少数据拷贝。举个例子，求 A 与 C 的并集，我们可以直接在 A 上面进行计算，得到结果。当我们的计算表达式包含多个 A 的时候且 A 在左侧的时候，这样就失效了。因此，需要我们处理的时候需要对整个表达式进行处理和判断，看看哪些计算可以在原地完成。当然，更进一步的话，在这个 Case 中我们通过移动位置（A 和 C 交换位置）也是可以做到原地计算的。\n3. 是我们在对比第一第二版本的时候发现，bitmap 在交集和补集的性能上相比原来的子查询有非常明显的提升，但是在大量的并集的情况下与原来的相比提升不够明显。这个一方面说明 clickhouse 的性能还是非常优越的，另一方面也给我们带来了挑战。最后我们发现可以把 RoaringBitmap32 的 Fast Union 的思想移植到 RoaringBiamap64 上，通过 lazy 计算的方式，提高大量并集的计算性能。\n\n当然，以上说的其实是我们在工程实践的一些大的有明显效果的优化点，其实小的优化点还有很多，工程上要做的事情很多。\n\n除了计算以外，读取的优化也很重要。大家都知道 clickhouse 是列存数据库，对于每一列的数据又是分块存储的，默认是每 8192 行为一块。分块存储的好处是能够更好的做压缩，减小数据存储。对于一些基本类型来说效果很好。但是对于 bitmap 类型来说本身值的类型就非常大，8192 行组成的块大小非常大，如果我只是读取其中的一个 bitmap，会有很大的读放大，会非常影响性能。\n\n另外，由于 clickhouse 是一个在主键上的稀疏索引，并不能精确地定位某一个块中是否包含对应的数据。这个对于普通类型也是没有问题的，因为有的时候建立精确索引并且查找索引的代价还不如直接暴力扫原始数据。但是对于 bitmap 来说我们是希望能够精确到定位到数据的。\n\n因此我们做了这几个优化：\n\n1. 调整块的大小，把默认的 8192 行改成了 128，这个是我们实际测试中在我们场景的最佳实践。如果数据太细，那么会导致 mark 文件过大，读取索引定位数据的时间变长。\n2. 定期合并历史数据，因为我们有的标签是一个增量数据，我们希望通过一些合并减少数据读取\n3. 通过二级索引的方式能够更好的精确定位，尽量减少读取不需要的数据\n\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/bcd16012b7e24162a7a0694b7dcd0f3d~tplv-k3u1fbpfcp-zoom-1.image)\n\n最后一个优化点也是很多系统都必备的，那就是 cache。因为用户读取的数据和计算的结果通常具有 2 8 原则，即经常读取的都是一小部分数据。因此，我们通过 cache 可以加速第二、第三次读取时间。实际上我们做了三层的 cache：\n\n1. 读取层面的 cache，对于同一个标签，通过 cache 第二次可以直接命中内存\n\n2. 中间计算结果的 cache，还是举之前望远镜例子，广告主除了想看到 北京的喜欢户外或者爬山的人的一共有多少人。还想看到这些人在头条、抖音等各端上分别多少人。如果我们是依次计算每个结果，这里面就有重复计算的过程。因此我们目前的做法是提供一个 udf multiCount，可以让用户复用中间的计算结果。比如我们想计算，A&B&C&D&E&F，A&B&C&D&E&F&G，A&B&C&D&E&F&H，这里有重复的部分。可以用这样的函数一次性计算出结果。multiCount 函数里 \\_1 来表示第一个表达式的计算结果，函数的结果返回一个数组，分别是每个表达式的计算结果。通过这种方式，一个是避免了重复结果的反复计算，另一个也减少了整体的 qps。当然，这样的方法还是有一定的局限性，后面讲未来的展望时我会提到我们想做的更通用性一些。\n\n3. 对结果的 cache，结果 cache 只需要记录一个 string 用来表示计算的表达式和一个 uint64 表示结果，代价非常小。那么可以用很小的空间存储大量的计算结果。当然前提是确实出现不少名字缓存的情况。\n\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3d4e4b06015147b3ad9e7c138b4cba00~tplv-k3u1fbpfcp-zoom-1.image)\n\n做了这么多，都是为了降低查询的时间，减少导入和查询的资源，那么到底效果怎么样呢？可以说还是非常突出的。从空间上来说，采用 RoaringBitmap 可以减少 tag_id 列的冗余存储，同时 uid 采用压缩存储，因此整的空间存储降低为原来的 1/3，因为数据量降低了，因此导入也变快了，导入时长也缩短为原来的 1/3，同时，在查询性能上收益非常明显，avg/pct99/max 下降明显，消除绝大多数 5 s 以上的大查询，可以说达到了开发的预期。最后，在资源上效果也很不错，CPU 使用下降明显，内存使用上 PageCache 节省 100 G+ 以上。\n\n![查询时长](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9248c9f290bb4b31b5867d77b5461ab8~tplv-k3u1fbpfcp-zoom-1.image)\n\n这个图是上线后的效果图，可以看到，原来确实是经常有一些大的查询，有些时间久的甚至超过了 20 s。上线后如右边的红框所示，很少看到超过 5 s 的查询了，绝大部分查询非常稳定。这个其实还是我们没有上中间结算结果 cache 时候的效果图，当我们通过 multiCount 缓存中间结果后，直接把 qps 下降了 4 倍以上。\n\n当然，要在更多的场景用上来，我们其实还要做不少工作的。比如，为了支持一些更复杂的查询我们还开发了其他一系列计算的 udf，比如结果不返回 count 而是 array 用来做投放。\n\n同时，为了支持与其他表 join，我们还支持了 in bitmap 语法，能够让 bitmap 表与其他表进行 join，join 的时候，因为做了编码，因此需要支持字典的复用（其他表使用相同的字典进行编码）等等。\n\n### 未来展望\n\n可以说，第二版本达到了我们的预期，也在线上取得了比较大的成果，业务方的反馈也很不错。可能在很长一段时间内都能满足业务需要。随着数据量的不断增长，将来又有哪些方面可以做一些持续的优化呢？我对未来的展望简单做了一些总结:\n\n我们主要想从这三个方面进行迭代：\n\n1. 从计算层面和数据层面进行更多的优化，读取的数据更少，更精准的找到真正要读取的数据。减少甚至尽可能消除读放大。计算上能够想更多的招，包括利用一些新硬件减少计算的时间\n2. 从 cache 层面能够做的更加智能化。通过解析表达式，从子表达式的粒度看看是否能够把一些公共子项缓存起来，这样 cache 才会更通用。当然，这可能要引入一些机器学习的算法。\n3. 扩充表达式的表现能力，能够在更过的场景得到应用。大家可以看到，目前我们在计算的时候是使用一个 uint64 来表示一个对应的标签，如果表示一个多维的标签，我们内部有一些做法，但是还不是很通用，业务方用起来也有点费劲，我们希望能够更好的支持标签的表达。同时，更多的场景也需要一些更多的 udf 开发，我们会逐步支持各个场景的需求。\n\n最后，此次分享主要介绍了 ClickHouse 在字节广告的应用场景，主要是人群预估、人群画像和统计分析这几个方面。其次，就人群预估这个场景介绍了我们的实现方案和优化的思路，以及未来的迭代计划。\n\n以上就是本次分享的全部内容，谢谢。\n\n## 沙龙预告\n\n### 《ClickHouse 在实时场景的应用和优化》\n\n#### 时间：2020 年 8 月 14 日 19:00-20:00\n\n#### 讲师：郭映中 字节跳动 ClickHouse 研发工程师\n\n## 报名链接\n\n[https://live.bytedance.com/8889/4136164](https://live.bytedance.com/8889/4136164)\n\n\n## 参与方式：\n\n![](https://imgkr2.cn-bj.ufileos.com/fd06383f-fc72-4062-b40e-91b0b1c78dda.png?UCloudPublicKey=TOKEN_8d8b72be-579a-4e83-bfd0-5f6ce1546f13&Signature=jUVbYbnkIVdbNV%252BcyxzlWUmAwUo%253D&Expires=1597141445)\n\n下载 **飞书** APP，扫码加入 ClickHouse 飞书交流群\n\n## 字节跳动技术沙龙\n\n字节跳动技术沙龙是由字节跳动技术学院发起，字节跳动技术学院、掘金技术社区联合主办的技术交流活动。\n\n字节跳动技术沙龙邀请来自字节跳动及业内互联网公司的技术专家，分享热门技术话题与一线实践经验，内容覆盖架构、大数据、前端、测试、运维、算法、系统等技术领域。\n\n字节跳动技术沙龙旨在为技术领域人才提供一个开放、自由的交流学习平台，帮助技术人学习成长，不断进阶。\n\n欢迎关注字节跳动技术团队\n", "user_name": "字节跳动技术团队", "description": "字节跳动的技术实践分享", "got_view_count": 172391, "category_name": "阅读", "ctime": 1457483895}
{"tag_name": "Vue.js", "concern_user_count": 263220, "user_id": "3175045313866702", "title": "Vue3文档【Vue2迁移Vue3】", "mark_content": "## Vue2与Vue3的全局配置API变化区别\n\n### `createApp`\n\n+ Vue2.x创建实例并且挂载DOM上\n\n  ```vue\n  import Vue from \"vue\";\n  import App from './App.vue'\n  \n  new Vue({\n    render: (h) => h(App)\n  }).$mount(\"#app\");\n  ```\n\n+ Vue3新增api===>createApp[源码地址](https://github.com/vuejs/vue-next/blob/4951d4352605eb9f4bcbea40ecc68fc6cbc3dce2/packages/runtime-dom/src/index.ts) 创建实例\n\n  > `createApp` 会产生一个 app 实例，该实例拥有全局的可配置上下文\n\n  ```vue\n  import { createApp } from 'vue'\n  import App from './App.vue'\n  \n  createApp(App).mount('#app')\n  ```\n\n#### createApp做了什么\n\n![源码](https://files.catbox.moe/t9vxaw.png)\n\n+ ensureRenderer方法追溯过去底[添加patchclass+patchStyle等跟操作DOM相关的方法](https://github.com/vuejs/vue-next/blob/4951d4352605eb9f4bcbea40ecc68fc6cbc3dce2/packages/runtime-dom/src/patchProp.ts)\n  + ensureRenderer(创建虚拟DOM)一直追溯到[createRenderer以及baseCreateRenderer](https://github.com/vuejs/vue-next/blob/de62cc040c22e3bd93222a9cc84b6564a4b08b51/packages/runtime-core/src/renderer.ts)，baseCreateRenderer方法涉及了虚拟DOM的创建更新DIFF算法\n+ 之后就是检查时候又mount是否挂载在DOM上\n+ [app对象](https://github.com/vuejs/vue-next/blob/54727f9874abe8d0c99ee153d252269ae519b45d/packages/runtime-core/src/apiCreateApp.ts)上的方法：config、use、mixin、component、directive、mount、unmount、provide/inject\n\n### `component`\n\n+ Vue2.x【注册或获取全局组件。注册还会自动使用给定的 `id` 设置组件的名称】\n\n  ```vue\n  // 注册组件，传入一个选项对象 (自动调用 Vue.extend) \n  \n  Vue.component('my-component', { /* ... */ }) \n  \n  // 获取注册的组件 (始终返回构造器) \n  var MyComponent = Vue.component('my-component')\n  ```\n\n+ Vue3【注册或获取全局组件. 注册还会自动使用给定的 name组件 设置组件的名称】[全局组件](https://codepen.io/team/Vue/pen/rNVqYvM)\n\n  > 基本vue2写法一致\n\n  ```vue\n  import { createApp } from 'vue'\n  \n  const app = createApp({})\n  \n  // 注册组件，传入一个选项对象\n  app.component('my-component', {\n    /* ... */\n  })\n  \n  // 获取注册的组件 (始终返回构造器) \n  const MyComponent = app.component('my-component', {})\n  ```\n\n\n### `config`【app=createApp(App)】\n\n#### `devtools`\n\n> 配置是否允许 [vue-devtools](https://github.com/vuejs/vue-devtools) 检查代码。开发版本默认为 `true`，生产版本默认为 `false`。生产版本设为 `true` 可以启用检查。\n\n```vue\n- Vue.config.devtools = true\n+ app.config.devtools = true    \n```\n\n#### `errorHandler`\n\n````vue\n- Vue.config.errorHandler = function (err, vm, info) {\n  // handle error\n  // `info` 是 Vue 特定的错误信息，比如错误所在的生命周期钩子\n  // 只在 2.2.0+ 可用\n}\n+ app.config.errorHandler = (err, vm, info) => {\n  // handle error\n  // `info` 是 Vue 特定的错误信息，比如错误所在的生命周期钩子\n  // 这里能发现错误\n}\n````\n\n> 指定组件的渲染和观察期间未捕获错误的处理函数。这个处理函数被调用时，可获取错误信息和 Vue 实例。\n\n> 错误追踪服务 [Sentry](https://sentry.io/) 和 [Bugsnag](https://docs.bugsnag.com/platforms/browsers/vue/) 都通过此选项提供了官方支持。\n\n#### `warnHandler`\n\n````vue\n- Vue.config.warnHandler = function (msg, vm, trace) {\n  // `trace` 是组件的继承关系追踪\n}\n+ app.config.warnHandler = function(msg, vm, trace) {\n  // `trace` 是组件的继承关系追踪\n}\n````\n\n> 为 Vue 的运行时警告赋予一个自定义处理函数。注意这只会在开发者环境下生效，在生产环境下它会被忽略。\n\n\n\n#### `globalProperties` 【新增属性】\n\n````vue\napp.config.globalProperties.foo = 'bar'\n\napp.component('child-component', {\n  mounted() {\n    console.log(this.foo) // 'bar'\n  }\n})\n````\n\n> 添加可在程序内的任何组件实例中访问的全局属性。当存在键冲突时，组件属性将优先\n>\n> 替代掉Vue2.x的 Vue.prototype属性放到原型上的写法\n\n````vue\n// Vue2.x\nVue.prototype.$http = () => {}\n\n// Vue3\nconst app = Vue.createApp({})\napp.config.globalProperties.$http = () => {}\n````\n\n#### `isCustomElement` 【新增属性】\n\n+ 替代掉Vue2.x的ignoredElements\n\n````vue\n- Vue.config.ignoredElements = [\n  // 用一个 `RegExp` 忽略所有“ion-”开头的元素\n  // 仅在 2.5+ 支持\n  /^ion-/\n]\n\n// 一些组件以'ion-'开头将会被解析为自定义组件\n+ app.config.isCustomElement = tag => tag.startsWith('ion-')\n````\n\n> 指定一个方法来识别在Vue之外定义的自定义组件(例如，使用[Web Component API](http://www.ruanyifeng.com/blog/2019/08/web_components.html))。如果组件符合这个条件，它就不需要本地或全局注册，Vue也不会抛出关于Unknown custom element的警告\n\n> 注意，这个函数中不需要匹配所有原生HTML和SVG标记—Vue解析器会自动执行此检查\n\n#### `optionMergeStrategies`\n\n````vue\nconst app = Vue.createApp({\n  mounted() {\n    console.log(this.$options.hello)\n  }\n})\n\napp.config.optionMergeStrategies.hello = (parent, child, vm) => {\n  return `Hello, ${child}`\n}\n\napp.mixin({\n  hello: 'Vue'\n})\n\n// 'Hello, Vue\n````\n\n> 定义自定义选项的合并策略。\n>\n> 合并策略接收在**父实例**$options和**子实例**$options，分别作为第一个和第二个参数。上下文Vue实例作为第三个参数传递\n\n##### 【自定义选项合并策略】[mixin](https://github.com/vuejs/docs-next/blob/master/src/guide/mixins.md#custom-option-merge-strategies)\n\n````vue\nconst app = Vue.createApp({\n  custom: 'hello!'\n})\n\napp.config.optionMergeStrategies.custom = (toVal, fromVal) => {\n  console.log(fromVal, toVal)\n  // => \"goodbye!\", undefined\n  // => \"hello!\", \"goodbye!\"\n  return fromVal || toVal\n}\n\napp.mixin({\n  custom: 'goodbye!',\n  created() {\n    console.log(this.$options.custom) // => \"hello!\"\n  }\n})\n````\n\n> + optionMergeStrategies先获取到子实例的$options的mixin而没有父实例【custom第一次改变从undefined到goodbye--->打印\"goodbye!\", undefined】\n> + 父实例的$options替换掉子实例的$options【custom第二次从goodbye到hello!--->打印了\"hello\", \"goodbye!\"】\n> + 最后在打印app.config.optionMergeStrategies.custom返回的父实例的$options\n\n\n\n> 无论如何this.$options.custom最后会返回合并策略的return的值【使用场景利用父子组件的$options,然后返回计算等操作得到所需要的值】optionMergeStrategies合并$options变化\n\n\n\n#### performance\n\n````vue\n- Vue.config.performance=true;\n+ app.config.performance=true;\n````\n\n> 设置为 true 以在浏览器开发工具的性能/时间线面板中启用对组件初始化、编译、渲染和打补丁的性能追踪。只适用于开发模式和支持 performance.mark API 的浏览器上。\n\n\n\n### directive[教程文档](https://github.com/vuejs/docs-next/blob/master/src/guide/custom-directive.md)\n\n> 注册或获取全局指令。\n\n````\nimport { createApp } from 'vue'\nconst app = createApp({})\n\n// 注册\napp.directive('my-directive', {\n  // 指令的生命周期\n  // 在绑定元素的父组件被挂载之前调用\n  beforeMount(el, binding, vnode) {},\n  // 在挂载绑定元素的父组件时调用\n  mounted(el, binding, vnode) {},\n  // 在更新包含组件的VNode之前调用\n  beforeUpdate(el, binding, vnode, prevNode) {},\n  // 组件的VNode及其子组件的VNode更新之后调用\n  updated(el, binding, vnode, prevNode) {},\n  // 在卸载绑定元素的父组件之前调用\n  beforeUnmount(el, binding, vnode) {},\n  // 在卸载绑定元素的父组件时调用\n  unmounted(el, binding, vnode) {}\n})\n\n// 注册 (指令函数)\napp.directive('my-directive', (el, binding, vnode, prevNode) => {\n  // 这里将会被 `mounted` 和 `updated` 调用\n})\n\n// getter，返回已注册的指令\nconst myDirective = app.directive('my-directive')\n````\n\n![注册 (指令函数)el+binding+vnode+prevNode](https://files.catbox.moe/m00sa0.png)\n\n![binding](https://files.catbox.moe/piuht7.png)\n\n+ el\n\n  指令绑定到的元素。这可以用来直接操作DOM。\n\n+ binding【包含下列属性的对象】\n\n  + instance：使用指令的组件的实例\n\n  + value：指令的绑定值，例如：`v-my-directive=\"1 + 1\"`中，绑定值为 `2`\n\n  + oldValue：指令绑定的前一个值，仅在 `beforeUpdate` 和 `updated` 钩子中可用。无论值是否改变都可用\n\n  + arg：传给指令的参数，可选。例如 `v-my-directive:foo` 中，参数为 `\"foo\"`\n\n  + modifiers：一个包含修饰符的对象。例如：`v-my-directive.foo.bar` 中，修饰符对象为 `{ foo: true, bar: true }`\n\n  + dir：一个对象，在注册指令时作为参数传递;  举个例子，看下面指令\n\n    ```\n    app.directive('focus', {\n      mounted(el) {\n        el.focus()\n      }\n    })\n    ```\n\n    dir就是下面的对象\n\n    ```\n    {\n      mounted(el) {\n        el.focus()\n      }\n    }\n    ```\n\n+ vnode\n\n  编译生成的虚拟节点\n\n+ prevNode\n\n  前一个虚拟节点，仅在beforeUpdate和updated钩子中可用\n\n  > tips:除了 `el` 之外，其它参数都应该是只读的，切勿进行修改。如果需要在钩子之间共享数据，建议通过元素的 [`dataset`](https://developer.mozilla.org/zh-CN/docs/Web/API/HTMLElement/dataset) 来进行\n\n\n\n### mixin【基本Vue2.x一致】\n\n+ optionMergeStrategies 影响，可看上面\n\n> 全局注册一个混入，影响注册之后所有创建的每个 Vue 实例。插件作者可以使用混入，向组件注入自定义的行为。**不推荐在应用代码中使用**。\n\n### mount【类似Vue2.x】\n\n> 在所提供的DOM元素上挂载应用程序实例的根组件\n\n````\nimport { createApp } from 'vue'\n\nconst app = createApp({})\n// 做一些准备\napp.mount('#my-app')\n````\n\n### provide/inject【Vue2.x一致】\n\n> 该选项与inject一起使用，允许一个祖先组件作为其所有后代的依赖注入器，无论组件层次结构有多深，只要它们位于同一父链中就可以\n\n> `provide` 选项应该是一个对象或返回一个对象的函数。该对象包含可注入其子孙的 property。在该对象中你可以使用 ES2015 Symbols 作为 key，但是只在原生支持 `Symbol` 和 `Reflect.ownKeys` 的环境下可工作。\n\n> 如果在组件中两者都只能在当前活动组件实例的 `setup()` 中调用，详细请看依赖注入部分\n\n````\nimport { createApp } from 'vue'\n\nconst app = createApp({\n  provide: {\n    user: 'John Doe'\n  }\n})\n\napp.component('user-card', {\n  inject: ['user'],\n  template: `\n    <div>\n      {{ user }}\n    </div>\n  `\n})\n````\n\n### unmount【新增属性】\n\n在所提供的DOM元素上卸载应用程序实例的根组件\n\n````\nimport { createApp } from 'vue'\n\nconst app = createApp({})\n// 做一些必要的准备\napp.mount('#my-app')\n\n// 应用程序将在挂载后5秒被卸载\nsetTimeout(() => app.unmount('#my-app'), 5000)\n````\n\n### use【Vue2.x一致】\n\n安装 Vue.js 插件。如果插件是一个对象，必须提供 `install` 方法。如果插件是一个函数，它会被作为 install 方法。install 方法调用时，会将 Vue 作为参数传入。\n\n当 install 方法被同一个插件多次调用，插件将只会被安装一次。\n\n\n\n## setup\n\n`setup` 函数是一个新的组件选项。作为在组件内使用 **Composition API** 的入口点\n\n+ 注意 `setup` 返回的 ref 在模板中会自动解开，不需要写 `.value`【`setup` 内部需要`.value`】\n\n### 调用时机\n\n+ 创建组件实例，然后初始化 `props` ，紧接着就调用`setup` 函数。从生命周期钩子的视角来看，它会在 `beforeCreate` 钩子之前被调用\n\n+ 如果 `setup` 返回一个对象，则对象的属性将会被合并到组件模板的渲染上下文\n\n### 参数\n\n+ `props` 作为其第一个参数\n\n> 注意 `props` 对象是响应式的，`watchEffect` 或 `watch` 会观察和响应 `props` 的更新\n>\n> **不要**解构 `props` 对象，那样会使其失去响应性\n\n````\nexport default {\n  props: {\n    name: String,\n  },\n  setup(props) {\n    console.log(props.name)\n     watchEffect(() => {\n      console.log(`name is: ` + props.name)\n    })\n  },\n}\n````\n\n+ 第二个参数提供了一个上下文对象【从原来 2.x 中 `this` 选择性地暴露了一些 property（attrs/emit/slots）】\n\n  > `attrs` 和 `slots` 都是内部组件实例上对应项的代理，可以确保在更新后仍然是最新值。所以可以解构，无需担心后面访问到过期的值\n\n  为什么props作为第一个参数？\n\n  + 组件使用 `props` 的场景更多，有时候甚至只使用 `props`\n  + 将 `props` 独立出来作为第一个参数，可以让 TypeScript 对 `props` 单独做类型推导，不会和上下文中的其他属性相混淆。这也使得 `setup` 、 `render` 和其他使用了 TSX 的函数式组件的签名保持一致\n\n  > **`this` 在 `setup()` 中不可用**。由于 `setup()` 在解析 2.x 选项前被调用，`setup()` 中的 `this` 将与 2.x 选项中的 `this` 完全不同。同时在 `setup()` 和 2.x 选项中使用 `this` 时将造成混乱\n\n  ```js\n  setup(props, { attrs }) {\n      // 一个可能之后回调用的签名\n      function onClick() {\n        console.log(attrs.foo) // 一定是最新的引用，没有丢失响应性\n      }\n    }\n  ```\n\n  ![ts](https://files.catbox.moe/vxu51z.png)\n\n  ![属性](https://files.catbox.moe/v5shq1.png)\n\n\n\n##  响应式系统 API\n\n### `reactive`\n\ndesc: 接收一个普通对象然后返回该普通对象的响应式代理【等同于 2.x 的 `Vue.observable()`】\n\n+ ssss\n\n  tips:`Proxy`对象是目标对象的一个代理器，任何对目标对象的操作（实例化，添加/删除/修改属性等等），都必须通过该代理器。因此我们可以把来自外界的所有操作进行拦截和过滤或者修改等操作\n\n> 响应式转换是“深层的”：会影响对象内部所有嵌套的属性。基于 ES2015 的 Proxy 实现，返回的代理对象**不等于**原始对象。建议仅使用代理对象而避免依赖原始对象\n\n> `reactive` 类的 api 主要提供了将复杂类型的数据处理成响应式数据的能力，其实这个复杂类型是要在`object array map set weakmap weakset` 这五种之中【如下源码，他会判断是否是五类以及是否被冻结】\n\n![源码](https://i.niupic.com/images/2020/08/03/8ubQ.png)\n\n\n\n> 因为是组合函数【对象】，所以必须始终保持对这个所返回对象的引用以保持响应性【不能解构该对象或者展开】例如 `const { x, y } = useMousePosition()`或者`return { ...useMousePosition() }`\n\n````js\nfunction useMousePosition() {\n    const pos = reactive({\n        x: 0,\n        y: 0,\n      })\n    return pos\n}\n````\n\n> [`toRefs`](https://vue-composition-api-rfc.netlify.app/zh/api.html#torefs) API 用来提供解决此约束的办法——它将响应式对象的每个 property 都转成了相应的 ref【把对象转成了ref】。\n>\n> ````js\n>  function useMousePosition() {\n>     const pos = reactive({\n>         x: 0,\n>         y: 0,\n>       })\n>     return toRefs(pos)\n> }\n> \n> // x & y 现在是 ref 形式了!\n> const { x, y } = useMousePosition()\n> ````\n\n### `ref`\n\n接受一个参数值并返回一个响应式且可改变的 ref 对象。ref 对象拥有一个指向内部值的单一属性 `.value`\n\n````js\nconst count = ref(0)\nconsole.log(count.value) // 0\n````\n\n> 如果传入 ref 的是一个对象，将调用 `reactive` 方法进行深层响应转换\n>\n> ![源码](https://i.niupic.com/images/2020/08/03/8uc2.png)\n\n\n\n#### 陷阱\n\n+ `setup` 中`return`返回会自动解套【在模板中不需要`.value`】\n\n  ![](https://i.niupic.com/images/2020/08/03/8uc5.png)\n\n+ ref 作为 reactive 对象的 property 被访问或修改时，也将自动解套 `.value` \n\n  ````js\n  const count = ref(0)\n  /*当做reactive的对象属性----解套*/\n  const state = reactive({\n    count,\n  })\n  /* 不需要.value*/\n  console.log(state.count) // 0\n  \n  /*修改reactive的值*/\n  state.count = 1\n  /*修改了ref的值*/\n  console.log(count.value) // 1\n  ````\n\n  > 注意如果将一个新的 ref 分配给现有的 ref， 将替换旧的 ref\n  >\n  > ````js\n  > /*创建一个新的ref*/\n  > const otherCount = ref(2)\n  > \n  > /*赋值给reactive的旧的ref，旧的会被替换掉*/\n  > state.count = otherCount\n  > /*修改reactive会修改otherCount*/\n  > console.log(state.count) // 2\n  > /*修改reactive会count没有被修改 */\n  > console.log(count.value) // 1\n  > ````\n\n+ 嵌套在 reactive `Object` 中时，ref 才会解套。从 `Array` 或者 `Map` 等原生集合类中访问 ref 时，不会自动解套【自由数据类型是Object才会解套，`array ` `map ` `set `  `weakmap ` `weakset`集合类 **访问 ref 时，不会自动解套**】\n\n  ````js\n  const arr = reactive([ref(0)])\n  // 这里需要 .value\n  console.log(arr[0].value)\n  \n  const map = reactive(new Map([['foo', ref(0)]]))\n  // 这里需要 .value\n  console.log(map.get('foo').value)\n  ````\n\n#### 心智负担上 `ref `  vs  `reactive`\n\n+ 在普通 JavaScript 中区别`声明基础类型变量`与`对象变量`时一样区别使用 `ref` 和 `reactive`\n+ 所有的地方都用 `reactive`，然后记得在组合函数返回响应式对象时使用 `toRefs`。这降低了一些关于 ref 的心智负担\n\n### `readonly`\n\n传入一个对象（响应式或普通）或 ref，返回一个原始对象的**只读**代理。一个只读的代理是“深层的”，对象内部任何嵌套的属性也都是只读的【返回一个永远不会变的只读代理】【场景可以参数比对等】\n\n````js\nconst original = reactive({ count: 0 })\n\nconst copy = readonly(original)\n\nwatchEffect(() => {\n  // 依赖追踪\n  console.log(copy.count)\n})\n\n// original 上的修改会触发 copy 上的侦听\noriginal.count++\n\n// 无法修改 copy 并会被警告\ncopy.count++ // warning!\n````\n\n## `reactive`响应式系统工具集\n\n### `isProxy`\n\n>  检查一个对象是否是由 `reactive` 或者 `readonly` 方法创建的代理\n\n### `isReactive`\n\n>  检查一个对象是否是由 `reactive` 创建的响应式代理\n>\n> ````js\n> import { reactive, isReactive } from 'vue'\n> const state = reactive({\n>       name: 'John'\n>     })\n> console.log(isReactive(state)) // -> true\n> ````\n\n> 如果这个代理是由 `readonly` 创建的，但是又被 `reactive` 创建的另一个代理包裹了一层，那么同样也会返回 `true`\n>\n> ````js\n> import { reactive, isReactive, readonly } from 'vue'\n> const state = reactive({\n>       name: 'John'\n>     })\n> // 用readonly创建一个只读响应式对象plain\n> const plain = readonly({\n>     name: 'Mary'\n> })\n> //readonly创建的，所以isReactive为false\n> console.log(isReactive(plain)) // -> false  \n> \n> // reactive创建的响应式代理对象包裹一层readonly,isReactive也是true,isReadonly也是true\n> const stateCopy = readonly(state)\n> console.log(isReactive(stateCopy)) // -> true\n> ````\n\n### `isReadonly`\n\n> 检查一个对象是否是由 `readonly` 创建的只读代理\n\n## `reactive`高级响应式系统API\n\n### `toRaw`\n\n> 返回由 `reactive` 或 `readonly` 方法转换成响应式代理的普通对象。这是一个还原方法，可用于临时读取，访问不会被代理/跟踪，写入时也不会触发更改。不建议一直持有原始对象的引用【`**不建议赋值给任何变量**`】。请谨慎使用\n\n被**`toRaw`**之后的对象是没有被代理/跟踪的的普通对象\n\n````js\nconst foo = {}\nconst reactiveFoo = reactive(foo)\n\nconsole.log(toRaw(reactiveFoo) === foo) // true\nconsole.log(toRaw(reactiveFoo) !== reactiveFoo) // true\n````\n\n### `markRaw`\n\n显式标记一个对象为“永远不会转为响应式代理”，函数返回这个对象本身。\n\n> 【`markRaw`传入对象，返回的值是永远不会被转为响应式代理的】\n>\n> ````js\n> const foo = markRaw({\n>     name: 'Mary'\n> })\n> console.log(isReactive(reactive(foo))) // false\n> ````\n\n> 被 markRaw 标记了，即使在响应式对象中作属性，也依然不是响应式的\n>\n> ```js\n> const bar = reactive({ foo })\n> console.log(isReactive(bar.foo)) // false\n> ```\n\n#### `markRaw`注意点\n\n+ markRaw和 shallowXXX 一族的 API允许**选择性的**覆盖reactive或者readonly 默认创建的 \"深层的\" 特性【响应式】/或者使用无代理的普通对象\n\n+ 设计这种「浅层读取」有很多原因\n\n  + 一些值的实际上的用法非常简单，并没有必要转为响应式【例如三方库的实例/省市区json/Vue组件对象】\n  + 当渲染一个元素数量庞大，但是数据是不可变的，跳过 Proxy 的转换可以带来性能提升\n\n+ 这些 API 被认为是高级的，是因为这种特性仅停留在根级别，所以如果你将一个嵌套的，没有 `markRaw` 的对象设置为 reactive 对象的属性，在重新访问时，你又会得到一个 Proxy 的版本，在使用中最终会导致**标识混淆**的严重问题：执行某个操作同时依赖于某个对象的原始版本和代理版本（标识混淆在一般使用当中应该是非常罕见的，但是要想完全避免这样的问题，必须要对整个响应式系统的工作原理有一个相当清晰的认知）。\n\n  ````js\n  const foo = markRaw({\n    nested: {},\n  })\n  \n  const bar = reactive({\n    // 尽管 `foo` 己经被标记为 raw 了, 但 foo.nested 并没有\n    nested: foo.nested,\n  })\n  \n  console.log(foo.nested === bar.nested) // false\n  ````\n\n  + foo.nested没有被标记为(永远不会转为响应式代理)，导致最后的值一个reactive\n\n  ![差异](https://i.niupic.com/images/2020/08/03/8udB.png)\n\n### `shallowReactive`\n\n只为某个对象的私有（第一层）属性创建浅层的响应式代理，不会对“属性的属性”做深层次、递归地响应式代理，而只是保留原样【第一层是响应式代理，深层次只保留原样(不具备响应式代理)】\n\n````js\nconst state = shallowReactive({\n  foo: 1,\n  nested: {\n    bar: 2,\n  },\n})\n\n// 变更 state 的自有属性是响应式的【第一层次响应式】\nstate.foo++\n// ...但不会深层代理【深层次不是响应式】(渲染性能)\nisReactive(state.nested) // false\nstate.nested.bar++ // 非响应式\n````\n\n### `shallowReadonly`\n\n类似于`shallowReactive`，区别是：\n\n+ 第一层将会是响应式代理【第一层修改属性会失败】，属性为响应式\n+ 深层次的对象属性可以修改，属性不是响应式\n\n````js\nconst state = shallowReadonly({\n  foo: 1,\n  nested: {\n    bar: 2,\n  },\n})\n\n// 变更 state 的自有属性会失败\nstate.foo++\n// ...但是嵌套的对象是可以变更的\nisReadonly(state.nested) // false\nstate.nested.bar++ // 嵌套属性依然可修改\n````\n\n## `ref` 响应式系统工具集\n\n### `unref`\n\n `unref`是`val = isRef(val) ? val.value : val` 的语法糖\n\n````js\nunref(ref(0))===unref(0)===0   返回number\n````\n\n````js\nfunction useFoo(x: number | Ref<number>) {\n  const unwrapped = unref(x) // unwrapped 一定是 number 类型\n}\n````\n\n### `toRef`\n\n`toRef` 可以用来为一个 reactive 对象的`属性`【某个属性区别toRefs每一个属性】创建一个 ref。这个 ref 可以被传递并且能够保持响应性\n\n````js\nconst state = reactive({\n  foo: 1,\n  bar: 2,\n})\n\n//reactive获取单个属性转为ref【fooRef只是一个代理】\nconst fooRef = toRef(state, 'foo')\n\nfooRef.value++\nconsole.log(state.foo) // 2\n\nstate.foo++\nconsole.log(fooRef.value) // 3\n````\n\n### `toRefs`\n\n把一个响应式对象转换成普通对象，该普通对象的每个 property 都是一个 ref ，和响应式对象 property 一一对应\n\n````js\nconst state = reactive({\n  foo: 1,\n  bar: 2,\n})\n\nconst stateAsRefs = toRefs(state)\n/*\nstateAsRefs 的类型如下:\n\n{\n  foo: Ref<number>,\n  bar: Ref<number>\n}\n*/\n\n// ref 对象 与 原属性的引用是 \"链接\" 上的\nstate.foo++\nconsole.log(stateAsRefs.foo) // 2\n\nstateAsRefs.foo.value++\nconsole.log(state.foo) // 3\n````\n\n> 可以通过`toRefs`返回可解构的reactive，因为`toRefs`包裹之后返回一一对应的ref属性\t\n>\n> ````js\n> function useFeatureX() {\n>   const state = reactive({\n>     foo: 1,\n>     bar: 2,\n>   })\n> \n>   // 对 state 的逻辑操作\n> \n>   // 返回时将属性都转为 ref\n>   return toRefs(state)\n> }\n> \n> export default {\n>   setup() {\n>     // 可以解构，不会丢失响应性\n>     const { foo, bar } = useFeatureX()\n> \n>     return {\n>       foo,\n>       bar,\n>     }\n>   },\n> }\n> ````\n\n### `isRef`\n\n检查一个值是否为一个 ref 对象\n\n## `ref` 高级响应式系统API\n\n### `customRef`\n\n用于自定义一个 `ref`，可以显式地控制依赖追踪和触发响应，接受一个工厂函数，两个参数分别是用于追踪的 `track` 与用于触发响应的 `trigger`，并返回一个一个带有 `get` 和 `set` 属性的对象【实际上就是手动 `track`追踪 和 `trigger`触发响应】\n\n+ 以下代码可以使得v-model防抖\n\n````js\nfunction useDebouncedRef(value, delay = 200) {\n  let timeout\n  return customRef((track, trigger) => {\n    return {\n      get() {\n          /*初始化手动追踪依赖讲究什么时候去触发依赖收集*/\n        track()\n        return value\n      },\n      set(newValue) {\n          /*修改数据的时候会把上一次的定时器清除【防抖】*/\n        clearTimeout(timeout)\n        timeout = setTimeout(() => {\n            /*把新设置的数据给到ref数据源*/\n          value = newValue\n            /*再有依赖追踪的前提下触发响应式*/\n          trigger()\n        }, delay)\n      },\n    }\n  })\n}\n\nsetup() {\n    return {\n        /*暴露返回的数据加防抖*/\n      text: useDebouncedRef('hello'),\n    }\n  }\n````\n\n### `shallowRef`\n\n创建一个 ref ，将会追踪它的 `.value` 更改操作，但是并不会对变更后的 `.value` 做响应式代理转换（即变更不会调用 `reactive`）\n\n> 前面我们说过如果传入 ref 的是一个对象，将调用 `reactive` 方法进行深层响应转换,通过`shallowRef`创建的ref,将不会调用reactive【对象不会是响应式的】\n>\n> ````js\n> const refOne = shallowRef({});\n> refOne.value = { id: 1 };\n> refOne.id == 20;\n> console.log(isReactive(refOne.value),refOne.value);//false  { id: 1 }\n> ````\n>\n> \n\n### `triggerRef` 【与`shallowRef`配合】\n\n手动执行与`shallowRef`相关的任何效果\n\n```js\nconst shallow = shallowRef({\n  greet: 'Hello, world'\n})\n\n// 第一次运行打印 \"Hello, world\" \nwatchEffect(() => {\n  console.log(shallow.value.greet)\n})\n\n// 这不会触发效果，因为ref是shallow\nshallow.value.greet = 'Hello, universe'\n\n// 打印 \"Hello, universe\"\ntriggerRef(shallow)\n```\n\n## Computed and watch【监控变化】\n\n### `computed`\n\n+ 传入一个 getter 函数，返回一个**默认不可手动修改的 ref 对象**【默认传入的是get函数的对象】\n\n+ 传入一个拥有 `get` 和 `set` 函数的对象，创建一个可手动修改的计算状态\n\n![源码](https://i.niupic.com/images/2020/08/03/8ucL.png)\n\n````js\nconst count = ref(1)\n/*不支持修改【只读的】 */\nconst plusOne = computed(() => count.value + 1)\nplusOne.value++ // 错误！\n\n/*【可更改的】 */\nconst plusOne = computed({\n  get: () => count.value + 1,\n  set: (val) => {\n    count.value = val - 1\n  },\n})\n\nplusOne.value = 1\nconsole.log(count.value) // 0\n````\n\n### `watchEffect`\n\n立即执行传入的一个*函数*，并响应式追踪其依赖，并在**其依赖变更时重新运行该函数**\n\n`computed`与`watchEffect`区别：\n\n+ `computed`计算属性可通过setup `return`，再模板中使用，watchEffect不能；\n+ `computed`可以使用多个，并且对多个属性进行不同的响应计算，watchEffect会存在副作用\n\n````js\nconst count = ref(0)\n\nwatchEffect(() => console.log(count.value))\n// -> 打印出 0\n\nsetTimeout(() => {\n  count.value++\n  // -> 打印出 1\n}, 100)\n````\n\n#### 停止观察\n\n> 当在组件的setup()函数或生命周期钩子期间调用watchEffect时，监视程序会链接到组件的生命周期，并在卸载组件时自动停止\n>\n> 一般情况下`watchEffect`返回可以stop 操作，停止监听程序\n>\n> ```js\n> const stop = watchEffect(() => {\n>   /* ... */\n> })\n> \n> // 停止监听程序\n> stop()\n> ```\n\n\n\n#### 副作用(函数式编程)\n\n一个带有副作用的函数不仅只是简单的返回一个值，还干了一些其他的事情，比如:\n\n- 修改一个变量\n- 直接修改数据结构\n- 设置一个对象的成员\n- 抛出一个异常或以一个错误终止\n- 打印到终端或读取用户的输入\n- 读取或写入一个文件\n- 在屏幕上绘画\n\n> buyCoffee的例子(p3)：函数只不过是需要返回一杯咖啡，可是却对费用进行了持久化操作（产生副作用），我们可以在buyCoffee方法返回咖啡时也把费用作为值一并返回，将费用这条记录交给其他程序来做持久化，以此来去除副作用 ====》通过把这些副作用推到程序的外层，来转换任何带有副作用的函数（纯的内核和一层很薄的外围来处理副作用）\n\n> 如果一个函数内外有依赖于外部变量或者环境时，常常我们称之为其有副作用，如果我们仅通过函数签名不打开内部代码检查并不能知道该函数在干什么，作为一个独立函数我们期望有明确的输入和输出，副作用是bug的发源地，作为程序员开发者应尽量少的开发有副作用的函数或方法，副作用也使得方法通用性下降不适合扩展和可重用性\n\n#### 清除副作用\n\n[^]: watchEffect函数都是副作用\n\n在一些时候监听函数将执行**异步**副作用【一个响应式依赖被修改了，会做其他事情】，这些响应需要在其失效时清除(例如在效果完成前状态改变)。effect函数接收一个onInvalidate 函数作入参， 用来注册清理失效时的回调。这个 invalidation函数 在什么时候会被调用：\n\n+ 监听函数重新被执行的时候【响应式依赖的数据被修改】\n\n+ 监听停止的时候（如果watchEffect在`setup()`或者生命周期函数中被使用的时候组件会被卸载）【停止观察】\n\n  ````js\n  watchEffect(onInvalidate => {\n    /*这是个异步操作*/\n    const token = performAsyncOperation(id.value)//id依赖\n    onInvalidate(() => {\n      // id被修改了或者监听停止了会触发token.cancel()事件【这块区域的代码】.\n      // 这里是异步事件的话，前面的peding的异步操作无效【这里的异步事件只执行一次】\n       token.cancel()/*异步操作*/\n      console.log('onInvalidate')\n    })\n  })\n  ````\n````\n  \n  从上面看：我们之所以是通过传入一个函数去注册失效回调，而不是从回调返回它（如 React `useEffect` 中的方式），是因为返回值对于异步错误处理很重要\n  \n  ````js\n  const data = ref(null)\n  watchEffect(async onInvalidate => {\n    onInvalidate(() => {...}) // 我们在Promise的resolves之前注册清理函数(cleanup function)\n    data.value = await fetchData(props.id)\n  })\n````\n\n  我们知道异步函数都会隐式地返回一个 Promise，但是**清理副作用的函数**必须要在 Promise 被 resolve **之前被注册**。另外，Vue 依赖这个返回的 Promise 来自动处理 Promise 链上的潜在错误\n\n#### 副作用刷新时机\n\nVue 的响应式系统会**缓存副作用函数**，并异步地刷新它们，这样可以避免同一个 tick 中多个状态改变导致的不必要的重复调用。在核心的具体实现中, 组件的更新函数也是一个被侦听的副作用。当一个用户定义的副作用函数进入队列时, 会在**所有的组件更新后执行**\n\n````js\n<template>\n  <div>{{ count }}</div>\n</template>\n\n<script>\n  export default {\n    setup() {\n      const count = ref(0)\n\n      watchEffect(() => {\n        console.log(count.value)\n      })\n\n      return {\n        count,\n      }\n    },\n  }\n</script>\n````\n\n- `count` 会在初始运行时同步打印出来\n\n- 更改 `count` 时，将在组件**更新后**执行副作用\n\n  > 初始化运行是在组件 `mounted` 之前执行的【你希望在编写副作用函数时访问 DOM（或模板 ref），请在 `onMounted` 钩子中进行】\n  >\n  > `````js\n  > onMounted(() => {\n  >   watchEffect(() => {\n  >     // 在这里可以访问到 DOM 或者 template refs\n  >   })\n  > })\n  > `````\n\n\n\n> 如果副作用需要同步或在组件更新之前重新运行，我们可以传递一个拥有 `flush` 属性的对象作为选项（默认为 `'post'`）\n>\n> ````js\n> // 同步运行\n> watchEffect(\n>   () => {\n>     /* ... */\n>   },\n>   {\n>     flush: 'sync',\n>   }\n> )\n> \n> // 组件更新前执行\n> watchEffect(\n>   () => {\n>     /* ... */\n>   },\n>   {\n>     flush: 'pre',\n>   }\n> )\n> ````\n\n#### 侦听器调试【响应式调试用的】\n\n`onTrack` 和 `onTrigger` 选项可用于调试一个侦听器的行为。\n\n- 当一个 reactive 对象属性或一个 ref 作为依赖被追踪时，将调用 `onTrack`【调用次数为被追踪的数量】\n- 依赖项变更会导致重新追踪依赖，从而`onTrack`被调用【调用次数为被追踪的数量】\n- 依赖项变更导致副作用被触发时，将调用 `onTrigger`\n\n这两个回调都将接收到一个包含有关所依赖项信息的调试器事件。建议在以下回调中编写 `debugger` 语句来检查依赖关系:【**`onTrack` 和 `onTrigger` 仅在开发模式下生效**】\n\n````js\nwatchEffect(\n  () => {\n    /* 副作用的内容 */\n  },\n  {\n    onTrigger(e) {\n      /*副作用依赖修改*/\n      debugger\n    },\n    onTrack(e) {\n      /*副作用依赖修改*/\n      debugger\n    },\n  }\n)\n````\n\n![ts](https://files.catbox.moe/eobnec.png)\n\n\n\n### `watch`\n\n`watch` API 完全等效于 2.x `watch` 中相应的选项。`watch` 需要侦听特定的数据源，并在回调函数中执行副作用【默认情况是懒执行的，也就是说仅在侦听的源变更时才执行回调】\n\n`watch`允许我们:\n\n+ 懒执行副作用\n+ 更明确哪些状态的改变会触发侦听器重新运行副作用\n+ 访问侦听状态变化前后的值\n\n#### **侦听单个数据源**\n\n侦听器的数据源可以是一个拥有返回值的 getter 函数，也可以是 ref:\n\n````js\n// 侦听一个 getter\nconst state = reactive({ count: 0 })\nwatch(\n  () => state.count,\n  (count, prevCount) => {\n    /* ... */\n  }\n)\n\n// 直接侦听一个 ref\nconst count = ref(0)\nwatch(count, (count, prevCount) => {\n  /* ... */\n})\n````\n\n#### **侦听多个数据源**\n\n> `watcher` 也可以使用数组来同时侦听多个源\n>\n> ````js\n> watch([fooRef, barRef], ([foo, bar], [prevFoo, prevBar]) => {\n>   /* ... */\n> })\n> ````\n\n\n\n#### **与 `watchEffect` 共享的行为**\n\nwatch 和 watchEffect 在[停止侦听](https://vue-composition-api-rfc.netlify.app/zh/api.html#手动停止侦听), [清除副作用](https://vue-composition-api-rfc.netlify.app/zh/api.html#清除副作用) (相应地 `onInvalidate` 会作为回调的第三个参数传入)，[副作用刷新时机](https://vue-composition-api-rfc.netlify.app/zh/api.html#副作用刷新时机) 和 [侦听器调试](https://vue-composition-api-rfc.netlify.app/zh/api.html#侦听器调试) 等方面行为一致\n\n````js\nwatch([fooRef, barRef], ([foo, bar], [prevFoo, prevBar],onInvalidate) => {\n  /* ... */\n  onInvalidate(() => {...})\n},\n  {\n    onTrigger(e) {\n      /*副作用依赖修改*/\n      debugger\n    },\n    onTrack(e) {\n      /*副作用依赖修改*/\n      debugger\n    },\n  })\n````\n\n## 生命周期钩子函数\n\n### **与 2.x 版本生命周期相对应的组合式 API**\n\n-  ~~`beforeCreate`~~ -> 使用 `setup()`\n- ~~`created`~~ -> 使用 `setup()`\n- `beforeMount` -> `onBeforeMount`\n- `mounted` -> `onMounted`\n- `beforeUpdate` -> `onBeforeUpdate`\n- `updated` -> `onUpdated`\n- `beforeDestroy` -> `onBeforeUnmount`\n- `destroyed` -> `onUnmounted`\n- `errorCaptured` -> `onErrorCaptured`\n\n````js\nimport { onMounted, onUpdated, onUnmounted } from 'vue'\nsetup() {\n    onMounted(() => {\n      console.log('mounted!')\n    })\n    onUpdated(() => {\n      console.log('updated!')\n    })\n    onUnmounted(() => {\n      console.log('unmounted!')\n    })\n  }\n````\n\n这些生命周期钩子注册函数只能在 `setup()` 期间同步使用， 因为它们依赖于内部的全局状态来定位当前组件实例（正在调用 `setup()` 的组件实例）, 不在当前组件下调用这些函数会抛出一个错误。\n\n组件实例上下文也是在生命周期钩子同步执行期间设置的，因此，在卸载组件时，在生命周期钩子内部同步创建的侦听器和计算状态也将自动删除。\n\n### **新增的钩子函数**\n\n除了和 2.x 生命周期等效项之外，组合式 API 还提供了以下调试钩子函数：\n\n- `onRenderTracked`\n- `onRenderTriggered`\n\n两个钩子函数都接收一个 `DebuggerEvent`，与 `watchEffect` 参数选项中的 `onTrack` 和 `onTrigger` 类似:\n\n````js\nexport default {\n  onRenderTracked(e){\n      debugger\n    // 检查有响应和追踪的依赖性\n },\n  onRenderTriggered(e) {\n    debugger\n    // 检查哪个依赖性导致组件重新渲染\n  },\n}\n````\n\n## Vue提供的内置组件\n\n### component 与Vue2.x一致\n\n渲染一个“元组件”为动态组件。依 `is` 的值，来决定哪个组件被渲染。\n\n````\n<!-- 动态组件由 vm 实例的 `componentId` property 控制 -->\n<component :is=\"componentId\"></component>\n\n<!-- 也能够渲染注册过的组件或 prop 传入的组件 -->\n<component :is=\"$options.components.child\"></component>\n````\n\n### transition 与 Vue2.x 【基本】 一致有差异\n\n+ **Props新增**：\n  + `persisted` \\- `boolean `如果为true，则表示这是一个转换，实际上不会插入/删除元素，而是切换显示/隐藏状态。 transition 过渡挂钩被注入，但会被渲染器跳过。 相反，自定义指令可以通过调用注入的钩子（例如v-show）来控制过渡\n  + ~~`enter-class`~~----->`enter-from-class`\n  + ~~`leave-class`~~----->`leave-from-class`\n+ 事件\n  + ~~`before-appear`~~\n\n### transition-group 与 Vue2.x 一致\n\n### slot 与 Vue2.x 一致\n\n### teleport 【新增组件】\n\n+ **Props**\n\n  + `to` - `string` 必填属性，必须是一个有效的query选择器，或者是元素(如果在浏览器环境中使用）。<teleport>中的内容将会被放置到指定的目标元素中\n\n    ````js\n    <!-- 正确的 -->\n    <teleport to=\"#some-id\" />\n    <teleport to=\".some-class\" />\n     /*元素*/\n    <teleport to=\"[data-teleport]\" />\n    \n    <!-- 错误的 -->\n    <teleport to=\"h1\" />\n    <teleport to=\"some-string\" />\n    ````\n\n  + `disabled`  \\- `boolean` 这是一个可选项 ，做一个是可以用来禁用<teleport>的功能，这意味着它的插槽内容不会移动到任何地方，而是按没有`teleport`组件一般来呈现【默认为false】\n\n    ````js\n    <teleport to=\"#popup\" :disabled=\"displayVideoInline\">\n      <h1>999999</h1>\n    </teleport>\n    ````\n\n    注意，这将移动实际的DOM节点，而不是销毁和重新创建，并且还将保持任何组件实例是活动的。所有有状态HTML元素(比如一个正在播放的视频)将保持它们的状态。【控制displayVideoInline并不是销毁重建，它保持实例是存在的，不会被注销】\n\n#### 关于Teleport 其他内容\n\nVue鼓励我们通过将UI和相关行为封装到组件中来构建UI。我们可以将它们彼此嵌套在一起，以构建构成应用程序UI的树\n\n但是，有时组件模板的一部分逻辑上属于这个组件，而从技术角度来看，最好将这一部分模板移到DOM中的其他地方，放到Vue应用程序之外\n\n一个常见的场景是创建一个包含全屏模态的组件。在大多数情况下，您希望模态的逻辑驻留在组件中，但是模态框的定位问题很快就很难通过CSS解决，或者需要更改组件的组成\n\n考虑下面的HTML结构：\n\n````js\n<body>\n  <div style=\"position: relative;\">\n    <h3>Tooltips with Vue 3 Teleport</h3>\n    <div>\n      <modal-button></modal-button>\n    </div>\n  </div>\n</body>\n````\n\n让我们看看 `mode -button`\n\n该组件将有一个`button`元素来触发模态的打开，还有一个div元素，其类为.modal，它将包含模态的内容和一个自关闭按钮\n\n````js\nconst app = Vue.createApp({});\n\napp.component('modal-button', {\n  template: `\n    <button @click=\"modalOpen = true\">\n        Open full screen modal!\n    </button>\n\n    <div v-if=\"modalOpen\" class=\"modal\">\n      <div>\n        I'm a modal! \n        <button @click=\"modalOpen = false\">\n          Close\n        </button>\n      </div>\n    </div>\n  `,\n  data() {\n    return { \n      modalOpen: false\n    }\n  }\n})\n````\n\n当在初始HTML结构中使用这个组件时，我们可以看到一个问题——模态被呈现在深嵌套的div中，模态的绝对位置以父div相对位置作为参考。\n\n![](https://files.catbox.moe/7pil2k.png)\n\n![](https://files.catbox.moe/nk1w9w.png)\n\nTeleport提供了一种干净的方式，允许我们控制DOM中希望在哪个父节点下呈现HTML片段，而不必诉诸全局状态或将其拆分为两个组件。\n\n让我们修改我们的modal-button来使用<teleport>并告诉Vue \"teleport this HTML to the \"body\"标签\"。\n\n````\napp.component('modal-button', {\n  template: `\n    <button @click=\"modalOpen = true\">\n        Open full screen modal! (With teleport!)\n    </button>\n\n    <teleport to=\"body\">\n      <div v-if=\"modalOpen\" class=\"modal\">\n        <div>\n          I'm a teleported modal! \n          (My parent is \"body\")\n          <button @click=\"modalOpen = false\">\n            Close\n          </button>\n        </div>\n      </div>\n    </teleport>\n  `,\n  data() {\n    return { \n      modalOpen: false\n    }\n  }\n})\n````\n\n![](https://files.catbox.moe/wymwe9.png)\n\n![](https://files.catbox.moe/9lrbzm.png)\n\n\n\n#### 与Vue组件一起使用\n\n如果<teleport>包含一个Vue组件，它将仍然是<teleport>的父组件的逻辑子组件\n\n````js\nconst app = Vue.createApp({\n  template: `\n    <h1>Root instance</h1>\n    <parent-component />\n  `\n})\n\napp.component('parent-component', {\n  template: `\n    <h2>This is a parent component</h2>\n    <teleport to=\"#endofbody\">\n      <child-component name=\"John\" />\n    </teleport>\n  `\n})\n\napp.component('child-component', {\n  props: ['name'],\n  template: `\n    <div>Hello, {{ name }}</div>\n  `\n})\n````\n\n在这种情况下，即使在不同的地方呈现`child-component`，它仍将是`parent-componen`的子组件【而不是爷爷组件】，并将从其父组件接收一个name 的props\n\n这也意味着来自父组件的注入如预期的那样工作，并且子组件将嵌套在Vue Devtools的父组件之下，而不是放在实际内容移动到的地方\n\n#### 对同一目标使用多次teleports\n\n一个常见的用例场景是一个可重用的<Modal>组件，该组件可能同时有多个活动实例。对于这种场景，多个<teleport>组件可以将它们的内容挂载到相同的目标元素。这个顺序将是一个简单的附加—稍后的挂载将位于目标元素中较早的挂载之后。\n\n`````js\n<teleport to=\"#modals\">\n  <div>A</div>\n</teleport>\n<teleport to=\"#modals\">\n  <div>B</div>\n</teleport>\n\n<!-- result-->\n<div id=\"modals\">\n  <div>A</div>\n  <div>B</div>\n</div>\n`````\n\n## 依赖注入Provide / Inject\n\n`provide` 和 `inject` 提供依赖注入，功能类似 2.x 的 `provide/inject`。两者都只能在当前活动组件实例的 `setup()` 中调用\n\n例如，如果我们想在根组件上提供一个book name，并将其inject到子组件上\n\n````js\nimport { provide, inject } from 'vue'\n\nconst RootComponent = {\n  setup() {\n    provide('book', 'Vue 3 guide')\n  }\n}\n\nconst MyBook = {\n  setup() {\n    const book = inject(\n      'book',\n      'Eloquent Javascript' /* 选项的默认值，假如父组件不提供值就返回默认 */\n    )\n    return {\n      book\n    }\n  }\n}\n````\n\n`inject` 接受一个可选的的默认值作为第二个参数。如果未提供默认值，并且在 provide 上下文中未找到该属性，则 `inject` 返回 `undefined`。\n\n如果我们需要提供或注入多个值，我们可以通过随后分别调用provide或inject来实现【多次调用】\n\n````js\nimport { provide, inject } from 'vue'\n\nconst RootComponent = {\n  setup() {\n    provide('book', 'Vue 3 guide')\n    provide('year', '2020')\n  }\n}\n\nconst MyBook = {\n  setup() {\n    const book = inject(\n      'book',\n      'Eloquent Javascript' /* 选项的默认值，假如父组件不提供值就返回默认 */\n    )\n    const year = inject('year')\n    return {\n      book,\n      year\n    }\n  }\n}\n````\n\n#### **注入的响应性**\n\n可以使用 `ref` 或 `reactive` 来保证 `provided` 和 `injected` 之间值的响应\n\n````js\nimport { ref, reactive } from 'vue'\n\n// 提供者\nsetup() {\n  const book = reactive({\n    title: 'Vue 3 Guide',\n    author: 'Vue Team'\n  })\n  const year = ref('2020')\n\n /*提供reactive响应式*/\n  provide('book', book)\n /*提供ref响应式*/\n  provide('year', year)\n}\n\n// 消费者\nsetup() {\n  const book = inject('book')\n  const year = inject('year')\n /*响应式*/\n  return { book, year }\n}\n````\n\n现在，当提供者组件上的book或year发生变化时，我们可以观察到它们在注入的组件上的变化。\n\n> 警告:我们不建议改变一个被注入的反应性属性【子组件去修改数据流】，因为它会破坏Vue的单向数据流。相反，尝试在提供值【父组件去修改】的地方改变值，或者提供一个方法来改变值\n>\n> ````js\n> import { ref, reactive } from 'vue'\n> \n> // in provider\n> setup() {\n>   const book = reactive({\n>     title: 'Vue 3 Guide',\n>     author: 'Vue Team'\n>   })\n> \n>   function changeBookName() {\n>     book.title = 'Vue 3 Advanced Guide'\n>   }\n> \n>   provide('book', book)\n>   provide('changeBookName', changeBookName)\n> }\n> \n> // in consumer\n> setup() {\n>   const book = inject('book')\n>   const changeBookName = inject('changeBookName')\n> \n>   return { book, changeBookName }\n> }\n> ````\n\n## 指令\n\n### v-text 【Vue2.x一致】\n\n### v-html【Vue2.x一致】\n\n### v-show【Vue2.x一致】\n\n### v-if【Vue2.x一致】\n\n### v-else【Vue2.x一致】\n\n### v-else-if【Vue2.x一致】\n\n### v-for【Vue2.x一致】\n\n### v-on【Vue2.x一致】\n\n### v-bind 【Vue2.x **修饰符**差异】\n\n**修饰符**\n\n+ ~~`.prop`~~ 去除\n+ ~~`.sync`~~ 去除\n+ `.camel` 将 kebab-case attribute 名转换为 camelCase\n\n### v-model【Vue2.x一致】\n\n### v-slot【Vue2.x一致】\n\n### v-cloak【Vue2.x一致】\n\n### v-once 【Vue2.x一致】\n\n### v-pre【Vue2.x一致】\n\n### v-is【新增】\n\n> 注意:本节只影响在页面的HTML中直接编写Vue模板的情况\n\n+ 限制：原生html元素\n\n+ 使用：\n\n   使用in-DOM模板时，该模板应遵守本机HTML解析规则。 某些HTML元素（例如<ul>，<ol>，<table>和<select>）对可以在其中显示哪些元素有限制，而某些元素（例如<li>，<tr>和<option>）只能 出现在某些其他元素内。 解决方法是，我们可以在这些元素上使用v-is指令【作用就是转成组件的名字】\n\n> 警告v-is 功能 像一个动态2.x `:is` 绑定 所以要根据注册的名称渲染组件，它的值应该是一个JavaScript字符串\n>\n> ````js\n> <!-- 不正确的, 不会出现任何渲染 -->\n> <tr v-is=\"blog-post-row\"></tr>\n> \n> <!-- 正确 -->\n> <tr v-is=\"'blog-post-row'\"></tr>\n> ````\n>\n> ![](https://files.catbox.moe/297484.png)\n\n\n\n## 全局API\n\n### createApp\n\n返回一个应用程序实例,提供了一个应用程序上下文。应用程序实例挂载的整个组件树共享相同的上下文\n\n```JS\nconst app = Vue.createApp({})\n```\n\n#### 参数\n\n+ 该函数接收一个根组件选项对象作为第一个参数\n\n````js\nconst app = Vue.createApp({\n  data() {\n    return {\n      ...\n    }\n  },\n  methods: {...},\n  computed: {...}\n  setup(){...}\n  ...\n})\n````\n\n+ 使用第二个参数，我们可以将根组件props 传递给应用\n\n````js\n<div id=\"app\">\n  <!-- 这里将会显示 'Evan' -->\n  {{ username }}\n</div>\n\nconst app = Vue.createApp(\n  {\n    props: ['username']\n  },\n  { username: 'Evan' }\n)\n````\n\n![](https://files.catbox.moe/wbzptw.png)\n\n### h\n\n返回“虚拟节点”，通常缩写为VNode:一个简单的对象，它包含描述Vue应该在页面上渲染何种类型的节点的信息，包括对任何子节点的描述。你可以手动阅读[render functions](https://github.com/vuejs/docs-next/blob/master/src/guide/render-function.md)\n\n````js\nrender() {\n  return Vue.h('h1', {}, 'Some title')\n}\n````\n\n#### 参数\n\n接受三个参数`tag`, `props` and `children`\n\n+ **tag**: \n\n  + 类型：`String | Object | Function | null`\n  + 详情:一个HTML标签名，一个组件，一个异步组件或null。使用null将渲染成注释。此参数是必需的\n\n+ #### **props**\n\n  + 类型:`Object`\n  + 详情:模板中使用的attributes、props 和events 对应的对象。可选\n\n+ **children**\n\n  + 类型: `String | Array | Object`\n\n  + 详情：\n\n    Children VNodes，使用h()构建，或使用字符串来获取“text VNodes”或带有槽的对象。可选\n\n````js\nconst aaa = {\n  props: {\n    someProp: String\n  },\n  setup(props) {\n    console.log(props, \"dsadasdasddasds\");\n  },\n  render() {\n    return h(\n      \"h2\",\n        // {Object}props\n        //与props，attributes和events相对应的对象\n        //我们将在template中使用。\n        // 可选的。\n        {style: {\"font-size\": \"20px\",\n          color: \"#136\"}},\n          [this.someProp,this.$slots.default()]);\n        }\n};\napp.component(\"anchored-heading\", {\n  render() {\n    return h(\n        /*\n\t\t// {String | Object | Function | null}标签\n        // HTML标记名称，组件，异步组件或null。\n        //使用null将渲染注释。\n        //必填\n        */\n      \"h\" + this.level, // tag name\n        // {Object}props\n        //与props，attributes和events相对应的对象\n        //我们将在template中使用。\n        // 可选的。\n      {}, \n        // {String | Array | Object} children\n        //使用`h（）`构建的子级VNode，\n        //或使用字符串获取“文本VNodes”或\n        //具有插槽的对象。\n        // 可选的。\n      [\n        \"Some text comes first.\",\n        h(\"h1\", \"A headline\"),\n        h(aaa, {\n          someProp: \"foobar\"\n        })\n      ]  );},\n});\n````\n\n![](https://files.catbox.moe/h8e4xn.png)\n\n````js\n Vue.h(\n        'a',\n        {\n          name: headingId,\n          href: '#' + headingId\n        },\n        this.$slots.default()\n      )\n    ])\n````\n\n#### 限制\n\n#####  VNodes 必须独一无二\n\n+ 组件树中的所有vnode必须是唯一的。这意味着下面的渲染函数是无效的\n\n  ````js\n   render() {\n       const myParagraphVNode = Vue.h('p', 'hi')\n        return Vue.h('div', [\n          // 表示惊讶 - 副本复制 VNodes!\n          myParagraphVNode, myParagraphVNode\n        ])\n    }\n  ````\n\n+ 如果您确实想多次复制相同的元素/组件，则可以使用工厂函数进行复制。 例如，以下呈现函数是呈现20个相同段落的完美有效方法：\n\n  ````js\n  render() {\n    return Vue.h('div',\n      Array.apply(null, { length: 20 }).map(() => {\n        return Vue.h('p', 'hi')\n      })\n    )\n  }\n  ````\n\n##### 用普通的JavaScript替换模板特性\n\n######  `v-if` and `v-for`\n\n在任何地方都可以用普通JavaScript轻松完成，Vue渲染functions 都不提供专有的替代方案。例如，在使用v-if和v-for的模板中\n\n````js\n<ul v-if=\"items.length\">\n  <li v-for=\"item in items\">{{ item.name }}</li>\n</ul>\n<p v-else>No items found.</p>\n==>\nprops: ['items'],\nrender() {\n  if (this.items.length) {\n    return Vue.h('ul', this.items.map((item) => {\n      return Vue.h('li', item.name)\n    }))\n  } else {\n    return Vue.h('p', 'No items found.')\n  }\n}   \n````\n\n###### `v-model`\n\nv-model指令被扩展到`modelValue`和`onUpdate:modelValue`道具在模板编译期间，我们将不得不自己提供这些props \n\n````js\nprops: ['modelValue'],\nrender() {\n  return Vue.h(SomeComponent, {\n    modelValue: this.modelValue,\n    'onUpdate:modelValue': value => this.$emit('update:modelValue', value)\n  })\n}\n````\n\n###### `v-on`\n\n我们必须为事件处理程序提供一个适当的prop名称，例如，为了处理`click`事件，prop名称应该是`onClick`\n\n````js\nrender() {\n  return Vue.h('div', {\n    onClick: $event => console.log('clicked', $event.target)\n  })\n}\n````\n\n###### `事件修饰符`\n\n对于.passive、.capture和.once事件修饰符，Vue提供了处理程序的对象语法\n\n```js\nrender() {\n  return Vue.h('input', {\n    onClick: {\n      handler: this.doThisInCapturingMode,\n      capture: true\n    },\n    onKeyUp: {\n      handler: this.doThisOnce,\n      once: true\n    },\n    onMouseOver: {\n      handler: this.doThisOnceInCapturingMode,  //事件\n      once: true, //是否触发一次\n      capture: true \n    },\n  })\n}\n```\n\n对于所有其他事件和键修饰符，不需要特殊的API，因为我们可以在处理程序中使用事件方法\n\n![](https://files.catbox.moe/ftdpzd.png)\n\n````js\nrender() {\n  return Vue.h('input', {\n    onKeyUp: event => {\n      // 如果发出事件的元素不存在，则中止事件绑定到的元素\n      if (event.target !== event.currentTarget) return\n      // 同时如果按下的键不是enter键key (13)以及shift键没有按下\n      if (!event.shiftKey || event.keyCode !== 13) return\n      // 停止事件传播\n      event.stopPropagation()\n      // 阻止此元素的默认keyup处理程序\n      event.preventDefault()\n      // ...\n    }\n  })\n}\n````\n\n###### `Slots`\n\n你可以访问插槽内容`this.$slots`在VNodes数组的\n\n````js\nrender() {\n  // `<div><slot></slot></div>`\n  return Vue.h('div', {}, this.$slots.default())\n}\n````\n\n````js\nprops: ['message'],\nrender() {\n  // `<div><slot :text=\"message\"></slot></div>`\n  return Vue.h('div', {}, this.$slots.default({\n    text: this.message\n  }))\n}\n````\n\n使用render函数将槽传递给子组件\n\n````js\nrender() {\n  // `<div><child v-slot=\"props\"><span>{{ props.text }}</span></child></div>`\n  return Vue.h('div', [\n    Vue.h('child', {}, {\n      // 通过`slots'作为子对象\n      // in the form of { name: props => VNode | Array<VNode> }\n      default: (props) => Vue.h('span', props.text)\n    })\n  ])\n}\n````\n\n###### `JSX`\n\n如果我们要编写大量的渲染函数，编写这样的东西可能会让人感到痛苦\n\n````js\nVue.h(\n  'anchored-heading',\n  {\n    level: 1\n  },\n  [Vue.h('span', 'Hello'), ' world!']\n)\n````\n\n特别是当模板版本相比之下如此简洁的时候\n\n````js\n<anchored-heading :level=\"1\"> <span>Hello</span> world! </anchored-heading>\n````\n\n这就是为什么有一个Babel插件可以在Vue中使用JSX，让我们回到更接近模板的语法\n\n````js\nimport AnchoredHeading from './AnchoredHeading.vue'\n\nnew Vue({\n  el: '#demo',\n  render() {\n    return (\n      <AnchoredHeading level={1}>\n        <span>Hello</span> world!\n      </AnchoredHeading>\n    )\n  }\n})\n````\n\n### defineComponent【组件】\n\n在实现方面，defineComponent只会执行返回传递给它的对象的操作。 但是，就类型而言，返回的值具有人工渲染功能，TSX和IDE工具支持的构造函数的综合类型\n\n#### 参数\n\n具有组件选项的对象\n\n```js\nimport { defineComponent } from 'vue'\n\nconst MyComponent = defineComponent({\n  data() {\n    return { count: 1 }\n  },\n  methods: {\n    increment() {\n      this.count++\n    }\n  }\n})\n```\n\n### defineAsyncComponent 【异步组件】\n\n创建只在必要时加载的异步组件\n\n#### 参数\n\n对于基本用法，defineAsyncComponent可以接受返回`Promise`的工厂函数。当您从serve检索到组件定义时，应该调用Promise的解析回调。您还可以调用reject(reason)来指示加载失败。\n\n````js\nimport { defineAsyncComponent } from 'vue'\n\n\nconst AsyncComp = defineAsyncComponent(() =>\n   /*或者*/\n  import('./components/AsyncComponent.vue')\n   /*或者*/\n  new Promise((resolve, reject) => {\n  /*可以reject*/\n      resolve({\n        template: '<div>I am async!</div>'\n      })\n    })\n)\n\napp.component('async-component', AsyncComp)\n````\n\n在使用本地注册时，还可以直接提供返回Promise的函数\n\n```js\nimport { createApp, defineAsyncComponent } from 'vue'\n\ncreateApp({\n  // ...\n  components: {\n    AsyncComponent: defineAsyncComponent(() =>\n      import('./components/AsyncComponent.vue')\n    )\n  }\n})\n```\n\n对于高级用法，defineAsyncComponent可以接受一个对象\n\n````js\nconst AsyncComp = defineAsyncComponent({\n  // 工厂函数\n  loader: () => import('./Foo.vue')\n  // 加载异步组件时使用的组件\n  loadingComponent: LoadingComponent,\n  //加载失败的时候使用的组件\n  errorComponent: ErrorComponent,\n  // 在显示加载组件之前延迟。默认值:200 ms。\n  delay: 200,\n  // 如果超时，将显示错误组件\n  // 存在timeout并且超过这个时间. 默认值:无穷\n  timeout: 3000,\n  // 返回布尔值的函数，指示当加载器promise rejects时异步组件是否应该重试\n  retryWhen: error => error.code !== 404,\n  // 允许的最大重试次数\n  maxRetries: 3,\n  // 定义组件是否可挂载\n  suspensible: false\n})\n````\n\n### resolveComponent\n\n> 警告resolveComponent只能在`render`或`setup`函数中使用。\n>\n> 允许通过名称解析组件，如果它在当前应用程序实例中可用。如果找不到组件，返回组件或未定义组件\n>\n> 如果找不到组件，返回组件或未定义组件【组件】\n>\n> ````js\n> app.component('MyComponent', {\n>   /* ... */\n> })\n> const MyComponent = resolveComponent('MyComponent')\n> ````\n\n###  resolveDynamicComponent【解析活动的组件active】\n\n> resolveDynamicComponent只能在`render`或`setup`函数中使用。\n>\n> 允许使用与<component:is=\"\">相同的机制来解析组件。\n>\n> 返回解析的组件或一个新创建的VNode以组件名称作为节点标记的。\n>\n> 如果没有找到组件，会发出警告\n\n### resolveDirective\n\n> 警告resolveDirective只能在`render`或`setup`函数中使用。\n>\n> 允许通过名称解析指令，如果它在当前应用程序实例中可用。\n>\n> 返回一个`Directive`或 当没有找到的时候，返回`undefined`。\n>\n> ````js\n> app.directive('highlight', {})\n> render(){\n>     const highlightDirective = resolveDirective('highlight')\n> }\n> ````\n\n### withDirectives\n\n> 警告`withDirectives`只能在`render`或`setup`函数中使用。\n>\n> :::允许应用指令到VNode。返回一个带有应用指令的VNode。\n>\n> ````js\n> const bar = resolveDirective('bar')\n> \n> return withDirectives(h('div'), [\n>   [bar, this.y]\n> ])\n> ````\n\n### createRenderer *【待】\n\n### nextTick\n\n将回调延迟到下一个DOM更新周期之后执行。在更改了一些数据以等待DOM更新之后立即使用它\n\n````js\nsetup() {\n    const message = ref('Hello!')\n    const changeMessage = async newMessage => {\n      message.value = newMessage\n      /*等待DOM更新*/\n      await nextTick()\n      console.log('Now DOM is updated')\n    }\n  }\n````\n\n## 实例方法methods\n\n### $watch\n\n#### 参数\n\n- `{string | Function} source`\n- `{Function | Object} callback`\n- `{Object} [options]`\n  - `{boolean} deep`\n  - `{boolean} immediate`\n\n#### 用法\n\n观察组件实例上的响应式属性或computed函数的更改。使用回调获取到给定属性的新值和旧值。我们只能通过顶级data、prop或computed的属性名作为字符串的形式传递。对于更复杂的表达式或嵌套属性，使用函数代替。\n\n#### 例子\n\n````js\nconst app = Vue.createApp({\n  data() {\n    return {\n      a: 1,\n      b: 2,\n      c: {\n        d: 3,\n        e: 4\n      }\n    }\n  },\n  created() {\n    // 顶级属性名a\n    this.$watch('a', (newVal, oldVal) => {\n      // 做一些事\n    })\n\n    // 观察监视单个嵌套属性\n    this.$watch(\n      () => this.c.d,\n      (newVal, oldVal) => {\n        // 做一些事\n      }\n    )\n\n    // 监控复杂表达式\n    this.$watch(\n      // 每当表达式`this.a + this.b`产生不同的结果时\n      // 处理程序将被调用。这就好像我们在看computed属性\n      // 而不定义计算属性本身\n      () => this.a + this.b,\n      (newVal, oldVal) => {\n        // 做一些事\n      }\n    )\n  }\n})\n````\n\n> + 当监视的值是对象或数组时，对其属性或元素的任何更改都不会触发监视程序，因为它们引用相同的对象/数组\n>\n> ````js\n> const app = Vue.createApp({\n>   data() {\n>     return {\n>       article: {\n>         text: 'Vue is awesome!'\n>       },\n>       comments: ['Indeed!', 'I agree']\n>     }\n>   },\n>   created() {\n>     this.$watch('article', () => {\n>       console.log('Article changed!')\n>     })\n> \n>     this.$watch('comments', () => {\n>       console.log('Comments changed!')\n>     })\n>   },\n>   methods: {\n>     // 这些方法不会触发观察者，因为我们仅更改了对象/数组的属性,\n>     // 并不是 Object/Array 本身\n>     changeArticleText() {\n>       this.article.text = 'Vue 3 is awesome'\n>     },\n>     addComment() {\n>       this.comments.push('New comment')\n>     },\n> \n>     // 这些方法会触发观察者，因为我们完整替换了对象/数组\n>     changeWholeArticle() {\n>       this.article = { text: 'Vue 3 is awesome' }\n>     },\n>     clearComments() {\n>       this.comments = []\n>     }\n>   }\n> })\n> ````\n>\n> + $watch返回一个取消监视的函数，该函数停止触发回调\n>\n> ````js\n> const unwatch = vm.$watch('a', cb)\n> // later, teardown the watcher\n> unwatch()\n> ````\n\n#### **Option: deep**\n\n检测对象内部嵌套的值更改，需要在options参数中传入deep: true。注意，侦听数组突变并不需要这样做。\n\n````js\nvm.$watch('someObject', callback, {\n  deep: true\n})\nvm.someObject.nestedValue = 123\n// 触发回调\n````\n\n#### **Option: immediate**\n\n在选项中传入immediate: true将立即用表达式的当前值触发回调\n\n````js\nvm.$watch('a', callback, {\n  immediate: true\n})\n// “callback”被立即触发，当前值为“a”\n````\n\n>  请注意，使用`immediate`选项，您将无法在第一个回调调用中取消监视给定的属性。\n>\n> ````js\n> //这个例子是错误的\n> const unwatch = vm.$watch(\n>   'value',\n>   function() {\n>     doSomething()\n>     unwatch()\n>   },\n>   { immediate: true }\n> )\n> ````\n>\n> 如果你仍然想在回调中调用一个unwatch函数，你应该首先检查它的可用性\n>\n> `````js\n> const unwatch = vm.$watch(\n>   'value',\n>   function() {\n>     doSomething()\n>     if (unwatch) {\n>       unwatch()\n>     }\n>   },\n>   { immediate: true }\n> )\n> `````\n\n### $emit 【一致】\n\n### $forceUpdate【一致】\n\n### $nextTick【一致】\n\n## 实例 property\n\n### vm.$data 【一致】\n\n### vm.$props 【一致】\n\n### vm.$el 【一致】\n\n### vm.$options 【一致】\n\n### vm.$parent 【一致】\n\n### vm.$root【一致】\n\n### vm.$slots 【一致】\n\n### vm.$refs 【一致】\n\n### vm.$attrs 【一致】\n\n![](https://files.catbox.moe/qw8krc.png)![](https://files.catbox.moe/1blngf.png)\n\n### 废弃:\n\n#### ~~vm.$children~~\n\n#### ~~vm.$slots~~\n\n#### ~~vm.$scopedSlots~~\n\n#### ~~vm.$isServer~~\n\n#### ~~vm.$listeners~~\n\n## 选项 / 组合\n\n#### mixins 【一致】\n\n#### extends【一致】\n\n#### provide / inject【一致】\n\n#### ~~parent~~【废弃】\n\n#### setup【新增】\n\n详情见上\n\n## 选项 / 资源\n\n### directives【一致】\n\n### components【一致】\n\n### ~~filters~~【废弃】\n\n## 选项 / 数据\n\n### data【一致】\n\n### props【一致】\n\n### computed【一致】\n\n### methods【一致】\n\n### watch【一致】\n\n### emits【新增】\n\n#### **详情**\n\n可以从组件发出的自定义事件的list/hash。 它具有基于数组的简单语法和允许配置事件验证的替代的基于对象的语法。\n\n在基于对象的语法中，每个属性的值可以为null或验证函数。 验证函数将接收传递给$emit调用的其他参数。 例如，如果调用this.$emit('foo',1)，则foo的相应验证器将接收参数1。验证器函数应返回一个布尔值，以指示事件参数是否有效。\n\n````js\nconst app = Vue.createApp({})\n\n// 数组语法\napp.component('todo-item', {\n  emits: ['check'],\n  created() {\n    this.$emit('check')\n  }\n})\n\n// 对象语法\napp.component('reply-form', {\n  emits: {\n    // 无效\n    click: null,\n    // 有效\n    submit: payload => {\n      if (payload.email && payload.password) {\n        return true\n      } else {\n        console.warn(`Invalid submit event payload!`)\n        return false\n      }\n    }\n  }\n})\n````\n\n> 提示 在emit选项中列出的事件将不会被组件的根元素继承【<template>模板】，而且也将被排除在$attrs属性之外。\n\n## 选项 / DOM\n\n### template【一致】\n\n### render【一致】\n\n### ~~el~~【废弃】\n\n### ~~renderError~~【废弃】\n\n## 特殊 attribute\n\n### key【一致】\n\n### ref【一致】\n\n### is【一致】\n\n### ~~slot~~【废弃】\n\n### ~~slot-scope~~【废弃】\n\n### ~~scope~~【废弃】\n\n## 选项 / 生命周期钩子\n\n### beforeCreate【一致】\n\n### created【一致】\n\n### beforeMount【一致】\n\n### mounted【一致】\n\n### beforeUpdate【一致】\n\n### updated【一致】\n\n### activated【一致】\n\n### deactivated【一致】\n\n### ~~beforeDestroy~~=>beforeUnmount\n\n### ~~destroyed~~=>unmounted\n\n### errorCaptured【一致】\n\n### renderTracked【新增】\n\n在跟踪虚拟DOM重新渲染时调用。钩子接收调试器事件作为参数。此事件告诉您跟踪组件和该操作的目标对象和键的操作\n\n````js\nconst app = Vue.createApp({\n  data() {\n    return {\n      cart: 0\n    }\n  },\n  renderTracked({ key, target, type }) {\n    console.log({ key, target, type })\n    /* 这将在组件第一次渲染时被记录\n    {\n      key: \"cart\",\n      target: {\n        cart: 0\n      },\n      type: \"get\"\n    }\n    */\n  },\n  methods: {\n    addToCart() {\n      this.cart += 1\n    }\n  }\n})\n\napp.mount('#app')\n````\n\n\n\n### renderTriggered【新增】\n\n当虚拟DOM重新渲染被触发时调用。与renderTracked类似，接收调试器事件作为参数。此事件告诉您触发重新渲染的操作以及该操作的目标对象和键。\n\n````js\nconst app = Vue.createApp({\n  data() {\n    return {\n      cart: 0\n    }\n  },\n  renderTriggered({ key, target, type }) {\n    console.log({ key, target, type })\n  },\n  methods: {\n    addToCart() {\n      this.cart += 1\n      /* This will cause renderTriggered call\n        {\n          key: \"cart\",\n          target: {\n            cart: 1\n          },\n          type: \"set\"\n        }\n      */\n    }\n  }\n})\n\napp.mount('#app')\n````\n\n## 选项 / 其它\n\n### name【一致】\n\n### inheritAttrs【一致】\n\n### delimiters【一致】\n\n### ~~comments~~【废弃】\n\n### ~~model~~【废弃】\n\n### ~~functional~~【废弃】\n\n![](https://files.catbox.moe/1jn619.png)\n\n可以看前面Vue2.x时候写的\n\n\n\n## Vue Router\n\n### 与vue-router@3.x相比，破坏变化\n\n+ mode: 'history' option 已被一个更灵活的 history 的选项所替代\n\n  ````js\n  // vue-router@3.x\n  const router = new VueRouter({\n    mode: 'history',\n    routes:[],\n    ...\n  })\n  \n  // vue-next-router\n  import { createRouter, createWebHistory } from 'vue-next-router'\n  // 还有createWebHashHistory和createMemoryHistory\n  const router = createRouter({\n    history: createWebHistory(),\n    routes: [],\n    ...\n  })\n  ````\n\n+ base选项现在作为第一个参数传递给createWebHistory(和其他histories模式)\n\n  > 应用的基路径。例如，如果整个单页应用服务在 `/app/` 下，然后 `base` 就应该设为 `\"/app/\"`【默认值: `\"/\"`】\n\n  ````js\n  //vue-router@3.x\n  const router = new VueRouter({\n    base: '/',\n  })\n  \n  // vue-next-router\n  import { createRouter, createWebHistory } from 'vue-next-router'\n  const router = createRouter({\n    history: createWebHistory('/'), \n  })\n  ````\n\n+ 现在必须使用带有自定义正则表达式的参数定义捕获所有路由(`/*`)：`/:catchAll(.*)`\n\n  ````js\n  // vue-router@3.x\n  const router = new VueRouter({\n    mode: 'history',\n    routes: [\n      { path: '/user/:a*', component: User },\n    ],\n  })\n  \n  // vue-next-router\n  const router = createRouter({\n    history: createWebHistory(),\n    routes: [\n      { path: '/user/:a:catchAll(.*)', component: User },\n    ],\n  })\n  ````\n\n+ `router.match` 与 `router.resolve` 合并在一起为 `router.resolve`，但签名略有不同。通过自动完成检查其类型 or [Router's `resolve` method](https://github.com/vuejs/vue-router-next/blob/master/src/router.ts)\n\n  ````js\n  // vue-router@3.x\n  function resolve(to: RawLocation, current?: Route, append?: boolean) {\n    //..............\n    return {\n      location,\n      route,\n      href,\n      normalizedTo: location,\n      resolved: route\n    }\n  }\n  \n  // vue-next-router\n   function resolve(\n      rawLocation: Readonly<RouteLocationRaw>,\n      currentLocation?: RouteLocationNormalizedLoaded\n    ): RouteLocation & { href: string } {\n  //..............\n  return assign(\n        {\n          fullPath,\n          // fullPath实际上是 path + encodedQuery +hash\n          hash,\n          query:\n            // 如果用户使用自定义的query库，比如qs, 可能嵌套对象, 所以我们保持query不变, 意味着它可以包含numbers 在`$route.query`，但是在此时，用户将不得不使用自己的类型\n            // https://github.com/vuejs/vue-router-next/issues/328#issuecomment-649481567\n            stringifyQuery === originalStringifyQuery\n              ? normalizeQuery(rawLocation.query)\n              : (rawLocation.query as LocationQuery),\n        },\n        matchedRoute,\n        {\n          redirectedFrom: undefined,\n          href,\n        }\n      )\n   }\n  ````\n\n+ 移除 `router.getMatchedComponents`，可以从 `router.currentRoute.value.matched` 中获取\n\n  router.getMatchedComponents(函数签名)-->返回目标位置或是当前路由匹配的组件数组 (是数组的定义/构造类，不是实例)。通常在服务端渲染的数据预加载时使用\n\n  `````js\n  router.currentRoute.value.matched.flatMap(record =>\n    Object.values(record.components)\n  )\n  `````\n\n  > append参数已被删除。您可以手动将该值连接到现有的path。\n\n+ `parent`从Route locations中被移除（`this.$route`）\n\n## Vue的变化\n\n### 采用vite作为Vue的脚手架开发构建工具\n\n> Vite，一个基于浏览器原生 ES imports 的开发服务器。利用浏览器去解析 imports，在服务器端按需编译返回，完全跳过了打包这个概念，服务器随起随用。同时不仅有 Vue 文件支持，还搞定了热更新，而且热更新的速度不会随着模块增多而变慢。针对生产环境则可以把同一份代码用 rollup 打。虽然现在还比较粗糙，但这个方向我觉得是有潜力的，做得好可以彻底解决改一行代码等半天热更新的问题", "user_name": "三藏会法术", "description": "老子是杠精，别杠我，不然杠死你丫的", "got_view_count": 9522, "category_name": "前端", "ctime": 1457483942}
{"tag_name": "JavaScript", "concern_user_count": 343215, "user_id": "3526889030558407", "title": "「面试必会」中高级前端必会的手写面试题(一)", "mark_content": "> 本文首发于我的个人网站：[litgod.net](https://litgod.net)\n\n## 前言\n在面试中，常常会问到一些“手写XXX”的面试题，如果我们只是停留在熟练使用这些 API，问到这种问题想必总是束手无策的。其实想要手写 API 的实现也并不难，更多的是需要我们训练自己**通过使用方式来推倒实现**的能力，千万不要死记硬背。最近我也在强化自己手写 API 的能力，并汇总了面试中高频的手写 API 面试题，希望对大家有一丢丢帮助～\n\n### 一、实现call/apply\n\n* 特点：\n\n1. 可以改变当前函数 this 的指向\n2. 让当前函数执行\n\n* 用法：\n\n```js\nfunction f1() {\n  console.log(1);\n}\n\nfunction f2() {\n  console.log(2);\n}\n\n// 让 f1 的 this 指向 f2，并且让 f1 执行\nf1.call(f2);  // 1\n\n// 如果多个 call，会让 call 方法执行，并把 call 中的 this 指向改变成 fn2\nf1.call.call.call(f2);\n```\n\n* 实现：\n\n```js\nFunction.prototype.call = function (context) {\n  // 如果 context 存在，使用 context，如果 context 不存在，使用 window；如果 context 是普通类型，转成对象。\n  context = context ? Object(context) : window;\n  context.fn = this;\n  let args = [];\n  for(let i = 1; i < arguments.length; i++) {\n    args.push('arguments['+i+']');\n  }\n\n  let r = eval('context.fn('+args+')');\n  delete context.fn;\n  return r;\n}\n\nFunction.prototype.apply = function (context, args) {\n  // 如果 context 存在，使用 context，如果 context 不存在，使用 window；如果 context 是普通类型，转成对象。\n  context = context ? Object(context) : window;\n  context.fn = this;\n\n  if(!args){\n    return context.fn();\n  }\n\n  let r = eval('context.fn('+args+')');\n  delete context.fn;\n  return r;\n}\n```\n### 二、实现bind方法\n\n* 特点：\n\n1. bind 方法可以绑定 this 指向\n2. bind 方法返回一个绑定后的函数\n3. 如果绑定的函数被 new，当前函数的 this 就是当前的实例\n4. new 出来的实例要保证原函数的原型对象上的属性不能丢失\n\n* 用法：\n\n```js\n// 用法一:\nlet person = {\n  name: \"Cherry\",\n}\n\nfunction fn(name, age) {\n  console.log(this.name+ '养了一只'+ name + '今年' + age + '了'); // Cherry养了一只猫今年2了\n}\n\nlet bindFn = fn.bind(person, '猫');\n\nbindFn(2);\n\n// 用法二：\nlet person = {\n  name: \"Cherry\",\n}\n\nfunction fn(name, age) {\n  this.say = '说话'\n  console.log(this);  // fn {say: \"说话\"}\n}\n\nlet bindFn = fn.bind(person, '猫');\nlet instance = new bindFn(9);\n\n// 用法三：\nlet person = {\n  name: \"Cherry\",\n}\n\nfunction fn(name, age) {\n  this.say = '说话'\n}\n\nfn.prototype.flag = '哺乳类';\nlet bindFn = fn.bind(person, '猫');\nlet instance = new bindFn(9);\nconsole.log(instance.flag);\n```\n\n* 实现：\n\n```js\nFuncition.protoType.bind = function (context) {\n  // this表示调用bind的函数\n  let that = this;\n  let bindArgs = Array.prototype.slice.call(arguments, 1);  //[\"猫\"]\n  function Fn() {}\n  function fBound() {\n    let args = Array.prototype.slice.call(arguments);  //[9] \n    //this instanceof fBound为true表示构造函数的情况。如new bindFn(9);\n    return that.apply(this instanceof fBound ? this : context, bindArgs.concat(args));\n  }\n\n  fn.prototype = this.prototype;\n  fBound.prototype = new Fn();\n  return fBound;\n}\n```\n\n### 三、实现new关键字\n\n* 特点： \n\n1. 创建一个全新的对象，这个对象的__proto__要指向构造函数的原型对象\n2. 执行构造函数\n3. 返回值为object类型则作为new方法的返回值返回，否则返回上述全新对象\n\n* 用法：\n\n```js\nfunction Animal(type) {\n  this.type = type;   // 实例上的属性\n  // 如果当前构造函数返回的是一个引用类型，需要直接返回这个对象\n  return {name: 'dog'}\n}\n\nAnimal.prototype.say = function () {\n  console.log('say');\n}\n\nlet animal = new Animal('哺乳类');\n\nconsole.log(animal.type); // 哺乳类\nanimal.say(); // say\n\n```\n\n* 实现：\n\n```js\nfunction mockNew() {\n  // Constructor => animal，剩余的 arguments 就是其他的参数\n  let Constructor = [].shift.call(arguments);\n  let obj = {};  //返回的结果\n  obj.__proto__ = Constructor.prototype;\n  Constructor.apply(obj, arguments);\n  return r instanceof Object ? r : obj;\n}  \n```\n\n### 四、用ES5实现数组的map方法\n\n* 特点：\n\n1. 循环遍历数组，并返回一个新数组\n2. 回调函数一共接收3个参数，分别是：「正在处理的当前元素的值、正在处理的当前元素的索引、正在遍历的集合对象」\n\n* 用法：\n```js\nlet array = [1, 2, 3].map((item) => {\n  return item * 2;\n})\n\nconsole.log(array);  // [2, 4, 6]\n```\n\n* 实现：\n\n```js\nArray.prototype.map = function(fn) {\n  let arr = [];\n  for(let i = 0; i < this.length; i++) {\n    arr.push(fn(this[i], i, this));\n  }\n  return arr;\n}\n```\n\n### 五、用ES5实现数组的filter方法\n\n* 特点：\n\n1. 该方法返回一个由通过测试的元素组成的新数组，如果没有通过测试的元素，则返回一个空数组\n2. 回调函数一共接收3个参数，同 map 方法一样。分别是：「正在处理的当前元素的值、正在处理的当前元素的索引、正在遍历的集合对象」\n\n* 用法：\n\n```js\nlet array = [1, 2, 3].filter((item) => {\n  return item > 2;\n})\n\nconsole.log(array); // [3]\n```\n\n* 实现：\n\n```js\nArray.prototype.filter = function(fn) {\n  let arr = [];\n  for(let i = 0; i < this.length; i++) {\n    fn(this[i]) && arr.push(fn(this[i], i, this));\n  }\n  return arr;\n}\n```\n\n### 六、用ES5实现数组的some方法\n\n* 特点：\n\n1. 在数组中查找元素，如果找到一个符合条件的元素就返回true，如果所有元素都不符合条件就返回 false；\n2. 回调函数一共接收3个参数，同 map 方法一样。分别是：「正在处理的当前元素的值、正在处理的当前元素的索引、正在遍历的集合对象」。\n\n* 用法：\n\n```js\nlet flag = [1, 2, 3].some((item) => {\n  return item > 1;\n})\n\nconsole.log(flag); // true\n```\n\n* 实现：\n\n```js\nArray.prototype.some = function(fn) {\n  for(let i = 0; i < this.length; i++) {\n    if (fn(this[i])) {\n      return true;\n    }\n  }\n  return false;\n}\n```\n\n### 七、用ES5实现数组的every方法\n\n* 特点：\n\n1. 检测一个数组中的元素是否都能符合条件，都符合条件返回true，有一个不符合则返回 false\n2. 如果收到一个空数组，此方法在任何情况下都会返回 true\n3. 回调函数一共接收3个参数，同 map 方法一样。分别是：「正在处理的当前元素的值、正在处理的当前元素的索引、正在遍历的集合对象」\n\n* 用法：\n\n```js\nlet flag = [1, 2, 3].every((item) => {\n  return item > 1;\n})\n\nconsole.log(flag); // false\n```\n\n* 实现：\n\n```js\nArray.prototype.every = function(fn) {\n  for(let i = 0; i < this.length; i++) {\n    if(!fn(this[i])) {\n      return false\n    }\n  }\n  return true;\n}\n```\n\n### 八、用ES5实现数组的find方法\n\n* 特点：\n\n1. 在数组中查找元素，如果找到符合条件的元素就返回这个元素，如果没有符合条件的元素就返回 undefined，且找到后不会继续查找\n2. 回调函数一共接收3个参数，同 map 方法一样。分别是：「正在处理的当前元素的值、正在处理的当前元素的索引、正在遍历的集合对象」\n\n* 用法：\n\n```js\nlet item = [1, 2, 3].find((item) => {\n  return item > 1;\n})\n\nconsole.log(item); // 2\n```\n\n* 实现：\n\n```js\nArray.prototype.find = function(fn) {\n  for(let i = 0; i < this.length; i++) {\n    if (fn(this[i])) return this[i];\n  }\n}\n```\n\n### 九、用ES5实现数组的forEach方法\n* 特点：\n\n1. 循环遍历数组，该方法没有返回值\n2. 回调函数一共接收3个参数，同 map 方法一样。分别是：「正在处理的当前元素的值、正在处理的当前元素的索引、正在遍历的集合对象」\n\n* 用法：\n\n```js\n[1, 2, 3].forEach((item, index, array) => {\n  // 1 0 [1, 2, 3]\n  // 2 1 [1, 2, 3]\n  // 3 2 [1, 2, 3]\n  console.log(item, index, array)  \n})\n```\n\n* 实现：\n\n```js\nArray.prototype.forEach = function(fn) {\n  for(let i = 0; i < this.length; i++) {\n    fn(this[i], i, this);\n  }\n}\n```\n\n### 十、用ES5实现数组的reduce方法\n\n* 特点：\n\n1. 初始值不传时的特殊处理：会默认用数组中的第一个元素\n2. 函数的返回结果会作为下一次循环的 prev\n3. 回调函数一共接收4个参数，分别是「上一次调用回调时返回的值、正在处理的元素、正在处理的元素的索引，正在遍历的集合对象」\n\n* 用法：\n\n```js\nlet total = [1, 2, 3].reduce((prev, next, currentIndex, array) => {\n  return prev + next;\n}, 0)\n\nconsole.log(total); // 6\n```\n\n* 实现：\n\n```js\nArray.prototype.reduce = function(fn, prev) {\n  for(let i = 0; i < this.length; i++) {\n    // 初始值不传时的处理\n    if (typeof prev === 'undefined') {\n      // 明确回调函数的参数都有哪些\n      prev = fn(this[i], this[i+1], i+1, this);\n      ++i;\n    } else {\n      prev = fn(prev, this[i], i, this)\n    }\n  }\n  // 函数的返回结果会作为下一次循环的 prev\n  return prev;\n}\n```\n\n### 十一、实现instanceof方法\n\n* 特点：\n\n沿着原型链的向上查找，直到找到原型的最顶端，也就是`Object.prototype`。查找构造函数的 prototype 属性是否出现在某个实例对象的原型链上，如果找到了返回 true，没找到返回 false。\n\n* 用法：\n\n```js\nconsole.log([] instanceof Array); // true\nconsole.log([] instanceof Object); // true\n\n// 相当于：\nconsole.log([].__proto__ === Array.prototype); // true\nconsole.log([].__proto__.__proto__ === Object.prototype); // true\n```\n\n* 实现：\n\n```js\nfunction myInstanceof(left, right) {\n  left = left.__proto__;\n  while(true) {\n    if (left === null) {\n      return false;\n    }\n    if (left === right.prototype) {\n      return true;\n    }\n    left = left.__proto__;\n  }\n}\n\nclass A{};\n\nconst a = new A();\nconsole.log(myInstanceof(a, A)); // true\nconsole.log(myInstanceof(a, Object)); // true \nconsole.log(myInstanceof(a, Array)); // false\n```\n\n### 十二、实现Object.create方法(经常考)\n* 特点：\n\n创建一个新对象，使用现有的对象来提供新创建的对象的__proto__\n\n* 用法：\n\n```js\nlet demo = {\n    c : '123'\n}\nlet cc = Object.create(demo)\nconsole.log(cc);\n```\n\n* 实现：\n\n```js\nfunction create(proto) {\n    function Fn() {};\n    // 将Fn的原型指向传入的 proto\n    Fn.prototype = proto;\n    Fn.prototype.constructor = Fn;\n    return new Fn();\n}\n```\n\n### 十三、实现一个通用的柯里化函数\n\n* 特点：\n柯里化就是将一个函数的功能细化，把接受「多个参数」的函数变换成接受一个「单一参数」的函数，并且返回接受「余下参数」返回结果的一种应用。\n\n1. 判断传递的参数是否达到执行函数的fn个数\n2. 没有达到的话，继续返回新的函数，将fn函数继续返回并将剩余参数累加\n3. 达到fn参数个数时，将累加后的参数传给fn执行\n\n* 用法：\n\n```js\nfunction sum(a, b, c, d, e) {\n  return a+b+c+d+e;\n}\n\nlet a = curring(sum)(1,2)(3,4)(5);  // 15\n```\n\n* 实现：\n\n```js\nconst curring = (fn, arr = []) => {\n  let len = fn.length;\n  return function (...args) {\n    arr = [...arr, ...args];\n    if (arr.length < len) {\n      return curring(fn, arr);\n    } else {\n      return fn(...arr);\n    }\n  };\n};\n```\n\n### 十四、实现一个反柯里化函数 \n\n* 特点：\n使用`call`、`apply`可以让非数组借用一些其他类型的函数，比如，`Array.prototype.push.call`, `Array.prototype.slice.call`， `uncrrying`把这些方法泛化出来，不在只单单的用于数组，更好的语义化。\n\n* 用法：\n\n```js\n// 利用反柯里化创建检测数据类型的函数\nlet checkType = uncurring(Object.prototype.toString);\n\ncheckType(1); // [object Number]\ncheckType(\"hello\"); // [object String]\ncheckType(true); // [object Boolean]\n```\n\n* 实现：\n\n```js\nFunction.prototype.uncurring = function () {\n  var self = this;\n  return function () {\n    return Function.prototype.call.apply(self, arguments);\n  }\n}\n```\n\n### 十五、实现一个简单的节流函数(throttle)\n\n* 特点：\n\n规定在一个单位时间内，只能触发一次函数。如果这个单位时间内触发多次函数，只有一次生效。\n\n节流重在加锁`flag = false`\n\n* 应用场景：\n\n  * scroll滚动事件，每隔特定描述执行回调函数\n  * input输入框，每个特定时间发送请求或是展开下拉列表，（防抖也可以）\n\n* 用法：\n\n```js\nconst throttleFn = throttle(fn, 300);\n```\n\n* 实现：\n\n```js\nconst throttle = (fn, delay = 500) => {\n  let flag = true;\n  return (...args) => {\n    if (!flag) return;\n    flag = false;\n    setTimeout(() => {\n      fn.apply(this, args);\n      flag = true;\n    }, delay);\n  };\n};\n```\n\n### 十六、实现一个简单的防抖函数(debounce)\n\n* 特点：\n\n在事件被触发n秒后再执行回调，如果在这n秒内又被触发，则重新计时\n\n防抖重在清零`clearTimeout(timer)`\n\n* 应用场景：\n\n  * 浏览器窗口大小resize避免次数过于频繁\n  * 登录，发短信等按钮避免发送多次请求\n  * 文本编辑器实时保存\n\n* 用法：\n\n```js\nconst debounceFn = debounce(fn, 300);\n```\n\n* 实现：\n\n```js\nconst debounce = (fn, delay) => {\n  let timer = null;\n  return (...args) => {\n    clearTimeout(timer);\n    timer = setTimeout(() => {\n      fn.apply(this, args);\n    }, delay);\n  };\n};\n```\n\n`lodash`、`underscore`等库中的节流防抖功能还提供了更多的配置参数，这里我们只是实现了最基本的节流防抖，感兴趣的同学可以看看`lodash`、`underscore`的源码。\n\n### 十七、实现一个 Compose (组合)\n\n* 特点：\n\n将需要嵌套执行的函数平铺，嵌套执行就是一个函数的返回值将作为另一个函数的参数。该函数调用的方向是从右至左的（先执行 sum，再执行 toUpper，再执行 add）\n\n* 用法：\n\n```js\nfunction sum(a, b) {\n  return a+b;\n}\n\nfunction toUpper(str) {\n  return str.toUpperCase();\n}\n\nfunction add(str) {\n  return '==='+str+'==='\n}\n\n// 使用 compose 之前：\nconsole.log(add(toUpper(sum('cherry', '27')))); // ===CHERRY27===\n// 使用 compose 之后：\nconsole.log(compose(add, toUpper, sum)('cherry', '27')); // ===CHERRY27===\n```\n\n* 实现：\n\n```js\n// 使用 ES5- reduceRight 实现\nfunction compose(...fns) {\n  return function (...args) {\n    let lastFn = fns.pop();\n    return fns.reduceRight((a, b) => {\n      return b(a);\n    }, lastFn(...args));\n  };\n}\n\n// 使用 ES6 - reduceRight 实现\nconst compose = (...fns) => (...args) => {\n  let lastFn = fns.pop();\n  return fns.reduceRight((a, b) => b(a), lastFn(...args));\n};\n\n// 使用 ES6 - reduce 一行代码实现：\nconst compose = (...fns) => fns.reduce((a, b) => (...args) => a(b(...args)));\n```\n\n### 十八、实现一个 Pipe （管道）\n\n* 特点：\n\npipe函数跟compose函数的作用是一样的，也是将参数平铺，只不过他的顺序是从左往右。（先执行 splitString，再执行 count）\n\n* 用法：\n\n```js\nfunction splitString(str) {\n  return str.split(' ');\n}\n\nfunction count(array) {\n  return array.length;\n}\n\n// 使用 pipe 之前：\nconsole.log(count(splitString('hello cherry'))); // 2\n// 使用 pipe 之后：\nconsole.log(pipe(splitString, count)('hello cherry')); // 2\n```\n\n* 实现：\n\n```js\nconst pipe = function(){\n  const args = [].slice.apply(arguments);\n  return function(x) {\n    return args.reduce((res, cb) => cb(res), x);\n  }\n}\n\n// 使用 ES5- reduceRight 实现\nfunction pipe(...fns) {\n  return function (...args) {\n    let lastFn = fns.shift();\n    return fns.reduceRight((a, b) => {\n      return b(a);\n    }, lastFn(...args));\n  };\n}\n\n// 使用 ES6 - reduceRight 实现\nconst pipe = (...fns) => (...args) => {\n  let lastFn = fns.shift();\n  return fns.reduceRight((a, b) => b(a), lastFn(...args));\n};\n\n// 使用 ES6 - reduce 一行代码实现：（redux源码）\nconst pipe = (...fns) => (...args) => fns.reduce((a, b) => b(a), ...args);\n```\n\n### 十九、实现一个模版引擎\n\n* 特点：with语法 + 字符串拼接 + new Function来实现\n\n1. 先将字符串中的 `<%=%>`替换掉，拼出一个结果的字符串；\n2. 再采用`new Function`的方式执行该字符串，并且使用`with`解决作用域的问题。\n\n* 用法：\n\n```js\nconst ejs = require('ejs');\nconst path = require('path');\n\nejs.renderFile(path.resolve(__dirname, 'template.html'),{name: 'Cherry', age: 27, arr: [1, 2, 3]}, function(err, data) {\n  console.log(data);\n})\n\n```\n\n```html\n// ===== template.html =====\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n  <meta charset=\"UTF-8\">\n  <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n  <title>Document</title>\n</head>\n<body>\n  <%=name%>  <%=age%>\n  <%arr.forEach(item =>{%>\n      <li><%=item%></li>\n  <%})%>\n</body>\n</html>\n```\n\n* 实现：\n\n我们用`{ {} }`替换`<%=%>`标签来模拟实现一个模版引擎，实现原理是一样的，重点看实现原理哈。\n\n```html\n// ===== my-template.html =====\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n  <meta charset=\"UTF-8\">\n  <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n  <title>Document</title>\n</head>\n<body>\n  {{name}}  {{age}}\n  {%arr.forEach(item => {%}\n      <li>{{item}}</li>\n  {%})%}\n</body>\n</html>\n```\n\n```js\nconst fs = require('fs');\nconst path = require('path');\n\nconst renderFile = (filePath, obj, cb) => {\n  fs.readFile(filePath, 'utf8', function(err, html) {\n    if(err) {\n      return cb(err, html);\n    }\n\n    html = html.replace(/\\{\\{([^}]+)\\}\\}/g, function() {\n      console.log(arguments[1], arguments[2]);\n      let key = arguments[1].trim();\n      return '${' + key + '}';\n    });\n\n    let head = `let str = '';\\r\\n with(obj){\\r\\n`;\n    head += 'str+=`';\n    html = html.replace(/\\{\\%([^%]+)\\%\\}/g, function() {\n      return '`\\r\\n' + arguments[1] + '\\r\\nstr+=`\\r\\n';\n    });\n    let tail = '`}\\r\\n return str;';\n    let fn = new Function('obj', head + html + tail);\n    cb(err, fn(obj));\n  });\n};\n\nrenderFile(path.resolve(__dirname, 'my-template.html'),{name: 'Cherry', age: 27, arr: [1, 2, 3]}, function(err, data) {\n  console.log(data);\n});\n```\n\n## 关于\n作者齐小神，前端程序媛一枚。\n\n有点文艺，喜欢摄影。\n虽然现在朝九晚五，埋头苦学，\n但梦想是做女侠，扶贫济穷，仗剑走天涯。\n希望有一天能改完 BUG 去实现自己的梦想。\n\n下面是我的公众号，不定时更新，欢迎来玩～\n\n![](https://imgkr2.cn-bj.ufileos.com/0c6dbe0a-51d6-4326-aa05-9f76b160cf95.jpg?UCloudPublicKey=TOKEN_8d8b72be-579a-4e83-bfd0-5f6ce1546f13&Signature=UPJ9Qy7Pd%252FraDj2mR8Pm9ecfgd8%253D&Expires=1597078015)\n\n计划输出：\n中高级前端工程师必会的手写API（二）\n", "user_name": "齐小神", "description": "公众号：大前端Space", "got_view_count": 11196, "category_name": "前端", "ctime": 1457483942}
{"tag_name": "CSS", "concern_user_count": 258450, "user_id": "2849531329280551", "title": "三行CSS为掘金添加暗黑模式支持", "mark_content": "**本文作者：[Gavin](https://juejin.im/user/4300945217562887)，未经授权禁止转载。**\n\n\n这是一个支持暗黑模式的傻瓜式转换方式，以掘金某文章页面为例：\n\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/721594cc426f4929aaf67291783b0fa4~tplv-k3u1fbpfcp-zoom-1.image)\n\n现在添加神奇的CSS\n\n```css\n@media (prefers-color-scheme: dark) {\n  html {\n    filter: invert(1) hue-rotate(180deg);\n  }\n}\n```\n\n就是这么简单，你已经完成了！✌️\n\n实现暗黑模式\n\n![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/265e08de29bb40b780dab301413794bf~tplv-k3u1fbpfcp-zoom-1.image)\n\n### chrome模拟暗黑模式\n\n![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e3f6eeab6192403699f0b6c64c917ed6~tplv-k3u1fbpfcp-zoom-1.image)\n\n\n### 解释\n\n`filter`CSS属性将模糊或颜色偏移等图形效果应用于元素。滤镜通常用于调整图像，背景和边框的渲染。（参考：[MDN Web文档](https://developer.mozilla.org/zh-CN/docs/Web/CSS/filter)）\n\n对于暗黑模式，将使用两个`filter`：`invert`和`hue-rotate`\n\n**invert**：反转输入图像。值定义转换的比例。100%（或`1`）将完全转换：黑色变为白色，白色变为黑色，其它颜色类似。\n\n**hue-rotate**：`hue-rotate`可以帮助我们处理非黑白的其它颜色，色调旋转180度，确保网页的颜色主题不改变，而只是削弱它的颜色。这种做法唯一的缺点是：它还会反转网页中所有的图像。因此，需要将页面中所有的图像添加相同的规则，以修复这个问题。\n\n```css\n@media (prefers-color-scheme: dark) {\n  html {\n    filter: invert(1) hue-rotate(180deg);\n  }\n  html img {\n    filter: invert(1) hue-rotate(180deg);\n  }\n}\n```\n\n当然，还可以添加一个`transition`的过渡效果\n\n```css\nhtml {\n    transition: color 300ms, background-color 300ms;\n}\n```\n\n\n\n### 结果\n\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d23f3eebe4f947d5b0014c91ea62ade0~tplv-k3u1fbpfcp-zoom-1.image)\n\n细心的同学可能发现上面头像还是有问题，没有变成原本的图片颜色，因为掘金文章头像用的a标签，与上同理，我们可以给a标签也加上反转，最终代码如下：\n\n```css\n@media (prefers-color-scheme: dark) {\n  html {\n    filter: invert(1) hue-rotate(180deg);\n  }\n  html img {\n      filter: invert(1) hue-rotate(180deg);\n  }\n  a {\n      filter: invert(1) hue-rotate(180deg);\n  }\n}\nhtml {\n  transition: color 300ms, background-color 300ms;\n}\n```\n\n**参考文章**：[https://dev.to/akhilarjun/one-line-dark-mode-using-css-24li](https://dev.to/akhilarjun/one-line-dark-mode-using-css-24li)\n\n**利用JS实现暗黑模式**：[https://dev.to/akhilarjun/dark-mode-unmistified-1ji6](https://dev.to/akhilarjun/dark-mode-unmistified-1ji6)", "user_name": "智云健康前端团队", "description": "https://github.com/clouDr-f2e", "got_view_count": 5655, "category_name": "前端", "ctime": 1457483942}
{"tag_name": "HBase", "concern_user_count": 5206, "user_id": "3966693685605143", "title": "内存总是不够？HBase&GeoMesa配置优化了解一下", "mark_content": "## 概况：\n\n生产环境HBase集群内存经常处于高位（90%），而且GC之后也是内存依然处于高位，经分析内存全部由集群的regionserver进程所持有，，经常重启之后，大概3-4天就会保持在高位。由上述症状，可以判断集群内存有泄露的嫌疑。\n\n## 分析\n\n### 1、**先熟悉一下HBase的内存模型**\n\nHBase系统中有两块大的内存管理模块，一块是**MemStore** ，一块是**BlockCache，前置是用于集群写入所属内存，而后者用于缓存热数据，提供查询速度。**这两者均可以通过配置文件进行配置。当前集群均配置了0.4和0.4的比例。而考虑到HBase集群是多写少读的情景，为此而引入了**MSLAB机制来优化HBase的MemStore 负担。内存的使用率会呈现很优美的锯齿图形。**\n\n **![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8768974bbb6c416db63f243ef169b57b~tplv-k3u1fbpfcp-zoom-1.image)** \n\n### **2、分析内存使用率和业务关系**\n\n起初认为是读写业务量已经超过了集群负载能力，但集群业务也不大，写和读的TPS，带宽吞吐量均未达到集群限定的能力，而且CPU利用率大多半都被GC占用，但内存就是持高不下，即使业务了停了一天，内存还是不怎么下降，很明显和业务量无关。\n\n那么和compaction有关？经观察的确可以看compact时特别消耗时间。此时感觉看到了希望，调整各个参数，把compact操作提升了10+倍之后，内存还是持高不下 。剩下最根治的办法就是分析内存，看一下内存数据都是什么？有无内存泄露问题。\n\n **![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/736fe8c018a345589031bf11873e9ffd~tplv-k3u1fbpfcp-zoom-1.image)** \n\n### **3、分析dunp文件**\n\n节点dump下regionserver的内存，分析发现内存中有50个RpcServer.FifoRWQ.default.read.handler线程，每个线程持有了1.2%左右的总内存，那么所有的线程持有的内存占有量大于为50*1.2%=60%。随着查询次数增多，线程持续的内存还会持续增加，如下图。\n\n **![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/49fd208c58ce4ab4a719e42eacbc28d2~tplv-k3u1fbpfcp-zoom-1.image)** \n\n分析每一个线程持有的内存数据，全部都是业务信息。\n\n<div>\n\n![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/38c84960e5ae46c389ebfa4fb5b23fbc~tplv-k3u1fbpfcp-zoom-1.image)  \n\n</div>\n\n那么继续分析，此业务信息所属对象：org.locationtech.**geomesa**.filter.factory.FastFilterFactory。而对比同规模的集群，的确是此异常集群开启了GeoMesa特性。找到问题所在，那就看源码分析是唯一出路。\n\n## 解决方案\n\n经分析GeoMesa源码，缓存数据为GeoMesa的**_filterCache，_**全部都是查询的条件及其优化后查询条件。如下代码：\n\n<div>\n\n    override def getOrElseUpdate(key: K, op: => V): V = {\n     val cached = caches.get.getIfPresent(key)\n     if (cached != null) { cached } else {\n     val value = op\n\n</div>\n\n<div>\n\n    //value=optimize(sft, ECQL.toFilter(ecql))\n\n</div>\n\n<div>\n\n    caches.get.put(key, value)\n         value\n       }\n     }\n\n</div>\n\n导致集群随着查询次数增多，内存一直持续不下。\n\n能否去掉此处缓存策略呢？为什么缓存此查询信息呢，目的就是为了减少同样的查询再次被优化的步骤。那么我们查询添条件key有没有重复使用，此处有个严格规定，就是key中不仅保证使用相同的GeoMesa函数还有使用相同的参数，基于这个原则，业务上查询条件是没有重复的。\n\n我们配置了可选参数useFilterCache，默认是开启的，没必要缓存此查询条件，应予以删除。\n\n## 结论\n\n在配置文件中添加了useFilterCache参数，默认是开启的，根据业务需要选择开始和关闭**_filterCache特效。_**\n\n经分析我们业务场景没必要缓存此查询条件，，应予以关闭。优化后的集群内存使用率情况就恢复了正常状态。\n\n **![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/54a49831c38c434f868ce6960267db91~tplv-k3u1fbpfcp-zoom-1.image)** \n\n**[点击关注，第一时间了解华为云新鲜技术~](https://bbs.huaweicloud.com/blogs/173946?utm_source=juejin&utm_medium=bbs-ex&utm_campaign=ei&utm_content=content)**", "user_name": "华为云开发者社区", "description": "华为云开发者社区，提供全面深入的云计算前景分析、丰富的技术干货、程", "got_view_count": 33299, "category_name": "后端", "ctime": 1457483880}
{"tag_name": "Linux", "concern_user_count": 198821, "user_id": "501033032750472", "title": "程序员轻松绘图神器", "mark_content": "我们程序员在工作生活中，有很多场合下需要绘制图表，比如PPT里的图表，学习笔记的一些助记图，还有最常见的，工作中大量使用的流程图。\n\n在 Window 下，我们有很多好用的工具，比如 `Visio` 、 `EA` 等等。这些软件也很好用，但都有个缺点，那就是太复杂。我们需要一定的美工基础，还要学很多软件操作，才能画出一张很简单的流程图。\n\n而且，更要命的是，一旦需求发生变动，很不好修改，往往牵一发而动全身。所以经常在听到需求变更的时候，良许就脊背一凉……\n\n后来，在大神的介绍下，良许开始使用一个神器。这个神器不需要你懂美工，也不太需要懂软件操作，绘图的过程跟你写软件的过程差不多，短短的几行代码，就能把你头脑里的想法表现出来。\n\n而且，不用担心布局，不用担心修改，甚至都不用鼠标，也给制作出相当精美的作品！\n\n这个神器就是：`dot` 命令！\n\n这个神器还有个图形界面版，叫 `Graphviz` ，但良许习惯了命令行，一般是在命令行下完成的。\n\n我们先来看下它能做什么。以下几个图片选自它的官网：\n\n![](https://i.loli.net/2019/03/07/5c811b2c07676.png)\n\n![](https://i.loli.net/2019/03/07/5c811b4c257ae.png)\n\n![](https://i.loli.net/2019/03/07/5c811b67391e7.png)\n\n![](https://i.loli.net/2019/03/07/5c811b7c770de.png)\n\n这只是其中的几张图而已，更多图片可以去它的官网查看：\n\n    http://www.graphviz.org\n\n这个软件非常强大，如果掌握得好的话，可以画出非常好看的作品，而且还不怕产品经理改需求。但是，在大多数情况下，我们不太需要用到它的高级功能，往往一些很基础的功能就可以应付我们工作中的 80% 以上的需求了。\n\n这个软件的安装很简单，只需执行以下命令即可：\n\n    sudo apt install graphviz\n\n稍等一小会儿，就安装成功了。然后，就可以愉快地玩耍啦~\n\n我们先来看看一个 Hello world 水平的作品。\n\n首先，在任意位置创建一个 `test.dot` 文件（当然也可以叫其它名字），文件的内容如下：\n\n    graph g{\n         \"Hello\" -- \"world\"\n    }\n\n然后，执行以下命令：\n\n    dot -Tpng -o test.png test.dot\n\n之后，就在当前目录下生成了下面这幅最简单的图片了，是不是非常简单？\n\n![](https://i.loli.net/2019/03/07/5c8120ee21c82.png)\n\n我们来简单介绍下 DOT 命令的语法。在 test.dot 文件里，`graph` 表示的是这幅图是 `无向图`，也就是连接线是没有箭头的。与之对应的是 `digraph` ，表示 `有向图` ，连接线是有箭头的。\n\n而图片的描述，是在 `{}` 里进行，并且也支持注释，注释风格与 C 语言类似，`//` 用于单行注释， `/**/` 用于多行注释。\n\n前文提到，dot 命令十分强大，这里只介绍它的最基本的一些用法，而学会这些最基本的命令，就可以应对 80% 左右的工作。更多高级用法可以参考它的官网。\n\n#### 节点\n\n类似于脚本语言，节点无需申明就可以直接使用。而对于节点，我们一般设置它的以下几个属性：\n\n*   shape 形状\n*   label 标签\n*   style 类型，填充还是非填充\n*   color 线条颜色\n*   fillcolor 填充颜色\n\n这些属性是在节点后的一对方括号 `[]` 里设置的。很多情况下，我们的节点属性是完全相同的，那么我们可以定义一个 `node` ，并对它进行设置，那么图形里所有节点属性都跟 node 一样。如果某个节点想搞特殊，只需单独对它进行设置即可。\n\n    graph g{\n        node [shape = \"box\", style = \"filled\", color = \"red\", fillcolor = \"green\"]   //设置节点的默认形状，类型，颜色，填充颜色\n        a [shape = \"ellipse\", fillcolor = \"yellow\", label = \"Hello\"]    //对某个节点进行单独设置\n        b [label = \"world\"]   \n        a -- b\n        a -- c     //不对c进行设置，使用默认属性\n        d [shape = \"circle\"，label = \"cicle\"]    //d单独设置属性\n        c -- d\n    }\n\n![](https://i.loli.net/2019/03/10/5c847ab47116f.png)\n\n#### 连接线\n\n连接线依照有无箭头分为有向边和无向边。它的常用属性有如下：\n\n*   style 类型，实线还是虚线\n*   color 连接线颜色\n*   label 标签\n*   labelfontcolor 标签字体颜色\n*   headlabel 起始标签内容\n*   taillabel 结束标签内容\n*   decorate 标签与连接线之间有连线标注\n\n对于有向边，还可以设置起点及终点的位置，用 `e, s, w, n` 表示 `东南西北` ，也可以组合来表示，详细请看下面实例。\n\n和节点类似，连接线也可以设置默认属性，用 `edge` 表示。如果不使用默认属性的话，也可以自定义属性。\n\n    digraph edge_settings {\n        edge [color = \"green\", decorate = false]        //设置边的默认属性\n        node [shape = \"polygon\", sides = 4, color = \"blue\"]\n        a -> b [style = \"dotted\", color = \"red\", label = \"a to b\"]  //设置style、color、label\n        b: se -> c: w [headlabel = \"end\",  taillabel = \"start\"]     //设置边从b的“东南方”出发，从c的“西方”结束，设置有向边起点和终点的label\n        {c, f} -> {d, e} [label = \"multi-lines\", decorate = true]    //可以用这种方式同时画多条边\n    }\n\n![](https://i.loli.net/2019/03/10/5c8489562c4fe.png)\n\n#### 图\n\nDOT语言可以描述无向图和有向图两种图，graph标识无向图，digraph标识有向图。对于图的属性设置，常用的有以下一些：\n\n*   size 尺寸\n*   label 标签\n*   labelloc 标签位置，通常设置为 t （顶），或 b （底）\n*   labeljust 标签对齐，比如左对齐、右对齐、居中，等等\n*   bgcolor 背景颜色\n*   rankdir 布局，比如从左往右，或者从上往下\n\n图里面还可以包含子图，子图必须以 `cluster` 作为前缀开始。比如官网首页上的图，即本文第一张图，就是图里包含子图，它的源码如下：\n\n    digraph graph_settings {\n        start [shape = \"Mdiamond\"]\n        end [shape = \"Msquare\"]\n\n        subgraph cluster_sub1 {\n            label = \"process #1\"\n            labelloc = \"t\"\n            bgcolor = \"gray55\"\n            node [style = \"filled\", color = \"white\"]\n            a0 -> a1 -> a2 -> a3 -> a0\n        }\n        subgraph cluster_sub2 {\n            label = \"process #2\"\n            labelloc = \"t\"\n            color = \"blue\"\n            node [style = \"filled\", color = \"black\", fillcolor = \"gray55\"]\n            b0 -> b1 -> b2 -> b3\n        }\n\n        start -> {a0, b0}\n        a1 -> b3\n        b2 -> a3\n        {a3, b3} -> end\n    }\n\n#### 小结\n\n利用 dot 命令来绘图，非常省事，也非常灵活，对于设计菜鸟而言，简直不能太方便！它的功能十分强大，本文所介绍的只是它非常常用，但也是非常实用的一些基本功能，掌握这些功能就能应对工作中绝大部分的场景。但想要做出更加炫酷的效果，还需要再细细研究它官网的资料。", "user_name": "良许Linux", "description": "公众号：良许Linux，回复1024获取5T技术资料", "got_view_count": 72073, "category_name": "后端", "ctime": 1457483880}
{"tag_name": "JavaScript", "concern_user_count": 343215, "user_id": "958429872534056", "title": "这些 JavaScript 细节，你知道不？", "mark_content": "## 前言\n\n本文主要给大家带来一些我读《你不知道的 JavaScript（中卷）》中遇到的一些**有意思**的内容，可以说是**打开新世界的大门**的感觉。希望能在工作之余，给大家带来一点乐趣。\n\n> JavaScript 是一门优秀的语言。只学其中一部分内容很容易，但是要全面掌握则很难。开发人员遇到困难时往往将其归咎于语言本身，而不反省他们自己对语言的理解有多匮乏。《你不知道的 JavaScript》旨在解决这个问题，使读者能够发自内心地喜欢上这门语言。\n\n## 强制类型转换\n\n### 值类型转换\n\n```js\nvar a = 42;\nvar b = a + \"\"; // 隐式强制类型转换\nvar c = String(a); // 显式强制类型转换\n```\n\n### 抽象值操作\n\n> `document.all` 是假值对象。也就是 `!!document.all` 值为 `false`。\n\n### 显示强制类型转换\n\n#### 日期显示转换为数字：\n\n使用 `Date.now()` 来获得当前的时间戳，使用 `new Date(..).getTime()` 来获得指定时间的时间戳。\n\n#### 奇特的 ~ 运算符：\n\n`~x` 大致等同于 `-(x+1)`。很奇怪，但相对更容易说明问题：\n`~42; // -(42+1) ==> -43`\n\nJavaScript 中字符串的 `indexOf(..)` 方法也遵循这一惯例，该方法在字符串中搜索指定的子\n字符串，如果找到就返回子字符串所在的位置（从 0 开始），否则返回 -1。\n\n`~` 和 `indexOf()` 一起可以将结果强制类型转换（实际上仅仅是转换）为真 / 假值：\n\n```js\nvar a = \"Hello World\";\n~a.indexOf(\"lo\"); // -4 <-- 真值!\n\nif (~a.indexOf(\"lo\")) { // true\n  // 找到匹配！\n}\n```\n\n#### 解析非字符串：\n\n曾经有人发帖吐槽过 `parseInt(..)` 的一个坑：\n\n```js\nparseInt( 1/0, 19 ); // 18\n```\n\n`parseInt(1/0, 19)` 实际上是 `parseInt(\"Infinity\", 19)`。第一个字符是 \"I\"，以 19 为基数\n时值为 18。\n\n此外还有一些看起来奇怪但实际上解释得通的例子：\n\n```js\nparseInt(0.000008); // 0 (\"0\" 来自于 \"0.000008\")\nparseInt(0.0000008); // 8 (\"8\" 来自于 \"8e-7\")\nparseInt(false, 16); // 250 (\"fa\" 来自于 \"false\")\nparseInt(parseInt, 16); // 15 (\"f\" 来自于 \"function..\")\nparseInt(\"0x10\"); // 16\nparseInt(\"103\", 2); // 2\n```\n\n### 隐式强制类型转换\n\n#### 字符串和数字之间的隐式强制类型转换\n\n例如：\n\n```js\nvar a = \"42\";\nvar b = \"0\";\nvar c = 42;\nvar d = 0;\na + b; // \"420\"\nc + d; // 42\n```\n\n再例如：\n\n```js\nvar a = [1,2];\nvar b = [3,4];\na + b; // \"1,23,4\"\n```\n\n根据 ES5 规范 11.6.1 节，如果某个操作数是字符串或者能够通过以下步骤转换为字符串的话，+ 将进行拼接操作。如果其中一个操作数是对象（包括数组），则首先对其调用 ToPrimitive 抽象操作（规范 9.1 节），该抽象操作再调用 `[[DefaultValue]]`（规范 8.12.8 节），以数字作为上下文。\n\n你或许注意到这与 `ToNumber` 抽象操作处理对象的方式一样（参见 4.2.2 节）。因为数组的 `valueOf()` 操作无法得到简单基本类型值，于是它转而调用 `toString()`。因此上例中的两个数组变成了 \"`1,2`\" 和 \"`3,4`\" 。+ 将它们拼接后返回 \"`1,23,4`\" 。\n\n**简单来说就是，如果 + 的其中一个操作数是字符串（或者通过以上步骤可以得到字符串），则执行字符串拼接；否则执行数字加法。**\n\n#### 符号的强制类型转换\n\nES6 允许从符号到字符串的显式强制类型转换，然而隐式强制类型转换会产生错误，具体的原因不在本书讨论范围之内。\n\n例如：\n\n```js\nvar s1 = Symbol(\"cool\");\nString(s1); // \"Symbol(cool)\"\nvar s2 = Symbol(\"not cool\");\ns2 + \"\"; // TypeError\n```\n\n符号不能够被强制类型转换为数字（显式和隐式都会产生错误），但可以被强制类型转换为布尔值（显式和隐式结果都是 `true`）。\n\n由于规则缺乏一致性，我们要对 ES6 中符号的强制类型转换多加小心。\n\n好在鉴于符号的特殊用途，我们不会经常用到它的强制类型转换。\n\n### 宽松相等和严格相等\n\n常见的误区是“`==` 检查值是否相等，`===` 检查值和类型是否相等”。听起来蛮有道理，然而还不够准确。很多 JavaScript 的书籍和博客也是这样来解释的，但是很遗憾他们都错了。\n\n正确的解释是：“`==` 允许在相等比较中进行强制类型转换，而 `===` 不允许。”\n\n字符串和数字之间的相等比较：\n\n- 如果 Type(x) 是数字，Type(y) 是字符串，则返回 x == ToNumber(y) 的结果。\n- 如果 Type(x) 是字符串，Type(y) 是数字，则返回 ToNumber(x) == y 的结果。\n\n其他类型和布尔类型之间的相等比较：\n\n- 如果 Type(x) 是布尔类型，则返回 ToNumber(x) == y 的结果；\n- 如果 Type(y) 是布尔类型，则返回 x == ToNumber(y) 的结果。\n\n`null` 和 `undefined` 之间的相等比较：\n\n- 如果 x 为 null，y 为 undefined，则结果为 true。\n- 如果 x 为 undefined，y 为 null，则结果为 true。\n\n对象和非对象之间的相等比较：\n\n- 如果 Type(x) 是字符串或数字，Type(y) 是对象，则返回 x == ToPrimitive(y) 的结果；\n- 如果 Type(x) 是对象，Type(y) 是字符串或数字，则返回 ToPromitive(x) == y 的结果。\n\n## 语法\n\n### 错误\n\n提前使用变量\n\nES6 规范定义了一个新概念，叫作 TDZ（Temporal Dead Zone，暂时性死区）。\n\nTDZ 指的是由于代码中的变量还没有初始化而不能被引用的情况。\n\n对此，最直观的例子是 ES6 规范中的 `let` 块作用域：\n\n```js\n{\n  a = 2; // ReferenceError!\n  let a;\n}\n```\n\n`a = 2` 试图在 `let a` 初始化 `a` 之前使用该变量（其作用域在 `{ .. }` 内），这里就是 `a` 的 TDZ，会产生错误。\n\n有意思的是，对未声明变量使用 typeof 不会产生错误（参见第 1 章），但在 TDZ 中却会报错：\n\n```js\n{\n  typeof a; // undefined\n  typeof b; // ReferenceError! (TDZ)\n  let b;\n}\n```\n\n## 回调\n\n### 省点回调\n\n构造一个超时验证工具：\n\n```js\nfunction timeoutify(fn, delay) {\n  var intv = setTimeout(function() {\n    intv = null\n    fn(new Error('Timeout!'))\n  }, delay)\n\n  return function() {\n    // 还没有超时？\n    if (intv) {\n      clearTimeout(intv)\n      fn.apply(this, arguments)\n    }\n  }\n}\n```\n\n以下是使用方式：\n\n```js\n// 使用 ‘error-first 风格’ 回调设计\nfunction foo(err, data) {\n  if (err) {\n    console.error(err)\n  }\n  else {\n    console.log(data)\n  }\n}\n\najax('http://some.url.1', timeoutify(foo, 500))\n```\n\n如果你不确定关注的 API 会不会永远异步执行怎么办呢？可以创建一个类似于这个“验证概念”版本的 `asyncify(..)` 工具：\n\n```js\nfunction asyncify(fn) {\n  var orig_fn = fn,\n    intv = setTimeout(function() {\n      intv = null\n      if (fn) fn()\n    }, 0)\n\n  fn = null\n\n  return function() {\n    // 触发太快，在定时器intv触发指示异步转换发生之前？\n    if (intv) {\n      fn = orig_fn.bind.apply(\n        orig_fn,\n        // 把封装器的this添加到bind(..)调用的参数中，\n        // 以及克里化（currying）所有传入参数\n        [this].concat([].slice.call(arguments))\n      )\n    }\n    // 已经是异步\n    else {\n      // 调用原来的函数\n      orig_fn.apply(this, arguments)\n    }\n  }\n}\n```\n\n可以像这样使用 `asyncify(..)`：\n\n```js\nfunction result(data) {\n  console.log(a)\n}\n\nvar a = 0\n\najax('..pre-cached-url..', asyncify(result))\na++\n```\n\n不管这个 Ajax 请求已经在缓存中并试图对回调立即调用，还是要从网络上取得，进而在将来异步完成，这段代码总是会输出 1，而不是 0——result(..) 只能异步调用，这意味着 a++ 有机会在 result(..) 之前运行。\n\n## Promise\n\n### Promise 信任问题\n\n#### 回调未调用\n\n提供一个超时处理的解决方案：\n\n```js\n// 用于超时一个Promise的工具\nfunction timeoutPromise(delay) {\n  return new Promise(function(resolve, reject) {\n    setTimeout(function() {\n      reject('Timeout!')\n    }, delay)\n  })\n}\n\n// 设置foo()超时\nPromise.race([\n  foo(),\n  timeoutPromise(3000)\n])\n.then(\n  function() {\n    // foo(..)及时完成！\n  },\n  function(err) {\n    // 或者foo()被拒绝，或者只是没能按时完成\n \t// 查看err来了解是哪种情况\n  }\n)\n```\n\n### 链式流\n\n为了进一步阐释链接，让我们把延迟 Promise 创建（没有决议消息）过程一般化到一个工具中，以便在多个步骤中复用：\n\n```js\nfunction delay(time) {\n  return new Promise(function(resolve, reject) {\n    setTimeout(resolve, time)\n  })\n}\n\ndelay(100) // 步骤1\n  .then(function STEP2() {\n    console.log(\"step 2 (after 100ms)\")\n    return delay(200)\n  })\n  .then(function STEP3() {\n    console.log(\"step 3 (after another 200ms)\")\n  })\n  .then(function STEP4() {\n    console.log(\"step 4 (next Job)\")\n    return delay(50)\n  })\n  .then(function STEP5() {\n    console.log(\"step 5 (after another 50ms)\")\n  })\n```\n\n调用 `delay(200)` 创建了一个将在 200ms 后完成的 promise，然后我们从第一个 `then(..)` 完成回调中返回这个 promise，这会导致第二个 `then(..)` 的 promise 等待这个 200ms 的 promise。\n\n### Promise 局限性\n\n#### 顺序错误处理\n\nPromise 的设计局限性（链式调用）造成了一个让人很容易中招的陷阱，即 Promise 链中的错误很容易被无意中默默忽略掉。\n\n关于 Promise 错误，还有其他需要考虑的地方。由于一个 Promise 链仅仅是连接到一起的成员 Promise，没有把整个链标识为一个个体的实体，这意味着没有外部方法可以用于观察可能发生的错误。\n\n如果构建了一个没有错误处理函数的 Promise 链，链中任何地方的任何错误都会在链中一直传播下去，直到在某个步骤注册拒绝处理函数。在这个特定的例子中，只要有一个指向链中最后一个 promise 的引用就足够了（下面代码中的 p），因为你可以在那里注册拒绝处理函数，而且这个处理函数能够得到所有传播过来的错误的通知：\n\n```js\n// foo(..), STEP2(..)以及STEP3(..)都是支持promise的工具\nvar p = foo(42)\n  .then(STEP2)\n  .then(STEP3);\n```\n\n虽然这里可能令人迷惑，但是这里的 `p` 并不指向链中的第一个 promise（调用 `foo(42)` 产生的那一个），而是指向最后一个 promise，即来自调用 `then(STEP3)` 的那一个。\n\n还有，这个 Promise 链中的任何一个步骤都没有显式地处理自身错误。这意味着你可以在 `p` 上注册一个拒绝错误处理函数，对于链中任何位置出现的任何错误，这个处理函数都会得到通知：\n\n```js\np.catch(handleErrors); \n```\n\n但是，如果链中的任何一个步骤事实上进行了自身的错误处理（可能以隐藏或抽象的不可见的方式），那你的 `handleErrors(..)` 就不会得到通知。这可能是你想要的——毕竟这是一个“已处理的拒绝”——但也可能并不是。不能清晰得到（对具体某一个“已经处理”的拒绝的）错误通知也是一个缺陷，它限制了某些用例的功能。\n\n基本上，这等同于 try..catch 存在的局限：try..catch 可能捕获一个异常并简单地吞掉它。所以这并不是 Promise 独有的局限性，但可能是我们希望绕过的陷阱。\n\n遗憾的是，很多时候并没有为 Promise 链序列的中间步骤保留的引用。因此，没有这样的引用，你就无法关联错误处理函数来可靠地检查错误。\n\n#### 单一值\n\n根据定义，Promise 只能有一个完成值或一个拒绝理由。在简单的例子中，这不是什么问题，但是在更复杂的场景中，你可能就会发现这是一种局限了。\n\n一般的建议是构造一个值封装（比如一个对象或数组）来保持这样的多个信息。这个解决方案可以起作用，但要在 Promise 链中的每一步都进行封装和解封，就十分丑陋和笨重了。\n\n1. 分裂值\n\n有时候，你可以把这一点，当作提示你应该把问题分解为两个或更多 Promise 的信号。\n\n设想你有一个工具 `foo(..)`，它可以异步产生两个值（x 和 y）：\n\n```js\nfunction getY(x) { \n  return new Promise(function(resolve, reject){ \n    setTimeout(function(){ \n      resolve((3 * x) - 1); \n    }, 100); \n  });\n} \n\nfunction foo(bar, baz) { \n  var x = bar * baz; \n  return getY(x).then(function(y){ \n    // 把两个值封装到容器中\n    return [x, y]; \n  }); \n} \n\nfoo(10, 20).then(function(msgs){ \n  var x = msgs[0]; \n  var y = msgs[1]; \n  console.log(x, y); // 200 599 \n}); \n```\n\n首先，我们重新组织一下 `foo(..)` 返回的内容，这样就不再需要把 `x` 和 `y` 封装到一个数组值中以通过 promise 传输。取而代之的是，我们可以把每个值封装到它自己的 promise：\n\n```js\nfunction foo(bar, baz) { \n  var x = bar * baz; \n  \n  // 返回两个 promise\n  return [ \n    Promise.resolve(x), \n    getY(x) \n  ]; \n} \n\nPromise.all( \n  foo(10, 20) \n).then(function(msgs){ \n  var x = msgs[0]; \n  var y = msgs[1]; \n  console.log(x, y); \n}); \n```\n\n一个 promise 数组真的要优于传递给单个 promise 的一个值数组吗？从语法的角度来说，这算不上是一个改进。\n\n但是，这种方法更符合 Promise 的设计理念。如果以后需要重构代码把对 `x` 和 `y` 的计算分开，这种方法就简单得多。由调用代码来决定如何安排这两个 promise，而不是把这种细节放在 `foo(..)` 内部抽象，这样更整洁也更灵活。这里使用了 `Promise.all([ .. ])`，当然，这并不是唯一的选择。\n\n2. 传递参数\n\n`var x = ..` 和 `var y = ..` 赋值操作仍然是麻烦的开销。我们可以在辅助工具中采用某种函数技巧：\n\n```js\nfunction spread(fn) { \n  return Function.apply.bind(fn, null); \n} \n\nPromise.all( \n  foo(10, 20) \n).then(spread(function(x, y){ \n  console.log(x, y); // 200 599 \n})) \n```\n\n这样会好一点！当然，你可以把这个函数戏法在线化，以避免额外的辅助工具：\n\n```js\nPromise.all( \n  foo(10, 20) \n).then(Function.apply.bind( \n  function(x, y){ \n    console.log(x, y); // 200 599 \n  },\n  null\n)); \n```\n\n这些技巧可能很灵巧，但 ES6 给出了一个更好的答案：解构。数组解构赋值形式看起来是这样的：\n\n```js\nPromise.all( \n  foo(10, 20) \n).then(function(msgs){ \n  var [x, y] = msgs; \n  console.log(x, y); // 200 599 \n}); \n```\n\n不过最好的是，ES6 提供了数组参数解构形式：\n\n```js\nPromise.all( \n  foo(10, 20) \n) \n.then(function([x, y]){ \n  console.log(x, y); // 200 599 \n}); \n```\n\n现在，我们符合了“每个 Promise 一个值”的理念，并且又将重复样板代码量保持在了最小！\n\n#### 单决议\n\nPromise 最本质的一个特征是：Promise 只能被决议一次（完成或拒绝）。在许多异步情况中，你只会获取一个值一次，所以这可以工作良好。\n\n但是，还有很多异步的情况适合另一种模式——一种类似于事件或数据流的模式。在表面上，目前还不清楚 Promise 能不能很好用于这样的用例，如果不是完全不可用的话。如果不在 Promise 之上构建显著的抽象，Promise 肯定完全无法支持多值决议处理。\n\n设想这样一个场景：你可能要启动一系列异步步骤以响应某种可能多次发生的激励（就像是事件），比如按钮点击。\n\n这样可能不会按照你的期望工作：\n\n```js\n// click(..) 把\"click\"事件绑定到一个 DOM 元素\n// request(..) 是前面定义的支持 Promise 的 Ajax \nvar p = new Promise(function(resolve, reject){ \n  click(\"#mybtn\", resolve); \n}); \n\np.then(function(evt){ \n  var btnID = evt.currentTarget.id; \n  return request(\"http://some.url.1/?id=\" + btnID); \n}).then(function(text){ \n  console.log(text); \n}); \n```\n\n只有在你的应用只需要响应按钮点击一次的情况下，这种方式才能工作。如果这个按钮被点击了第二次的话，promise p 已经决议，因此第二个 `resolve(..)` 调用就会被忽略。\n\n因此，你可能需要转化这个范例，为每个事件的发生创建一整个新的 Promise 链：\n\n```js\nclick(\"#mybtn\", function(evt){ \n  var btnID = evt.currentTarget.id; \n  request(\"http://some.url.1/?id=\" + btnID).then(function(text){ \n    console.log(text); \n  }); \n}); \n```\n\n这种方法可以工作，因为针对这个按钮上的每个 \"click\" 事件都会启动一整个新的 Promise 序列。\n\n由于需要在事件处理函数中定义整个 Promise 链，这很丑陋。除此之外，这个设计在某种程度上破坏了关注点与功能分离（SoC）的思想。你很可能想要把事件处理函数的定义和对事件的响应（那个 Promise 链）的定义放在代码中的不同位置。如果没有辅助机制的话，在这种模式下很难这样实现。\n\n## 感谢\n\n如果本文对你有帮助，就点个赞支持下吧！感谢阅读。", "user_name": "Liam__", "description": "", "got_view_count": 5818, "category_name": "阅读", "ctime": 1457483895}
{"tag_name": "后端", "concern_user_count": 364361, "user_id": "958429871749192", "title": "被我用烂的DEBUG调试技巧，专治各种搜索不到的问题！", "mark_content": "> SpringBoot实战电商项目mall（35k+star）地址：[https://github.com/macrozheng/mall](https://github.com/macrozheng/mall)\n\n## 摘要\n\n在开发过程中，遇到问题，我们经常会使用搜索引擎来查找问题的解决方案，然后予以解决。但是有些问题一时半会搜索不到解决方案，需要自己去解决。这里分享下我解决这些问题使用的调试技巧，给大家一个解决问题的新思路！\n\n## 问题描述\n\n在[《我扒了半天源码，终于找到了Oauth2自定义处理结果的最佳方案！》](https://juejin.im/post/6857296054392471559)一文中，当JWT令牌过期或者签名不正确时，我们想要自定义网关认证失败的返回结果。这个问题解决起来很简单，只需修改一行代码即可。但是当时查找解决方案确实花费了一番功夫，通过DEBUG源码才找到了Spring Security中提供的自定义配置，解决了该问题。下面讲讲我是如何通过DEBUG源码找到这个解决方案的！\n\n## 解决过程\n\n- 首先我们需要找到一个切入点，既然问题是由于JWT令牌过期或者签名不正确才产生的，我们很容易想到`RSASSAVerifier`这个关键类，它的`verify()`方法是用来验证签名是否正确的，我们可以在该方法上面打个断点DEBUG一下，发现程序执行过程果然会经过这里，要是签名不正确会直接返回false;\n\n![](http://img.macrozheng.com/mall/blog/my_debug_skill_01.png)\n\n- 这时候我们可以查下堆栈信息，了解下这次调用的整个过程，可以看到红框以下的调用都是WebFlux里面的调用，没有参考意义，所以调用最早是从`NimbusReactiveJwtDecoder`类开始的；\n\n![](http://img.macrozheng.com/mall/blog/my_debug_skill_02.png)\n\n- 我们搜索下`NimbusReactiveJwtDecoder`在哪里被使用到了，可以找到又一个关键类`ServerHttpSecurity`，我们在网关的安全配置`ResourceServerConfig`中曾经用到过它，猜想下如果Spring Security提供了自定义配置，那估计就在这个类里面了；\n\n![](http://img.macrozheng.com/mall/blog/my_debug_skill_03.png)\n\n- 查看下`ServerHttpSecurity`的类注释，我们可以发现它相当于WebFlux版本的Spring Security配置；\n\n```java\n/**\n * A {@link ServerHttpSecurity} is similar to Spring Security's {@code HttpSecurity} but for WebFlux.\n * It allows configuring web based security for specific http requests. By default it will be applied\n * to all requests, but can be restricted using {@link #securityMatcher(ServerWebExchangeMatcher)} or\n * other similar methods.\n **/\n```\n\n- 在我们网关的`ResourceServerConfig`中，我们曾经调用过`ServerHttpSecurity`的`build()`方法，用于生成`SecurityWebFilterChain`;\n\n![](http://img.macrozheng.com/mall/blog/my_debug_skill_04.png)\n\n- 让我们看看这个`build()`方法干了点啥，其中有段比较关键的是它调用了`OAuth2ResourceServerSpec`类的`configure()`方法；\n\n![](http://img.macrozheng.com/mall/blog/my_debug_skill_05.png)\n\n- 而`OAuth2ResourceServerSpec`类的`configure()`方法又调用了`JwtSpec`类的`configure()`方法；\n\n![](http://img.macrozheng.com/mall/blog/my_debug_skill_06.png)\n\n- 这个`JwtSpec`对象是不会为空的，因为我们在`ResourceServerConfig`中调用了`OAuth2ResourceServerSpec`类的`jwt()`方法创建了它；\n\n![](http://img.macrozheng.com/mall/blog/my_debug_skill_07.png)\n\n- `JwtSpec`类的`configure`方法很关键，使用过滤器来进行认证是Spring Security实现认证的老套路了，于是我们找到了默认的认证过滤器`BearerTokenAuthenticationWebFilter`；\n\n![](http://img.macrozheng.com/mall/blog/my_debug_skill_08.png)\n\n- `BearerTokenAuthenticationWebFilter`使用了`OAuth2ResourceServerSpec`中的`entryPoint`来处理认证失败，默认实现为`BearerTokenServerAuthenticationEntryPoint`；\n\n![](http://img.macrozheng.com/mall/blog/my_debug_skill_09.png)\n\n- 之后我们在`BearerTokenAuthenticationWebFilter`的`filter()`方法，`BearerTokenServerAuthenticationEntryPoint`的`commence()`方法上分别打个断点，来验证下，调用过程中都经过了，完全正确；\n\n![](http://img.macrozheng.com/mall/blog/my_debug_skill_10.png)\n\n- 也就是说我们只要把默认的认证失败处理器换成我们自定义的就行了，直接通过如下代码把`OAuth2ResourceServerSpec`中的`entryPoint`来设置成自定义的即可。\n\n```java\n/**\n * 资源服务器配置\n * Created by macro on 2020/6/19.\n */\n@AllArgsConstructor\n@Configuration\n@EnableWebFluxSecurity\npublic class ResourceServerConfig {\n    private final RestAuthenticationEntryPoint restAuthenticationEntryPoint;\n\n    @Bean\n    public SecurityWebFilterChain springSecurityFilterChain(ServerHttpSecurity http) {\n       //省略若干代码...\n       //自定义处理JWT请求头过期或签名错误的结果\n       http.oauth2ResourceServer().authenticationEntryPoint(restAuthenticationEntryPoint);\n       //省略若干代码...\n       return http.build();\n    }\n}\n```\n\n## 总结\n\n对于一时找不到解决方法的问题，我推荐使用DEBUG源码的方式来解决。首先寻找一个突破口，可以从你熟悉的一些类中去寻找一个必定会执行的方法，然后打断点，进行DEBUG，从调用的栈信息中查找出关键的类，之后通过这些关键类顺藤摸瓜就能找解决方法了！\n\n## 项目源码地址\n\nhttps://github.com/macrozheng/springcloud-learning/tree/master/micro-oauth2\n\n## 推荐阅读\n\n[Github标星35K+，SpringBoot（2.3.0）电商实战项目，全套教程无套路获取！](https://www.yuque.com/macrozheng/github/ny150b)\n", "user_name": "MacroZheng", "description": "Java后端技术 | 公众号：macrozheng | Github开源项目mall(35k+star)", "got_view_count": 643187, "category_name": "后端", "ctime": 1457483880}
{"tag_name": "面试", "concern_user_count": 285351, "user_id": "3913917126415166", "title": "面试这么撩准拿offer，HashMap深度学习，扰动函数、负载因子、扩容拆分，原理和实践验证，让懂了就是真的懂！", "mark_content": "作者：小傅哥\n<br/>博客：[https://bugstack.cn](https://bugstack.cn)\n\n>沉淀、分享、成长，让自己和他人都能有所收获！😄\n\n## 一、前言\n\n得益于`Doug Lea`老爷子的操刀，让`HashMap`成为使用和面试最频繁的API，没办法设计的太优秀了！\n\nHashMap 最早出现在 JDK 1.2中，底层基于散列算法实现。HashMap 允许 null 键和 null 值，在计算哈键的哈希值时，null 键哈希值为 0。HashMap 并不保证键值对的顺序，这意味着在进行某些操作后，键值对的顺序可能会发生变化。另外，需要注意的是，HashMap 是非线程安全类，在多线程环境下可能会存在问题。\n\nHashMap 最早在JDK 1.2中就出现了，底层是基于散列算法实现，随着几代的优化更新到目前为止它的源码部分已经比较复杂，涉及的知识点也非常多，在JDK 1.8中包括；`1、散列表实现`、`2、扰动函数`、`3、初始化容量`、`4、负载因子`、`5、扩容元素拆分`、`6、链表树化`、`7、红黑树`、`8、插入`、`9、查找`、`10、删除`、`11、遍历`、`12、分段锁`等等，因涉及的知识点较多所以需要分开讲解，本章节我们会先把目光放在前五项上，也就是关于数据结构的使用上。\n\n数据结构相关往往与数学离不开，学习过程中建议下载相应源码进行实验验证，可能这个过程有点烧脑，但学会后不用死记硬背就可以理解这部分知识。\n\n## 二、资源下载\n\n本章节涉及的源码和资源在工程，**interview-04**中，包括；\n1. 10万单词测试数据，在doc文件夹\n2. 扰动函数excel展现，在dock文件夹\n3. 测试源码部分在`interview-04`工程中\n\n可以通过关注公众号：[`bugstack虫洞栈`](https://bugstack.cn/assets/images/qrcode.png)，回复下载进行获取{*回复下载后打开获得的链接，找到编号ID：19*}\n\n## 三、源码分析\n\n### 1. 写一个最简单的HashMap\n\n学习HashMap前，最好的方式是先了解这是一种怎么样的数据结构来存放数据。而HashMap经过多个版本的迭代后，乍一看代码还是很复杂的。就像你原来只穿个裤衩，现在还有秋裤和风衣。所以我们先来看看最根本的HashMap是什么样，也就是只穿裤衩是什么效果，之后再去分析它的源码。\n\n**问题：** 假设我们有一组7个字符串，需要存放到数组中，但要求在获取每个元素的时候时间复杂度是O(1)。也就是说你不能通过循环遍历的方式进行获取，而是要定位到数组ID直接获取相应的元素。\n\n**方案：** 如果说我们需要通过ID从数组中获取元素，那么就需要把每个字符串都计算出一个在数组中的位置ID。*字符串获取ID你能想到什么方式？* 一个字符串最直接的获取跟数字相关的信息就是HashCode，可HashCode的取值范围太大了`[-2147483648, 2147483647]`，不可能直接使用。那么就需要使用HashCode与数组长度做与运算，得到一个可以在数组中出现的位置。如果说有两个元素得到同样的ID，那么这个数组ID下就存放两个字符串。\n\n以上呢其实就是我们要把字符串散列到数组中的一个基本思路，接下来我们就把这个思路用代码实现出来。\n\n#### 1.1 代码实现\n\n```java\n// 初始化一组字符串\nList<String> list = new ArrayList<>();\nlist.add(\"jlkk\");\nlist.add(\"lopi\");\nlist.add(\"小傅哥\");\nlist.add(\"e4we\");\nlist.add(\"alpo\");\nlist.add(\"yhjk\");\nlist.add(\"plop\");\n\n// 定义要存放的数组\nString[] tab = new String[8];\n\n// 循环存放\nfor (String key : list) {\n    int idx = key.hashCode() & (tab.length - 1);  // 计算索引位置\n    System.out.println(String.format(\"key值=%s Idx=%d\", key, idx));\n    if (null == tab[idx]) {\n        tab[idx] = key;\n        continue;\n    }\n    tab[idx] = tab[idx] + \"->\" + key;\n}\n// 输出测试结果\nSystem.out.println(JSON.toJSONString(tab));\n```\n\n这段代码整体看起来也是非常简单，并没有什么复杂度，主要包括以下内容；\n1. 初始化一组字符串集合，这里初始化了7个。\n2. 定义一个数组用于存放字符串，注意这里的长度是8，也就是2的倍数。这样的数组长度才会出现一个 `0111` 除高位以外都是1的特征，也是为了散列。\n3. 接下来就是循环存放数据，计算出每个字符串在数组中的位置。`key.hashCode() & (tab.length - 1)`。\n4. 在字符串存放到数组的过程，如果遇到相同的元素，进行连接操作`模拟链表的过程`。\n5. 最后输出存放结果。\n\n**测试结果**\n\n```java\nkey值=jlkk Idx=2\nkey值=lopi Idx=4\nkey值=小傅哥 Idx=7\nkey值=e4we Idx=5\nkey值=alpo Idx=2\nkey值=yhjk Idx=0\nkey值=plop Idx=5\n测试结果：[\"yhjk\",null,\"jlkk->alpo\",null,\"lopi\",\"e4we->plop\",null,\"小傅哥\"]\n```\n\n- 在测试结果首先是计算出每个元素在数组的Idx，也有出现重复的位置。\n- 最后是测试结果的输出，1、3、6，位置是空的，2、5，位置有两个元素被链接起来`e4we->plop`。\n- 这就达到了我们一个最基本的要求，将串元素散列存放到数组中，最后通过字符串元素的索引ID进行获取对应字符串。这样是HashMap的一个最基本原理，有了这个基础后面就会更容易理解HashMap的源码实现。\n\n#### 1.2 Hash散列示意图\n\n如果上面的测试结果不能在你的头脑中很好的建立出一个数据结构，那么可以看以下这张散列示意图，方便理解；\n\n![bugstack.cn Hash散列示意图](https://bugstack.cn/assets/images/2020/interview/interview-4-01.png)\n\n- 这张图就是上面代码实现的全过程，将每一个字符串元素通过Hash计算索引位置，存放到数组中。\n- 黄色的索引ID是没有元素存放、绿色的索引ID存放了一个元素、红色的索引ID存放了两个元素。\n\n#### 1.3 这个简单的HashMap有哪些问题\n\n以上我们实现了一个简单的HashMap，或者说还算不上HashMap，只能算做一个散列数据存放的雏形。但这样的一个数据结构放在实际使用中，会有哪些问题呢？\n\n1. 这里所有的元素存放都需要获取一个索引位置，而如果元素的位置不够散列碰撞严重，那么就失去了散列表存放的意义，没有达到预期的性能。\n2. 在获取索引ID的计算公式中，需要数组长度是2的倍数，那么怎么进行初始化这个数组大小。\n3. 数组越小碰撞的越大，数组越大碰撞的越小，时间与空间如何取舍。\n4. 目前存放7个元素，已经有两个位置都存放了2个字符串，那么链表越来越长怎么优化。\n5. 随着元素的不断添加，数组长度不足扩容时，怎么把原有的元素，拆分到新的位置上去。\n\n以上这些问题可以归纳为；`扰动函数`、`初始化容量`、`负载因子`、`扩容方法`以及`链表和红黑树`转换的使用等。接下来我们会逐个问题进行分析。\n\n### 2. 扰动函数\n\n在HashMap存放元素时候有这样一段代码来处理哈希值，这是`java 8`的散列值扰动函数，用于优化散列效果；\n\n```java\nstatic final int hash(Object key) {\n    int h;\n    return (key == null) ? 0 : (h = key.hashCode()) ^ (h >>> 16);\n}\n```\n\n#### 2.1 为什么使用扰动函数\n\n理论上来说字符串的`hashCode`是一个int类型值，那可以直接作为数组下标了，且不会出现碰撞。但是这个`hashCode`的取值范围是[-2147483648, 2147483647]，有将近40亿的长度，谁也不能把数组初始化的这么大，内存也是放不下的。\n\n我们默认初始化的Map大小是16个长度 `DEFAULT_INITIAL_CAPACITY = 1 << 4`，所以获取的Hash值并不能直接作为下标使用，需要与数组长度进行取模运算得到一个下标值，也就是我们上面做的散列列子。\n\n那么，hashMap源码这里不只是直接获取哈希值，还进行了一次扰动计算，`(h = key.hashCode()) ^ (h >>> 16)`。把哈希值右移16位，也就正好是自己长度的一半，之后与原哈希值做异或运算，这样就混合了原哈希值中的高位和低位，增大了**随机性**。计算方式如下图；\n\n![bugstack.cn 扰动函数](https://bugstack.cn/assets/images/2020/interview/interview-4-02.png)\n\n- 说白了，使用扰动函数就是为了增加随机性，让数据元素更加均衡的散列，减少碰撞。\n\n#### 2.2 实验验证扰动函数\n\n从上面的分析可以看出，扰动函数使用了哈希值的高半区和低半区做异或，混合原始哈希码的高位和低位，以此来加大低位区的随机性。\n\n但看不到实验数据的话，这终究是一段理论，具体这段哈希值真的被增加了随机性没有，并不知道。所以这里我们要做一个实验，这个实验是这样做；\n\n1. 选取10万个单词词库\n2. 定义128位长度的数组格子\n3. 分别计算在扰动和不扰动下，10万单词的下标分配到128个格子的数量\n4. 统计各个格子数量，生成波动曲线。如果扰动函数下的波动曲线相对更平稳，那么证明扰动函数有效果。\n\n##### 2.2.1 扰动代码测试\n\n**扰动函数对比方法**\n\n```java\npublic class Disturb {\n\n    public static int disturbHashIdx(String key, int size) {\n        return (size - 1) & (key.hashCode() ^ (key.hashCode() >>> 16));\n    }\n\n    public static int hashIdx(String key, int size) {\n        return (size - 1) & key.hashCode();\n    }\n\n}\n```\n\n- `disturbHashIdx` 扰动函数下，下标值计算\n- `hashIdx` 非扰动函数下，下标值计算\n\n**单元测试**\n\n```java\n// 10万单词已经初始化到words中\n@Test\npublic void test_disturb() {\n    Map<Integer, Integer> map = new HashMap<>(16);\n    for (String word : words) {\n        // 使用扰动函数\n        int idx = Disturb.disturbHashIdx(word, 128);\n        // 不使用扰动函数\n        // int idx = Disturb.hashIdx(word, 128);\n        if (map.containsKey(idx)) {\n            Integer integer = map.get(idx);\n            map.put(idx, ++integer);\n        } else {\n            map.put(idx, 1);\n        }\n    }\n    System.out.println(map.values());\n}\n```\n\n以上分别统计两种函数下的下标值分配，最终将统计结果放到excel中生成图表。\n\n##### 2.2.2 扰动函数散列图表\n\n以上的两张图，分别是没有使用扰动函数和使用扰动函数的，下标分配。实验数据；\n1. 10万个不重复的单词\n2. 128个格子，相当于128长度的数组\n\n**未使用扰动函数**\n\n![bugstack.cn 未使用扰动函数](https://bugstack.cn/assets/images/2020/interview/interview-4-03.png)\n\n**使用扰动函数**\n\n![bugstack.cn 使用扰动函数](https://bugstack.cn/assets/images/2020/interview/interview-4-04.png)\n\n- 从这两种的对比图可以看出来，在使用了扰动函数后，数据分配的更加均匀了。\n- 数据分配均匀，也就是散列的效果更好，减少了hash的碰撞，让数据存放和获取的效率更佳。\n\n### 3. 初始化容量和负载因子\n\n接下来我们讨论下一个问题，从我们模仿HashMap的例子中以及HashMap默认的初始化大小里，都可以知道，散列数组需要一个2的倍数的长度，因为只有2的倍数在减1的时候，才会出现`01111`这样的值。\n\n那么这里就有一个问题，我们在初始化HashMap的时候，如果传一个17个的值`new HashMap<>(17);`，它会怎么处理呢？\n\n#### 3.1 寻找2的倍数最小值\n\n在HashMap的初始化中，有这样一段方法；\n\n```java\npublic HashMap(int initialCapacity, float loadFactor) {\n    ...\n    this.loadFactor = loadFactor;\n    this.threshold = tableSizeFor(initialCapacity);\n}\n```\n\n- 阀值`threshold`，通过方法`tableSizeFor`进行计算，是根据初始化来计算的。\n- 这个方法也就是要寻找比初始值大的，最小的那个2进制数值。比如传了17，我应该找到的是32。\n\n计算阀值大小的方法；\n\n```java\nstatic final int tableSizeFor(int cap) {\n    int n = cap - 1;\n    n |= n >>> 1;\n    n |= n >>> 2;\n    n |= n >>> 4;\n    n |= n >>> 8;\n    n |= n >>> 16;\n    return (n < 0) ? 1 : (n >= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + 1;\n}\n```\n\n- MAXIMUM_CAPACITY = 1 << 30，这个是临界范围，也就是最大的Map集合。\n- 乍一看可能有点晕😵怎么都在向右移位1、2、4、8、16，这主要是为了把二进制的各个位置都填上1，当二进制的各个位置都是1以后，就是一个标准的2的倍数减1了，最后把结果加1再返回即可。\n\n那这里我们把17这样一个初始化计算阀值的过程，用图展示出来，方便理解；\n\n![bugstack.cn 计算阀值](https://bugstack.cn/assets/images/2020/interview/interview-4-05.png)\n\n#### 3.2 负载因子\n\n```java\nstatic final float DEFAULT_LOAD_FACTOR = 0.75f;\n```\n\n**负载因子是做什么的？**\n\n负载因子，可以理解成一辆车可承重重量超过某个阀值时，把货放到新的车上。\n\n那么在HashMap中，负载因子决定了数据量多少了以后进行扩容。*这里要提到上面做的HashMap例子，我们准备了7个元素，但是最后还有3个位置空余，2个位置存放了2个元素。* 所以可能即使你数据比数组容量大时也是不一定能正正好好的把数组占满的，而是在某些小标位置出现了大量的碰撞，只能在同一个位置用链表存放，那么这样就失去了Map数组的性能。\n\n所以，要选择一个合理的大小下进行扩容，默认值0.75就是说当阀值容量占了3/4s时赶紧扩容，减少Hash碰撞。\n\n同时0.75是一个默认构造值，在创建HashMap也可以调整，比如你希望用更多的空间换取时间，可以把负载因子调的更小一些，减少碰撞。\n\n### 4.  扩容元素拆分\n\n为什么扩容，因为数组长度不足了。那扩容最直接的问题，就是需要把元素拆分到新的数组中。拆分元素的过程中，原jdk1.7中会需要重新计算哈希值，但是到jdk1.8中已经进行优化，不在需要重新计算，提升了拆分的性能，设计的还是非常巧妙的。\n\n#### 4.1 测试数据\n\n```java\n@Test\npublic void test_hashMap() {\n    List<String> list = new ArrayList<>();\n    list.add(\"jlkk\");\n    list.add(\"lopi\");\n    list.add(\"jmdw\");\n    list.add(\"e4we\");\n    list.add(\"io98\");\n    list.add(\"nmhg\");\n    list.add(\"vfg6\");\n    list.add(\"gfrt\");\n    list.add(\"alpo\");\n    list.add(\"vfbh\");\n    list.add(\"bnhj\");\n    list.add(\"zuio\");\n    list.add(\"iu8e\");\n    list.add(\"yhjk\");\n    list.add(\"plop\");\n    list.add(\"dd0p\");\n    for (String key : list) {\n        int hash = key.hashCode() ^ (key.hashCode() >>> 16);\n        System.out.println(\"字符串：\" + key + \" \\tIdx(16)：\" + ((16 - 1) & hash) + \" \\tBit值：\" + Integer.toBinaryString(hash) + \" - \" + Integer.toBinaryString(hash & 16) + \" \\t\\tIdx(32)：\" + ((\n        System.out.println(Integer.toBinaryString(key.hashCode()) +\" \"+ Integer.toBinaryString(hash) + \" \" + Integer.toBinaryString((32 - 1) & hash));\n    }\n}\n```\n\n**测试结果**\n\n```java\n字符串：jlkk \tIdx(16)：3 \tBit值：1100011101001000010011 - 10000 \t\tIdx(32)：19\n1100011101001000100010 1100011101001000010011 10011\n字符串：lopi \tIdx(16)：14 \tBit值：1100101100011010001110 - 0 \t\tIdx(32)：14\n1100101100011010111100 1100101100011010001110 1110\n字符串：jmdw \tIdx(16)：7 \tBit值：1100011101010100100111 - 0 \t\tIdx(32)：7\n1100011101010100010110 1100011101010100100111 111\n字符串：e4we \tIdx(16)：3 \tBit值：1011101011101101010011 - 10000 \t\tIdx(32)：19\n1011101011101101111101 1011101011101101010011 10011\n字符串：io98 \tIdx(16)：4 \tBit值：1100010110001011110100 - 10000 \t\tIdx(32)：20\n1100010110001011000101 1100010110001011110100 10100\n字符串：nmhg \tIdx(16)：13 \tBit值：1100111010011011001101 - 0 \t\tIdx(32)：13\n1100111010011011111110 1100111010011011001101 1101\n字符串：vfg6 \tIdx(16)：8 \tBit值：1101110010111101101000 - 0 \t\tIdx(32)：8\n1101110010111101011111 1101110010111101101000 1000\n字符串：gfrt \tIdx(16)：1 \tBit值：1100000101111101010001 - 10000 \t\tIdx(32)：17\n1100000101111101100001 1100000101111101010001 10001\n字符串：alpo \tIdx(16)：7 \tBit值：1011011011101101000111 - 0 \t\tIdx(32)：7\n1011011011101101101010 1011011011101101000111 111\n字符串：vfbh \tIdx(16)：1 \tBit值：1101110010111011000001 - 0 \t\tIdx(32)：1\n1101110010111011110110 1101110010111011000001 1\n字符串：bnhj \tIdx(16)：0 \tBit值：1011100011011001100000 - 0 \t\tIdx(32)：0\n1011100011011001001110 1011100011011001100000 0\n字符串：zuio \tIdx(16)：8 \tBit值：1110010011100110011000 - 10000 \t\tIdx(32)：24\n1110010011100110100001 1110010011100110011000 11000\n字符串：iu8e \tIdx(16)：8 \tBit值：1100010111100101101000 - 0 \t\tIdx(32)：8\n1100010111100101011001 1100010111100101101000 1000\n字符串：yhjk \tIdx(16)：8 \tBit值：1110001001010010101000 - 0 \t\tIdx(32)：8\n1110001001010010010000 1110001001010010101000 1000\n字符串：plop \tIdx(16)：9 \tBit值：1101001000110011101001 - 0 \t\tIdx(32)：9\n1101001000110011011101 1101001000110011101001 1001\n字符串：dd0p \tIdx(16)：14 \tBit值：1011101111001011101110 - 0 \t\tIdx(32)：14\n1011101111001011000000 1011101111001011101110 1110\n```\n\n- 这里我们随机使用一些字符串计算他们分别在16位长度和32位长度数组下的索引分配情况，看哪些数据被重新路由到了新的地址。\n- 同时，这里还可以观察🕵出一个非常重要的信息，原哈希值与扩容新增出来的长度16，进行&运算，如果值等于0，则下标位置不变。如果不为0，那么新的位置则是原来位置上加16。｛这个地方需要好好理解下，并看实验数据｝\n- 这样一来，就不需要在重新计算每一个数组中元素的哈希值了。\n\n#### 4.2 数据迁移\n\n![bugstack.cn 数据迁移](https://bugstack.cn/assets/images/2020/interview/interview-4-06.png)\n\n- 这张图就是原16位长度数组元素，像32位数组长度中转移的过程。\n- 其中黄色区域元素`zuio`因计算结果 `hash & oldCap` 不为1，则被迁移到下标位置24。\n- 同时还是用重新计算哈希值的方式验证了，确实分配到24的位置，因为这是在二进制计算中补1的过程，所以可以通过上面简化的方式确定哈希值的位置。\n\n## 四、总结\n\n- 如果你能坚持看完这部分内容，并按照文中的例子进行相应的实验验证，那么一定可以学会本章节涉及这五项知识点；`1、散列表实现`、`2、扰动函数`、`3、初始化容量`、`4、负载因子`、`5、扩容元素拆分`。\n- 对我个人来说以前也知道这部分知识，但是没有验证过，只知道概念如此，正好借着写面试手册专栏，加深学习，用数据验证理论，让知识点可以更加深入的理解。\n- 这一章节完事，下一章节继续进行HashMap的其他知识点挖掘，让懂了就是真的懂了。好了，写到这里了，感谢大家的阅读。如果某处没有描述清楚，或者有不理解的点，欢迎与我讨论交流。\n\n## 五、推荐阅读\n\n- [HashCode为什么使用31作为乘数？](https://bugstack.cn/interview/2020/08/04/%E9%9D%A2%E7%BB%8F%E6%89%8B%E5%86%8C-%E7%AC%AC2%E7%AF%87-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-HashCode%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BD%BF%E7%94%A831%E4%BD%9C%E4%B8%BA%E4%B9%98%E6%95%B0.html)\n- [面经手册 · 开篇《面试官都问我啥》](https://bugstack.cn/interview/2020/07/28/%E9%9D%A2%E7%BB%8F%E6%89%8B%E5%86%8C-%E5%BC%80%E7%AF%87-%E9%9D%A2%E8%AF%95%E5%AE%98%E9%83%BD%E9%97%AE%E6%88%91%E5%95%A5.html)\n- [工作两年简历写成这样，谁要你呀！](https://bugstack.cn/itstack-code-life/2020/04/11/工作两年简历写成这样-谁要你呀.html)\n- [讲道理，只要你是一个爱折腾的程序员，毕业找工作真的不需要再花钱培训！](https://bugstack.cn/itstack-code-life/2020/04/30/讲道理-只要你是一个爱折腾的程序员-毕业找工作真的不需要再花钱培训.html)\n- [大学四年到毕业工作5年的学习路线资源汇总](https://bugstack.cn/itstack-code-life/2020/03/31/大学四年到毕业工作5年的学习路线资源汇总.html)\n- [源码分析 | Mybatis接口没有实现类为什么可以执行增删改查](https://bugstack.cn/itstack-demo-any/2019/12/25/源码分析-Mybatis接口没有实现类为什么可以执行增删改查.html)", "user_name": "小傅哥", "description": "沉淀、分享、成长，让自己和他人都能有所收获！", "got_view_count": 48291, "category_name": "后端", "ctime": 1457483880}
{"tag_name": "Flutter", "concern_user_count": 34101, "user_id": "1926000101569870", "title": "老司机 iOS 周报 #123 | 2020-08-10", "mark_content": "老司机 iOS 周报，只为你呈现有价值的信息。\n\n你也可以为这个项目出一份力，如果发现有价值的信息、文章、工具等可以到 [Issues](https://github.com/SwiftOldDriver/iOS-Weekly/issues) 里提给我们，我们会尽快处理。记得写上推荐的理由哦。有建议和意见也欢迎到 [Issues](https://github.com/SwiftOldDriver/iOS-Weekly/issues) 提出。\n\n## WWDC20\n\n本周在周报公众号上我们推送了 4 篇 WWDC20 内参专栏内的文章，每篇都很精彩！\n\n- [App Clips 探索之旅](https://mp.weixin.qq.com/s/_Uc2EBTk26IjZzS9GmVJ-g)\n- [SwiftUI 编程指南](https://mp.weixin.qq.com/s/smQmdXF-3VkHQnUV3G8Z3w)\n- [App Clips 开发设计指北](https://mp.weixin.qq.com/s/yBBIkBdwvhJMSWsDnJJMsA)\n- [为其他商户构建 App Clips](https://mp.weixin.qq.com/s/2_pmJ0JFtAP0nbSoEj8V9g)\n\n## 文章\n\n### 🌟 🐕 [Flutter 1.20 正式发布，新特性解读](https://mp.weixin.qq.com/s/Ua-463pSzEUiwl4WZMW5bw)\n\n[@邦Ben](https://linwenbang.weibo.com)：Flutter 1.20 正式发布，带来了不少新特性，Flutter 的更新速度还是非常让人满意。\n\n- 图标字体摇树优化（即删除你未使用的图标字体，降低体积）\n- 提供 SKSL 预热功能，优化动画效果（需要设置）。\n- 优化了鼠标命中测试，提高 web 性能。\n- Dart 2.9 优化了 utf-8 解码器，在低端 ARM 设备上，英语文本的解码速度也提升至近 200%，而中文文本更是提升至 400%。\n- 支持 Android 和 iOS 自动补全功能。\n- 更新了 InteractiveViewer 组件（用于平移、缩放、拖拽以及大小调整等）。\n- 更新 Meterial Slider、RangeSlider、TimePicker 以及 DatePicker.\n- AboutDialog 用于显示所有用到的 package 的 licenses\n- pubspec.yaml 新格式，主要是指定特定平台\n- VSCode 集成 Dart DevTools（可以不打开网页了）。\n- DevTools 支持网络分析。\n- VSCode 重命名或者移动自动更新对应引用。\n- Channel 生成器（Pigeon），通过 Dart 声明，工具生成 Channel 三端通信代码。\n- 还有很多的 bugfix 以及一些新特性处理。\n\n除了性能优化之外，特别推荐关注一下 Pigeon，可以节省下不少编写 Channel 的时间。\n\n### 🌟 🐕 [Flutter 初学者必读的高级布局规则](https://mp.weixin.qq.com/s/t5R112IIQUc9SXwWeAgsoA)\n\n[@Damien](https://github.com/ZengyiMa)：本文通过 29 个示例来展示了 Flutter 高级布局规则并且总结 Flutter 布局的原理如下：\n\n1. Widget 从其父项获得自己的约束 。一个“约束”是由 4 个 double 值组成的：分别是最小和最大宽度，以及最小和最大高度。\n2. Widget 会遍历自己的 子项（Children）列表。Widget 会逐个向每个子项告知它们的约束（各个子项的约束可以是不同的），然后询问每个子项想要设置的大小。\n3. 接下来，Widget 一个个确定子项的位置（在 x 轴上确定水平位置，在 y 轴上确定垂直位置）。\n4. 最后，Widget 将其自身大小告知父项（当然这个大小也要符合原始约束）。\n\n对于 Flutter 初学者来说，这是一篇很好阐述 Flutter 布局规则的文章。\n\n### 🐢 [Verify your app’s integrity with the new App Attest API](https://developer.apple.com/news/?id=2sngpulc)\n[@anotheren](https://github.com/anotheren)：新的 App Attest API 是 [DeviceCheck](https://developer.apple.com/documentation/devicecheck) 框架的一部分，可帮助防止 iOS 14 或更高版本上的应用受到安全威胁，从而减少对服务的欺诈性使用。借助 App Attest，你可以在设备上生成特殊的加密密钥，并在服务器提供对敏感数据的访问之前，使用该密钥来验证应用程序的完整性。其核心类为 [DCAppAttestService](https://developer.apple.com/documentation/devicecheck/dcappattestservice)。Apple 提供了一个系列文章来具体讲述如何使用该新特性，包括：[建立应用程序的完整性](https://developer.apple.com/documentation/devicecheck/establishing_your_app_s_integrity)；[验证连接到服务器的应用程序](https://developer.apple.com/documentation/devicecheck/validating_apps_that_connect_to_your_server)；[评估欺诈风险](https://developer.apple.com/documentation/devicecheck/assessing_fraud_risk)；[准备使用 App Attest 服务](https://developer.apple.com/documentation/devicecheck/preparing_to_use_the_app_attest_service)。\n\n### 🐎 [Dependency Injection via Property Wrappers](https://www.kiloloco.com/articles/004-dependency-injection-via-property-wrappers/)\n\n[@四娘](https://kemchenj.github.io/)：依赖注入是一种解决高低层级抽象耦合的方式，这篇文章介绍了在 Swift 里如何简单地实现这种模式，并且使用 `@propertyWrapper` 优化它的语法：\n\n```swift\nstruct ContentView: View {\n    @Inject var dependency: MyDependency\n    \n    var body: some View {\n        Button(\"Tap Me\", action: dependency.doSomething)\n        // prints \"Next level injection 💉\" when tapped\n    }\n}\n```\n\n### 🐢 [Swiftʼs Collection Types](https://harshil.net/blog/swift-sequence-collection-array)\n\n[@JonyFang](https://github.com/JonyFang)：这篇文章基于 Sequence、Collection 和 Array 进行拓展，解释了一些重要协议的功能及其存在的原因。在深入探讨复杂结构之前引入了两项思考：\n- 1.如何设计 API 以达到最低要求？\n- 2.如何设计共享和专项的实现？\n\nSequences 和 Iterators 是构建其他协议和具体类型的基础，文中做了部分介绍。最后以 Collection、BidirectionalCollecton、RandomAccessCollection、MutableCollection、RangeReplaceableCollection 的对比分析，解释了为什么存在这些协议及他们可以实现的改进。为了进一步阅读，也可以深入了解源码，尽管 Swift 本身以 C++ 编写，但标准库大部分是使用 Swift 编写的，包括[公共 API 源代码目录](http://github.com/apple/swift/blob/master/stdlib/public/core)。可以最先从 [Sequence](http://github.com/apple/swift/blob/master/stdlib/public/core/Sequence.swift) 和 [Collection](http://github.com/apple/swift/blob/master/stdlib/public/core/Collection.swift) 类型的源代码看起。\n\n### 🐕 [MessageMock：优雅的模拟 Objective-C 方法](https://mp.weixin.qq.com/s/jm2QvYqnvFCPcRPocpj9ZQ)\n\n在代码测试中，对于一些不容易获取的对象，可以虚拟（mock）出一个对象来帮助完成测试。在 iOS 中，已经有 OCMock 这样比较有名的开源框架去解决这个问题。但是 OCMock 在使用上的问题是比较繁琐麻烦，测试一个小的功能可能在使用上也比较麻烦。本文为这种场景提供了一种新的思路，基于 `objc_msgSend` 来进行方法的“模拟”和“校验”。\n\n[项目源代码](https://github.com/indulgeIn/MessageMock)\n\n### 🐕 [Self-Sizing UITableView Cells with SwiftUI](https://noahgilmore.com/blog/swiftui-self-sizing-cells/)\n\n[@zvving](https://github.com/zvving)：在已有 UIKit 项目中如何 Hybrid 使用 SwiftUI，很多小伙伴都关心这个问题。作者尝试在一个略有复杂度的场景：自适应 UITableviewCell 中使用 SwiftUI。如何解决自适应高度，cell 复用？状态改变如何更新？作者对这些问题做了细致的探索，提供不错的实践参考。\n\n## 工具\n\n### [为啥 Flutter Hooks 没有受到太多关注和青睐？](https://mp.weixin.qq.com/s/L96a8Jc_HAzPdk4VYJ1Q3g)\n\n[@极速男孩](https://github.com/ztlyyznf001)：hooks 最早起源于 React 当中，他可以是我们在不用写类的情况下去管理我们的 state。Flutter Hooks 并不需要掌握 React ，他可以使我们方便的在多个 widget 中共享同一套代码，他为我们提供了状态管理的另一种思路。flutter_hooks 中我们即可以只是用一个函数也同样可以创建一个类去创建一个 hook 。更多的内容可以参考 pub.dev 中的[文档](https://pub.dev/packages/flutter_hooks)。\n\n## 代码\n\n### [ConfigableCollectionView](https://github.com/miku1958/ConfigableCollectionView)\n\n[@老峰](https://github.com/gesantung)：一个类似用 iOS 13 UICollectionViewDiffableDataSource + CellRegistration 配置 UICollectionView 的库, CellRegistration 封装了 DataSource 简洁 API 配置 CollectionView，DiffableDataSource 提供了高效安全数据操作 API, 对 UICollectionView 新特性感兴趣的读者可以尝试一下。\n\n>推荐人：[庄黛淳华](https://weibo.com/augcommaaugust)\n\n### [HappyCodable](https://github.com/miku1958/HappyCodable)\n\n[@EyreFree](https://github.com/EyreFree)：通过使用 SourceKittenFramework 去自动生成 Codable 代码，让人更愉悦地使用 Codable，具有以下优势：\n\n- 支持自定义某个属性的 Coding Key；\n- 支持忽略掉某些不能 Codable 的属性；\n- 支持自动合成非 RawRepresentable 的 Enum；\n- Decode 时支持多个 Coding Key 映射同一个属性；\n- 便于调试；\n- 可以使用模型的默认值；\n- 支持简单的类型转换，比如转换 0/1 到 False/True, \"123\" 到 Int 的 123 或者反过来。\n\n>推荐人：[庄黛淳华](https://weibo.com/augcommaaugust)\n\n## 内推\n\n老司机周报团队联合知识小集和 SwiftGG 翻译组收录了一份靠谱的内推职位。\n\n如果你想**找工作**，点这里：https://www.yuque.com/iosalliance/article/bhutav\n\n如果你想**招人**，点这里：https://www.yuque.com/iosalliance/article/ycyhf3\n\n当然，也欢迎你关注我们每一期的周报，我们会在每期周报底部及时更新编辑内推岗位。\n\n## 关注我们\n\n我们开通了公众号，每期发布时公众号（LSJCoding）会推送消息，欢迎关注。\n\n![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f42387938a824ecc8ace057840d56b33~tplv-k3u1fbpfcp-zoom-1.image)\n\n同时也支持了 RSS 订阅：https://github.com/SwiftOldDriver/iOS-Weekly/releases.atom 。\n\n## 说明\n\n🚧 表示需某工具，🌟 表示编辑推荐\n\n预计阅读时间：🐎 很快就能读完（1 - 10 mins）；🐕 中等 （10 - 20 mins）；🐢 慢（20+ mins）\n", "user_name": "老司机技术周报", "description": "老司机技术周报，只为你呈现有价值的信息", "got_view_count": 427217, "category_name": "iOS", "ctime": 1461266350}
{"tag_name": "JavaScript", "concern_user_count": 343215, "user_id": "1556564164747437", "title": "精读《可视化搭建思考 - 富文本搭建》", "mark_content": "## 1 引言\n\n[「可视化搭建系统」——从设计到架构，探索前端的领域和意义](https://juejin.im/post/6854573220532748302) 这篇文章主要分析了现阶段可视化搭建的几种表现形式和实现原理，并重点介绍了基于富文本的可视化搭建思路，让人耳目一新。\n\n基于富文本的可视化搭建看似很新颖，但其实早就被广泛使用了，任何一个富文本编辑器几乎都有插入表格功能，这就是一个典型插入自定义组件的场景。\n\n使用过 [语雀](https://www.yuque.com/) 的同学应该知道，这个产品的富文本编辑器可以插入各种各样自定义区块，是 “最像搭建” 的富文本编辑器。\n\n那么积木式搭建和富文本搭建存在哪些差异，除了富文本更倾向于记录静态内容外，还有哪些差异，两者是否可以结合？本文将围绕这两点进行讨论。\n\n## 2 精读\n\n还是先顺着原文谈谈对可视化搭建的理解：\n\n可视化搭建是通过可视化方式代替开发。**前端代码开发主要围绕的是 html + js + css**，那么无论是 markdown 语法，还是创建另一套模版语言亦或 JSON 构成的 DSL，**都是用一种 dsl + 组件 + css 的方式代替 html + js + css**，可视化搭建则更进一步，用 ui 代替了 dsl + 组件，**即精简为 ui 操作 + css**。\n\n可以看到，这种转换的推演过程存在一定瑕疵，因为每次转换都有部分损耗：\n\n**用 dsl + 组件 代替 html + js。**\n\n如果 dsl 拓展得足够好，理论上可以达到 html 的水平，尤其在垂直业务场景是不需要那么多特殊 html 标签的。\n\n但用组件代替 js 就有点奇怪了，首先并不是所有 js 逻辑都沉淀在组件里，一定有组件间的联动逻辑是无法通过一个组件 js 完成的，另一方面如果将 js 逻辑寄托在组件代码里，本质上是没有提效的，用源码开发项目与开发搭建平台的组件都是 pro code，更极端一点来说，无论是组件间联动还是整个应用都可以用一个组件来写，那搭建平台就无事可做了，这个组件也成了整个应用，game over。\n\n为了弥补这块缺憾，低代码能力的呼声越来越高，而低代码能力的核心在于设计是否合理，比如暴露哪些 API 可以覆盖大部分需求？写多少代码合适，如何以最小 API 透出最大弥补组件间缺失的 js 能力？目前来看，以状态数据驱动的低代码是相对优雅的。\n\n**用 ui 操作 代替 dsl + 组件。**\n\nUI 操作并不是标准的，相比直接操作模版或者 JSON DSL，UI 化后就仁者见仁智者见智了，但 UI 化带来的效率提升是巨大的，因为所见即所得是生产力的源泉，从直观的 UI 布局来看，就比维护代码更轻松。但 UI 化也存在两个问题，一个是可能有人觉得不如 markdown 效率高，另一个是功能有丢失。\n\n对于第一点 UI 操作效率不如 markdown 高，可能很多程序员都崇尚用 markdown 维护文档而不是富文本，原因是觉得程序员维护代码的效率反而比所见即所得高，但那可能是错觉，原因是还没有遇到好用的富文本编辑器，体验过语雀富文本编辑器后，相信大部分程序员都不会再想回头写 markdown。当然语雀富文本战胜 markdown 的原因有很多，我觉得主要两点是吸收并兼容了 markdown 操作习惯，与支持了更多仅 UI 能做到的拓展能力，对 markdown 形成降维打击。\n\n第二点功能丢失很好理解，markdown 有一套标准语法和解析器可以验证，但 UI 操作并没有标准化，也没有独立验证系统，如果无法回退到源码模式，UI 没有实现的功能就做不到。\n\n回到富文本搭建上，其实富文本搭建和普通网页构建并没有本质区别。html 是超文本标记语言，富文本是跨平台文档格式，从逻辑上这两个格式是可以互转的，只要富文本规则作出足够多的拓展，就可以大致覆盖 html 的能力。\n\n但富文本搭建有着显著的特征，就是光标。\n\n### 积木式搭建和富文本搭建的区别\n\n富文本以文本为中心，因此编辑文字的光标会常驻，编辑的核心逻辑是排版文字，并考虑如何在文字周围添加一些自定义区块。\n\n有了光标后，圈选也非常重要，因为大家编辑文字时有一种很自然的想法是，任何文字圈选后复制，可以粘贴到任何地方，那么所有插入到富文本中的自定义组件也要支持被圈选，被复制。\n\n实际上富文本内插入自定义区块也可以转换为积木式搭建方案解决，比如下面的场景：\n\n```text\n文本 A\n图表 B\n文本 C\n```\n\n我们在文本 A 与 文本 C 之间插入图表 B，也可以理解为拖拽了三个组件：文本组件 A + 图表组件 B + 文本组件 C，然后分别编辑这三个组件，微调样式后可以达到与富文本一样的编辑效果，甚至加上自由布局后，在布局能力上会超越富文本。\n\n虽然功能层面上富文本略有输给积木式搭建，但富文本在编辑体验上是胜出的，对于文字较多的场景，我们还是会选择富文本方式编辑而不是积木式搭建拖拽 N 个文本组件。\n\n所以微软 OneNote 也吸取了这个经验，毕竟笔记本主要还是记录文字，因此还是采用富文本的编辑模式，但创造性的加入了一个个独立区块，点击任何区域都会创造一个区块，整个文档可以由一个区块构成，也可以是多个区块组合而成，这样对于连贯性的文字场景可以采用一个富文本区块，对于自定义区块较多，比如大部分是图片和表格的，还可以回到积木式搭建的体验。由于 OneNote 采用绝对定位模拟流式布局的思路，当区块重叠时还可以自动挤压底部区块，因此多区块模式下编辑体验还是相对顺畅的。\n\n可以看出来这是一种结合的尝试，从前端角度来看，富文本本质上是对一个 div 进行 contenteditable 申明，那么一个应用可以整体是 contenteditable 的，也可以局部几个区块是，这种代码层面的自由度体现在搭建上就是积木式搭建可以与富文本搭建自由结合。\n\n### 积木式搭建与富文本搭建如何结合\n\n对于积木式搭建来说，富文本只是其中一个组件，在不考虑有富文本组件时是完全没有富文本能力的。比如一个搭建平台只提供了几个图表和基础控件，你是不可能在其基础上使用富文本能力的，甚至连写静态文本都做不到。\n\n所以富文本只是搭建中一个组件，就像 contenteditable 也只能依附于一个标签，整个网页还是由标签组成的。但对于一个提供了富文本组件的积木式搭建系统来说，文字与控件混排又是一个痛点，毕竟要以一个个区块组件的方式去拖拽文本节点，成本比富文本模式大得多。\n\n所以理想情况是富文本与整个搭建系统使用同一套 DSL 描述结构，富文本只是在布局上有所简化，简化为简单的平铺模式即可，但因为 DSL 描述打通，富文本也可以描述使用搭建提供的任意组件嵌套在内，所以只要用户愿意，可以将富文本组件拉到最大，整个页面都基于富文本模式去搭建，这就变成了富文本搭建，也可以将富文本缩小，将普通控件以积木方式拖拽到画布中，走积木式搭建路线。\n\n用代码方式描述积木式搭建：\n\n```html\n<bar-chart />\n<div>\n  <p>header</p>\n  <line-chart />\n  <p>footer</p>\n</div>\n```\n\n上述模式需要拖拽 `bar-chart`、`div`、`p`、`line-chart`、`p` 共 5 个组件。富文本模式则类似下面的结构：\n\n```html\n<bar-chart />\n<div contenteditable>\n  <p>header</p>\n  <line-chart />\n  <p>footer</p>\n</div>\n```\n\n只要拖拽 `bar-chart`、`div` 两个组件即可，`div` 内部的文字通过光标输入，`line-chart` 通过富文本某个按钮或者键盘快捷键添加。\n\n可以看到虽然操作方式不同，但本质上描述协议并没有本质区别，我们理论上可以将任何容器标签切换为富文本模式。\n\n## 3 总结\n\n富文本是一种重要的交互模式，可以基于富文本模式做搭建，也可以在搭建系统中嵌入富文本组件，甚至还可以追求搭建与富文本的结合。\n\n富文本组件既可以是搭建系统中一个组件，又可以在内部承载搭建系统的所有组件，做到这一步才算是真正发挥出富文本的潜力。\n\n> 讨论地址是：[精读《可视化搭建思考 - 富文本搭建》· Issue #262 · dt-fe/weekly](https://github.com/dt-fe/weekly/issues/262)\n\n**如果你想参与讨论，请 [点击这里](https://github.com/dt-fe/weekly)，每周都有新的主题，周末或周一发布。前端精读 - 帮你筛选靠谱的内容。**\n\n> 关注 **前端精读微信公众号**\n\n<img width=200 src=\"https://img.alicdn.com/tfs/TB165W0MCzqK1RjSZFLXXcn2XXa-258-258.jpg\">\n\n> 版权声明：自由转载-非商用-非衍生-保持署名（[创意共享 3.0 许可证](https://creativecommons.org/licenses/by-nc-nd/3.0/deed.zh)）\n", "user_name": "黄子毅", "description": "热爱编程", "got_view_count": 361719, "category_name": "前端", "ctime": 1457483942}
{"tag_name": "Android", "concern_user_count": 240175, "user_id": "1978776659695784", "title": "倒计时方案深入分析", "mark_content": "# 倒计时方案深入分析\n#### 目录介绍\n- 01.使用多种方式实现倒计时\n- 02.各种倒计时器分析\n- 03.CountDownTimer解读\n- 04.Timer和TimerTask解读\n- 05.自定义倒计时器案例\n\n\n\n\n### 01.使用多种方式实现倒计时\n- 首先看一下需求\n    - 要求可以创建多个倒计时器，可以暂停，以及恢复暂停。可以自由设置倒计时器总时间，倒计时间隔。下面会一步步实现一个多功能倒计时器。\n- 01.使用Handler实现倒计时\n    - mHandler + runnable ，这种是最常见的一种方式。实质是不断调用mHandler.postDelayed(this, 1000)达到定时周期目的\n- 02.使用CountDownTimer实现倒计时\n    - 也是利用mHandler + runnable，在此基础上简单封装一下。使用场景更强大，比如一个页面有多个倒计时器，用这个就很方便……\n- 03.利用Timer实现定时器\n    - 使用Timer + TimerTask + handler方式实现倒计时\n- 04.使用chronometer控件倒计时\n    - 新出的继承TextView组件，里头是使用了View.postDelayed + runnable实现倒计时\n- 05.利用动画实现倒计时\n    - 这种方式用的比较少，但也是一种思路。主要是设置动画时间，在onAnimationUpdate监听设置倒计时处理\n- 具体代码案例可以看\n    - [6种实现倒计时器的代码案例](https://github.com/yangchong211/YCTimer/blob/master/read/01.%E5%80%92%E8%AE%A1%E6%97%B6%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F.md)\n- 具体代码案例\n    - [6种实现倒计时器方案](https://github.com/yangchong211/YCTimer)\n\n\n\n### 02.各种倒计时器分析\n- 第一种利用Handler实现倒计时\n    - 这种用的很普遍，但存在一个问题。如果是一个页面需要开启多个倒计时【比如列表页面】，则比较难处理。\n- 第二种使用CountDownTimer实现倒计时\n    - new CountDownTimer(5000, 1000).start()\n        - 期待的效果是：“5-4-3-2-1-finish”或者“5-4-3-2-1-0”。这里，显示 0 和 finish 的时间应该是一致的，所以把 0 放在 onFinish() 里显示也可以。但实际有误差……\n    - 存在的几个问题\n        - 问题1. 每次 onTick() 都会有几毫秒的误差，并不是期待的准确的 \"5000, 4000, 3000, 2000, 1000, 0\"。\n        - 问题2. 多运行几次，就会发现这几毫秒的误差，导致了计算得出的剩余秒数并不准确，如果你的倒计时需要显示剩余秒数，就会发生 秒数跳跃/缺失 的情况（比如一开始从“4”开始显示——缺少“5”，或者直接从“5”跳到了“3”——缺少“4”）。\n        - 问题3. 最后一次 onTick() 到 onFinish() 的间隔通常超过了 1 秒，差不多是 2 秒左右。如果你的倒计时在显示秒数，就能很明显的感觉到最后 1 秒停顿的时间很长。\n        - 问题4. 如果onTick耗时超时，比如超过了1000毫秒，则会导致出现onTick出现跳动问题\n    - 解决方案\n        - 具体看lib中的CountDownTimer类。下面也会分析到\n        - 注意：onTick方法中如何执行耗时操作【大于1秒的执行代码】，建议使用handler消息机制进行处理，避免出现其他问题。\n- 第三种利用Timer实现定时器\n    - 注意点\n        - Timer和TimerTask都有cancel方法，而且最好同时调用；如果已经cancel，下次必须创建新的Timer才能schedule。\n    - 可能存在的问题\n        - 如果你在当前的activity中schedule了一个task，但是没有等到task结束，就按Back键finish了当前的activity，Timer和TimerTask并不会自动cancel或者销毁，它还会在后台运行，此时如果你在task的某个阶段要调起一个控件（比如AlertDialog），而该控制依赖被销毁的activity，那么将会引发crash。\n        - 所以建议在页面销毁的时候，将Timer和TimerTask都有cancel结束并且设置成null\n        - Timer 的方式实现定时任务，用来做倒计时是没有问题的。但是如果用来执行周期任务，恰好又有多个任务，恰好两个任务之间的时间间隔又比前一个任务执行时间短就会发生定时不准确的现象了。Timer 在执行过程中如果任务跑出了异常，Timer 会停止所有的任务。Timer 执行周期任务时依赖系统时间，系统时间的变化会引起 Timer 任务执行的变化。\n\n\n### 03.CountDownTimer解读\n#### 03.1 来看一个问题\n- 先看案例代码，如下所示\n    - 期待的效果是：“5-4-3-2-1-finish”或者“5-4-3-2-1-0”。这里，显示 0 和 finish 的时间应该是一致的，所以把 0 放在 onFinish() 里显示也可以。\n    ```\n    mCountDownTimer = new CountDownTimer(5000, 1000) {\n        @Override\n        public void onTick(long millisUntilFinished) {\n            Log.i(TAG, \"----倒计时----onTick--\"+millisUntilFinished);\n        }\n\n        public void onFinish() {\n            Log.i(TAG, \"----倒计时----onFinish\");\n        }\n    };\n    ```\n- 然后看一下打印日志，如下所示\n    ```\n    2020-08-05 10:04:28.742 17266-17266/com.yc.yctimer I/CountDownTimer: ----倒计时----onTick--5000\n    2020-08-05 10:04:29.744 17266-17266/com.yc.yctimer I/CountDownTimer: ----倒计时----onTick--3998\n    2020-08-05 10:04:30.746 17266-17266/com.yc.yctimer I/CountDownTimer: ----倒计时----onTick--2997\n    2020-08-05 10:04:31.746 17266-17266/com.yc.yctimer I/CountDownTimer: ----倒计时----onTick--1996\n    2020-08-05 10:04:32.747 17266-17266/com.yc.yctimer I/CountDownTimer: ----倒计时----onTick--995\n    2020-08-05 10:04:33.747 17266-17266/com.yc.yctimer I/CountDownTimer: ----倒计时----onFinish\n    2020-08-05 10:04:45.397 17266-17266/com.yc.yctimer I/CountDownTimer: ----倒计时----onTick--4999\n    2020-08-05 10:04:46.398 17266-17266/com.yc.yctimer I/CountDownTimer: ----倒计时----onTick--3998\n    2020-08-05 10:04:47.400 17266-17266/com.yc.yctimer I/CountDownTimer: ----倒计时----onTick--2996\n    2020-08-05 10:04:48.402 17266-17266/com.yc.yctimer I/CountDownTimer: ----倒计时----onTick--1994\n    2020-08-05 10:04:49.405 17266-17266/com.yc.yctimer I/CountDownTimer: ----倒计时----onTick--992\n    2020-08-05 10:04:50.401 17266-17266/com.yc.yctimer I/CountDownTimer: ----倒计时----onFinish\n    ```\n- 可以看到有几个问题：\n    - 问题1. 每次 onTick() 都会有几毫秒的误差，并不是期待的准确的 \"5000, 4000, 3000, 2000, 1000, 0\"。\n    - 问题2. 多运行几次，就会发现这几毫秒的误差，导致了计算得出的剩余秒数并不准确，如果你的倒计时需要显示剩余秒数，就会发生 秒数跳跃/缺失 的情况（比如一开始从“4”开始显示——缺少“5”，或者直接从“5”跳到了“3”——缺少“4”）。\n    - 问题3. 最后一次 onTick() 到 onFinish() 的间隔通常超过了 1 秒，差不多是 2 秒左右。如果你的倒计时在显示秒数，就能很明显的感觉到最后 1 秒停顿的时间很长。\n\n\n#### 03.3 分析时间误差\n- 为什么会存在这个问题\n    - 先看start()方法，计算的 mStopTimeInFuture（未来停止倒计时的时刻，即倒计时结束时间） 加了一个 SystemClock.elapsedRealtime() ，系统自开机以来（包括睡眠时间）的毫秒数，也可以叫“系统时间戳”。\n    - 即倒计时结束时间为“当前系统时间戳 + 你设置的倒计时时长 mMillisInFuture ”，也就是计算出的相对于手机系统开机以来的一个时间。在下面代码中打印日志看看\n    ```\n    public synchronized final void start() {\n        if (mMillisInFuture <= 0 && mCountdownInterval <= 0) {\n            throw new RuntimeException(\"you must set the millisInFuture > 0 or countdownInterval >0\");\n        }\n        mCancelled = false;\n        long elapsedRealtime = SystemClock.elapsedRealtime();\n        mStopTimeInFuture = elapsedRealtime + mMillisInFuture;\n        CountTimeTools.i(\"start → mMillisInFuture = \" + mMillisInFuture + \", seconds = \" + mMillisInFuture / 1000 );\n        CountTimeTools.i(\"start → elapsedRealtime = \" + elapsedRealtime + \", → mStopTimeInFuture = \" + mStopTimeInFuture);\n        mPause = false;\n        mHandler.sendMessage(mHandler.obtainMessage(MSG));\n        if (mCountDownListener!=null){\n            mCountDownListener.onStart();\n        }\n    }\n\n    @SuppressLint(\"HandlerLeak\")\n    private Handler mHandler = new Handler() {\n        @Override\n        public void handleMessage(@NonNull Message msg) {\n            synchronized (CountDownTimer.this) {\n                if (mCancelled) {\n                    return;\n                }\n                //剩余毫秒数\n                final long millisLeft = mStopTimeInFuture - SystemClock.elapsedRealtime();\n                if (millisLeft <= 0) {\n                    mCurrentMillisLeft = 0;\n                    if (mCountDownListener != null) {\n                        mCountDownListener.onFinish();\n                        CountTimeTools.i(\"onFinish → millisLeft = \" + millisLeft);\n                    }\n                } else if (millisLeft < mCountdownInterval) {\n                    mCurrentMillisLeft = 0;\n                    CountTimeTools.i(\"handleMessage → millisLeft < mCountdownInterval !\");\n                    // 剩余时间小于一次时间间隔的时候，不再通知，只是延迟一下\n                    sendMessageDelayed(obtainMessage(MSG), millisLeft);\n                } else {\n                    //有多余的时间\n                    long lastTickStart = SystemClock.elapsedRealtime();\n                    CountTimeTools.i(\"before onTick → lastTickStart = \" + lastTickStart);\n                    CountTimeTools.i(\"before onTick → millisLeft = \" + millisLeft + \", seconds = \" + millisLeft / 1000 );\n                    if (mCountDownListener != null) {\n                        mCountDownListener.onTick(millisLeft);\n                        CountTimeTools.i(\"after onTick → elapsedRealtime = \" + SystemClock.elapsedRealtime());\n                    }\n                    mCurrentMillisLeft = millisLeft;\n                    // 考虑用户的onTick需要花费时间,处理用户onTick执行的时间\n                    long delay = lastTickStart + mCountdownInterval - SystemClock.elapsedRealtime();\n                    CountTimeTools.i(\"after onTick → delay1 = \" + delay);\n                    // 特殊情况：用户的onTick方法花费的时间比interval长，那么直接跳转到下一次interval\n                    // 注意，在onTick回调的方法中，不要做些耗时的操作\n                    boolean isWhile = false;\n                    while (delay < 0){\n                        delay += mCountdownInterval;\n                        isWhile = true;\n                    }\n                    if (isWhile){\n                        CountTimeTools.i(\"after onTick执行超时 → delay2 = \" + delay);\n                    }\n                    sendMessageDelayed(obtainMessage(MSG), delay);\n                }\n            }\n        }\n    };\n    ```\n- 然后看一下日志\n    ```\n    2020-08-05 13:36:02.475 8742-8742/com.yc.yctimer I/CountDownTimer: start → mMillisInFuture = 5000, seconds = 5\n    2020-08-05 13:36:02.475 8742-8742/com.yc.yctimer I/CountDownTimer: start → elapsedRealtime = 122669630, → mStopTimeInFuture = 122674630\n    2020-08-05 13:36:02.478 8742-8742/com.yc.yctimer I/CountDownTimer: before onTick → lastTickStart = 122669634\n    2020-08-05 13:36:02.478 8742-8742/com.yc.yctimer I/CountDownTimer: before onTick → millisLeft = 4996, seconds = 4\n    2020-08-05 13:36:02.479 8742-8742/com.yc.yctimer I/CountDownTimer: after onTick → elapsedRealtime = 122669635\n    2020-08-05 13:36:02.479 8742-8742/com.yc.yctimer I/CountDownTimer: after onTick → delay1 = 999\n    2020-08-05 13:36:03.480 8742-8742/com.yc.yctimer I/CountDownTimer: before onTick → lastTickStart = 122670636\n    2020-08-05 13:36:03.480 8742-8742/com.yc.yctimer I/CountDownTimer: before onTick → millisLeft = 3994, seconds = 3\n    2020-08-05 13:36:03.483 8742-8742/com.yc.yctimer I/CountDownTimer: after onTick → elapsedRealtime = 122670639\n    2020-08-05 13:36:03.484 8742-8742/com.yc.yctimer I/CountDownTimer: after onTick → delay1 = 996\n    2020-08-05 13:36:04.482 8742-8742/com.yc.yctimer I/CountDownTimer: before onTick → lastTickStart = 122671638\n    2020-08-05 13:36:04.483 8742-8742/com.yc.yctimer I/CountDownTimer: before onTick → millisLeft = 2992, seconds = 2\n    2020-08-05 13:36:04.486 8742-8742/com.yc.yctimer I/CountDownTimer: after onTick → elapsedRealtime = 122671642\n    2020-08-05 13:36:04.486 8742-8742/com.yc.yctimer I/CountDownTimer: after onTick → delay1 = 996\n    2020-08-05 13:36:05.485 8742-8742/com.yc.yctimer I/CountDownTimer: before onTick → lastTickStart = 122672641\n    2020-08-05 13:36:05.485 8742-8742/com.yc.yctimer I/CountDownTimer: before onTick → millisLeft = 1989, seconds = 1\n    2020-08-05 13:36:05.488 8742-8742/com.yc.yctimer I/CountDownTimer: after onTick → elapsedRealtime = 122672644\n    2020-08-05 13:36:05.488 8742-8742/com.yc.yctimer I/CountDownTimer: after onTick → delay1 = 997\n    2020-08-05 13:36:06.487 8742-8742/com.yc.yctimer I/CountDownTimer: handleMessage → millisLeft < mCountdownInterval !\n    2020-08-05 13:36:07.481 8742-8742/com.yc.yctimer I/CountDownTimer: onFinish → millisLeft = -3\n    ```\n- 分析一下日志\n    - 倒计时 5 秒，而 onTick() 一共只执行了 4 次。分别是出现4，3，2，1\n    - start() 启动计时时，mMillisInFuture = 5000。且根据当前系统时间戳（记为 elapsedRealtime0 = 122669630，开始 start() 倒计时时的系统时间戳）计算了倒计时结束时相对于系统开机时的时间点 mStopTimeInFuture。\n    - 此后到第一次进入 handleMessage() 时，中间经历了很短的时间 122669630 - 122669634 = 6 毫秒。\n    - handleMessage() 这里精确计算了程序执行时间，虽然是第一次进入 handleMessage，也没有直接使用 mStopTimeInFuture，而是根据程序执行到此处时的 elapsedRealtime() （记为 elapsedRealtime1）来计算此时剩余的倒计时时长。\n    - millisLeft = 4996，进入 else，执行 onTick()方法回调。所以第一次 onTick() 时，millisLeft = 4996，导致计算的剩余秒数是“4996/1000 = 4”，所以倒计时显示秒数是从“4”开始，而不是“5”开始。这便是前面提到的 问题1 和 问题2。\n    - 考虑用户的onTick需要花费时间，处理用户onTick执行的时间，于是便发出一个延迟delay时间的消息sendMessageDelayed(obtainMessage(MSG), delay);在日志里看到delay1 = 997\n\n\n### 03.3 onTick耗时超时\n- 上面分析到了用户的onTick需要花费时间，如果delay < 0则需要特殊处理，这个究竟是什么意思呢？下面来分析一下\n- 分析一下下面这个while循环作用\n    ```\n    // 考虑用户的onTick需要花费时间,处理用户onTick执行的时间\n    long delay = lastTickStart + mCountdownInterval - SystemClock.elapsedRealtime();\n    CountTimeTools.i(\"after onTick → delay1 = \" + delay);\n    // 特殊情况：用户的onTick方法花费的时间比interval长，那么直接跳转到下一次interval\n    while (delay < 0){\n        delay += mCountdownInterval;\n    }\n    CountTimeTools.i(\"after onTick → delay2 = \" + delay);\n    sendMessageDelayed(obtainMessage(MSG), delay);\n    ```\n    - 如果这次 onTick() 执行时间太长，超过了 mCountdownInterval ，那么执行完 onTick() 后计算得到的 delay 是一个负数，此时直接跳到下一次 mCountdownInterval 间隔，让 delay + mCountdownInterval。\n- 举一个例子来说一下，不然这里不太好理解\n    - 假如设定每 1000 毫秒执行一次 onTick()。假设第一次 onTick() 开始前时的相对于手机系统开机时间的剩余倒计时时长是 5000 毫秒， 执行完这次 onTick() 操作消耗了 1015 毫秒，超出了我们设定的 1000 毫秒的间隔，那么第一次计算的 delay = 1000 - 1015 = -15 < 0，那么负数意味着什么呢？\n    - 本来我们设定的 onTick() 调用间隔是 1000 毫秒，可是它执行完一次却用了 1015 毫秒，现在剩余倒计时还剩下 5000 - 1015 = 3985 毫秒，本来第二次 onTick() 按期望应该是在 4000 毫秒时开始执行的，可是此时第一次的 onTick() 却还未执行完。所以第二次 onTick() 就会被延迟 delay = -15 + 1000 = 985 毫秒，也就是到剩余 3000 毫秒时再执行了。\n    - 那么此时就会 3985 / 1000 = 3，就会从5过度到3；依次类推，后续的delay延迟985毫秒后执行sendMessageDelayed，会导致时间出现跳跃性变动。具体可以看一下下面的例子……\n- onTick()做耗时操作会出现什么情况\n    - 比如下面，看打印日志可知：4，2没有，这就意味着这个阶段没有执行到onTick()方法，而如果你在这个里有业务逻辑与时间节点有关，则可能会出现bug\n    ```\n    2020-08-05 13:58:00.657 11912-11912/com.yc.yctimer I/CountDownTimer: start → mMillisInFuture = 5000, seconds = 5\n    2020-08-05 13:58:00.657 11912-11912/com.yc.yctimer I/CountDownTimer: start → elapsedRealtime = 123987813, → mStopTimeInFuture = 123992813\n    2020-08-05 13:58:01.781 11912-11912/com.yc.yctimer I/CountDownTimer: before onTick → lastTickStart = 123988937\n    2020-08-05 13:58:01.781 11912-11912/com.yc.yctimer I/CountDownTimer: before onTick → millisLeft = 3876, seconds = 3\n    2020-08-05 13:58:02.858 11912-11912/com.yc.yctimer I/CountDownTimer: after onTick → elapsedRealtime = 123990014\n    2020-08-05 13:58:02.858 11912-11912/com.yc.yctimer I/CountDownTimer: after onTick → delay1 = -77\n    2020-08-05 13:58:02.858 11912-11912/com.yc.yctimer I/CountDownTimer: after onTick执行超时 → delay2 = 923\n    2020-08-05 13:58:03.784 11912-11912/com.yc.yctimer I/CountDownTimer: before onTick → lastTickStart = 123990940\n    2020-08-05 13:58:03.784 11912-11912/com.yc.yctimer I/CountDownTimer: before onTick → millisLeft = 1873, seconds = 1\n    2020-08-05 13:58:04.896 11912-11912/com.yc.yctimer I/CountDownTimer: after onTick → elapsedRealtime = 123992052\n    2020-08-05 13:58:04.896 11912-11912/com.yc.yctimer I/CountDownTimer: after onTick → delay1 = -112\n    2020-08-05 13:58:04.896 11912-11912/com.yc.yctimer I/CountDownTimer: after onTick执行超时 → delay2 = 888\n    2020-08-05 13:58:05.788 11912-11912/com.yc.yctimer I/CountDownTimer: onFinish → millisLeft = -130\n    ```\n- onTick方法中如何执行耗时操作【大于1秒的执行代码】\n    - 建议使用handler消息机制进行处理，避免出现其他问题。\n\n\n#### 03.4 代码改进完善\n- 针对 问题1 和 问题 2：\n    - 问题描述\n        - 问题1. 每次 onTick() 都会有几毫秒的误差，并不是期待的准确的 \"5000, 4000, 3000, 2000, 1000, 0\"。\n        - 问题2. 多运行几次，就会发现这几毫秒的误差，导致了计算得出的剩余秒数并不准确，如果你的倒计时需要显示剩余秒数，就会发生 秒数跳跃/缺失 的情况（比如一开始从“4”开始显示——缺少“5”，或者直接从“5”跳到了“3”——缺少“4”）。\n    - 解决方案\n        - 这2个问题可以放在一起处理，网上也有很多人对这里做了改进，那就是给我们的 倒计时时长扩大一点点，通常是手动将 mMillisInFuture 扩大几十毫秒\n    - 效果\n        - 这里多加了 20 毫秒，运行一下（举个栗子）。倒计时打印日志：“5，4，3，2，1，finish”，\n\n\n\n### 04.Timer和TimerTask解读\n#### 04.1 Timer和TimerTask方法\n- Timer核心方法如下所示\n    ```java\n    //安排指定任务在指定时间执行。如果时间在过去，任务被安排立即执行。\n    void schedule(TimerTask task, long delay)\n    //将指定的任务调度为重复执行<i>固定延迟执行</i>，从指定的延迟开始。后续执行大约按按指定周期间隔的规则间隔进行。\n    void schedule(TimerTask task, long delay, long period)\n    ```\n    - 第一个方法只执行一次；\n    - 第二个方式每隔period执行一次，delay表示每次执行的延时时间，其实主要表现在第一次的延时效果，比如delay设置为0，那么立马执行task内容，如果设置为1000，那么第一次执行task会有一秒的延时效果。\n- TimerTask核心方法\n    - TimerTask用于继承（或者直接定义并初始化匿名类），并重写run方法，定义自己的业务逻辑。\n    ```java\n    //取消此计时器任务。如果任务被计划为一次性执行而尚未运行，或尚未被计划，则它将永远不会运行。\n    //如果任务被安排为重复执行，它将永远不会再运行。(如果在此调用发生时任务正在运行，则任务将运行到完成，但将不再运行。)\n    public boolean cancel() {\n        synchronized(lock) {\n            boolean result = (state == SCHEDULED);\n            state = CANCELLED;\n            return result;\n        }\n    }\n    ```\n- 关于结束定时器\n    - Timer和TimerTask都有cancel方法，而且最好同时调用；如果已经cancel，下次必须创建新的Timer才能schedule。\n    ```java\n    public void destroyTimer() {\n        if (mTimer != null) {\n            mTimer.cancel();\n            mTimer = null;\n        }\n        if (mTimerTask != null) {\n            mTimerTask.cancel();\n            mTimerTask = null;\n        }\n    }\n    ```\n- 可能存在的问题\n    - 如果你在当前的activity中schedule了一个task，但是没有等到task结束，就按Back键finish了当前的activity，Timer和TimerTask并不会自动cancel或者销毁，它还会在后台运行，此时如果你在task的某个阶段要调起一个控件（比如AlertDialog），而该控制依赖被销毁的activity，那么将会引发crash。\n    - 所以建议在页面销毁的时候，将Timer和TimerTask都有cancel结束并且设置成null\n    - Timer 的方式实现定时任务，用来做倒计时是没有问题的。但是如果用来执行周期任务，恰好又有多个任务，恰好两个任务之间的时间间隔又比前一个任务执行时间短就会发生定时不准确的现象了。Timer 在执行过程中如果任务跑出了异常，Timer 会停止所有的任务。Timer 执行周期任务时依赖系统时间，系统时间的变化会引起 Timer 任务执行的变化。\n\n\n\n### 04.2 Timer原理分析\n- 其基本处理模型是单线程调度的任务队列模型，Timer不停地接受调度任务，所有任务接受Timer调度后加入TaskQueue,TimerThread不停地去TaskQueue中取任务来执行。\n    - [image](https://github.com/yangchong211/YCTimer/blob/master/read/timer.png)\n- 此种方式的不足之处为当某个任务执行时间较长，以致于超过了TaskQueue中下一个任务开始执行的时间，会影响整个任务执行的实时性。为了提高实时性，可以采用多个消费者一起消费来提高处理效率，避免此类问题的实现。\n\n\n### 04.3 TimerTask分析\n- 源代码如下所示\n    - 可以发现TimerTask是实现Runnable接口的一个抽象类。如果直接继承该类并且实现该类的run() 方法就可以了，里面包含这种对应的状态。\n    ```java\n    public abstract class TimerTask implements Runnable {\n        final Object lock = new Object();\n        int state = VIRGIN;\n        //表示尚未计划此任务（也表示初始状态）\n        static final int VIRGIN = 0;\n        //表示正在执行任务状态\n        static final int SCHEDULED   = 1;\n        //表示执行完成状态\n        static final int EXECUTED    = 2;\n        //取消状态\n        static final int CANCELLED   = 3;\n        //下次执行任务的时间\n        long nextExecutionTime;\n        //执行时间间隔\n        long period = 0;\n        //子类需要实现该方法，执行的任务的代码在该方法中实现\n        public abstract void run();\n        //取消任务，从这里我们可以很清楚知道取消任务就是修改状态\n        public boolean cancel() {\n            synchronized(lock) {\n                boolean result = (state == SCHEDULED);\n                state = CANCELLED;\n                return result;\n            }\n        }\n    }\n    ```\n\n\n### 04.4 Timer源码分析\n- Timer才是真正的核心，在创建Timer对象的同时也创建一个TimerThread对象，该类集成Thread，本质上就是开启了一个线程。\n    ```java\n    public class Timer {\n        //创建一个任务队列\n        private final TaskQueue queue = new TaskQueue();\n        //创建一个Thread线程对象，并且将queue队列传进去\n        private final TimerThread thread = new TimerThread(queue);\n        public Timer() {\n            this(\"Timer-\" + serialNumber());\n        }\n\n        public Timer(boolean isDaemon) {\n            this(\"Timer-\" + serialNumber(), isDaemon);\n        }\n\n        public Timer(String name) {\n            thread.setName(name);\n            thread.start();\n        }\n\n        public Timer(String name, boolean isDaemon) {\n            thread.setName(name);\n            thread.setDaemon(isDaemon);\n            thread.start();\n        }\n    }\n    ```\n- 然后看一下TimerThread线程的源码，如下所示\n    - 首先看run方法中的mainLoop()，开启一个不断循环的线程如果队列中不存在任务则阻塞当前的线程，直到队列中添加任务以后唤醒线程。\n    - 然后获取队列中执行时间最小的任务，如果该任务的状态是取消的话则从队列中移除掉再从队列中重新获取。\n    - 最后判断当前的时间是否大于等于任务的执行的时间，如果任务的执行时间还未到则当前线程再阻塞一段时间，同时我们还要将该任务重新扔到任务队列中重新排序，我们必须保证队列中的第一个任务的执行时间是最小的。\n    - 执行完mainLoop()方法完后，接着就将newTasksMayBeScheduled设置为false，并且清空队列中所有的任务。\n    - 思考一下，这里的最小任务是什么意思？先把这个疑问记着……\n    ```java\n    class TimerThread extends Thread {\n        boolean newTasksMayBeScheduled = true;\n        private TaskQueue queue;\n\n        TimerThread(TaskQueue queue) {\n            this.queue = queue;\n        }\n\n        public void run() {\n            try {\n                mainLoop();\n            } finally {\n                synchronized(queue) {\n                //同时将状态置为false\n                newTasksMayBeScheduled = false;\n                //清空队列中所有的任务\n                queue.clear();\n            }\n        }\n\n        private void mainLoop() {\n            //while死循环\n            while (true) {\n                try {\n                    TimerTask task;\n                    boolean taskFired;\n                    synchronized(queue) {\n                        //如果任务队列为空并且该标志位 true的话，则该线程一直进行等待中，直到队列中有任务进来的时候执行 queue.notify才会解除阻塞\n                        while (queue.isEmpty() && newTasksMayBeScheduled)\n                            queue.wait();\n                        //如果队列中的内容为空的话直接跳出循环，外部调用者可能取消了Timer\n                        if (queue.isEmpty())\n                            break;\n                        long currentTime, executionTime;\n                        //获取队列中最近执行时间最小的任务（也就是最近需要执行的任务）\n                        task = queue.getMin();\n                        synchronized(task.lock) {\n                            //如果该任务的状态是取消状态的话，那从队列中移除这个任务，然后继续执行循环队列操作\n                            if (task.state == TimerTask.CANCELLED) {\n                                queue.removeMin();\n                                continue;\n                            }\n                            //获取当前系统时间\n                            currentTime = System.currentTimeMillis();\n                            //获取下一个目标要执行的时间\n                            executionTime = task.nextExecutionTime;\n                            //如果下一个目标要执行的时间大于等于等于时间了，表示要执行任务了\n                            if (taskFired = (executionTime<=currentTime)) {\n                                //如果task的时间间隔为0，表示只执行一次该任务\n                                if (task.period == 0) {\n                                    //将任务状态改为已执行状态，同时从队列中删除该任务\n                                    queue.removeMin();\n                                    task.state = TimerTask.EXECUTED;\n                                } else {\n                                    //将任务重新跟队列中的任务进行排列，要始终保证第一个task的时间是最小的\n                                    queue.rescheduleMin(task.period<0 ? currentTime   - task.period\n                                                    : executionTime + task.period);\n                                }\n                            }\n                        }\n                        //这里表示最近要执行的任务时间没有到，那么再让当前的线程阻塞一段时间\n                        if (!taskFired)\n                            queue.wait(executionTime - currentTime);\n                    }\n                    //表示要执行的任务时间已经到了，那么直接调用任务的run() 执行代码\n                    if (taskFired)\n                        task.run();\n                } catch(InterruptedException e) {\n                }\n            }\n        }\n    }\n    ```\n- 接着再来看一下TaskQueue队列的源代码\n    - 可以发现这个队列使用数组实现的，如果超过了128的话则扩容为原来的两倍。这个代码不多，注释写的很详细了，没什么好讲的……\n    ```java\n    public class TaskQueue {\n        //创建一个数组为128的数组存放需要执行的任务，如果超过了128的话则扩容为原来的两倍\n        private TimerTask[] queue = new TimerTask[128];\n        //用于统计队列中任务的个数\n        private int size = 0;\n        //返回队列中任务的个数\n        int size() {\n            return size;\n        }\n\n        //依次遍历数组中的任务，并且置为null，有利于内存回收，注意这里的下标是从1开始计算的，不是从0\n        void clear() {\n            for (int i=1; i<=size; i++)\n                queue[i] = null;\n            size = 0;\n        }\n\n        //这里添加一个新的元素使用的是最小堆的操作，这里不详细说明了。\n        void add(TimerTask task) {\n            //如果数组已经存满任务，那么扩容一个新的数组为之前的两倍\n            if (size + 1 == queue.length)\n                queue = Arrays.copyOf(queue, 2*queue.length);\n            queue[++size] = task;\n            fixUp(size);\n        }\n\n        private void fixUp(int k) {\n            while (k > 1) {\n                int j = k >> 1;\n                if (queue[j].nextExecutionTime <= queue[k].nextExecutionTime)\n                    break;\n                TimerTask tmp = queue[j];  queue[j] = queue[k]; queue[k] = tmp;\n                k = j;\n            }\n        }\n    }\n    ```\n\n\n### 04.5 schedule发布任务\n- 当我们创建好Timer并且启动了循环线程以后，这个时候我们就需要发布任务。发布任务主要有以下几个方法。\n    - schedule(TimerTask task, Date time)\n        - 表示第一次执行任务的时间，时间间隔为0，也表示该任务只执行一次就结束了\n    - schedule(TimerTask task, Date firstTime, long period)\n        - firstTime 表示第一次执行的时间，period表示执行任务的时间间隔也就是多久时间执行一次\n    - schedule(TimerTask task, long delay)\n        - 延迟 delay时间执行任务，也就是在当前的时间+delay执行任务（该方法只执行一次任务）\n- 上面这三个方法都会执行sched方法，然后看一下这个\n    - sched(TimerTask task, long time, long period)\n        - 上面所有的执行任务的函数最后都是调用的该方法，task表示要执行的任务，time表示要执行任务的时间，period表示任务执行的间隔时间。\n    - 具体看一下源代码\n        ```java\n        private void sched(TimerTask task, long time, long period) {\n            //如果时间间隔大于 long最大值的一般的话，需要对该数值 /2\n            if (Math.abs(period) > (Long.MAX_VALUE >> 1))\n                period >>= 1;\n\n            synchronized(queue) {\n                //首先判断轮训线程是否取消，如果取消状态直接抛出异常\n                if (!thread.newTasksMayBeScheduled)\n                    throw new IllegalStateException(\"Timer already cancelled.\");\n                synchronized(task.lock) {\n                    //判断新执行的任务状态如果不是初始化状态话，直接抛出异常\n                    if (task.state != TimerTask.VIRGIN)\n                        throw new IllegalStateException(\"Task already scheduled or cancelled\");\n                    //赋值下次执行任务的时间\n                    task.nextExecutionTime = time;\n                    task.period = period;\n                    //将任务状态修改为发布状态\n                    task.state = TimerTask.SCHEDULED;\n                }\n                //将任务添加到最小堆队列中，注意：这里在添加到队列里面要保证第一个元素始终是最小的\n                queue.add(task);\n                //如果task就是队列中最小的任务话，则直接唤醒轮训线程执行任务（也就是唤醒TimerThread线程）\n                if (queue.getMin() == task)\n                    queue.notify();\n            }\n        }\n        ```\n    - 从上面的代码中可以清楚的明白发布任务非常简单的，就是往任务队列中添加任务然后判断条件是否需要唤醒轮训线程去执行任务。其核心代码是在 TimerThread 轮训中以及使用最小堆实现的队列保证每次取出来的第一个任务的执行时间是最小的。\n\n\n### 04.6 存在的问题分析\n- Timer通过一个寻轮线程循环的从队列中获取需要执行的任务，如果任务的执行时间未到则进行等待（通过Object类的 wait 方法实现阻塞等待）一段时间再自动唤醒执行任务。\n- 但是细心的我们发现这个是单线程执行的如果有多个任务需要执行的话会不会应付不过来呢？类似一个程序员，要开发多个需求，要是所有的事情所耗费的时间很短的话，那么就不会出现延迟问题，要是其中一件或者是某件事情非常耗时间的话那么则会影响到后面事情的时间。\n- 其实这个现象一样跟Timer出现的问题也是一样的道理，如果某个任务非常耗时间，而且任务队列中的任务又比较多的话，那 TimerThread 是忙不过来的，这样子就会导致后面的任务出现延迟执行的问题，进而会影响所有的定时任务的准确执行时间。\n- 那么有人就会想要可以一个TimerTask对应一个Timer不就行了吗？但是我们要清楚的明白计算机的系统资源是有限的，如果我们一个任务就去单独的开一个轮训线程执行的话，其实是有一点浪费系统的资源的，完全没有必要的，如果不需要定时任务了话，我们还需要去销毁线程释放资源的，如果是这样子的反复操作的话，不利于我们程序的流畅性。\n\n\n\n### 05.自定义倒计时器案例\n- 为了方便实现倒计时器自由灵活设置，且代码精简，能够适应一个页面创建多个定时器。或者用在列表中，同时倒计时器支持暂停，恢复倒计时等功能。这个就需要做特使处理呢。\n    ```java\n    public class CountDownTimer {\n\n        /**\n         * 时间，即开始的时间，通俗来说就是倒计时总时间\n         */\n        private long mMillisInFuture;\n        /**\n         * 布尔值，表示计时器是否被取消\n         * 只有调用cancel时才被设置为true\n         */\n        private boolean mCancelled = false;\n        /**\n         * 用户接收回调的时间间隔，一般是1秒\n         */\n        private long mCountdownInterval;\n        /**\n         * 记录暂停时候的时间\n         */\n        private long mStopTimeInFuture;\n        /**\n         * mas.what值\n         */\n        private static final int MSG = 520;\n        /**\n         * 暂停时，当时剩余时间\n         */\n        private long mCurrentMillisLeft;\n        /**\n         * 是否暂停\n         * 只有当调用pause时，才设置为true\n         */\n        private boolean mPause = false;\n        /**\n         * 监听listener\n         */\n        private TimerListener mCountDownListener;\n        /**\n         * 是否创建开始\n         */\n        private boolean isStart;\n\n        public CountDownTimer(){\n            isStart = true;\n        }\n\n        public CountDownTimer(long millisInFuture, long countdownInterval) {\n            long total = millisInFuture + 20;\n            this.mMillisInFuture = total;\n            //this.mMillisInFuture = millisInFuture;\n            this.mCountdownInterval = countdownInterval;\n            isStart = true;\n        }\n\n        /**\n         * 开始倒计时，每次点击，都会重新开始\n         */\n        public synchronized final void start() {\n            if (mMillisInFuture <= 0 && mCountdownInterval <= 0) {\n                throw new RuntimeException(\"you must set the millisInFuture > 0 or countdownInterval >0\");\n            }\n            mCancelled = false;\n            long elapsedRealtime = SystemClock.elapsedRealtime();\n            mStopTimeInFuture = elapsedRealtime + mMillisInFuture;\n            CountTimeTools.i(\"start → mMillisInFuture = \" + mMillisInFuture + \", seconds = \" + mMillisInFuture / 1000 );\n            CountTimeTools.i(\"start → elapsedRealtime = \" + elapsedRealtime + \", → mStopTimeInFuture = \" + mStopTimeInFuture);\n            mPause = false;\n            mHandler.sendMessage(mHandler.obtainMessage(MSG));\n            if (mCountDownListener!=null){\n                mCountDownListener.onStart();\n            }\n        }\n\n        /**\n         * 取消计时器\n         */\n        public synchronized final void cancel() {\n            if (mHandler != null) {\n                //暂停\n                mPause = false;\n                mHandler.removeMessages(MSG);\n                //取消\n                mCancelled = true;\n            }\n        }\n\n        /**\n         * 按一下暂停，再按一下继续倒计时\n         */\n        public synchronized final void pause() {\n            if (mHandler != null) {\n                if (mCancelled) {\n                    return;\n                }\n                if (mCurrentMillisLeft < mCountdownInterval) {\n                    return;\n                }\n                if (!mPause) {\n                    mHandler.removeMessages(MSG);\n                    mPause = true;\n                }\n            }\n        }\n\n        /**\n         * 恢复暂停，开始\n         */\n        public synchronized final  void resume() {\n            if (mMillisInFuture <= 0 && mCountdownInterval <= 0) {\n                throw new RuntimeException(\"you must set the millisInFuture > 0 or countdownInterval >0\");\n            }\n            if (mCancelled) {\n                return;\n            }\n            //剩余时长少于\n            if (mCurrentMillisLeft < mCountdownInterval || !mPause) {\n                return;\n            }\n            mStopTimeInFuture = SystemClock.elapsedRealtime() + mCurrentMillisLeft;\n            mHandler.sendMessage(mHandler.obtainMessage(MSG));\n            mPause = false;\n        }\n\n\n        @SuppressLint(\"HandlerLeak\")\n        private Handler mHandler = new Handler() {\n            @Override\n            public void handleMessage(@NonNull Message msg) {\n                synchronized (CountDownTimer.this) {\n                    if (mCancelled) {\n                        return;\n                    }\n                    //剩余毫秒数\n                    final long millisLeft = mStopTimeInFuture - SystemClock.elapsedRealtime();\n                    if (millisLeft <= 0) {\n                        mCurrentMillisLeft = 0;\n                        if (mCountDownListener != null) {\n                            mCountDownListener.onFinish();\n                            CountTimeTools.i(\"onFinish → millisLeft = \" + millisLeft);\n                        }\n                    } else if (millisLeft < mCountdownInterval) {\n                        mCurrentMillisLeft = 0;\n                        CountTimeTools.i(\"handleMessage → millisLeft < mCountdownInterval !\");\n                        // 剩余时间小于一次时间间隔的时候，不再通知，只是延迟一下\n                        sendMessageDelayed(obtainMessage(MSG), millisLeft);\n                    } else {\n                        //有多余的时间\n                        long lastTickStart = SystemClock.elapsedRealtime();\n                        CountTimeTools.i(\"before onTick → lastTickStart = \" + lastTickStart);\n                        CountTimeTools.i(\"before onTick → millisLeft = \" + millisLeft + \", seconds = \" + millisLeft / 1000 );\n                        if (mCountDownListener != null) {\n                            mCountDownListener.onTick(millisLeft);\n                            CountTimeTools.i(\"after onTick → elapsedRealtime = \" + SystemClock.elapsedRealtime());\n                        }\n                        mCurrentMillisLeft = millisLeft;\n                        // 考虑用户的onTick需要花费时间,处理用户onTick执行的时间\n                        // 打印这个delay时间，大概是997毫秒\n                        long delay = lastTickStart + mCountdownInterval - SystemClock.elapsedRealtime();\n                        CountTimeTools.i(\"after onTick → delay1 = \" + delay);\n                        // 特殊情况：用户的onTick方法花费的时间比interval长，那么直接跳转到下一次interval\n                        // 注意，在onTick回调的方法中，不要做些耗时的操作\n                        boolean isWhile = false;\n                        while (delay < 0){\n                            delay += mCountdownInterval;\n                            isWhile = true;\n                        }\n                        if (isWhile){\n                            CountTimeTools.i(\"after onTick执行超时 → delay2 = \" + delay);\n                        }\n                        sendMessageDelayed(obtainMessage(MSG), delay);\n                    }\n                }\n            }\n        };\n\n        /**\n         * 设置倒计时总时间\n         * @param millisInFuture                    毫秒值\n         */\n        public void setMillisInFuture(long millisInFuture) {\n            long total = millisInFuture + 20;\n            this.mMillisInFuture = total;\n        }\n\n        /**\n         * 设置倒计时间隔值\n         * @param countdownInterval                 间隔，一般设置为1000毫秒\n         */\n        public void setCountdownInterval(long countdownInterval) {\n            this.mCountdownInterval = countdownInterval;\n        }\n\n        /**\n         * 设置倒计时监听\n         * @param countDownListener                 listener\n         */\n        public void setCountDownListener(TimerListener countDownListener) {\n            this.mCountDownListener = countDownListener;\n        }\n\n    }\n    ```\n- 如何使用\n    ```\n    //开始\n    mCountDownTimer.start();\n    //结束销毁\n    mCountDownTimer.cancel();\n    //暂停\n    mCountDownTimer.pause();\n    //恢复暂停\n    mCountDownTimer.resume();\n    ```\n\n\n### 代码案例：https://github.com/yangchong211/YCTimer\n\n\n\n\n\n\n", "user_name": "杨充", "description": "每个时间段完成一个小目标", "got_view_count": 218250, "category_name": "Android", "ctime": 1461266353}
{"tag_name": "React.js", "concern_user_count": 199177, "user_id": "2594503172832477", "title": "Redux，React-Router接入Hooks", "mark_content": "<section id=\"nice\" data-tool=\"mdnice编辑器\" data-website=\"https://www.mdnice.com\" style=\"font-size: 16px; color: black; line-height: 1.6; word-spacing: 0px; letter-spacing: 0px; word-break: break-word; word-wrap: break-word; text-align: left; font-family: Optima-Regular, Optima, PingFangSC-light, PingFangTC-light, 'PingFang SC', Cambria, Cochin, Georgia, Times, 'Times New Roman', serif; margin-top: 0; padding: 0;\"><h2 data-tool=\"mdnice编辑器\" style=\"padding: 0px; color: black; font-weight: bold; font-size: 20px; margin-top: 24px; margin-bottom: 12px;\"><span class=\"prefix\" style=\"display: none;\"></span><span class=\"content\" style=\"color: #e7642b; text-align: center; display: block; background-color: #e7642b; color: white; padding: 3px 11px; border-radius: 1px;\">Redux，React-Router接入Hooks</span><span class=\"suffix\"></span></h2>\n<blockquote data-tool=\"mdnice编辑器\" style=\"display: block; font-size: 0.9em; overflow: auto; overflow-scrolling: touch; border-left: 3px solid rgba(0, 0, 0, 0.4); color: #6a737d; padding-top: 10px; padding-bottom: 10px; padding-left: 20px; padding-right: 10px; margin-bottom: 20px; margin-top: 20px; margin: 0 8px; border: none; background: #ffffff; box-shadow: 0 1px 2px -2px rgba(0,0,0,.16), 0 3px 6px 0 rgba(0,0,0,.12), 0 5px 12px 4px rgba(0,0,0,.09);\">\n<p style=\"padding-top: 8px; padding-bottom: 8px; word-spacing: 3px; letter-spacing: 1px; margin: 0px; font-size: 14px; color: #424B5D; line-height: 24px;\">随着<code style=\"font-size: 14px; word-wrap: break-word; padding: 2px 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; padding-left: 0; padding-right: 0; background: transparent; border-radius: 0; color: #eb6161; border-bottom: 1px solid #eb6161;\">react hooks</code>发布之后，react生态也更新相关对的函数式组件<code style=\"font-size: 14px; word-wrap: break-word; padding: 2px 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; padding-left: 0; padding-right: 0; background: transparent; border-radius: 0; color: #eb6161; border-bottom: 1px solid #eb6161;\">hooks</code>APIs</p>\n</blockquote>\n<h3 data-tool=\"mdnice编辑器\" style=\"padding: 0px; margin-top: 24px; margin-bottom: 12px; font-weight: bold; font-size: 18px; color: #424B5D;\"><span class=\"prefix\" style=\"display: none;\"></span><span class=\"content\">React-Redux</span><span class=\"suffix\" style=\"display: none;\"></span></h3>\n<p data-tool=\"mdnice编辑器\" style=\"padding-top: 8px; padding-bottom: 8px; margin: 0; font-size: 16px; line-height: 26px; word-spacing: 3px; letter-spacing: 1px; color: #424B5D;\"><a href=\"https://react-redux.js.org/api/hooks#using-hooks-in-a-react-redux-app\" style=\"text-decoration: none; word-wrap: break-word; font-weight: bold; color: #eb6161; border-bottom: 1px solid #eb6161;\"><span style=\"margin-right: 6px;\">👉</span>React-Redux7.1</a> 提供了 <code style=\"font-size: 14px; word-wrap: break-word; padding: 2px 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; padding-left: 0; padding-right: 0; background: transparent; border-radius: 0; color: #eb6161; border-bottom: 1px solid #eb6161;\">useSelector</code> 、 <code style=\"font-size: 14px; word-wrap: break-word; padding: 2px 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; padding-left: 0; padding-right: 0; background: transparent; border-radius: 0; color: #eb6161; border-bottom: 1px solid #eb6161;\">useActions</code> 、<code style=\"font-size: 14px; word-wrap: break-word; padding: 2px 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; padding-left: 0; padding-right: 0; background: transparent; border-radius: 0; color: #eb6161; border-bottom: 1px solid #eb6161;\">useDispatch</code> 、<code style=\"font-size: 14px; word-wrap: break-word; padding: 2px 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; padding-left: 0; padding-right: 0; background: transparent; border-radius: 0; color: #eb6161; border-bottom: 1px solid #eb6161;\">useStore</code>，可代替<code style=\"font-size: 14px; word-wrap: break-word; padding: 2px 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; padding-left: 0; padding-right: 0; background: transparent; border-radius: 0; color: #eb6161; border-bottom: 1px solid #eb6161;\">connect()</code>高阶组件</p>\n<h6 data-tool=\"mdnice编辑器\" style=\"padding: 0px; color: black; font-size: 16px; margin-top: 24px; margin-bottom: 12px; font-weight: bold;\"><span class=\"prefix\" style=\"display: none;\"></span><span class=\"content\">useSelector</span><span class=\"suffix\" style=\"display: none;\"></span></h6>\n<pre class=\"custom\" data-tool=\"mdnice编辑器\" style=\"margin-top: 10px; margin-bottom: 10px; margin: 12px auto; border-radius: 5px; box-shadow: 0 1px 2px -2px rgba(0,0,0,.16), 0 3px 6px 0 rgba(0,0,0,.12), 0 5px 12px 4px rgba(0,0,0,.09) !important;\"><span style=\"display: block; background: url(https://my-wechat.mdnice.com/point.png); height: 30px; width: 100%; background-size: 40px; background-repeat: no-repeat; background-color: #272822; margin-bottom: -7px; border-radius: 5px; background-position: 10px 10px;\"></span><code class=\"hljs\" style=\"overflow-x: auto; padding: 16px; color: #ddd; display: -webkit-box; font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; font-size: 12px; -webkit-overflow-scrolling: touch; padding-top: 15px; background: #272822; border-radius: 5px;\">const&nbsp;result:&nbsp;any&nbsp;=&nbsp;useSelector(selector:&nbsp;Function,&nbsp;equalityFn?:&nbsp;Function)<br></code></pre>\n<p data-tool=\"mdnice编辑器\" style=\"padding-top: 8px; padding-bottom: 8px; margin: 0; font-size: 16px; line-height: 26px; word-spacing: 3px; letter-spacing: 1px; color: #424B5D;\">允许您使用选择器功能从Redux存储状态提取数据</p>\n<blockquote data-tool=\"mdnice编辑器\" style=\"display: block; font-size: 0.9em; overflow: auto; overflow-scrolling: touch; border-left: 3px solid rgba(0, 0, 0, 0.4); color: #6a737d; padding-top: 10px; padding-bottom: 10px; padding-left: 20px; padding-right: 10px; margin-bottom: 20px; margin-top: 20px; margin: 0 8px; border: none; background: #ffffff; box-shadow: 0 1px 2px -2px rgba(0,0,0,.16), 0 3px 6px 0 rgba(0,0,0,.12), 0 5px 12px 4px rgba(0,0,0,.09);\">\n<p style=\"padding-top: 8px; padding-bottom: 8px; word-spacing: 3px; letter-spacing: 1px; margin: 0px; font-size: 14px; color: #424B5D; line-height: 24px;\">选择器函数应该是纯函数，因为它可能在任意时间点多次执行</p>\n</blockquote>\n<p data-tool=\"mdnice编辑器\" style=\"padding-top: 8px; padding-bottom: 8px; margin: 0; font-size: 16px; line-height: 26px; word-spacing: 3px; letter-spacing: 1px; color: #424B5D;\">从概念上讲，<code style=\"font-size: 14px; word-wrap: break-word; padding: 2px 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; padding-left: 0; padding-right: 0; background: transparent; border-radius: 0; color: #eb6161; border-bottom: 1px solid #eb6161;\">selector</code> 函数与 <code style=\"font-size: 14px; word-wrap: break-word; padding: 2px 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; padding-left: 0; padding-right: 0; background: transparent; border-radius: 0; color: #eb6161; border-bottom: 1px solid #eb6161;\">connect</code> 的 <code style=\"font-size: 14px; word-wrap: break-word; padding: 2px 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; padding-left: 0; padding-right: 0; background: transparent; border-radius: 0; color: #eb6161; border-bottom: 1px solid #eb6161;\">mapStateToProps</code>的参数是差不多一样的。<code style=\"font-size: 14px; word-wrap: break-word; padding: 2px 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; padding-left: 0; padding-right: 0; background: transparent; border-radius: 0; color: #eb6161; border-bottom: 1px solid #eb6161;\">selector</code> 函数被调用时，将会被传入<code style=\"font-size: 14px; word-wrap: break-word; padding: 2px 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; padding-left: 0; padding-right: 0; background: transparent; border-radius: 0; color: #eb6161; border-bottom: 1px solid #eb6161;\">Redux store</code>的整个<code style=\"font-size: 14px; word-wrap: break-word; padding: 2px 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; padding-left: 0; padding-right: 0; background: transparent; border-radius: 0; color: #eb6161; border-bottom: 1px solid #eb6161;\">state</code>，作为唯一的参数。每次函数组件渲染时， selector 函数都会被调用。<code style=\"font-size: 14px; word-wrap: break-word; padding: 2px 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; padding-left: 0; padding-right: 0; background: transparent; border-radius: 0; color: #eb6161; border-bottom: 1px solid #eb6161;\">useSelector()</code>同样会订阅 <code style=\"font-size: 14px; word-wrap: break-word; padding: 2px 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; padding-left: 0; padding-right: 0; background: transparent; border-radius: 0; color: #eb6161; border-bottom: 1px solid #eb6161;\">Redux</code> 的<code style=\"font-size: 14px; word-wrap: break-word; padding: 2px 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; padding-left: 0; padding-right: 0; background: transparent; border-radius: 0; color: #eb6161; border-bottom: 1px solid #eb6161;\">sotre</code>，并且在你每 分发(<code style=\"font-size: 14px; word-wrap: break-word; padding: 2px 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; padding-left: 0; padding-right: 0; background: transparent; border-radius: 0; color: #eb6161; border-bottom: 1px solid #eb6161;\">dispatch</code>) 一个 action 时，都会被执行一次</p>\n<p data-tool=\"mdnice编辑器\" style=\"padding-top: 8px; padding-bottom: 8px; margin: 0; font-size: 16px; line-height: 26px; word-spacing: 3px; letter-spacing: 1px; color: #424B5D;\">注意点：当 分发(<code style=\"font-size: 14px; word-wrap: break-word; padding: 2px 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; padding-left: 0; padding-right: 0; background: transparent; border-radius: 0; color: #eb6161; border-bottom: 1px solid #eb6161;\">dispatch</code>) 了一个<code style=\"font-size: 14px; word-wrap: break-word; padding: 2px 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; padding-left: 0; padding-right: 0; background: transparent; border-radius: 0; color: #eb6161; border-bottom: 1px solid #eb6161;\">action</code>时，<code style=\"font-size: 14px; word-wrap: break-word; padding: 2px 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; padding-left: 0; padding-right: 0; background: transparent; border-radius: 0; color: #eb6161; border-bottom: 1px solid #eb6161;\">useSelector()</code>会将上一次调用 <code style=\"font-size: 14px; word-wrap: break-word; padding: 2px 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; padding-left: 0; padding-right: 0; background: transparent; border-radius: 0; color: #eb6161; border-bottom: 1px solid #eb6161;\">selector</code>函数结果与当前调用的结果进行引用(<code style=\"font-size: 14px; word-wrap: break-word; padding: 2px 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; padding-left: 0; padding-right: 0; background: transparent; border-radius: 0; color: #eb6161; border-bottom: 1px solid #eb6161;\">===</code>)比较，如果不一样，组件会被强制重新渲染。如果一样，就不会被重新渲染</p>\n<p data-tool=\"mdnice编辑器\" style=\"padding-top: 8px; padding-bottom: 8px; margin: 0; font-size: 16px; line-height: 26px; word-spacing: 3px; letter-spacing: 1px; color: #424B5D;\">优化：进行浅比较</p>\n<pre class=\"custom\" data-tool=\"mdnice编辑器\" style=\"margin-top: 10px; margin-bottom: 10px; margin: 12px auto; border-radius: 5px; box-shadow: 0 1px 2px -2px rgba(0,0,0,.16), 0 3px 6px 0 rgba(0,0,0,.12), 0 5px 12px 4px rgba(0,0,0,.09) !important;\"><span style=\"display: block; background: url(https://my-wechat.mdnice.com/point.png); height: 30px; width: 100%; background-size: 40px; background-repeat: no-repeat; background-color: #272822; margin-bottom: -7px; border-radius: 5px; background-position: 10px 10px;\"></span><code class=\"hljs\" style=\"overflow-x: auto; padding: 16px; color: #ddd; display: -webkit-box; font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; font-size: 12px; -webkit-overflow-scrolling: touch; padding-top: 15px; background: #272822; border-radius: 5px;\">import&nbsp;{&nbsp;useSelector,&nbsp;shallowEqual&nbsp;}&nbsp;from&nbsp;<span class=\"hljs-string\" style=\"color: #a6e22e; line-height: 26px;\">'react-redux'</span><br><br><span class=\"hljs-built_in\" style=\"color: #a6e22e; line-height: 26px;\">export</span>&nbsp;<span class=\"hljs-keyword\" style=\"color: #f92672; font-weight: bold; line-height: 26px;\">function</span>&nbsp;useShallowEqualSelector(selector)&nbsp;{<br>&nbsp;&nbsp;<span class=\"hljs-built_in\" style=\"color: #a6e22e; line-height: 26px;\">return</span>&nbsp;useSelector(selector,&nbsp;shallowEqual)<br>}<br></code></pre>\n<h6 data-tool=\"mdnice编辑器\" style=\"padding: 0px; color: black; font-size: 16px; margin-top: 24px; margin-bottom: 12px; font-weight: bold;\"><span class=\"prefix\" style=\"display: none;\"></span><span class=\"content\">useActions</span><span class=\"suffix\" style=\"display: none;\"></span></h6>\n<p data-tool=\"mdnice编辑器\" style=\"padding-top: 8px; padding-bottom: 8px; margin: 0; font-size: 16px; line-height: 26px; word-spacing: 3px; letter-spacing: 1px; color: #424B5D;\">废弃，不推荐使用（actionCreater）</p>\n<h6 data-tool=\"mdnice编辑器\" style=\"padding: 0px; color: black; font-size: 16px; margin-top: 24px; margin-bottom: 12px; font-weight: bold;\"><span class=\"prefix\" style=\"display: none;\"></span><span class=\"content\">useDispatch</span><span class=\"suffix\" style=\"display: none;\"></span></h6>\n<pre class=\"custom\" data-tool=\"mdnice编辑器\" style=\"margin-top: 10px; margin-bottom: 10px; margin: 12px auto; border-radius: 5px; box-shadow: 0 1px 2px -2px rgba(0,0,0,.16), 0 3px 6px 0 rgba(0,0,0,.12), 0 5px 12px 4px rgba(0,0,0,.09) !important;\"><span style=\"display: block; background: url(https://my-wechat.mdnice.com/point.png); height: 30px; width: 100%; background-size: 40px; background-repeat: no-repeat; background-color: #272822; margin-bottom: -7px; border-radius: 5px; background-position: 10px 10px;\"></span><code class=\"hljs\" style=\"overflow-x: auto; padding: 16px; color: #ddd; display: -webkit-box; font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; font-size: 12px; -webkit-overflow-scrolling: touch; padding-top: 15px; background: #272822; border-radius: 5px;\">const&nbsp;dispatch&nbsp;=&nbsp;useDispatch()<br></code></pre>\n<h6 data-tool=\"mdnice编辑器\" style=\"padding: 0px; color: black; font-size: 16px; margin-top: 24px; margin-bottom: 12px; font-weight: bold;\"><span class=\"prefix\" style=\"display: none;\"></span><span class=\"content\">useStore</span><span class=\"suffix\" style=\"display: none;\"></span></h6>\n<pre class=\"custom\" data-tool=\"mdnice编辑器\" style=\"margin-top: 10px; margin-bottom: 10px; margin: 12px auto; border-radius: 5px; box-shadow: 0 1px 2px -2px rgba(0,0,0,.16), 0 3px 6px 0 rgba(0,0,0,.12), 0 5px 12px 4px rgba(0,0,0,.09) !important;\"><span style=\"display: block; background: url(https://my-wechat.mdnice.com/point.png); height: 30px; width: 100%; background-size: 40px; background-repeat: no-repeat; background-color: #272822; margin-bottom: -7px; border-radius: 5px; background-position: 10px 10px;\"></span><code class=\"hljs\" style=\"overflow-x: auto; padding: 16px; color: #ddd; display: -webkit-box; font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; font-size: 12px; -webkit-overflow-scrolling: touch; padding-top: 15px; background: #272822; border-radius: 5px;\">const&nbsp;store&nbsp;=&nbsp;useStore()<br></code></pre>\n<h4 data-tool=\"mdnice编辑器\" style=\"padding: 0px; margin-top: 24px; margin-bottom: 12px; font-weight: bold; font-size: 16px; color: #424B5D;\"><span class=\"prefix\" style=\"display: none;\"></span><span class=\"content\">dva中使用</span><span class=\"suffix\" style=\"display: none;\"></span></h4>\n<p data-tool=\"mdnice编辑器\" style=\"padding-top: 8px; padding-bottom: 8px; margin: 0; font-size: 16px; line-height: 26px; word-spacing: 3px; letter-spacing: 1px; color: #424B5D;\"><code style=\"font-size: 14px; word-wrap: break-word; padding: 2px 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; padding-left: 0; padding-right: 0; background: transparent; border-radius: 0; color: #eb6161; border-bottom: 1px solid #eb6161;\">dva</code>在<code style=\"font-size: 14px; word-wrap: break-word; padding: 2px 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; padding-left: 0; padding-right: 0; background: transparent; border-radius: 0; color: #eb6161; border-bottom: 1px solid #eb6161;\">2.6.0-beta.6</code>中已支持以上几个<code style=\"font-size: 14px; word-wrap: break-word; padding: 2px 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; padding-left: 0; padding-right: 0; background: transparent; border-radius: 0; color: #eb6161; border-bottom: 1px solid #eb6161;\">hooks</code>API，可直接使用</p>\n<pre class=\"custom\" data-tool=\"mdnice编辑器\" style=\"margin-top: 10px; margin-bottom: 10px; margin: 12px auto; border-radius: 5px; box-shadow: 0 1px 2px -2px rgba(0,0,0,.16), 0 3px 6px 0 rgba(0,0,0,.12), 0 5px 12px 4px rgba(0,0,0,.09) !important;\"><span style=\"display: block; background: url(https://my-wechat.mdnice.com/point.png); height: 30px; width: 100%; background-size: 40px; background-repeat: no-repeat; background-color: #272822; margin-bottom: -7px; border-radius: 5px; background-position: 10px 10px;\"></span><code class=\"hljs\" style=\"overflow-x: auto; padding: 16px; color: #ddd; display: -webkit-box; font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; font-size: 12px; -webkit-overflow-scrolling: touch; padding-top: 15px; background: #272822; border-radius: 5px;\">import&nbsp;{&nbsp;useSelector,&nbsp;useDispatch&nbsp;}&nbsp;from&nbsp;<span class=\"hljs-string\" style=\"color: #a6e22e; line-height: 26px;\">'dva'</span>;<br></code></pre>\n<h3 data-tool=\"mdnice编辑器\" style=\"padding: 0px; margin-top: 24px; margin-bottom: 12px; font-weight: bold; font-size: 18px; color: #424B5D;\"><span class=\"prefix\" style=\"display: none;\"></span><span class=\"content\">React-Router</span><span class=\"suffix\" style=\"display: none;\"></span></h3>\n<p data-tool=\"mdnice编辑器\" style=\"padding-top: 8px; padding-bottom: 8px; margin: 0; font-size: 16px; line-height: 26px; word-spacing: 3px; letter-spacing: 1px; color: #424B5D;\"><a href=\"https://reacttraining.com/react-router/\" style=\"text-decoration: none; word-wrap: break-word; font-weight: bold; color: #eb6161; border-bottom: 1px solid #eb6161;\"><span style=\"margin-right: 6px;\">👉</span>React-Router</a> 提供了<code style=\"font-size: 14px; word-wrap: break-word; padding: 2px 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; padding-left: 0; padding-right: 0; background: transparent; border-radius: 0; color: #eb6161; border-bottom: 1px solid #eb6161;\">useHistory</code> 、<code style=\"font-size: 14px; word-wrap: break-word; padding: 2px 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; padding-left: 0; padding-right: 0; background: transparent; border-radius: 0; color: #eb6161; border-bottom: 1px solid #eb6161;\">useNavigate</code>、<code style=\"font-size: 14px; word-wrap: break-word; padding: 2px 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; padding-left: 0; padding-right: 0; background: transparent; border-radius: 0; color: #eb6161; border-bottom: 1px solid #eb6161;\">useLocation</code>、<code style=\"font-size: 14px; word-wrap: break-word; padding: 2px 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; padding-left: 0; padding-right: 0; background: transparent; border-radius: 0; color: #eb6161; border-bottom: 1px solid #eb6161;\">useParams</code>、<code style=\"font-size: 14px; word-wrap: break-word; padding: 2px 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; padding-left: 0; padding-right: 0; background: transparent; border-radius: 0; color: #eb6161; border-bottom: 1px solid #eb6161;\">useRoutes</code>、</p>\n<h5 data-tool=\"mdnice编辑器\" style=\"padding: 0px; margin-top: 24px; margin-bottom: 12px; font-weight: bold; font-size: 16px; color: #424B5D;\"><span class=\"prefix\" style=\"display: none;\"></span><span class=\"content\">useNavigate</span><span class=\"suffix\" style=\"display: none;\"></span></h5>\n<pre class=\"custom\" data-tool=\"mdnice编辑器\" style=\"margin-top: 10px; margin-bottom: 10px; margin: 12px auto; border-radius: 5px; box-shadow: 0 1px 2px -2px rgba(0,0,0,.16), 0 3px 6px 0 rgba(0,0,0,.12), 0 5px 12px 4px rgba(0,0,0,.09) !important;\"><span style=\"display: block; background: url(https://my-wechat.mdnice.com/point.png); height: 30px; width: 100%; background-size: 40px; background-repeat: no-repeat; background-color: #272822; margin-bottom: -7px; border-radius: 5px; background-position: 10px 10px;\"></span><code class=\"hljs\" style=\"overflow-x: auto; padding: 16px; color: #ddd; display: -webkit-box; font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; font-size: 12px; -webkit-overflow-scrolling: touch; padding-top: 15px; background: #272822; border-radius: 5px;\"><span class=\"hljs-comment\" style=\"color: #75715e; line-height: 26px;\">//&nbsp;v5</span><br><span class=\"hljs-keyword\" style=\"color: #f92672; font-weight: bold; line-height: 26px;\">import</span>&nbsp;{&nbsp;useHistory&nbsp;}&nbsp;<span class=\"hljs-keyword\" style=\"color: #f92672; font-weight: bold; line-height: 26px;\">from</span>&nbsp;<span class=\"hljs-string\" style=\"color: #a6e22e; line-height: 26px;\">'react-router-dom'</span>;<br><br><span class=\"hljs-function\" style=\"line-height: 26px;\"><span class=\"hljs-keyword\" style=\"color: #f92672; font-weight: bold; line-height: 26px;\">function</span>&nbsp;<span class=\"hljs-title\" style=\"color: #a6e22e; font-weight: bold; line-height: 26px;\">MyButton</span>(<span class=\"hljs-params\" style=\"line-height: 26px;\"></span>)&nbsp;</span>{<br>&nbsp;&nbsp;<span class=\"hljs-keyword\" style=\"color: #f92672; font-weight: bold; line-height: 26px;\">let</span>&nbsp;history&nbsp;=&nbsp;useHistory();<br>&nbsp;&nbsp;<span class=\"hljs-function\" style=\"line-height: 26px;\"><span class=\"hljs-keyword\" style=\"color: #f92672; font-weight: bold; line-height: 26px;\">function</span>&nbsp;<span class=\"hljs-title\" style=\"color: #a6e22e; font-weight: bold; line-height: 26px;\">handleClick</span>(<span class=\"hljs-params\" style=\"line-height: 26px;\"></span>)&nbsp;</span>{<br>&nbsp;&nbsp;&nbsp;&nbsp;history.push(<span class=\"hljs-string\" style=\"color: #a6e22e; line-height: 26px;\">'/home'</span>);<br>&nbsp;&nbsp;};<br>&nbsp;&nbsp;<span class=\"hljs-keyword\" style=\"color: #f92672; font-weight: bold; line-height: 26px;\">return</span>&nbsp;<span class=\"xml\" style=\"line-height: 26px;\"><span class=\"hljs-tag\" style=\"color: #f92672; line-height: 26px;\">&lt;<span class=\"hljs-name\" style=\"color: #f92672; line-height: 26px;\">button</span>&nbsp;<span class=\"hljs-attr\" style=\"line-height: 26px;\">onClick</span>=<span class=\"hljs-string\" style=\"color: #a6e22e; line-height: 26px;\">{handleClick}</span>&gt;</span>Submit<span class=\"hljs-tag\" style=\"color: #f92672; line-height: 26px;\">&lt;/<span class=\"hljs-name\" style=\"color: #f92672; line-height: 26px;\">button</span>&gt;</span></span>;<br>};<br></code></pre>\n<pre class=\"custom\" data-tool=\"mdnice编辑器\" style=\"margin-top: 10px; margin-bottom: 10px; margin: 12px auto; border-radius: 5px; box-shadow: 0 1px 2px -2px rgba(0,0,0,.16), 0 3px 6px 0 rgba(0,0,0,.12), 0 5px 12px 4px rgba(0,0,0,.09) !important;\"><span style=\"display: block; background: url(https://my-wechat.mdnice.com/point.png); height: 30px; width: 100%; background-size: 40px; background-repeat: no-repeat; background-color: #272822; margin-bottom: -7px; border-radius: 5px; background-position: 10px 10px;\"></span><code class=\"hljs\" style=\"overflow-x: auto; padding: 16px; color: #ddd; display: -webkit-box; font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; font-size: 12px; -webkit-overflow-scrolling: touch; padding-top: 15px; background: #272822; border-radius: 5px;\"><span class=\"hljs-comment\" style=\"color: #75715e; line-height: 26px;\">//&nbsp;v6</span><br><span class=\"hljs-keyword\" style=\"color: #f92672; font-weight: bold; line-height: 26px;\">import</span>&nbsp;{&nbsp;useNavigate&nbsp;}&nbsp;<span class=\"hljs-keyword\" style=\"color: #f92672; font-weight: bold; line-height: 26px;\">from</span>&nbsp;<span class=\"hljs-string\" style=\"color: #a6e22e; line-height: 26px;\">'react-router-dom'</span>;<br><br><span class=\"hljs-function\" style=\"line-height: 26px;\"><span class=\"hljs-keyword\" style=\"color: #f92672; font-weight: bold; line-height: 26px;\">function</span>&nbsp;<span class=\"hljs-title\" style=\"color: #a6e22e; font-weight: bold; line-height: 26px;\">MyButton</span>(<span class=\"hljs-params\" style=\"line-height: 26px;\"></span>)&nbsp;</span>{<br>&nbsp;&nbsp;<span class=\"hljs-keyword\" style=\"color: #f92672; font-weight: bold; line-height: 26px;\">let</span>&nbsp;navigate&nbsp;=&nbsp;useNavigate();<br>&nbsp;&nbsp;<span class=\"hljs-function\" style=\"line-height: 26px;\"><span class=\"hljs-keyword\" style=\"color: #f92672; font-weight: bold; line-height: 26px;\">function</span>&nbsp;<span class=\"hljs-title\" style=\"color: #a6e22e; font-weight: bold; line-height: 26px;\">handleClick</span>(<span class=\"hljs-params\" style=\"line-height: 26px;\"></span>)&nbsp;</span>{<br>&nbsp;&nbsp;&nbsp;&nbsp;navigate(<span class=\"hljs-string\" style=\"color: #a6e22e; line-height: 26px;\">'/home'</span>);<br>&nbsp;&nbsp;};<br>&nbsp;&nbsp;<span class=\"hljs-keyword\" style=\"color: #f92672; font-weight: bold; line-height: 26px;\">return</span>&nbsp;<span class=\"xml\" style=\"line-height: 26px;\"><span class=\"hljs-tag\" style=\"color: #f92672; line-height: 26px;\">&lt;<span class=\"hljs-name\" style=\"color: #f92672; line-height: 26px;\">button</span>&nbsp;<span class=\"hljs-attr\" style=\"line-height: 26px;\">onClick</span>=<span class=\"hljs-string\" style=\"color: #a6e22e; line-height: 26px;\">{handleClick}</span>&gt;</span>Submit<span class=\"hljs-tag\" style=\"color: #f92672; line-height: 26px;\">&lt;/<span class=\"hljs-name\" style=\"color: #f92672; line-height: 26px;\">button</span>&gt;</span></span>;<br>};<br></code></pre>\n<h5 data-tool=\"mdnice编辑器\" style=\"padding: 0px; margin-top: 24px; margin-bottom: 12px; font-weight: bold; font-size: 16px; color: #424B5D;\"><span class=\"prefix\" style=\"display: none;\"></span><span class=\"content\">useLocation</span><span class=\"suffix\" style=\"display: none;\"></span></h5>\n<pre class=\"custom\" data-tool=\"mdnice编辑器\" style=\"margin-top: 10px; margin-bottom: 10px; margin: 12px auto; border-radius: 5px; box-shadow: 0 1px 2px -2px rgba(0,0,0,.16), 0 3px 6px 0 rgba(0,0,0,.12), 0 5px 12px 4px rgba(0,0,0,.09) !important;\"><span style=\"display: block; background: url(https://my-wechat.mdnice.com/point.png); height: 30px; width: 100%; background-size: 40px; background-repeat: no-repeat; background-color: #272822; margin-bottom: -7px; border-radius: 5px; background-position: 10px 10px;\"></span><code class=\"hljs\" style=\"overflow-x: auto; padding: 16px; color: #ddd; display: -webkit-box; font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; font-size: 12px; -webkit-overflow-scrolling: touch; padding-top: 15px; background: #272822; border-radius: 5px;\"><span class=\"hljs-built_in\" style=\"color: #a6e22e; line-height: 26px;\">let</span>&nbsp;location&nbsp;=&nbsp;useLocation();<br></code></pre>\n<h5 data-tool=\"mdnice编辑器\" style=\"padding: 0px; margin-top: 24px; margin-bottom: 12px; font-weight: bold; font-size: 16px; color: #424B5D;\"><span class=\"prefix\" style=\"display: none;\"></span><span class=\"content\">useParams</span><span class=\"suffix\" style=\"display: none;\"></span></h5>\n<pre class=\"custom\" data-tool=\"mdnice编辑器\" style=\"margin-top: 10px; margin-bottom: 10px; margin: 12px auto; border-radius: 5px; box-shadow: 0 1px 2px -2px rgba(0,0,0,.16), 0 3px 6px 0 rgba(0,0,0,.12), 0 5px 12px 4px rgba(0,0,0,.09) !important;\"><span style=\"display: block; background: url(https://my-wechat.mdnice.com/point.png); height: 30px; width: 100%; background-size: 40px; background-repeat: no-repeat; background-color: #272822; margin-bottom: -7px; border-radius: 5px; background-position: 10px 10px;\"></span><code class=\"hljs\" style=\"overflow-x: auto; padding: 16px; color: #ddd; display: -webkit-box; font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; font-size: 12px; -webkit-overflow-scrolling: touch; padding-top: 15px; background: #272822; border-radius: 5px;\">const&nbsp;{&nbsp;flag&nbsp;}&nbsp;=&nbsp;useParams();<br></code></pre>\n<h5 data-tool=\"mdnice编辑器\" style=\"padding: 0px; margin-top: 24px; margin-bottom: 12px; font-weight: bold; font-size: 16px; color: #424B5D;\"><span class=\"prefix\" style=\"display: none;\"></span><span class=\"content\">useRoutes</span><span class=\"suffix\" style=\"display: none;\"></span></h5>\n<pre class=\"custom\" data-tool=\"mdnice编辑器\" style=\"margin-top: 10px; margin-bottom: 10px; margin: 12px auto; border-radius: 5px; box-shadow: 0 1px 2px -2px rgba(0,0,0,.16), 0 3px 6px 0 rgba(0,0,0,.12), 0 5px 12px 4px rgba(0,0,0,.09) !important;\"><span style=\"display: block; background: url(https://my-wechat.mdnice.com/point.png); height: 30px; width: 100%; background-size: 40px; background-repeat: no-repeat; background-color: #272822; margin-bottom: -7px; border-radius: 5px; background-position: 10px 10px;\"></span><code class=\"hljs\" style=\"overflow-x: auto; padding: 16px; color: #ddd; display: -webkit-box; font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; font-size: 12px; -webkit-overflow-scrolling: touch; padding-top: 15px; background: #272822; border-radius: 5px;\">//&nbsp;v6<br><span class=\"hljs-keyword\" style=\"color: #f92672; font-weight: bold; line-height: 26px;\">function</span>&nbsp;<span class=\"hljs-function\" style=\"line-height: 26px;\"><span class=\"hljs-title\" style=\"color: #a6e22e; font-weight: bold; line-height: 26px;\">App</span></span>()&nbsp;{<br>&nbsp;&nbsp;<span class=\"hljs-built_in\" style=\"color: #a6e22e; line-height: 26px;\">let</span>&nbsp;element&nbsp;=&nbsp;useRoutes([<br>&nbsp;&nbsp;&nbsp;&nbsp;{&nbsp;path:&nbsp;<span class=\"hljs-string\" style=\"color: #a6e22e; line-height: 26px;\">'/'</span>,&nbsp;element:&nbsp;&lt;Home&nbsp;/&gt;&nbsp;},<br>&nbsp;&nbsp;&nbsp;&nbsp;{&nbsp;path:&nbsp;<span class=\"hljs-string\" style=\"color: #a6e22e; line-height: 26px;\">'dashboard'</span>,&nbsp;element:&nbsp;&lt;Dashboard&nbsp;/&gt;&nbsp;},<br>&nbsp;&nbsp;&nbsp;&nbsp;{&nbsp;path:&nbsp;<span class=\"hljs-string\" style=\"color: #a6e22e; line-height: 26px;\">'invoices'</span>,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;element:&nbsp;&lt;Invoices&nbsp;/&gt;,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;children:&nbsp;[<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{&nbsp;path:&nbsp;<span class=\"hljs-string\" style=\"color: #a6e22e; line-height: 26px;\">':id'</span>,&nbsp;element:&nbsp;&lt;Invoice&nbsp;/&gt;&nbsp;},<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{&nbsp;path:&nbsp;<span class=\"hljs-string\" style=\"color: #a6e22e; line-height: 26px;\">'sent'</span>,&nbsp;element:&nbsp;&lt;SentInvoices&nbsp;/&gt;&nbsp;}<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;]<br>&nbsp;&nbsp;&nbsp;&nbsp;},<br>&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;重定向<br>&nbsp;&nbsp;&nbsp;&nbsp;{&nbsp;path:&nbsp;<span class=\"hljs-string\" style=\"color: #a6e22e; line-height: 26px;\">'home'</span>,&nbsp;redirectTo:&nbsp;<span class=\"hljs-string\" style=\"color: #a6e22e; line-height: 26px;\">'/'</span>&nbsp;},<br>&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;404找不到<br>&nbsp;&nbsp;&nbsp;&nbsp;{&nbsp;path:&nbsp;<span class=\"hljs-string\" style=\"color: #a6e22e; line-height: 26px;\">'*'</span>,&nbsp;element:&nbsp;&lt;NotFound&nbsp;/&gt;&nbsp;}<br>&nbsp;&nbsp;]);<br>&nbsp;&nbsp;<span class=\"hljs-built_in\" style=\"color: #a6e22e; line-height: 26px;\">return</span>&nbsp;element;<br>}<br></code></pre>\n</section>", "user_name": "Navy", "description": "", "got_view_count": 191, "category_name": "前端", "ctime": 1457483942}
{"tag_name": "ECMAScript 6", "concern_user_count": 156509, "user_id": "325111171779912", "title": "带你重学ES6 | Reflect", "mark_content": "<section id=\"nice\" data-tool=\"mdnice编辑器\" data-website=\"https://www.mdnice.com\" style=\"font-size: 16px; padding: 0 10px; word-spacing: 0px; word-break: break-word; word-wrap: break-word; text-align: left; line-height: 1.75; color: #595959; font-family: Optima-Regular, Optima, PingFangTC-Light, PingFangSC-light, PingFangTC-light; letter-spacing: 2px; background-image: linear-gradient(90deg, rgba(50, 0, 0, 0.05) 3%, rgba(0, 0, 0, 0) 3%), linear-gradient(360deg, rgba(50, 0, 0, 0.05) 3%, rgba(0, 0, 0, 0) 3%); background-size: 20px 20px; background-position: center center;\"><h2 data-tool=\"mdnice编辑器\" style=\"margin-top: 30px; margin-bottom: 15px; padding: 0px; font-weight: bold; color: black; font-size: 22px; text-align: left; margin: 20px 10px 0px 0px;\"><span class=\"prefix\" style=\"display: none;\"></span><span class=\"content\" style=\"font-size: 18px; font-weight: bold; display: inline-block; padding-left: 10px; border-left: 5px solid #DEC6FB; color: #595959;\">前言</span><span class=\"suffix\"></span></h2>\n<p data-tool=\"mdnice编辑器\" style=\"padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: #595959; margin: 10px 0px; letter-spacing: 2px; font-size: 14px; word-spacing: 2px;\">其实说实在的，在没重学 ES6 之前，我对 Reflect 这个对象完全是空白的，一是在实际工作中用不到，二是面试的时候也没人问起。这也是自己的一个问题，在驱动式学习，而没有去自主学习。</p>\n<p data-tool=\"mdnice编辑器\" style=\"padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: #595959; margin: 10px 0px; letter-spacing: 2px; font-size: 14px; word-spacing: 2px;\">那今天就讲讲 Reflect 对象。</p>\n<h2 data-tool=\"mdnice编辑器\" style=\"margin-top: 30px; margin-bottom: 15px; padding: 0px; font-weight: bold; color: black; font-size: 22px; text-align: left; margin: 20px 10px 0px 0px;\"><span class=\"prefix\" style=\"display: none;\"></span><span class=\"content\" style=\"font-size: 18px; font-weight: bold; display: inline-block; padding-left: 10px; border-left: 5px solid #DEC6FB; color: #595959;\">1、概述</span><span class=\"suffix\"></span></h2>\n<p data-tool=\"mdnice编辑器\" style=\"padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: #595959; margin: 10px 0px; letter-spacing: 2px; font-size: 14px; word-spacing: 2px;\">Reflect 对象不是构造函数，所以创建时不是用 new 来进行创建。</p>\n<p data-tool=\"mdnice编辑器\" style=\"padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: #595959; margin: 10px 0px; letter-spacing: 2px; font-size: 14px; word-spacing: 2px;\">在 ES6 中增加这个对象的目的：</p>\n<ol data-tool=\"mdnice编辑器\" style=\"margin-top: 8px; margin-bottom: 8px; padding-left: 25px; list-style-type: decimal; font-size: 15px; color: #595959;\">\n<li><section style=\"margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; font-size: 14px; font-weight: normal; color: #595959;\">将 Object 对象的一些明显属于语言内部的方法（比如 Object.defineProperty），放到 Reflect 对象上。现阶段，某些方法同时在 Object 和 Reflect 对象上部署，未来的新方法将只部署在 Reflect 对象上。也就是说，从 Reflect 对象上可以拿到语言内部的方法。</section></li><li><section style=\"margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; font-size: 14px; font-weight: normal; color: #595959;\">修改某些 Object 方法的返回结果，让其变得更合理。比如，Object.defineProperty(obj, name, desc)在无法定义属性时，会抛出一个错误，而 Reflect.defineProperty(obj, name, desc)则会返回 false。</section></li><li><section style=\"margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; font-size: 14px; font-weight: normal; color: #595959;\">让 Object 操作都变成函数行为。某些 Object 操作是命令式，比如 name in obj 和 delete obj[name]，而 Reflect.has(obj, name)和 Reflect.deleteProperty(obj, name)让它们变成了函数行为。</section></li><li><section style=\"margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; font-size: 14px; font-weight: normal; color: #595959;\">Reflect 对象的方法与 Proxy 对象的方法一一对应，只要是 Proxy 对象的方法，就能在 Reflect 对象上找到对应的方法。这就让 Proxy 对象可以方便地调用对应的 Reflect 方法，完成默认行为，作为修改行为的基础。也就是说，不管 Proxy 怎么修改默认行为，你总可以在 Reflect 上获取默认行为。</section></li></ol>\n<pre class=\"custom\" data-tool=\"mdnice编辑器\" style=\"margin-top: 10px; margin-bottom: 10px; border-radius: 5px; box-shadow: rgba(0, 0, 0, 0.55) 0px 2px 10px;\"><span style=\"display: block; background: url(https://my-wechat.mdnice.com/point.png); height: 30px; width: 100%; background-size: 40px; background-repeat: no-repeat; background-color: #fafafa; margin-bottom: -7px; border-radius: 5px; background-position: 10px 10px;\"></span><code class=\"hljs\" style=\"overflow-x: auto; padding: 16px; color: #383a42; display: -webkit-box; font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; font-size: 12px; -webkit-overflow-scrolling: touch; padding-top: 15px; background: #fafafa; border-radius: 5px;\"><span class=\"hljs-keyword\" style=\"color: #a626a4; line-height: 26px;\">var</span>&nbsp;loggedObj&nbsp;=&nbsp;<span class=\"hljs-keyword\" style=\"color: #a626a4; line-height: 26px;\">new</span>&nbsp;<span class=\"hljs-built_in\" style=\"color: #c18401; line-height: 26px;\">Proxy</span>(obj,&nbsp;{<br>&nbsp;&nbsp;<span class=\"hljs-keyword\" style=\"color: #a626a4; line-height: 26px;\">get</span>(target,&nbsp;name)&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;<span class=\"hljs-built_in\" style=\"color: #c18401; line-height: 26px;\">console</span>.log(<span class=\"hljs-string\" style=\"color: #50a14f; line-height: 26px;\">\"get\"</span>,&nbsp;target,&nbsp;name);<br>&nbsp;&nbsp;&nbsp;&nbsp;<span class=\"hljs-keyword\" style=\"color: #a626a4; line-height: 26px;\">return</span>&nbsp;<span class=\"hljs-built_in\" style=\"color: #c18401; line-height: 26px;\">Reflect</span>.get(target,&nbsp;name);<br>&nbsp;&nbsp;},<br>&nbsp;&nbsp;deleteProperty(target,&nbsp;name)&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;<span class=\"hljs-built_in\" style=\"color: #c18401; line-height: 26px;\">console</span>.log(<span class=\"hljs-string\" style=\"color: #50a14f; line-height: 26px;\">\"delete\"</span>&nbsp;+&nbsp;name);<br>&nbsp;&nbsp;&nbsp;&nbsp;<span class=\"hljs-keyword\" style=\"color: #a626a4; line-height: 26px;\">return</span>&nbsp;<span class=\"hljs-built_in\" style=\"color: #c18401; line-height: 26px;\">Reflect</span>.deleteProperty(target,&nbsp;name);<br>&nbsp;&nbsp;},<br>&nbsp;&nbsp;has(target,&nbsp;name)&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;<span class=\"hljs-built_in\" style=\"color: #c18401; line-height: 26px;\">console</span>.log(<span class=\"hljs-string\" style=\"color: #50a14f; line-height: 26px;\">\"has\"</span>&nbsp;+&nbsp;name);<br>&nbsp;&nbsp;&nbsp;&nbsp;<span class=\"hljs-keyword\" style=\"color: #a626a4; line-height: 26px;\">return</span>&nbsp;<span class=\"hljs-built_in\" style=\"color: #c18401; line-height: 26px;\">Reflect</span>.has(target,&nbsp;name);<br>&nbsp;&nbsp;},<br>});<br></code></pre>\n<p data-tool=\"mdnice编辑器\" style=\"padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: #595959; margin: 10px 0px; letter-spacing: 2px; font-size: 14px; word-spacing: 2px;\">上面代码中，每一个 Proxy 对象的拦截操作（get、delete、has），内部都调用对应的 Reflect 方法，保证原生行为能够正常执行。添加的工作，就是将每一个操作输出一行日志。</p>\n<h2 data-tool=\"mdnice编辑器\" style=\"margin-top: 30px; margin-bottom: 15px; padding: 0px; font-weight: bold; color: black; font-size: 22px; text-align: left; margin: 20px 10px 0px 0px;\"><span class=\"prefix\" style=\"display: none;\"></span><span class=\"content\" style=\"font-size: 18px; font-weight: bold; display: inline-block; padding-left: 10px; border-left: 5px solid #DEC6FB; color: #595959;\">2、静态 API</span><span class=\"suffix\"></span></h2>\n<p data-tool=\"mdnice编辑器\" style=\"padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: #595959; margin: 10px 0px; letter-spacing: 2px; font-size: 14px; word-spacing: 2px;\">Reflect 拥有 13 个静态 API，其大部分与 Object 对象的同名方法的作用都是相同的，而且它与 Proxy 对象的方法是一一对应的。</p>\n<h3 data-tool=\"mdnice编辑器\" style=\"margin-top: 30px; margin-bottom: 15px; padding: 0px; color: black; font-size: 16px; font-weight: bold; text-align: center;\"><span class=\"prefix\" style=\"display: none;\"></span><span class=\"content\" style=\"border-bottom: 2px solid #DEC6FB; color: #595959;\">2.1、Reflect.apply()</span><span class=\"suffix\" style=\"display: none;\"></span></h3>\n<p data-tool=\"mdnice编辑器\" style=\"padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: #595959; margin: 10px 0px; letter-spacing: 2px; font-size: 14px; word-spacing: 2px;\">通过指定的参数列表发起对目标(target)函数的调用。该方法接受是三个参数，target：目标函数。thisArgument：target 函数调用时绑定的 this 对象。argumentsList：target 函数调用时传入的实参列表，该参数应该是一个类数组的对象。</p>\n<p data-tool=\"mdnice编辑器\" style=\"padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: #595959; margin: 10px 0px; letter-spacing: 2px; font-size: 14px; word-spacing: 2px;\">该方法与 ES5 中 Function.prototype.apply()方法类似，Reflect.apply()可以让代码看起来更加的通俗易懂。</p>\n<pre class=\"custom\" data-tool=\"mdnice编辑器\" style=\"margin-top: 10px; margin-bottom: 10px; border-radius: 5px; box-shadow: rgba(0, 0, 0, 0.55) 0px 2px 10px;\"><span style=\"display: block; background: url(https://my-wechat.mdnice.com/point.png); height: 30px; width: 100%; background-size: 40px; background-repeat: no-repeat; background-color: #fafafa; margin-bottom: -7px; border-radius: 5px; background-position: 10px 10px;\"></span><code class=\"hljs\" style=\"overflow-x: auto; padding: 16px; color: #383a42; display: -webkit-box; font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; font-size: 12px; -webkit-overflow-scrolling: touch; padding-top: 15px; background: #fafafa; border-radius: 5px;\"><span class=\"hljs-built_in\" style=\"color: #c18401; line-height: 26px;\">Function</span>.prototype.apply.call(<span class=\"hljs-built_in\" style=\"color: #c18401; line-height: 26px;\">Math</span>.floor,&nbsp;<span class=\"hljs-literal\" style=\"color: #0184bb; line-height: 26px;\">undefined</span>,&nbsp;[<span class=\"hljs-number\" style=\"color: #986801; line-height: 26px;\">1.75</span>]);<br><span class=\"hljs-built_in\" style=\"color: #c18401; line-height: 26px;\">Reflect</span>.apply(<span class=\"hljs-built_in\" style=\"color: #c18401; line-height: 26px;\">Math</span>.floor,&nbsp;<span class=\"hljs-literal\" style=\"color: #0184bb; line-height: 26px;\">undefined</span>,&nbsp;[<span class=\"hljs-number\" style=\"color: #986801; line-height: 26px;\">1.75</span>]);<br></code></pre>\n<h3 data-tool=\"mdnice编辑器\" style=\"margin-top: 30px; margin-bottom: 15px; padding: 0px; color: black; font-size: 16px; font-weight: bold; text-align: center;\"><span class=\"prefix\" style=\"display: none;\"></span><span class=\"content\" style=\"border-bottom: 2px solid #DEC6FB; color: #595959;\">2.2、Reflect.construct()</span><span class=\"suffix\" style=\"display: none;\"></span></h3>\n<p data-tool=\"mdnice编辑器\" style=\"padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: #595959; margin: 10px 0px; letter-spacing: 2px; font-size: 14px; word-spacing: 2px;\">该方法的行为有点像 new 操作符 构造函数 ， 相当于运行 new target(...args)。该方法接受三个参数，target：被运行的目标构造函数。argumentsList：类数组，目标构造函数调用时的参数。newTarget（可选）：作为新创建对象的原型对象的 constructor 属性， 参考 new.target 操作符，默认值为 target。</p>\n<pre class=\"custom\" data-tool=\"mdnice编辑器\" style=\"margin-top: 10px; margin-bottom: 10px; border-radius: 5px; box-shadow: rgba(0, 0, 0, 0.55) 0px 2px 10px;\"><span style=\"display: block; background: url(https://my-wechat.mdnice.com/point.png); height: 30px; width: 100%; background-size: 40px; background-repeat: no-repeat; background-color: #fafafa; margin-bottom: -7px; border-radius: 5px; background-position: 10px 10px;\"></span><code class=\"hljs\" style=\"overflow-x: auto; padding: 16px; color: #383a42; display: -webkit-box; font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; font-size: 12px; -webkit-overflow-scrolling: touch; padding-top: 15px; background: #fafafa; border-radius: 5px;\"><span class=\"hljs-class\" style=\"line-height: 26px;\"><span class=\"hljs-keyword\" style=\"color: #a626a4; line-height: 26px;\">class</span>&nbsp;<span class=\"hljs-title\" style=\"color: #c18401; line-height: 26px;\">Person</span>&nbsp;</span>{<br>&nbsp;&nbsp;<span class=\"hljs-keyword\" style=\"color: #a626a4; line-height: 26px;\">constructor</span>(name)&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;<span class=\"hljs-keyword\" style=\"color: #a626a4; line-height: 26px;\">this</span>.name&nbsp;=&nbsp;name;<br>&nbsp;&nbsp;}<br>}<br><span class=\"hljs-keyword\" style=\"color: #a626a4; line-height: 26px;\">let</span>&nbsp;person&nbsp;=&nbsp;<span class=\"hljs-keyword\" style=\"color: #a626a4; line-height: 26px;\">new</span>&nbsp;Person(<span class=\"hljs-string\" style=\"color: #50a14f; line-height: 26px;\">\"Jack\"</span>);<br><span class=\"hljs-comment\" style=\"color: #a0a1a7; font-style: italic; line-height: 26px;\">//&nbsp;等价于</span><br><span class=\"hljs-keyword\" style=\"color: #a626a4; line-height: 26px;\">let</span>&nbsp;person&nbsp;=&nbsp;<span class=\"hljs-built_in\" style=\"color: #c18401; line-height: 26px;\">Reflect</span>.construct(Person,&nbsp;[<span class=\"hljs-string\" style=\"color: #50a14f; line-height: 26px;\">\"Jack\"</span>]);<br></code></pre>\n<h3 data-tool=\"mdnice编辑器\" style=\"margin-top: 30px; margin-bottom: 15px; padding: 0px; color: black; font-size: 16px; font-weight: bold; text-align: center;\"><span class=\"prefix\" style=\"display: none;\"></span><span class=\"content\" style=\"border-bottom: 2px solid #DEC6FB; color: #595959;\">2.3、Reflect.defineProperty()</span><span class=\"suffix\" style=\"display: none;\"></span></h3>\n<p data-tool=\"mdnice编辑器\" style=\"padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: #595959; margin: 10px 0px; letter-spacing: 2px; font-size: 14px; word-spacing: 2px;\">基本等同于 Object.defineProperty() 方法，唯一不同是返回 Boolean 值。该方法接受三个参数，target：目标对象。propertyKey：要定义或修改的属性的名称。attributes：要定义或修改的属性的描述。</p>\n<pre class=\"custom\" data-tool=\"mdnice编辑器\" style=\"margin-top: 10px; margin-bottom: 10px; border-radius: 5px; box-shadow: rgba(0, 0, 0, 0.55) 0px 2px 10px;\"><span style=\"display: block; background: url(https://my-wechat.mdnice.com/point.png); height: 30px; width: 100%; background-size: 40px; background-repeat: no-repeat; background-color: #fafafa; margin-bottom: -7px; border-radius: 5px; background-position: 10px 10px;\"></span><code class=\"hljs\" style=\"overflow-x: auto; padding: 16px; color: #383a42; display: -webkit-box; font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; font-size: 12px; -webkit-overflow-scrolling: touch; padding-top: 15px; background: #fafafa; border-radius: 5px;\"><span class=\"hljs-keyword\" style=\"color: #a626a4; line-height: 26px;\">let</span>&nbsp;obj&nbsp;=&nbsp;{};<br><span class=\"hljs-built_in\" style=\"color: #c18401; line-height: 26px;\">Object</span>.defineProperty({},&nbsp;<span class=\"hljs-string\" style=\"color: #50a14f; line-height: 26px;\">\"value\"</span>,&nbsp;{<br>&nbsp;&nbsp;<span class=\"hljs-attr\" style=\"color: #986801; line-height: 26px;\">value</span>:&nbsp;<span class=\"hljs-string\" style=\"color: #50a14f; line-height: 26px;\">\"18\"</span>,<br>});<br><span class=\"hljs-comment\" style=\"color: #a0a1a7; font-style: italic; line-height: 26px;\">//&nbsp;等价于</span><br><span class=\"hljs-built_in\" style=\"color: #c18401; line-height: 26px;\">Reflect</span>.defineProperty({},&nbsp;<span class=\"hljs-string\" style=\"color: #50a14f; line-height: 26px;\">\"value\"</span>,&nbsp;{<br>&nbsp;&nbsp;<span class=\"hljs-attr\" style=\"color: #986801; line-height: 26px;\">value</span>:&nbsp;<span class=\"hljs-string\" style=\"color: #50a14f; line-height: 26px;\">\"18\"</span>,<br>});<br></code></pre>\n<h3 data-tool=\"mdnice编辑器\" style=\"margin-top: 30px; margin-bottom: 15px; padding: 0px; color: black; font-size: 16px; font-weight: bold; text-align: center;\"><span class=\"prefix\" style=\"display: none;\"></span><span class=\"content\" style=\"border-bottom: 2px solid #DEC6FB; color: #595959;\">2.4、Reflect.deleteProperty()</span><span class=\"suffix\" style=\"display: none;\"></span></h3>\n<p data-tool=\"mdnice编辑器\" style=\"padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: #595959; margin: 10px 0px; letter-spacing: 2px; font-size: 14px; word-spacing: 2px;\">允许用于删除属性。它很像 delete operator ，但它是一个函数。该方法接受两个参数，target：删除属性的目标对象。propertyKey：需要删除的属性的名称。</p>\n<pre class=\"custom\" data-tool=\"mdnice编辑器\" style=\"margin-top: 10px; margin-bottom: 10px; border-radius: 5px; box-shadow: rgba(0, 0, 0, 0.55) 0px 2px 10px;\"><span style=\"display: block; background: url(https://my-wechat.mdnice.com/point.png); height: 30px; width: 100%; background-size: 40px; background-repeat: no-repeat; background-color: #fafafa; margin-bottom: -7px; border-radius: 5px; background-position: 10px 10px;\"></span><code class=\"hljs\" style=\"overflow-x: auto; padding: 16px; color: #383a42; display: -webkit-box; font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; font-size: 12px; -webkit-overflow-scrolling: touch; padding-top: 15px; background: #fafafa; border-radius: 5px;\"><span class=\"hljs-keyword\" style=\"color: #a626a4; line-height: 26px;\">let</span>&nbsp;obj&nbsp;=&nbsp;{<br>&nbsp;&nbsp;<span class=\"hljs-attr\" style=\"color: #986801; line-height: 26px;\">value</span>:&nbsp;<span class=\"hljs-string\" style=\"color: #50a14f; line-height: 26px;\">\"18\"</span>,<br>};<br><span class=\"hljs-keyword\" style=\"color: #a626a4; line-height: 26px;\">delete</span>&nbsp;obj[<span class=\"hljs-string\" style=\"color: #50a14f; line-height: 26px;\">\"value\"</span>];<br><span class=\"hljs-comment\" style=\"color: #a0a1a7; font-style: italic; line-height: 26px;\">//&nbsp;等价于</span><br><span class=\"hljs-built_in\" style=\"color: #c18401; line-height: 26px;\">Reflect</span>.deleteProperty(obj,&nbsp;<span class=\"hljs-string\" style=\"color: #50a14f; line-height: 26px;\">\"value\"</span>);<br></code></pre>\n<h3 data-tool=\"mdnice编辑器\" style=\"margin-top: 30px; margin-bottom: 15px; padding: 0px; color: black; font-size: 16px; font-weight: bold; text-align: center;\"><span class=\"prefix\" style=\"display: none;\"></span><span class=\"content\" style=\"border-bottom: 2px solid #DEC6FB; color: #595959;\">2.5、Reflect.get()</span><span class=\"suffix\" style=\"display: none;\"></span></h3>\n<p data-tool=\"mdnice编辑器\" style=\"padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: #595959; margin: 10px 0px; letter-spacing: 2px; font-size: 14px; word-spacing: 2px;\">该方法与从 对象 (target[propertyKey]) 中读取属性类似，但它是通过一个函数执行来操作的。该方法接受三个参数，target：需要取值的目标对象。propertyKey：需要获取的值的键值。receiver：如果 target 对象中指定了 getter，receiver 则为 getter 调用时的 this 值。值得注意的是如果 target 不是对象的话，则会报错。</p>\n<pre class=\"custom\" data-tool=\"mdnice编辑器\" style=\"margin-top: 10px; margin-bottom: 10px; border-radius: 5px; box-shadow: rgba(0, 0, 0, 0.55) 0px 2px 10px;\"><span style=\"display: block; background: url(https://my-wechat.mdnice.com/point.png); height: 30px; width: 100%; background-size: 40px; background-repeat: no-repeat; background-color: #fafafa; margin-bottom: -7px; border-radius: 5px; background-position: 10px 10px;\"></span><code class=\"hljs\" style=\"overflow-x: auto; padding: 16px; color: #383a42; display: -webkit-box; font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; font-size: 12px; -webkit-overflow-scrolling: touch; padding-top: 15px; background: #fafafa; border-radius: 5px;\"><span class=\"hljs-keyword\" style=\"color: #a626a4; line-height: 26px;\">let</span>&nbsp;obj&nbsp;=&nbsp;{<br>&nbsp;&nbsp;<span class=\"hljs-attr\" style=\"color: #986801; line-height: 26px;\">value</span>:&nbsp;<span class=\"hljs-string\" style=\"color: #50a14f; line-height: 26px;\">\"18\"</span>,<br>};<br><span class=\"hljs-built_in\" style=\"color: #c18401; line-height: 26px;\">Reflect</span>.get(obj,&nbsp;<span class=\"hljs-string\" style=\"color: #50a14f; line-height: 26px;\">\"value\"</span>);&nbsp;<span class=\"hljs-comment\" style=\"color: #a0a1a7; font-style: italic; line-height: 26px;\">//&nbsp;18</span><br><span class=\"hljs-comment\" style=\"color: #a0a1a7; font-style: italic; line-height: 26px;\">//&nbsp;当有getter函数时</span><br><span class=\"hljs-keyword\" style=\"color: #a626a4; line-height: 26px;\">let</span>&nbsp;obj&nbsp;=&nbsp;{<br>&nbsp;&nbsp;<span class=\"hljs-attr\" style=\"color: #986801; line-height: 26px;\">value</span>:&nbsp;<span class=\"hljs-string\" style=\"color: #50a14f; line-height: 26px;\">\"18\"</span>,<br>&nbsp;&nbsp;<span class=\"hljs-keyword\" style=\"color: #a626a4; line-height: 26px;\">get</span>&nbsp;foo()&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;<span class=\"hljs-keyword\" style=\"color: #a626a4; line-height: 26px;\">return</span>&nbsp;<span class=\"hljs-keyword\" style=\"color: #a626a4; line-height: 26px;\">this</span>.a&nbsp;+&nbsp;<span class=\"hljs-keyword\" style=\"color: #a626a4; line-height: 26px;\">this</span>.b;<br>&nbsp;&nbsp;},<br>};<br><span class=\"hljs-keyword\" style=\"color: #a626a4; line-height: 26px;\">let</span>&nbsp;foo&nbsp;=&nbsp;{<br>&nbsp;&nbsp;<span class=\"hljs-attr\" style=\"color: #986801; line-height: 26px;\">a</span>:&nbsp;<span class=\"hljs-number\" style=\"color: #986801; line-height: 26px;\">2</span>,<br>&nbsp;&nbsp;<span class=\"hljs-attr\" style=\"color: #986801; line-height: 26px;\">b</span>:&nbsp;<span class=\"hljs-number\" style=\"color: #986801; line-height: 26px;\">3</span>,<br>};<br><span class=\"hljs-built_in\" style=\"color: #c18401; line-height: 26px;\">Reflect</span>.get(obj,&nbsp;<span class=\"hljs-string\" style=\"color: #50a14f; line-height: 26px;\">\"foo\"</span>,&nbsp;foo);&nbsp;<span class=\"hljs-comment\" style=\"color: #a0a1a7; font-style: italic; line-height: 26px;\">//&nbsp;5</span><br></code></pre>\n<h3 data-tool=\"mdnice编辑器\" style=\"margin-top: 30px; margin-bottom: 15px; padding: 0px; color: black; font-size: 16px; font-weight: bold; text-align: center;\"><span class=\"prefix\" style=\"display: none;\"></span><span class=\"content\" style=\"border-bottom: 2px solid #DEC6FB; color: #595959;\">2.6、Reflect.getOwnPropertyDescriptor()</span><span class=\"suffix\" style=\"display: none;\"></span></h3>\n<p data-tool=\"mdnice编辑器\" style=\"padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: #595959; margin: 10px 0px; letter-spacing: 2px; font-size: 14px; word-spacing: 2px;\">该方法与 Object.getOwnPropertyDescriptor() 方法相似。如果在对象中存在，则返回给定的属性的属性描述符。否则返回 undefined。该方法接受两个参数，target：需要寻找属性的目标对象。propertyKey：获取自己的属性描述符的属性的名称。值得注意的是如果 target 不是对象的话，会报错。</p>\n<pre class=\"custom\" data-tool=\"mdnice编辑器\" style=\"margin-top: 10px; margin-bottom: 10px; border-radius: 5px; box-shadow: rgba(0, 0, 0, 0.55) 0px 2px 10px;\"><span style=\"display: block; background: url(https://my-wechat.mdnice.com/point.png); height: 30px; width: 100%; background-size: 40px; background-repeat: no-repeat; background-color: #fafafa; margin-bottom: -7px; border-radius: 5px; background-position: 10px 10px;\"></span><code class=\"hljs\" style=\"overflow-x: auto; padding: 16px; color: #383a42; display: -webkit-box; font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; font-size: 12px; -webkit-overflow-scrolling: touch; padding-top: 15px; background: #fafafa; border-radius: 5px;\"><span class=\"hljs-keyword\" style=\"color: #a626a4; line-height: 26px;\">var</span>&nbsp;myObject&nbsp;=&nbsp;{};<br><span class=\"hljs-built_in\" style=\"color: #c18401; line-height: 26px;\">Object</span>.defineProperty(myObject,&nbsp;<span class=\"hljs-string\" style=\"color: #50a14f; line-height: 26px;\">\"hidden\"</span>,&nbsp;{<br>&nbsp;&nbsp;<span class=\"hljs-attr\" style=\"color: #986801; line-height: 26px;\">value</span>:&nbsp;<span class=\"hljs-literal\" style=\"color: #0184bb; line-height: 26px;\">true</span>,<br>&nbsp;&nbsp;<span class=\"hljs-attr\" style=\"color: #986801; line-height: 26px;\">enumerable</span>:&nbsp;<span class=\"hljs-literal\" style=\"color: #0184bb; line-height: 26px;\">false</span>,<br>});<br><span class=\"hljs-keyword\" style=\"color: #a626a4; line-height: 26px;\">var</span>&nbsp;theDescriptor&nbsp;=&nbsp;<span class=\"hljs-built_in\" style=\"color: #c18401; line-height: 26px;\">Object</span>.getOwnPropertyDescriptor(myObject,&nbsp;<span class=\"hljs-string\" style=\"color: #50a14f; line-height: 26px;\">\"hidden\"</span>);<br><span class=\"hljs-comment\" style=\"color: #a0a1a7; font-style: italic; line-height: 26px;\">//&nbsp;等价于</span><br><span class=\"hljs-keyword\" style=\"color: #a626a4; line-height: 26px;\">var</span>&nbsp;theDescriptor&nbsp;=&nbsp;<span class=\"hljs-built_in\" style=\"color: #c18401; line-height: 26px;\">Reflect</span>.getOwnPropertyDescriptor(myObject,&nbsp;<span class=\"hljs-string\" style=\"color: #50a14f; line-height: 26px;\">\"hidden\"</span>);<br></code></pre>\n<h3 data-tool=\"mdnice编辑器\" style=\"margin-top: 30px; margin-bottom: 15px; padding: 0px; color: black; font-size: 16px; font-weight: bold; text-align: center;\"><span class=\"prefix\" style=\"display: none;\"></span><span class=\"content\" style=\"border-bottom: 2px solid #DEC6FB; color: #595959;\">2.7、Reflect.getPrototypeOf()</span><span class=\"suffix\" style=\"display: none;\"></span></h3>\n<p data-tool=\"mdnice编辑器\" style=\"padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: #595959; margin: 10px 0px; letter-spacing: 2px; font-size: 14px; word-spacing: 2px;\">该方法与 Object.getPrototypeOf() 方法几乎是一样的。都是返回指定对象的原型（即内部的 [[Prototype]] 属性的值）。该方法只能接受一个参数，target：获取原型的目标对象。注意得是如果 target 不是对象的话，会报错。</p>\n<pre class=\"custom\" data-tool=\"mdnice编辑器\" style=\"margin-top: 10px; margin-bottom: 10px; border-radius: 5px; box-shadow: rgba(0, 0, 0, 0.55) 0px 2px 10px;\"><span style=\"display: block; background: url(https://my-wechat.mdnice.com/point.png); height: 30px; width: 100%; background-size: 40px; background-repeat: no-repeat; background-color: #fafafa; margin-bottom: -7px; border-radius: 5px; background-position: 10px 10px;\"></span><code class=\"hljs\" style=\"overflow-x: auto; padding: 16px; color: #383a42; display: -webkit-box; font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; font-size: 12px; -webkit-overflow-scrolling: touch; padding-top: 15px; background: #fafafa; border-radius: 5px;\"><span class=\"hljs-class\" style=\"line-height: 26px;\"><span class=\"hljs-keyword\" style=\"color: #a626a4; line-height: 26px;\">class</span>&nbsp;<span class=\"hljs-title\" style=\"color: #c18401; line-height: 26px;\">MyObj</span>&nbsp;</span>{}<br><span class=\"hljs-keyword\" style=\"color: #a626a4; line-height: 26px;\">let</span>&nbsp;myObj&nbsp;=&nbsp;<span class=\"hljs-keyword\" style=\"color: #a626a4; line-height: 26px;\">new</span>&nbsp;MyObj();<br><span class=\"hljs-built_in\" style=\"color: #c18401; line-height: 26px;\">Object</span>.getPrototypeOf(myObj)&nbsp;===&nbsp;MyObj.prototype;&nbsp;<span class=\"hljs-comment\" style=\"color: #a0a1a7; font-style: italic; line-height: 26px;\">//&nbsp;true</span><br><span class=\"hljs-comment\" style=\"color: #a0a1a7; font-style: italic; line-height: 26px;\">//&nbsp;等价于</span><br><span class=\"hljs-built_in\" style=\"color: #c18401; line-height: 26px;\">Reflect</span>.getPrototypeOf(myObj)&nbsp;===&nbsp;MyObj.prototype;&nbsp;<span class=\"hljs-comment\" style=\"color: #a0a1a7; font-style: italic; line-height: 26px;\">//&nbsp;true</span><br></code></pre>\n<h3 data-tool=\"mdnice编辑器\" style=\"margin-top: 30px; margin-bottom: 15px; padding: 0px; color: black; font-size: 16px; font-weight: bold; text-align: center;\"><span class=\"prefix\" style=\"display: none;\"></span><span class=\"content\" style=\"border-bottom: 2px solid #DEC6FB; color: #595959;\">2.8、Reflect.has()</span><span class=\"suffix\" style=\"display: none;\"></span></h3>\n<p data-tool=\"mdnice编辑器\" style=\"padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: #595959; margin: 10px 0px; letter-spacing: 2px; font-size: 14px; word-spacing: 2px;\">作用与 in 操作符 相同。该方法接受两个参数，target：目标对象。propertyKey：属性名，需要检查目标对象是否存在此属性。注意，如果目标对象并非 Object 类型，则会报错。</p>\n<pre class=\"custom\" data-tool=\"mdnice编辑器\" style=\"margin-top: 10px; margin-bottom: 10px; border-radius: 5px; box-shadow: rgba(0, 0, 0, 0.55) 0px 2px 10px;\"><span style=\"display: block; background: url(https://my-wechat.mdnice.com/point.png); height: 30px; width: 100%; background-size: 40px; background-repeat: no-repeat; background-color: #fafafa; margin-bottom: -7px; border-radius: 5px; background-position: 10px 10px;\"></span><code class=\"hljs\" style=\"overflow-x: auto; padding: 16px; color: #383a42; display: -webkit-box; font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; font-size: 12px; -webkit-overflow-scrolling: touch; padding-top: 15px; background: #fafafa; border-radius: 5px;\"><span class=\"hljs-keyword\" style=\"color: #a626a4; line-height: 26px;\">let</span>&nbsp;obj&nbsp;=&nbsp;{<br>&nbsp;&nbsp;<span class=\"hljs-attr\" style=\"color: #986801; line-height: 26px;\">value</span>:&nbsp;<span class=\"hljs-string\" style=\"color: #50a14f; line-height: 26px;\">\"18\"</span>,<br>};<br><span class=\"hljs-string\" style=\"color: #50a14f; line-height: 26px;\">\"value\"</span>&nbsp;<span class=\"hljs-keyword\" style=\"color: #a626a4; line-height: 26px;\">in</span>&nbsp;obj;&nbsp;<span class=\"hljs-comment\" style=\"color: #a0a1a7; font-style: italic; line-height: 26px;\">//&nbsp;true</span><br><span class=\"hljs-comment\" style=\"color: #a0a1a7; font-style: italic; line-height: 26px;\">//&nbsp;等价于</span><br><span class=\"hljs-built_in\" style=\"color: #c18401; line-height: 26px;\">Reflect</span>.has(obj,&nbsp;<span class=\"hljs-string\" style=\"color: #50a14f; line-height: 26px;\">\"value\"</span>);&nbsp;<span class=\"hljs-comment\" style=\"color: #a0a1a7; font-style: italic; line-height: 26px;\">//&nbsp;ture</span><br></code></pre>\n<h3 data-tool=\"mdnice编辑器\" style=\"margin-top: 30px; margin-bottom: 15px; padding: 0px; color: black; font-size: 16px; font-weight: bold; text-align: center;\"><span class=\"prefix\" style=\"display: none;\"></span><span class=\"content\" style=\"border-bottom: 2px solid #DEC6FB; color: #595959;\">2.9、Reflect.isExtensible()</span><span class=\"suffix\" style=\"display: none;\"></span></h3>\n<p data-tool=\"mdnice编辑器\" style=\"padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: #595959; margin: 10px 0px; letter-spacing: 2px; font-size: 14px; word-spacing: 2px;\">判断一个对象是否可扩展 （即是否能够添加新的属性）。与它 Object.isExtensible() 方法相似，但有一些不同，如果该方法的第一个参数不是一个对象（原始值），那么将会报错。对于 Object.isExtensible()，非对象的第一个参数会被强制转换为一个对象。该方法只接受一个参数，target：检查是否可扩展的目标对象。</p>\n<pre class=\"custom\" data-tool=\"mdnice编辑器\" style=\"margin-top: 10px; margin-bottom: 10px; border-radius: 5px; box-shadow: rgba(0, 0, 0, 0.55) 0px 2px 10px;\"><span style=\"display: block; background: url(https://my-wechat.mdnice.com/point.png); height: 30px; width: 100%; background-size: 40px; background-repeat: no-repeat; background-color: #fafafa; margin-bottom: -7px; border-radius: 5px; background-position: 10px 10px;\"></span><code class=\"hljs\" style=\"overflow-x: auto; padding: 16px; color: #383a42; display: -webkit-box; font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; font-size: 12px; -webkit-overflow-scrolling: touch; padding-top: 15px; background: #fafafa; border-radius: 5px;\"><span class=\"hljs-keyword\" style=\"color: #a626a4; line-height: 26px;\">let</span>&nbsp;obj&nbsp;=&nbsp;{};<br><span class=\"hljs-built_in\" style=\"color: #c18401; line-height: 26px;\">Object</span>.isExtensible(obj);&nbsp;<span class=\"hljs-comment\" style=\"color: #a0a1a7; font-style: italic; line-height: 26px;\">//&nbsp;true</span><br><span class=\"hljs-comment\" style=\"color: #a0a1a7; font-style: italic; line-height: 26px;\">//&nbsp;等价于</span><br><span class=\"hljs-built_in\" style=\"color: #c18401; line-height: 26px;\">Reflect</span>.isExtensible(obj);&nbsp;<span class=\"hljs-comment\" style=\"color: #a0a1a7; font-style: italic; line-height: 26px;\">//&nbsp;true</span><br></code></pre>\n<h3 data-tool=\"mdnice编辑器\" style=\"margin-top: 30px; margin-bottom: 15px; padding: 0px; color: black; font-size: 16px; font-weight: bold; text-align: center;\"><span class=\"prefix\" style=\"display: none;\"></span><span class=\"content\" style=\"border-bottom: 2px solid #DEC6FB; color: #595959;\">2.10、Reflect.ownKeys()</span><span class=\"suffix\" style=\"display: none;\"></span></h3>\n<p data-tool=\"mdnice编辑器\" style=\"padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: #595959; margin: 10px 0px; letter-spacing: 2px; font-size: 14px; word-spacing: 2px;\">返回一个由目标对象自身的属性键组成的数组。该方法接受一个参数，target：获取自身属性键的目标对象。返回一个由目标对象的自身属性键组成的 Array。返回值等同于 Object.getOwnPropertyNames(target).concat(Object.getOwnPropertySymbols(target))。</p>\n<pre class=\"custom\" data-tool=\"mdnice编辑器\" style=\"margin-top: 10px; margin-bottom: 10px; border-radius: 5px; box-shadow: rgba(0, 0, 0, 0.55) 0px 2px 10px;\"><span style=\"display: block; background: url(https://my-wechat.mdnice.com/point.png); height: 30px; width: 100%; background-size: 40px; background-repeat: no-repeat; background-color: #fafafa; margin-bottom: -7px; border-radius: 5px; background-position: 10px 10px;\"></span><code class=\"hljs\" style=\"overflow-x: auto; padding: 16px; color: #383a42; display: -webkit-box; font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; font-size: 12px; -webkit-overflow-scrolling: touch; padding-top: 15px; background: #fafafa; border-radius: 5px;\"><span class=\"hljs-keyword\" style=\"color: #a626a4; line-height: 26px;\">let</span>&nbsp;myObject&nbsp;=&nbsp;{<br>&nbsp;&nbsp;<span class=\"hljs-attr\" style=\"color: #986801; line-height: 26px;\">foo</span>:&nbsp;<span class=\"hljs-number\" style=\"color: #986801; line-height: 26px;\">1</span>,<br>&nbsp;&nbsp;<span class=\"hljs-attr\" style=\"color: #986801; line-height: 26px;\">bar</span>:&nbsp;<span class=\"hljs-number\" style=\"color: #986801; line-height: 26px;\">2</span>,<br>&nbsp;&nbsp;[<span class=\"hljs-built_in\" style=\"color: #c18401; line-height: 26px;\">Symbol</span>.for(<span class=\"hljs-string\" style=\"color: #50a14f; line-height: 26px;\">\"baz\"</span>)]:&nbsp;<span class=\"hljs-number\" style=\"color: #986801; line-height: 26px;\">3</span>,<br>&nbsp;&nbsp;[<span class=\"hljs-built_in\" style=\"color: #c18401; line-height: 26px;\">Symbol</span>.for(<span class=\"hljs-string\" style=\"color: #50a14f; line-height: 26px;\">\"bing\"</span>)]:&nbsp;<span class=\"hljs-number\" style=\"color: #986801; line-height: 26px;\">4</span>,<br>};<br><br><span class=\"hljs-built_in\" style=\"color: #c18401; line-height: 26px;\">Object</span>.getOwnPropertyNames(myObject).concat(<br>&nbsp;&nbsp;<span class=\"hljs-built_in\" style=\"color: #c18401; line-height: 26px;\">Object</span>.getOwnPropertySymbols(myObject)<br>);<br><span class=\"hljs-comment\" style=\"color: #a0a1a7; font-style: italic; line-height: 26px;\">//&nbsp;等价于</span><br><span class=\"hljs-built_in\" style=\"color: #c18401; line-height: 26px;\">Reflect</span>.ownKeys(myObject);&nbsp;<span class=\"hljs-comment\" style=\"color: #a0a1a7; font-style: italic; line-height: 26px;\">//&nbsp;['foo',&nbsp;'bar',&nbsp;Symbol(baz),&nbsp;Symbol(bing)]</span><br></code></pre>\n<h3 data-tool=\"mdnice编辑器\" style=\"margin-top: 30px; margin-bottom: 15px; padding: 0px; color: black; font-size: 16px; font-weight: bold; text-align: center;\"><span class=\"prefix\" style=\"display: none;\"></span><span class=\"content\" style=\"border-bottom: 2px solid #DEC6FB; color: #595959;\">2.11、Reflect.preventExtensions()</span><span class=\"suffix\" style=\"display: none;\"></span></h3>\n<p data-tool=\"mdnice编辑器\" style=\"padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: #595959; margin: 10px 0px; letter-spacing: 2px; font-size: 14px; word-spacing: 2px;\">该方法阻止新属性添加到对象 (例如：防止将来对对象的扩展被添加到对象中)。该方法与 Object.preventExtensions()相似，但有一些不同点。该方法接受一个参数，target：阻止扩展的目标对象。</p>\n<pre class=\"custom\" data-tool=\"mdnice编辑器\" style=\"margin-top: 10px; margin-bottom: 10px; border-radius: 5px; box-shadow: rgba(0, 0, 0, 0.55) 0px 2px 10px;\"><span style=\"display: block; background: url(https://my-wechat.mdnice.com/point.png); height: 30px; width: 100%; background-size: 40px; background-repeat: no-repeat; background-color: #fafafa; margin-bottom: -7px; border-radius: 5px; background-position: 10px 10px;\"></span><code class=\"hljs\" style=\"overflow-x: auto; padding: 16px; color: #383a42; display: -webkit-box; font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; font-size: 12px; -webkit-overflow-scrolling: touch; padding-top: 15px; background: #fafafa; border-radius: 5px;\"><span class=\"hljs-keyword\" style=\"color: #a626a4; line-height: 26px;\">let</span>&nbsp;obj&nbsp;=&nbsp;{};<br><span class=\"hljs-built_in\" style=\"color: #c18401; line-height: 26px;\">Object</span>.preventExtensions(obj);&nbsp;<span class=\"hljs-comment\" style=\"color: #a0a1a7; font-style: italic; line-height: 26px;\">//&nbsp;Object&nbsp;{}</span><br><span class=\"hljs-comment\" style=\"color: #a0a1a7; font-style: italic; line-height: 26px;\">//&nbsp;等价于</span><br><span class=\"hljs-built_in\" style=\"color: #c18401; line-height: 26px;\">Reflect</span>.preventExtensions(obj);&nbsp;<span class=\"hljs-comment\" style=\"color: #a0a1a7; font-style: italic; line-height: 26px;\">//&nbsp;true</span><br></code></pre>\n<h3 data-tool=\"mdnice编辑器\" style=\"margin-top: 30px; margin-bottom: 15px; padding: 0px; color: black; font-size: 16px; font-weight: bold; text-align: center;\"><span class=\"prefix\" style=\"display: none;\"></span><span class=\"content\" style=\"border-bottom: 2px solid #DEC6FB; color: #595959;\">2.12、Reflect.set()</span><span class=\"suffix\" style=\"display: none;\"></span></h3>\n<p data-tool=\"mdnice编辑器\" style=\"padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: #595959; margin: 10px 0px; letter-spacing: 2px; font-size: 14px; word-spacing: 2px;\">该方法设置 target 对象的 name 属性等于 value。该方法接受四个参数，target：设置属性的目标对象。propertyKey：设置的属性的名称。value：设置的值。receiver：如果遇到 setter，receiver 则为 setter 调用时的 this 值。</p>\n<pre class=\"custom\" data-tool=\"mdnice编辑器\" style=\"margin-top: 10px; margin-bottom: 10px; border-radius: 5px; box-shadow: rgba(0, 0, 0, 0.55) 0px 2px 10px;\"><span style=\"display: block; background: url(https://my-wechat.mdnice.com/point.png); height: 30px; width: 100%; background-size: 40px; background-repeat: no-repeat; background-color: #fafafa; margin-bottom: -7px; border-radius: 5px; background-position: 10px 10px;\"></span><code class=\"hljs\" style=\"overflow-x: auto; padding: 16px; color: #383a42; display: -webkit-box; font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; font-size: 12px; -webkit-overflow-scrolling: touch; padding-top: 15px; background: #fafafa; border-radius: 5px;\"><span class=\"hljs-keyword\" style=\"color: #a626a4; line-height: 26px;\">let</span>&nbsp;person&nbsp;=&nbsp;{<br>&nbsp;&nbsp;<span class=\"hljs-attr\" style=\"color: #986801; line-height: 26px;\">name</span>:&nbsp;<span class=\"hljs-string\" style=\"color: #50a14f; line-height: 26px;\">\"Jack\"</span>,<br>};<br>person.name;&nbsp;<span class=\"hljs-comment\" style=\"color: #a0a1a7; font-style: italic; line-height: 26px;\">//&nbsp;'Jack'</span><br><span class=\"hljs-built_in\" style=\"color: #c18401; line-height: 26px;\">Reflect</span>.set(person,&nbsp;<span class=\"hljs-string\" style=\"color: #50a14f; line-height: 26px;\">\"name\"</span>,&nbsp;<span class=\"hljs-string\" style=\"color: #50a14f; line-height: 26px;\">\"Luci\"</span>);<br>person.name;&nbsp;<span class=\"hljs-comment\" style=\"color: #a0a1a7; font-style: italic; line-height: 26px;\">//&nbsp;'Luci'</span><br><span class=\"hljs-comment\" style=\"color: #a0a1a7; font-style: italic; line-height: 26px;\">//&nbsp;当有setter函数时</span><br><span class=\"hljs-keyword\" style=\"color: #a626a4; line-height: 26px;\">let</span>&nbsp;person&nbsp;=&nbsp;{<br>&nbsp;&nbsp;<span class=\"hljs-attr\" style=\"color: #986801; line-height: 26px;\">name</span>:&nbsp;<span class=\"hljs-string\" style=\"color: #50a14f; line-height: 26px;\">\"Jack\"</span>,<br>&nbsp;&nbsp;<span class=\"hljs-keyword\" style=\"color: #a626a4; line-height: 26px;\">set</span>&nbsp;foo(value)&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;<span class=\"hljs-keyword\" style=\"color: #a626a4; line-height: 26px;\">return</span>&nbsp;(<span class=\"hljs-keyword\" style=\"color: #a626a4; line-height: 26px;\">this</span>.name&nbsp;=&nbsp;value);<br>&nbsp;&nbsp;},<br>};<br><span class=\"hljs-keyword\" style=\"color: #a626a4; line-height: 26px;\">let</span>&nbsp;receiverObject&nbsp;=&nbsp;{<br>&nbsp;&nbsp;<span class=\"hljs-attr\" style=\"color: #986801; line-height: 26px;\">name</span>:&nbsp;<span class=\"hljs-string\" style=\"color: #50a14f; line-height: 26px;\">\"Luci\"</span>,<br>};<br><span class=\"hljs-built_in\" style=\"color: #c18401; line-height: 26px;\">Reflect</span>.set(person,&nbsp;<span class=\"hljs-string\" style=\"color: #50a14f; line-height: 26px;\">\"foo\"</span>,&nbsp;<span class=\"hljs-string\" style=\"color: #50a14f; line-height: 26px;\">\"Jhon\"</span>,&nbsp;receiverObject);<br>receiverObject.name;&nbsp;<span class=\"hljs-comment\" style=\"color: #a0a1a7; font-style: italic; line-height: 26px;\">//&nbsp;Jhon</span><br></code></pre>\n<h3 data-tool=\"mdnice编辑器\" style=\"margin-top: 30px; margin-bottom: 15px; padding: 0px; color: black; font-size: 16px; font-weight: bold; text-align: center;\"><span class=\"prefix\" style=\"display: none;\"></span><span class=\"content\" style=\"border-bottom: 2px solid #DEC6FB; color: #595959;\">2.13、Reflect.setPrototypeOf()</span><span class=\"suffix\" style=\"display: none;\"></span></h3>\n<p data-tool=\"mdnice编辑器\" style=\"padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: #595959; margin: 10px 0px; letter-spacing: 2px; font-size: 14px; word-spacing: 2px;\">该方法与 Object.setPrototypeOf() 方法是一样的。它可设置对象的原型（即内部的 [[Prototype]] 属性）为另一个对象或 null，如果操作成功返回 true，否则返回 false。该方法接受两个参数，target：设置原型的目标对象。prototype：对象的新原型（一个对象或 null）。如果 target 不是对象的话将会报错。</p>\n<pre class=\"custom\" data-tool=\"mdnice编辑器\" style=\"margin-top: 10px; margin-bottom: 10px; border-radius: 5px; box-shadow: rgba(0, 0, 0, 0.55) 0px 2px 10px;\"><span style=\"display: block; background: url(https://my-wechat.mdnice.com/point.png); height: 30px; width: 100%; background-size: 40px; background-repeat: no-repeat; background-color: #fafafa; margin-bottom: -7px; border-radius: 5px; background-position: 10px 10px;\"></span><code class=\"hljs\" style=\"overflow-x: auto; padding: 16px; color: #383a42; display: -webkit-box; font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; font-size: 12px; -webkit-overflow-scrolling: touch; padding-top: 15px; background: #fafafa; border-radius: 5px;\"><span class=\"hljs-keyword\" style=\"color: #a626a4; line-height: 26px;\">const</span>&nbsp;myObj&nbsp;=&nbsp;{};<br><br><span class=\"hljs-built_in\" style=\"color: #c18401; line-height: 26px;\">Object</span>.setPrototypeOf(myObj,&nbsp;<span class=\"hljs-built_in\" style=\"color: #c18401; line-height: 26px;\">Array</span>.prototype);<br><span class=\"hljs-comment\" style=\"color: #a0a1a7; font-style: italic; line-height: 26px;\">//&nbsp;等价于</span><br><span class=\"hljs-built_in\" style=\"color: #c18401; line-height: 26px;\">Reflect</span>.setPrototypeOf(myObj,&nbsp;<span class=\"hljs-built_in\" style=\"color: #c18401; line-height: 26px;\">Array</span>.prototype);<br></code></pre>\n<h2 data-tool=\"mdnice编辑器\" style=\"margin-top: 30px; margin-bottom: 15px; padding: 0px; font-weight: bold; color: black; font-size: 22px; text-align: left; margin: 20px 10px 0px 0px;\"><span class=\"prefix\" style=\"display: none;\"></span><span class=\"content\" style=\"font-size: 18px; font-weight: bold; display: inline-block; padding-left: 10px; border-left: 5px solid #DEC6FB; color: #595959;\">参考</span><span class=\"suffix\"></span></h2>\n<p data-tool=\"mdnice编辑器\" style=\"padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: #595959; margin: 10px 0px; letter-spacing: 2px; font-size: 14px; word-spacing: 2px;\"><a href=\"https://es6.ruanyifeng.com/#docs/reflect\" style=\"text-decoration: none; word-wrap: break-word; color: #664D9D; font-weight: normal; border-bottom: 1px solid #664D9D;\">阮一峰：ECMAScript 6 入门——Reflect</a></p>\n<h2 data-tool=\"mdnice编辑器\" style=\"margin-top: 30px; margin-bottom: 15px; padding: 0px; font-weight: bold; color: black; font-size: 22px; text-align: left; margin: 20px 10px 0px 0px;\"><span class=\"prefix\" style=\"display: none;\"></span><span class=\"content\" style=\"font-size: 18px; font-weight: bold; display: inline-block; padding-left: 10px; border-left: 5px solid #DEC6FB; color: #595959;\">后语</span><span class=\"suffix\"></span></h2>\n<p data-tool=\"mdnice编辑器\" style=\"padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: #595959; margin: 10px 0px; letter-spacing: 2px; font-size: 14px; word-spacing: 2px;\">觉得还可以的，麻烦走的时候能给点个赞，大家一起学习和探讨！</p>\n<p data-tool=\"mdnice编辑器\" style=\"padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: #595959; margin: 10px 0px; letter-spacing: 2px; font-size: 14px; word-spacing: 2px;\">相关文章：</p>\n<ul data-tool=\"mdnice编辑器\" style=\"margin-top: 8px; margin-bottom: 8px; padding-left: 25px; font-size: 15px; color: #595959; list-style-type: circle;\">\n<li><section style=\"margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; font-size: 14px; font-weight: normal; color: #595959;\"><a href=\"https://juejin.im/post/5f09297b5188252e851c5fe9\" style=\"text-decoration: none; word-wrap: break-word; color: #664D9D; font-weight: normal; border-bottom: 1px solid #664D9D;\">带你重学ES6 | var、let和const的区别</a></section></li><li><section style=\"margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; font-size: 14px; font-weight: normal; color: #595959;\"><a href=\"https://juejin.im/post/5f0c0a0f5188252e8272da31\" style=\"text-decoration: none; word-wrap: break-word; color: #664D9D; font-weight: normal; border-bottom: 1px solid #664D9D;\">带你重学ES6 | Promsie</a></section></li><li><section style=\"margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; font-size: 14px; font-weight: normal; color: #595959;\"><a href=\"https://juejin.im/post/5f0d0b2ef265da22f034a0ac\" style=\"text-decoration: none; word-wrap: break-word; color: #664D9D; font-weight: normal; border-bottom: 1px solid #664D9D;\">带你重学ES6 | Generator</a></section></li><li><section style=\"margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; font-size: 14px; font-weight: normal; color: #595959;\"><a href=\"https://juejin.im/post/5f11006b5188252e58584b2e\" style=\"text-decoration: none; word-wrap: break-word; color: #664D9D; font-weight: normal; border-bottom: 1px solid #664D9D;\">带你重学ES6 | Async和Await</a></section></li><li><section style=\"margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; font-size: 14px; font-weight: normal; color: #595959;\"><a href=\"https://juejin.im/post/5f1644d2f265da22bc29c159\" style=\"text-decoration: none; word-wrap: break-word; color: #664D9D; font-weight: normal; border-bottom: 1px solid #664D9D;\">带你重学ES6 | Set和Map</a></section></li><li><section style=\"margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; font-size: 14px; font-weight: normal; color: #595959;\"><a href=\"https://juejin.im/post/6854573219320430605\" style=\"text-decoration: none; word-wrap: break-word; color: #664D9D; font-weight: normal; border-bottom: 1px solid #664D9D;\">带你重学ES6 | Symbol(不仅仅只是一个新的数据类型)</a></section></li><li><section style=\"margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; font-size: 14px; font-weight: normal; color: #595959;\"><a href=\"https://juejin.im/post/6855593806818902030\" style=\"text-decoration: none; word-wrap: break-word; color: #664D9D; font-weight: normal; border-bottom: 1px solid #664D9D;\">带你重学ES6 | Export(谨记输出的都是变量)</a></section></li><li><section style=\"margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; font-size: 14px; font-weight: normal; color: #595959;\"><a href=\"https://juejin.im/post/6857319959774265358\" style=\"text-decoration: none; word-wrap: break-word; color: #664D9D; font-weight: normal; border-bottom: 1px solid #664D9D;\">带你重学ES6 | proxy和defineProperty</a></section></li></ul>\n<p data-tool=\"mdnice编辑器\" style=\"padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: #595959; margin: 10px 0px; letter-spacing: 2px; font-size: 14px; word-spacing: 2px;\">还可以关注我的<a href=\"https://tomatoesman.github.io/\" style=\"text-decoration: none; word-wrap: break-word; color: #664D9D; font-weight: normal; border-bottom: 1px solid #664D9D;\">博客</a>希望能给<a href=\"https://github.com/TomatoesMan/TomatoesMan.github.io\" style=\"text-decoration: none; word-wrap: break-word; color: #664D9D; font-weight: normal; border-bottom: 1px solid #664D9D;\">我的github</a>上点个Start，小伙伴们一定会发现一个问题，我的所有用户名几乎都与番茄有关，因为我真的很喜欢吃番茄❤️！！！</p>\n<p data-tool=\"mdnice编辑器\" style=\"padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: #595959; margin: 10px 0px; letter-spacing: 2px; font-size: 14px; word-spacing: 2px;\">想跟车不迷路的小伙还希望可以关注公众号 前端老番茄 或者扫一扫下面的二维码👇👇👇。\n<img src=\"https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d2babd9582ef4cb2b59aac518ca9b266~tplv-k3u1fbpfcp-zoom-1.image\" alt style=\"max-width: 100%; border-radius: 6px; display: block; margin: 20px auto; object-fit: contain;\"></p>\n<p data-tool=\"mdnice编辑器\" style=\"padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: #595959; margin: 10px 0px; letter-spacing: 2px; font-size: 14px; word-spacing: 2px;\">我是一个编程界的小学生，您的鼓励是我不断前进的动力，😄希望能一起加油前进。</p>\n</section>", "user_name": "番茄先森", "description": "文章汇总：https://tomatoesman.github.io/", "got_view_count": 4241, "category_name": "前端", "ctime": 1457483942}
{"tag_name": "Java", "concern_user_count": 252044, "user_id": "2796746683483751", "title": "Java8中你可能不知道的一些地方之Stream实战三", "mark_content": "<h2 data-tool=\"mdnice编辑器\" style=\"margin-top: 30px; margin-bottom: 15px; padding: 0px; font-weight: bold; color: black; font-size: 22px; display: block; border-bottom: 4px solid #40B8FA;\"><span class=\"prefix\" style=\"display: flex; width: 20px; height: 20px; background-size: 20px 20px; background-image: url(https://my-wechat.mdnice.com/fullstack-1.png); margin-bottom: -22px;\"></span><span class=\"content\" style=\"display: flex; color: #40B8FA; font-size: 20px; margin-left: 25px;\">汇总</span><span class=\"suffix\" style=\"display: flex; box-sizing: border-box; width: 200px; height: 10px; border-top-left-radius: 20px; background: RGBA(64, 184, 250, .5); color: rgb(255, 255, 255); font-size: 16px; letter-spacing: 0.544px; justify-content: flex-end; float: right; margin-top: -10px; box-sizing: border-box !important; overflow-wrap: break-word !important;\"></span></h2>\n<p data-tool=\"mdnice编辑器\" style=\"padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: #2b2b2b; margin: 10px 0px; letter-spacing: 2px; font-size: 14px; word-spacing: 2px;\">汇总操作在Stream流操作比较常见，比如计算总数，求平均等操作，常用方法如下:</p>\n<figure data-tool=\"mdnice编辑器\" style=\"margin: 0; margin-top: 10px; margin-bottom: 10px; display: flex; flex-direction: column; justify-content: center; align-items: center;\"><img src=\"https://cushier.coding.net/p/picture/d/picture/git/raw/master/20200810161926.png\" alt style=\"max-width: 100%; border-radius: 6px; display: block; margin: 20px auto; object-fit: contain; box-shadow: 2px 4px 7px #999;\"></figure>\n<p data-tool=\"mdnice编辑器\" style=\"padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: #2b2b2b; margin: 10px 0px; letter-spacing: 2px; font-size: 14px; word-spacing: 2px;\">相关操作如下</p>\n<ul data-tool=\"mdnice编辑器\" style=\"margin-top: 8px; margin-bottom: 8px; padding-left: 25px; font-size: 15px; color: #595959; list-style-type: circle;\">\n<li><section style=\"margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; font-size: 14px; font-weight: normal; color: #595959;\">筛选所有有效订单 返回订单总数</section></li></ul>\n<pre class=\"custom\" data-tool=\"mdnice编辑器\" style=\"margin-top: 10px; margin-bottom: 10px;\"><code class=\"hljs\" style=\"overflow-x: auto; padding: 16px; color: #abb2bf; background: #282c34; display: -webkit-box; font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; border-radius: 0px; font-size: 12px; -webkit-overflow-scrolling: touch; letter-spacing: 0px;\">System.out.println(<span class=\"hljs-string\" style=\"color: #98c379; line-height: 26px;\">\"count结果:\"</span>+<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ordersList.stream()<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;.filter((order)&nbsp;-&gt;&nbsp;order.getIsValid()&nbsp;==&nbsp;<span class=\"hljs-number\" style=\"color: #d19a66; line-height: 26px;\">1</span>)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;.collect(Collectors.counting())<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;);<br>System.out.println(<span class=\"hljs-string\" style=\"color: #98c379; line-height: 26px;\">\"count结果:\"</span>+<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ordersList.stream()<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;.filter((order)&nbsp;-&gt;&nbsp;order.getIsValid()&nbsp;==&nbsp;<span class=\"hljs-number\" style=\"color: #d19a66; line-height: 26px;\">1</span>)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;.count()<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;);<br></code></pre>\n<ul data-tool=\"mdnice编辑器\" style=\"margin-top: 8px; margin-bottom: 8px; padding-left: 25px; font-size: 15px; color: #595959; list-style-type: circle;\">\n<li><section style=\"margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; font-size: 14px; font-weight: normal; color: #595959;\">返回订单总金额</section></li></ul>\n<pre class=\"custom\" data-tool=\"mdnice编辑器\" style=\"margin-top: 10px; margin-bottom: 10px;\"><code class=\"hljs\" style=\"overflow-x: auto; padding: 16px; color: #abb2bf; background: #282c34; display: -webkit-box; font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; border-radius: 0px; font-size: 12px; -webkit-overflow-scrolling: touch; letter-spacing: 0px;\">System.out.println(<span class=\"hljs-string\" style=\"color: #98c379; line-height: 26px;\">\"订单总金额:\"</span>+<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ordersList.stream()<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;.filter((order)&nbsp;-&gt;&nbsp;order.getIsValid()&nbsp;==&nbsp;<span class=\"hljs-number\" style=\"color: #d19a66; line-height: 26px;\">1</span>)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;.collect(Collectors.summarizingDouble(Order::getTotal))<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;);<br>System.out.println(<span class=\"hljs-string\" style=\"color: #98c379; line-height: 26px;\">\"订单总金额:\"</span>+<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ordersList.stream()<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;.filter((order)&nbsp;-&gt;&nbsp;order.getIsValid()&nbsp;==&nbsp;<span class=\"hljs-number\" style=\"color: #d19a66; line-height: 26px;\">1</span>)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;.mapToDouble(Order::getTotal)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;.sum()<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;);<br>System.out.println(<span class=\"hljs-string\" style=\"color: #98c379; line-height: 26px;\">\"订单总金额:\"</span>+<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ordersList.stream()<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;.filter((order)&nbsp;-&gt;&nbsp;order.getIsValid()&nbsp;==&nbsp;<span class=\"hljs-number\" style=\"color: #d19a66; line-height: 26px;\">1</span>)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;.map(Order::getTotal)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;.reduce(Double::sum)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;.get()<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;);<br></code></pre>\n<ul data-tool=\"mdnice编辑器\" style=\"margin-top: 8px; margin-bottom: 8px; padding-left: 25px; font-size: 15px; color: #595959; list-style-type: circle;\">\n<li><section style=\"margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; font-size: 14px; font-weight: normal; color: #595959;\">返回用户id=20 有效订单平均每笔消费金额</section></li></ul>\n<pre class=\"custom\" data-tool=\"mdnice编辑器\" style=\"margin-top: 10px; margin-bottom: 10px;\"><code class=\"hljs\" style=\"overflow-x: auto; padding: 16px; color: #abb2bf; background: #282c34; display: -webkit-box; font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; border-radius: 0px; font-size: 12px; -webkit-overflow-scrolling: touch; letter-spacing: 0px;\">System.out.println(<span class=\"hljs-string\" style=\"color: #98c379; line-height: 26px;\">\"用户id=20&nbsp;有效订单平均每笔消费金额:\"</span>+<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ordersList.stream()<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;.filter((order)&nbsp;-&gt;&nbsp;order.getIsValid()&nbsp;==&nbsp;<span class=\"hljs-number\" style=\"color: #d19a66; line-height: 26px;\">1</span>)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;.filter((order&nbsp;-&gt;&nbsp;order.getUserId()==<span class=\"hljs-number\" style=\"color: #d19a66; line-height: 26px;\">20</span>))<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;.collect(Collectors.averagingDouble(Order::getTotal))<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;);<br>System.out.println(<span class=\"hljs-string\" style=\"color: #98c379; line-height: 26px;\">\"用户id=20&nbsp;有效订单平均每笔消费金额:\"</span>+<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ordersList.stream()<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;.filter((order)&nbsp;-&gt;&nbsp;order.getIsValid()&nbsp;==&nbsp;<span class=\"hljs-number\" style=\"color: #d19a66; line-height: 26px;\">1</span>)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;.filter((order&nbsp;-&gt;&nbsp;order.getUserId()==<span class=\"hljs-number\" style=\"color: #d19a66; line-height: 26px;\">20</span>))<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;.mapToDouble(Order::getTotal)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;.average()<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;.getAsDouble()<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;);<br><br>System.out.println(<span class=\"hljs-string\" style=\"color: #98c379; line-height: 26px;\">\"用户id=20&nbsp;有效订单平均每笔消费金额:\"</span>+<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ordersList.stream()<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;.filter((order)&nbsp;-&gt;&nbsp;order.getIsValid()&nbsp;==&nbsp;<span class=\"hljs-number\" style=\"color: #d19a66; line-height: 26px;\">1</span>)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;.filter((order&nbsp;-&gt;&nbsp;order.getUserId()==<span class=\"hljs-number\" style=\"color: #d19a66; line-height: 26px;\">20</span>))<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;.collect(Collectors.summarizingDouble(Order::getTotal))<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;.getAverage()<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;);<br></code></pre>\n<ul data-tool=\"mdnice编辑器\" style=\"margin-top: 8px; margin-bottom: 8px; padding-left: 25px; font-size: 15px; color: #595959; list-style-type: circle;\">\n<li><section style=\"margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; font-size: 14px; font-weight: normal; color: #595959;\">筛选所有有效订单 并计算订单总金额</section></li></ul>\n<pre class=\"custom\" data-tool=\"mdnice编辑器\" style=\"margin-top: 10px; margin-bottom: 10px;\"><code class=\"hljs\" style=\"overflow-x: auto; padding: 16px; color: #abb2bf; background: #282c34; display: -webkit-box; font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; border-radius: 0px; font-size: 12px; -webkit-overflow-scrolling: touch; letter-spacing: 0px;\">System.out.println(<span class=\"hljs-string\" style=\"color: #98c379; line-height: 26px;\">\"订单总金额:\"</span>+<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ordersList.stream()<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;.filter((order)&nbsp;-&gt;&nbsp;order.getIsValid()&nbsp;==&nbsp;<span class=\"hljs-number\" style=\"color: #d19a66; line-height: 26px;\">1</span>)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;.collect(Collectors.summingDouble(Order::getTotal))<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;);<br></code></pre>\n<h2 data-tool=\"mdnice编辑器\" style=\"margin-top: 30px; margin-bottom: 15px; padding: 0px; font-weight: bold; color: black; font-size: 22px; display: block; border-bottom: 4px solid #40B8FA;\"><span class=\"prefix\" style=\"display: flex; width: 20px; height: 20px; background-size: 20px 20px; background-image: url(https://my-wechat.mdnice.com/fullstack-1.png); margin-bottom: -22px;\"></span><span class=\"content\" style=\"display: flex; color: #40B8FA; font-size: 20px; margin-left: 25px;\">最值</span><span class=\"suffix\" style=\"display: flex; box-sizing: border-box; width: 200px; height: 10px; border-top-left-radius: 20px; background: RGBA(64, 184, 250, .5); color: rgb(255, 255, 255); font-size: 16px; letter-spacing: 0.544px; justify-content: flex-end; float: right; margin-top: -10px; box-sizing: border-box !important; overflow-wrap: break-word !important;\"></span></h2>\n<ul data-tool=\"mdnice编辑器\" style=\"margin-top: 8px; margin-bottom: 8px; padding-left: 25px; font-size: 15px; color: #595959; list-style-type: circle;\">\n<li><section style=\"margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; font-size: 14px; font-weight: normal; color: #595959;\">筛选所有有效订单 并计算最小订单金额</section></li></ul>\n<pre class=\"custom\" data-tool=\"mdnice编辑器\" style=\"margin-top: 10px; margin-bottom: 10px;\"><code class=\"hljs\" style=\"overflow-x: auto; padding: 16px; color: #abb2bf; background: #282c34; display: -webkit-box; font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; border-radius: 0px; font-size: 12px; -webkit-overflow-scrolling: touch; letter-spacing: 0px;\">System.out.println(<span class=\"hljs-string\" style=\"color: #98c379; line-height: 26px;\">\"最小订单金额:\"</span>+<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ordersList.stream()<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;.filter((order)&nbsp;-&gt;&nbsp;order.getIsValid()&nbsp;==&nbsp;<span class=\"hljs-number\" style=\"color: #d19a66; line-height: 26px;\">1</span>)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;.map(Order::getTotal)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;.collect(Collectors.minBy(Double::compare))<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;);<br></code></pre>\n<ul data-tool=\"mdnice编辑器\" style=\"margin-top: 8px; margin-bottom: 8px; padding-left: 25px; font-size: 15px; color: #595959; list-style-type: circle;\">\n<li><section style=\"margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; font-size: 14px; font-weight: normal; color: #595959;\">筛选所有有效订单 并计算最大订单金额</section></li></ul>\n<pre class=\"custom\" data-tool=\"mdnice编辑器\" style=\"margin-top: 10px; margin-bottom: 10px;\"><code class=\"hljs\" style=\"overflow-x: auto; padding: 16px; color: #abb2bf; background: #282c34; display: -webkit-box; font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; border-radius: 0px; font-size: 12px; -webkit-overflow-scrolling: touch; letter-spacing: 0px;\"><span class=\"hljs-comment\" style=\"color: #5c6370; font-style: italic; line-height: 26px;\">//&nbsp;筛选所有有效订单&nbsp;并计算最大订单金额</span><br>System.out.println(<span class=\"hljs-string\" style=\"color: #98c379; line-height: 26px;\">\"最大订单金额:\"</span>+<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ordersList.stream()<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;.filter((order)&nbsp;-&gt;&nbsp;order.getIsValid()&nbsp;==&nbsp;<span class=\"hljs-number\" style=\"color: #d19a66; line-height: 26px;\">1</span>)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;.map(Order::getTotal)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;.collect(Collectors.maxBy(Double::compare))<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;);<br></code></pre>\n<h2 data-tool=\"mdnice编辑器\" style=\"margin-top: 30px; margin-bottom: 15px; padding: 0px; font-weight: bold; color: black; font-size: 22px; display: block; border-bottom: 4px solid #40B8FA;\"><span class=\"prefix\" style=\"display: flex; width: 20px; height: 20px; background-size: 20px 20px; background-image: url(https://my-wechat.mdnice.com/fullstack-1.png); margin-bottom: -22px;\"></span><span class=\"content\" style=\"display: flex; color: #40B8FA; font-size: 20px; margin-left: 25px;\">分组&amp;分区</span><span class=\"suffix\" style=\"display: flex; box-sizing: border-box; width: 200px; height: 10px; border-top-left-radius: 20px; background: RGBA(64, 184, 250, .5); color: rgb(255, 255, 255); font-size: 16px; letter-spacing: 0.544px; justify-content: flex-end; float: right; margin-top: -10px; box-sizing: border-box !important; overflow-wrap: break-word !important;\"></span></h2>\n<h3 data-tool=\"mdnice编辑器\" style=\"padding: 0px; color: black; font-size: 17px; font-weight: bold; text-align: center; position: relative; margin-top: 20px; margin-bottom: 20px;\"><span class=\"prefix\" style=\"display: none;\"></span><span class=\"content\" style=\"border-bottom: 2px solid RGBA(79, 177, 249, .65); color: #2b2b2b; padding-bottom: 2px;\"><span style=\"width: 30px; height: 30px; display: block; background-image: url(https://my-wechat.mdnice.com/fullstack-2.png); background-position: center; background-size: 30px; margin: auto; opacity: 1; background-repeat: no-repeat; margin-bottom: -8px;\"></span>1 分组</span><span class=\"suffix\" style=\"display: none;\"></span></h3>\n<p data-tool=\"mdnice编辑器\" style=\"padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: #2b2b2b; margin: 10px 0px; letter-spacing: 2px; font-size: 14px; word-spacing: 2px;\">groupingBy 用于将数据分组，最终返回一个 Map 类型 ，groupingBy 第二参数用于实现多级分组</p>\n<ul data-tool=\"mdnice编辑器\" style=\"margin-top: 8px; margin-bottom: 8px; padding-left: 25px; font-size: 15px; color: #595959; list-style-type: circle;\">\n<li><section style=\"margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; font-size: 14px; font-weight: normal; color: #595959;\">根据有效订单支付状态进行分组操作</section></li></ul>\n<pre class=\"custom\" data-tool=\"mdnice编辑器\" style=\"margin-top: 10px; margin-bottom: 10px;\"><code class=\"hljs\" style=\"overflow-x: auto; padding: 16px; color: #abb2bf; background: #282c34; display: -webkit-box; font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; border-radius: 0px; font-size: 12px; -webkit-overflow-scrolling: touch; letter-spacing: 0px;\">Map&lt;Integer,List&lt;Order&gt;&gt;&nbsp;g01=ordersList.stream()<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;.filter((order)&nbsp;-&gt;&nbsp;order.getIsValid()&nbsp;==&nbsp;<span class=\"hljs-number\" style=\"color: #d19a66; line-height: 26px;\">1</span>)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;.collect(Collectors.groupingBy(Order::getStatus));<br>g01.forEach((status,order)-&gt;{<br>&nbsp;&nbsp;&nbsp;&nbsp;System.out.println(<span class=\"hljs-string\" style=\"color: #98c379; line-height: 26px;\">\"----------------\"</span>);<br>&nbsp;&nbsp;&nbsp;&nbsp;System.out.println(<span class=\"hljs-string\" style=\"color: #98c379; line-height: 26px;\">\"订单状态:\"</span>+status);<br>&nbsp;&nbsp;&nbsp;&nbsp;order.forEach(System.out::println);<br>});<br></code></pre>\n<ul data-tool=\"mdnice编辑器\" style=\"margin-top: 8px; margin-bottom: 8px; padding-left: 25px; font-size: 15px; color: #595959; list-style-type: circle;\">\n<li><section style=\"margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; font-size: 14px; font-weight: normal; color: #595959;\">筛选有效订单，根据用户id 和 支付状态进行分组</section></li></ul>\n<pre class=\"custom\" data-tool=\"mdnice编辑器\" style=\"margin-top: 10px; margin-bottom: 10px;\"><code class=\"hljs\" style=\"overflow-x: auto; padding: 16px; color: #abb2bf; background: #282c34; display: -webkit-box; font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; border-radius: 0px; font-size: 12px; -webkit-overflow-scrolling: touch; letter-spacing: 0px;\">Map&lt;Integer,Map&lt;String,List&lt;Order&gt;&gt;&gt;&nbsp;g02=&nbsp;ordersList.stream()<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;.filter((order)&nbsp;-&gt;&nbsp;order.getIsValid()&nbsp;==&nbsp;<span class=\"hljs-number\" style=\"color: #d19a66; line-height: 26px;\">1</span>)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;.collect(Collectors.groupingBy(Order::getUserId,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Collectors.groupingBy((o)-&gt;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class=\"hljs-keyword\" style=\"color: #c678dd; line-height: 26px;\">if</span>(o.getStatus()==<span class=\"hljs-number\" style=\"color: #d19a66; line-height: 26px;\">0</span>){<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class=\"hljs-keyword\" style=\"color: #c678dd; line-height: 26px;\">return</span>&nbsp;<span class=\"hljs-string\" style=\"color: #98c379; line-height: 26px;\">\"未支付\"</span>;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<span class=\"hljs-keyword\" style=\"color: #c678dd; line-height: 26px;\">else</span>&nbsp;<span class=\"hljs-keyword\" style=\"color: #c678dd; line-height: 26px;\">if</span>&nbsp;(o.getStatus()==<span class=\"hljs-number\" style=\"color: #d19a66; line-height: 26px;\">1</span>){<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class=\"hljs-keyword\" style=\"color: #c678dd; line-height: 26px;\">return</span>&nbsp;<span class=\"hljs-string\" style=\"color: #98c379; line-height: 26px;\">\"已支付\"</span>;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<span class=\"hljs-keyword\" style=\"color: #c678dd; line-height: 26px;\">else</span>&nbsp;<span class=\"hljs-keyword\" style=\"color: #c678dd; line-height: 26px;\">if</span>&nbsp;(o.getStatus()==<span class=\"hljs-number\" style=\"color: #d19a66; line-height: 26px;\">2</span>){<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class=\"hljs-keyword\" style=\"color: #c678dd; line-height: 26px;\">return</span>&nbsp;<span class=\"hljs-string\" style=\"color: #98c379; line-height: 26px;\">\"待发货\"</span>;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<span class=\"hljs-keyword\" style=\"color: #c678dd; line-height: 26px;\">else</span>&nbsp;<span class=\"hljs-keyword\" style=\"color: #c678dd; line-height: 26px;\">if</span>&nbsp;(o.getStatus()==<span class=\"hljs-number\" style=\"color: #d19a66; line-height: 26px;\">3</span>){<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class=\"hljs-keyword\" style=\"color: #c678dd; line-height: 26px;\">return</span>&nbsp;<span class=\"hljs-string\" style=\"color: #98c379; line-height: 26px;\">\"已发货\"</span>;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<span class=\"hljs-keyword\" style=\"color: #c678dd; line-height: 26px;\">else</span>&nbsp;<span class=\"hljs-keyword\" style=\"color: #c678dd; line-height: 26px;\">if</span>&nbsp;(o.getStatus()==<span class=\"hljs-number\" style=\"color: #d19a66; line-height: 26px;\">4</span>){<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class=\"hljs-keyword\" style=\"color: #c678dd; line-height: 26px;\">return</span>&nbsp;<span class=\"hljs-string\" style=\"color: #98c379; line-height: 26px;\">\"已接收\"</span>;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;<span class=\"hljs-keyword\" style=\"color: #c678dd; line-height: 26px;\">else</span>{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class=\"hljs-keyword\" style=\"color: #c678dd; line-height: 26px;\">return</span>&nbsp;<span class=\"hljs-string\" style=\"color: #98c379; line-height: 26px;\">\"已完成\"</span>;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;))<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;);<br>g02.forEach((userId,m)-&gt;{<br>&nbsp;&nbsp;&nbsp;&nbsp;System.out.println(<span class=\"hljs-string\" style=\"color: #98c379; line-height: 26px;\">\"用户id:\"</span>+userId+<span class=\"hljs-string\" style=\"color: #98c379; line-height: 26px;\">\"--&gt;有效订单如下:\"</span>);<br>&nbsp;&nbsp;&nbsp;&nbsp;m.forEach((status,os)-&gt;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println(<span class=\"hljs-string\" style=\"color: #98c379; line-height: 26px;\">\"状态:\"</span>+status+<span class=\"hljs-string\" style=\"color: #98c379; line-height: 26px;\">\"---订单列表如下:\"</span>);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;os.forEach(System.out::println);<br>&nbsp;&nbsp;&nbsp;&nbsp;});<br>&nbsp;&nbsp;&nbsp;&nbsp;System.out.println(<span class=\"hljs-string\" style=\"color: #98c379; line-height: 26px;\">\"-----------------------\"</span>);<br>});<br></code></pre>\n<h3 data-tool=\"mdnice编辑器\" style=\"padding: 0px; color: black; font-size: 17px; font-weight: bold; text-align: center; position: relative; margin-top: 20px; margin-bottom: 20px;\"><span class=\"prefix\" style=\"display: none;\"></span><span class=\"content\" style=\"border-bottom: 2px solid RGBA(79, 177, 249, .65); color: #2b2b2b; padding-bottom: 2px;\"><span style=\"width: 30px; height: 30px; display: block; background-image: url(https://my-wechat.mdnice.com/fullstack-2.png); background-position: center; background-size: 30px; margin: auto; opacity: 1; background-repeat: no-repeat; margin-bottom: -8px;\"></span>2 分区</span><span class=\"suffix\" style=\"display: none;\"></span></h3>\n<p data-tool=\"mdnice编辑器\" style=\"padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: #2b2b2b; margin: 10px 0px; letter-spacing: 2px; font-size: 14px; word-spacing: 2px;\">分区与分组的区别在于，分区是按照 true 和 false 来分的，因此partitioningBy 接受的参数的 lambda 也是 <code style=\"font-size: 14px; word-wrap: break-word; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #3594F7; background: RGBA(59, 170, 250, .1); padding: 0 2px; border-radius: 2px; height: 21px; line-height: 22px;\">T -&gt; boolean</code></p>\n<ul data-tool=\"mdnice编辑器\" style=\"margin-top: 8px; margin-bottom: 8px; padding-left: 25px; font-size: 15px; color: #595959; list-style-type: circle;\">\n<li><section style=\"margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; font-size: 14px; font-weight: normal; color: #595959;\">分区操作-筛选订单金额&gt;1000 的有效订单</section></li></ul>\n<pre class=\"custom\" data-tool=\"mdnice编辑器\" style=\"margin-top: 10px; margin-bottom: 10px;\"><code class=\"hljs\" style=\"overflow-x: auto; padding: 16px; color: #abb2bf; background: #282c34; display: -webkit-box; font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; border-radius: 0px; font-size: 12px; -webkit-overflow-scrolling: touch; letter-spacing: 0px;\">Map&lt;Boolean,List&lt;Order&gt;&gt;&nbsp;g03=&nbsp;ordersList.stream()<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;.filter((order)&nbsp;-&gt;&nbsp;order.getIsValid()&nbsp;==&nbsp;<span class=\"hljs-number\" style=\"color: #d19a66; line-height: 26px;\">1</span>)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;.collect(Collectors.partitioningBy((o)-&gt;o.getTotal()&gt;<span class=\"hljs-number\" style=\"color: #d19a66; line-height: 26px;\">1000</span>));<br>g03.forEach((b,os)-&gt;{<br>&nbsp;&nbsp;&nbsp;&nbsp;System.out.println(<span class=\"hljs-string\" style=\"color: #98c379; line-height: 26px;\">\"分区结果:\"</span>+b+<span class=\"hljs-string\" style=\"color: #98c379; line-height: 26px;\">\"--列表结果:\"</span>);<br>&nbsp;&nbsp;&nbsp;&nbsp;os.forEach(System.out::println);<br>});<br></code></pre>\n<ul data-tool=\"mdnice编辑器\" style=\"margin-top: 8px; margin-bottom: 8px; padding-left: 25px; font-size: 15px; color: #595959; list-style-type: circle;\">\n<li><section style=\"margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; font-size: 14px; font-weight: normal; color: #595959;\">拼接操作-筛选有效订单并进行拼接</section></li></ul>\n<pre class=\"custom\" data-tool=\"mdnice编辑器\" style=\"margin-top: 10px; margin-bottom: 10px;\"><code class=\"hljs\" style=\"overflow-x: auto; padding: 16px; color: #abb2bf; background: #282c34; display: -webkit-box; font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; border-radius: 0px; font-size: 12px; -webkit-overflow-scrolling: touch; letter-spacing: 0px;\">String&nbsp;orderStr=ordersList.stream()<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;.filter((order)&nbsp;-&gt;&nbsp;order.getIsValid()&nbsp;==&nbsp;<span class=\"hljs-number\" style=\"color: #d19a66; line-height: 26px;\">1</span>)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;.map(Order::getOrderNo)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;.collect(Collectors.joining(<span class=\"hljs-string\" style=\"color: #98c379; line-height: 26px;\">\",\"</span>));<br>System.out.println(orderStr);<br></code></pre>\n<h2 data-tool=\"mdnice编辑器\" style=\"margin-top: 30px; margin-bottom: 15px; padding: 0px; font-weight: bold; color: black; font-size: 22px; display: block; border-bottom: 4px solid #40B8FA;\"><span class=\"prefix\" style=\"display: flex; width: 20px; height: 20px; background-size: 20px 20px; background-image: url(https://my-wechat.mdnice.com/fullstack-1.png); margin-bottom: -22px;\"></span><span class=\"content\" style=\"display: flex; color: #40B8FA; font-size: 20px; margin-left: 25px;\">流的应用</span><span class=\"suffix\" style=\"display: flex; box-sizing: border-box; width: 200px; height: 10px; border-top-left-radius: 20px; background: RGBA(64, 184, 250, .5); color: rgb(255, 255, 255); font-size: 16px; letter-spacing: 0.544px; justify-content: flex-end; float: right; margin-top: -10px; box-sizing: border-box !important; overflow-wrap: break-word !important;\"></span></h2>\n<p data-tool=\"mdnice编辑器\" style=\"padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: #2b2b2b; margin: 10px 0px; letter-spacing: 2px; font-size: 14px; word-spacing: 2px;\">Java8引入Stream流操作，使得对元素的处理更加的方便快捷，通过Stream提供的相关方法很好的结合Lambda、函数式接口、方法引用等相关内容，使得流的处理相比较原始集合处理代码极大简化，Stream支持函数的链式调用，代码上更加紧凑同时Stream支持的元素的并行化处理提高了程序的执行性能。</p>\n<p data-tool=\"mdnice编辑器\" style=\"padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: #2b2b2b; margin: 10px 0px; letter-spacing: 2px; font-size: 14px; word-spacing: 2px;\">对于Stream流的应用通常在集合元素数据处理上特别是对元素需要进行多次处理的情况，同时对于函数式编程的味道更加浓重，也是以后开发的一个趋势。</p>\n<p data-tool=\"mdnice编辑器\" style=\"padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: #2b2b2b; margin: 10px 0px; letter-spacing: 2px; font-size: 14px; word-spacing: 2px;\">好了，Java8核心特性之Stream流就介绍到这里了，应该是非常详尽了，希望大家喜欢。</p>\n</section>", "user_name": "同一片蓝天下", "description": "一个呆萌の小小程序员", "got_view_count": 2082, "category_name": "后端", "ctime": 1457483880}
{"tag_name": "CSS", "concern_user_count": 258450, "user_id": "325111174662855", "title": "精读《CSS揭秘》之背景与边框", "mark_content": "CSS对于前端工程师来说是基础中的基础，如果基础不扎实，就得日常跪求UED给图来实现效果。\n\n>《CSS揭秘》这本书读来让人有满满的安全感，LEA VEROU 是CSS方面的专家，对CSS3的设计和未来的发展了解很多。描述的47个css技巧也很接地气，值得一读再读。\n\n> 本文是精读《CSS揭秘》系列文章的第一篇，预计有8篇，以一（kan）周（wo）一（xin）篇（qing）的进度发布。\n\n> 如无特殊说明，样式对应的html结构都是 `<div class=\"box\"></div>`\n\n> 由于掘金限制，无法嵌入 iframe 标签，我把 codepen 的示例链接都附在了每一节，方便大家边读边练。\n\n## 半透明边框\n\n> view demo on [codepen](https://codepen.io/youngjuning/pen/KKzKroB)\n\nCSS 背景的工作原理是默认延伸到border区域的，CSS3 中，我们可以使用 `background-clip` 属性来调整这个默认行为带来的不便。将它设为 `padding-box`，便可以不让背景侵入边框所在的范围。\n\n```css\n.box {\n  border: 10px solid rgba(255,255,255,0.5);\n  background: pink;\n  background-clip: padding-box;\n}\n```\n\n<img src=\"https://i.loli.net/2020/08/09/WzDYntbHJx49kaI.png\" style=\"zoom:50%;\" />\n\n## 多重边框\n\n> view demo on [codepen](https://codepen.io/youngjuning/pen/rNeaOob)\n\n### box-shadow 方案\n\n1. 利用 `box-shadow` 属性第四个参数（扩张半径）控制投影面积，其他两个偏移量和模糊半径都设置为。\n2. 利用 `box-shadow` 支持逗号分隔的语法，我们可以创建任意数量的投影。\n\n```css\n.box {\n  width: 100px;\n  height: 100px;\n  margin: 15px;\n  background: yellowgreen;\n  border-radius: 5px;\n  box-shadow: 0 0 0 10px #655, 0 0 0 15px deeppink,\n    0 2px 5px 15px rgba(0, 0, 0, 0.6);\n}\n```\n\n![](https://i.loli.net/2020/08/08/PzA4XJSi8eME7UK.png)\n\n注意：\n\n1. 投影的行为跟外边框不完全一致，因为它不会影响布局，而且也不会受到 `box-sizing` 属性的影响。不过，你还是可以通过内边距或外边距（这取决于投影是内嵌还是外扩的）来额外模拟出边框\n2. 上述代码创建出的假边框出现在元素的**外圈**。它们并不会响应鼠标事件，比如悬停或点击。如果这一点非常重要，你可以给 `box-shadow` 属性加上 `inset` 关键字，来使投影绘制在元素的**内圈**。请注意，此时你需要增加额外的内边距来腾出足够的空隙。\n\n### outline 方案\n\n如果你只需要两层边框，那就可以先设置一层常规边框，再加上 `outline`（描边）属性来产生外层的边框。\n\n该方案还可以利用 `outline-offset` 属性来控制描边和元素边缘之间的距离（可以为负值），下面代码的效果就是一个缝边的效果。\n\n```css\n.box {\n  width: 100px;\n  height: 100px;\n  margin: 5px;\n  background: yellowgreen;\n  border-radius: 5px;\n  outline: 1px dashed deeppink;\n  outline-offset: -10px;\n}\n```\n\n![](https://i.loli.net/2020/08/08/Orcg4ytVRuKNbGS.png)\n\n## 灵活的背景定位\n\n> view demo on [codepen](https://codepen.io/youngjuning/pen/WNwbmRj)\n\n### background-position 的扩展语法方案\n\n在CSS3中，`background-position` 属性已经得到扩展，它允许我们制定背景图片**距离任意角的偏移量**，只要我们**在偏移量前面加上指定关键字**：\n\n```css\n.box {\n  background: url(https://i.loli.net/2020/08/08/jWNPK6e3ucf47LV.png) no-repeat\n    right bottom/50px #6a99bf;\n  background-position: right 15px bottom 15px;\n  width: 200px;\n  height: 120px;\n  border-radius: 8px;\n}\n```\n\n![](https://i.loli.net/2020/08/08/yIVnde16BwN3bSk.png)\n\n### background-origin 方案\n\n`background-origin` 是用来控制背景起始点的属性，默认是以`padding-box` 为准的，如果我们想让背景的的起点以内容区的边缘为基准（也就是说，此时背景图片距离边角的偏移量就跟内边距保持一致了）。\n\n如果你想要背景偏移量与容器的内边距一致，那么就可以使用这个方案，代码实现如下：\n\n```css\n.box {\n  box-sizing: border-box;\n  width: 200px;\n  height: 120px;\n  border-radius: 8px;\n  background: url(https://i.loli.net/2020/08/08/jWNPK6e3ucf47LV.png) no-repeat\n    right bottom/50px #6a99bf;\n  padding: 10px;\n  background-origin: content-box;\n  background-clip: content-box;\n  border: 1px solid #000;\n}\n```\n\n![](https://i.loli.net/2020/08/08/CufS4jGV75qhgJL.png)\n\n### calc() + background-position 方案\n\ncalc() 函数可以传入形似 `100% - 20px` 的表达式（注意，`-` 两边必须有空格。）。我们可以利用这个特性来结合 `background-position` 以右上角为基准定位：\n\n```css\n.box {\n  width: 200px;\n  height: 120px;\n  border-radius: 8px;\n  background: url(https://i.loli.net/2020/08/08/jWNPK6e3ucf47LV.png) no-repeat\n    right bottom/50px #6a99bf;\n  background-position: calc(100% - 20px) calc(100% - 10px)\n}\n```\n\n![](https://i.loli.net/2020/08/08/yIVnde16BwN3bSk.png)\n\n## 边框内圆角\n\n> view demo on [codepen](https://codepen.io/youngjuning/pen/ZEWYNxe)\n\n有时，我们需要一个容器，只在内侧有圆角，而边框或描边的四个角在外部仍然保持直角的形状。\n\n```css\n.box {\n  margin: 20px;\n  width: 100px;\n  height: 100px;\n  background: #d9c2bc;\n  border-radius: 10px;\n  box-shadow: 0 0 0 5px #655;\n  outline: 10px solid #655;\n}\n```\n\n![](https://i.loli.net/2020/08/08/jesrqO2BW1yXuDp.png)\n\n能实现以上的效果，主要得益于两个事实：描边（outline）不会跟着元素的圆角走（因而显示出直角），但`box-shadow`却是会的。\n\n我们把这两者叠加到一起，`box-shadow` 会刚好填补描边和容器圆角之间的空隙，这两者的组合达成了我们想要的效果。\n\n> 注意：`box-shadow` 的颜色需要和 `outline` 保持一致，`box-shadow` 的扩张半径设为`outline`的一半即可。\n\n## 条纹背景\n\n条纹背景在CSS中是基于 `linear-gradient`、`repeat-linear-gradient` 实现的，本节为大家展示了一些可快速食用的例子。\n\n### 1、德国国旗🇩🇪\n\n> view demo on [codepen](https://codepen.io/youngjuning/pen/gOrbVGo)\n\n```css\n.box {\n  width: 130px;\n  height: 78px;\n  background: linear-gradient(\n    #000 0,\n    #000 33.3%,\n    #cc2a1d 33.3%,\n    #cc2a1d 66.6%,\n    #f8cf47 66.6%,\n    #f8cf47 100%\n  );\n  background-size: 100% 100%;\n}\n```\n\n![](https://upload.wikimedia.org/wikipedia/commons/thumb/b/ba/Flag_of_Germany.svg/260px-Flag_of_Germany.svg.png)\n\n### 2、法国国旗🇫🇷\n\n> view demo on [codepen](https://codepen.io/youngjuning/pen/gOrbVGo)\n\n```css\n.box {\n  width: 130px;\n  height: 78px;\n  background: linear-gradient(\n    to right,\n    #002590 0,\n    #002590 33.3%,\n    #ffffff 33.3%,\n    #ffffff 66.6%,\n    #db3c3f 66.6%,\n    #db3c3f 100%\n  );\n  background-size: 100% 100%;\n}\n```\n\n![](https://upload.wikimedia.org/wikipedia/commons/thumb/c/c3/Flag_of_France.svg/260px-Flag_of_France.svg.png)\n\n### 3、地址栏红蓝分割线\n\n> view demo on [codepen](https://codepen.io/youngjuning/pen/mdPyZBe)\n\n代码搬运自vant的联系人组件，使用了循环式的加强版`linear-gradient`：`repeating-linear-gradient`，它的色标是无限循环重复的，直到铺满整个背景。\n\n重复线性渐变完美适用于——条纹效果！这得益于它们可以无限循环的天赋是，一个渐变图案就可以自动重复并铺满整个背景。\n\n```css\n.box {\n  background: #fff;\n  width: 200px;\n  position: relative;\n}\n.box::before {\n  position: absolute;\n  left: 0;\n  right: 0;\n  bottom: 0;\n  height: 2px;\n  /* 这里的语法在CSS4中可能会被简化 */\n  background: repeating-linear-gradient(\n    -45deg,\n    #ff6c6c 0,\n    #ff6c6c 20%,\n    transparent 0,\n    transparent 25%,\n    #1989fa 0,\n    #1989fa 45%,\n    transparent 0,\n    transparent 50%\n  );\n  background-size: 80px;\n  content: \"\";\n}\n```\n\n![](https://i.loli.net/2020/08/09/d9olAseI1npxgFw.png)\n\n### 4、老式信封边框样式\n\n> view demo on [codepen](https://codepen.io/youngjuning/pen/ZEWGYKN)\n\n使用 `border-image` + `repeating-linear-gradient` 很容易实现：\n\n```html\n<div class=\"box\">\n  My name is 俊宁\n</div>\n```\n\n```css\n.box {\n  text-align: center;\n  line-height: 70px;\n  box-sizing: padding-box;\n  width: 200px;\n  height: 70px;\n  background: #fff;\n  border: 5px solid transparent;\n  border-image: 5\n    repeating-linear-gradient(\n      -45deg,\n      #ff6c6c 0,\n      #ff6c6c 10%,\n      transparent 0,\n      transparent 15%,\n      #1989fa 0,\n      #1989fa 25%,\n      transparent 0,\n      transparent 30%\n    );\n}\n```\n\n> border-image 第一个值不能带单位，否则没有效果！\n\n![](https://i.loli.net/2020/08/09/IXDHzKROQhyLsxu.png)\n\n### 5、🐜蚂蚁行军边框\n\n> view demo on [codepen](https://codepen.io/youngjuning/pen/BaKNymx)\n\n```css\n.box {\n  width: 100px;\n  height: 100px;\n  border: 1px solid transparent;\n  background: linear-gradient(white, white) padding-box,\n    repeating-linear-gradient(\n        -45deg,\n        black 0,\n        black 25%,\n        transparent 0,\n        transparent 50%\n      )\n      0% 0% / 0.6em 0.6em;\n  animation: ants 10s linear infinite;\n}\n@keyframes ants {\n  to {\n    background-position: 100% 100%;\n  }\n}\n```\n\n- 首先要设置容器的边框宽度为1px，颜色要设置成透明，以便稍后设置的背景能够显示出来。\n- 可以设置多重背景，并用逗号隔开，设置在前面的总是会覆盖后面的。这里设置了两层背景，第一层背景使用线性渐变`linear-gradient`设置了从白色到白色的渐变，`padding-box`是`background-clip`属性的值，表示背景图片绘制在内边距方框内。其实就是绘制了一个白色的块，用来遮盖第二层背景的中间部分，保留边框部分。\n- 把 `background-size` 改为某个合适的值。\n- 最后将背景图片的位置从左上角（0% 0%）逐渐过渡到右下角（100% 100%），看起来的效果就像边框动起来了一样。\n\n> 本文首发于[杨俊宁的博客](https://youngjuning.js.org/)，创作不易，您的点赞👍是我坚持的动力！！！\n", "user_name": "俊宁", "description": "怕什么真理无穷，进一寸有一寸的欢喜", "got_view_count": 113962, "category_name": "前端", "ctime": 1457483942}
{"tag_name": "RxJava", "concern_user_count": 61697, "user_id": "817692382075102", "title": "RxNet做网络请求，简洁得没法了", "mark_content": "# RxNet [Github](https://github.com/DonaldDu/RxNet)\n\n# Android网络请求一般怎么写？\n## Kotlin协程\n很多人说用Kotlin协程，看了后发现不太好用。\n\n- 外面需要一个asyncUI {}，看着都不爽\n- 如果接口出错了，需要在每个调用处，写逻辑来处理。不能全局处理错误，比如网络超时。\n- 代码不容易懂，比如： deferred1.wait(TOAST)这个wait(TOAST)是什么东西。\n- 没有全局进度框\n\n以下代码引用于 [用 Kotlin 协程把网络请求玩出花来](https://www.jianshu.com/p/272430328b6e)\n```\nasyncUI {\n    // 假设这是两个不同的 api 请求\n    val deferred1 = bg {\n        Server.getApiStore().login1(\"173176360\", \"123456\").execute()\n    }\n\n    val deferred2 = bg {\n        Server.getApiStore().login2(\"173176360\", \"123456\").execute()\n    }\n\n    // 后台请求着 api，此时我还可以在 UI 协程中做我想做的事情\n    textView.text = \"loading\"\n    delay(5, TimeUnit.SECONDS)\n\n    // 等 UI 协程中的事情做完了，专心等待 api 请求完成（其实 api 请求有可能已经完成了）\n    // 通过提供 ExceptionHandleType 进行异常的过滤\n    val response = deferred1.wait(TOAST)\n    deferred2.wait(THROUGH) // deferred2 的结果我不关心\n\n    // 此时两个请求肯定都完成了，并且 deferred1 没有异常发生\n    textView.text = response.toString()\n}\n```\n## 纯OkHttp\n- 代码写起来也比较麻烦，没有提示功能。\n- 不能全局处理错误，比如网络超时。\n- 没有全局进度框\n- 需要切换线程以操作UI\n```\n//代码同样来源上面引用的文章\ncallback = {\n    onSuccess =  { res ->\n        // TODO\n    }\n\n    onFail =  { error -> \n        // TODO\n    }\n}\nrequest.execute(callback)\n```\n## 封装OkHttp\n还有人自己封装OkHttp，这个就看个人了。\n\n我觉得这个不太好用，假如有个接口调用10次，就要写10次接口地址和‘toClass<Response<Student>>()’，显然这样不好。\n\n- 代码有点冗余（服务地址和返回参对象类）。\n- ~~不能全局处理错误，比如网络超时~~（没用过，不太确定有没有）。\n- ~~没有全局进度框~~（没用过，不太确定有没有）。\n\n以下代码引用于 [RxHttp 2000+star，协程请求，仅需三步](https://juejin.im/post/6856550856796897287?utm_source=gold_browser_extension)\n```\nval response = RxHttp.get(\"/service/...\")\n    .toClass<Response<Student>>()\n    .await()\nif (response.code == 200) {\n    //拿到data字段(Student)刷新UI\n} else {\n    //拿到msg字段给出错误提示\n} \n```\n# 干货\n那么，有没有一种方法能\n- 全局默认进度框，同时支持自定义进度框。\n- 全局默认处理错误，同时支持自定义处理错误。\n- 多个依次请求也能友好支持。\n- 页面结束，自动取消请求。\n\n## 有的：RxNet=RxJava3+Retrofit2+OkHttp3\n\n下面就是调用示例。调用返回的对象是接口中申明的类型，有完整的代码提示，IDE中可以看到Hint\n```\n    interface API {\n        @GET(\"Simple?net=1&bz=1\")\n        fun simple(): Observable<ResponsePacket<String>>\n    \n        @GET(\"NetError?net=0&bz=1\")\n        fun netError(): Observable<ResponsePacket<String>>\n    \n        @GET(\"BzError?net=1&bz=0\")\n        fun bzError(): Observable<ResponsePacket<String>>\n    \n        @GET(\"authorizeFailed\")\n        fun authorizeFailed(): Observable<ResponsePacket<String>>\n    }\n\n    private fun subscribeX() {\n        //简单模式，通常都用这个\n        api.simple().subscribeX(context) {\n            Toast.makeText(context, \"response:\" + it.message, Toast.LENGTH_SHORT).show()\n        }\n        //构造方法模式，看名字就知道功能了\n        api.simple().subscribeXBuilder(context)\n                .progress {\n                    null//null means no default and custom progress\n                }.failed {\n                    true//return error handled or not\n                }.successOnly(true)\n                .response {\n                    Toast.makeText(context, \"response:\" + it.message, Toast.LENGTH_SHORT).show()\n                }\n    }\n```\n## 多个请求依次发起\n需要额外引用\n> implementation \"com.github.DonaldDu:XIntent:1.5.3\"//Waterfall\n\n```\n    //多个请求依次发起，不调用 next 就自动结束流程。请求间切换时，进度框不会闪烁\n    buttonMultReq.setOnClickListener {\n        Waterfall.flow {\n            apiSample.subscribeX(context) {\n                Log.i(\"TAG\", \"apiSample1\")\n                next()//进入下一个flow，可以带任意类型的数据如：next(\"DATA\")\n            }\n        }.flow {\n            apiSample.subscribeX(context) {\n                Log.i(\"TAG\", \"apiSample2\")\n                next()\n            }\n        }.flow {\n            apiSample.subscribeX(context) {\n                Log.i(\"TAG\", \"apiSample3\")\n                Toast.makeText(context, \"response:\" + it.message, Toast.LENGTH_SHORT).show()\n            }\n        }\n    }\n```\n## 延时返回结果\n有时，想请求慢一点，动画需要时间展示。比如检查App更新，如果太快，屏幕会闪一下，然后显示没有更新的结果。如果延时900ms就可以解决这个问题（个人感觉好些）。\n```\n    buttonDelay.setOnClickListener {\n        val start = System.currentTimeMillis()\n        apiSample.delayResponse(5000)\n                .subscribeX(context) {\n                    val cost = System.currentTimeMillis() - start\n                    Log.i(\"TAG\", \"apiSample cost $cost\")\n                }\n    }\n```\n## 实现方式\n为了支持默认进度框和全局错误处理需要实现两个类，StyledProgressGenerator 和 IErrorHandler。已经有了默认实现，需要根据实际需要作一些调整就行了。\n```\nclass SampleStyledProgressGenerator : StyledProgressGenerator {\n    override fun generate(observer: IObserverX): StyledProgress? {\n        val context = observer.context\n        return if (context is FragmentActivity) {\n            MultListenerDialog.getInstance(context, observer)\n        } else null\n    }\n}\n\nclass SampleErrorHandler : BaseErrorHandler() {\n    override fun showDialog(context: Context, msg: String): Dialog? {\n        return AlertDialog.Builder(context)\n                .setMessage(msg)\n                .setPositiveButton(\"OK\", null).show()\n    }\n\n    override fun isAuthorizeFailed(activity: Activity, error: IError): Boolean {\n        return error.code == 9001\n    }\n\n    override fun onLogout(context: Context) {\n        val msg = \"onLogout\"\n        Toast.makeText(context, msg, Toast.LENGTH_SHORT).show()\n        Log.i(TAG, msg)\n    }\n\n    override fun isDebug(): Boolean = true\n\n    companion object {\n        private val TAG = IErrorHandler::class.java.simpleName\n    }\n}\n```\n## 进度框样式调整\n默认实现的是这个类MultListenerDialog，可以参考这个自己实现。如果只是调整比较小，也可以直接创建一个同名的Layout（R.layout.net_progress_dialog）自己随意调整就好。\n## 手动控制进度框\n如果在接口调用以外的地方需要控制进度框，可以调用以下两个方法。\n\n比如先压缩图片，再上传。在启动压缩前最好显示进度框，上传完成后会自动关闭进度框。还可以实现压缩过程中取消后，就不上传了。\n\n>需要特别注意下：如果 Activity中也有同名的方法时，调用以下方法执行的是Activity中定义的，而不是下面的。\n\n```\nfun FragmentActivity.showProgress(): MultListenerDialog {\n    val dialog = MultListenerDialog.getInstance(this)\n    dialog.showProgress()\n    return dialog\n}\n\nfun FragmentActivity.dismissProgress(delay: Boolean = true) {\n    MultListenerDialog.getInstance(this).dismissProgress(delay)\n}\n```\n## 引入依赖\n```\ndependencies {\n    implementation 'com.github.DonaldDu:RxNet:x.x.x'//JitPack version\n}\n```\n# 其它说明\n这个项目是由以前的[RetrofitRxUtil](https://github.com/SugarAndroid/RetrofitRxUtil)改名的，主要是以前的名字不太容易看懂功能，所以修改为RxNet，意为用RxJava来快捷实现网络请求的工具。\n\n以前的项目不维护，转到新项目了。\n# 作者其它开源项目\n[Android项目多服务端接口适配(超简单)](https://juejin.im/post/6858891439540011015/)\n# 最后\n开源不易，写文章更不易，劳烦大家给本文点个赞，可以的话，再给个star，感激不尽", "user_name": "DonaldDu", "description": "", "got_view_count": 2660, "category_name": "Android", "ctime": 1461266353}
{"tag_name": "Vue.js", "concern_user_count": 263220, "user_id": "2049145405450056", "title": "用（Node+MongoDB）搭建最简单的图床或者网盘", "mark_content": "<section id=\"nice\" data-tool=\"mdnice编辑器\" data-website=\"https://www.mdnice.com\" style=\"font-size: 16px; color: black; line-height: 1.6; word-spacing: 0px; letter-spacing: 0px; word-break: break-word; word-wrap: break-word; text-align: left; font-family: Optima-Regular, Optima, PingFangSC-light, PingFangTC-light, 'PingFang SC', Cambria, Cochin, Georgia, Times, 'Times New Roman', serif; margin-top: 0; padding: 0;\"><figure data-tool=\"mdnice编辑器\" style=\"margin: 0; margin-top: 10px; margin-bottom: 10px; display: flex; flex-direction: column; justify-content: center; align-items: center;\"><img src=\"https://timegods.oss-cn-shenzhen.aliyuncs.com/user/pg4.png\" alt style=\"display: block; max-width: 100%; border-radius: 5px; margin: 12px auto;\"></figure>\n<h2 data-tool=\"mdnice编辑器\" style=\"padding: 0px; color: black; font-weight: bold; font-size: 20px; margin-top: 24px; margin-bottom: 12px;\"><span class=\"prefix\" style=\"display: none;\"></span><span class=\"content\" style=\"color: #e7642b; text-align: center; display: block; background-color: #e7642b; color: white; padding: 3px 11px; border-radius: 1px;\">1 文章起源</span><span class=\"suffix\"></span></h2>\n<p data-tool=\"mdnice编辑器\" style=\"padding-top: 8px; padding-bottom: 8px; margin: 0; font-size: 16px; line-height: 26px; word-spacing: 3px; letter-spacing: 1px; color: #424B5D;\">在掘金白嫖了这么久，总觉得得有个产出，否则白嫖的怪不好意思的🤣看到网上各种各样的附件上传，觉得对于入门的人可能有些难度，今天就带来了关于Node+Mongodb的附件上传下载方面的文章。该项目比较简单，所以目录简单的一批，各位学到的可以快速搭建一个小网盘图床啥的。感谢掘金各位大大的文章让我升职加薪了😁（俺是男娃）</p>\n<h2 data-tool=\"mdnice编辑器\" style=\"padding: 0px; color: black; font-weight: bold; font-size: 20px; margin-top: 24px; margin-bottom: 12px;\"><span class=\"prefix\" style=\"display: none;\"></span><span class=\"content\" style=\"color: #e7642b; text-align: center; display: block; background-color: #e7642b; color: white; padding: 3px 11px; border-radius: 1px;\">2 起手式</span><span class=\"suffix\"></span></h2>\n<h3 data-tool=\"mdnice编辑器\" style=\"padding: 0px; margin-top: 24px; margin-bottom: 12px; font-weight: bold; font-size: 18px; color: #424B5D;\"><span class=\"prefix\" style=\"display: none;\"></span><span class=\"content\">2.1 概念</span><span class=\"suffix\" style=\"display: none;\"></span></h3>\n<p data-tool=\"mdnice编辑器\" style=\"padding-top: 8px; padding-bottom: 8px; margin: 0; font-size: 16px; line-height: 26px; word-spacing: 3px; letter-spacing: 1px; color: #424B5D;\">首先我们得先去了解一下<a href=\"https://mongodb.net.cn/manual/core/gridfs/\" style=\"text-decoration: none; word-wrap: break-word; font-weight: bold; color: #eb6161; border-bottom: 1px solid #eb6161;\"><span style=\"margin-right: 6px;\">👉</span>Mongodb的文件储存（GridFS）</a>是啥，因为我们都是基于 <strong style=\"font-weight: bold; color: #424B5D;\">GridFS</strong> 来进行文件储存</p>\n<h3 data-tool=\"mdnice编辑器\" style=\"padding: 0px; margin-top: 24px; margin-bottom: 12px; font-weight: bold; font-size: 18px; color: #424B5D;\"><span class=\"prefix\" style=\"display: none;\"></span><span class=\"content\">2.2 我们需要什么</span><span class=\"suffix\" style=\"display: none;\"></span></h3>\n<p data-tool=\"mdnice编辑器\" style=\"padding-top: 8px; padding-bottom: 8px; margin: 0; font-size: 16px; line-height: 26px; word-spacing: 3px; letter-spacing: 1px; color: #424B5D;\">了解了大概概念后就可以着手安装我们必须的插件了</p>\n<ul data-tool=\"mdnice编辑器\" style=\"margin-top: 8px; margin-bottom: 8px; list-style-type: disc; font-size: 15px; margin: 0; padding-left: 24px; color: #424B5D;\">\n<li><section style=\"margin-top: 5px; margin-bottom: 5px; text-align: left; font-weight: 500; margin: 4px 0; line-height: 24px; color: #424B5D;\"><a href=\"https://www.npmjs.com/package/express\" style=\"text-decoration: none; word-wrap: break-word; font-weight: bold; color: #eb6161; border-bottom: 1px solid #eb6161;\"><span style=\"margin-right: 6px;\">👉</span>express</a> （这是啥不用我多说）</section></li><li><section style=\"margin-top: 5px; margin-bottom: 5px; text-align: left; font-weight: 500; margin: 4px 0; line-height: 24px; color: #424B5D;\"><a href=\"https://www.npmjs.com/package/body-parser\" style=\"text-decoration: none; word-wrap: break-word; font-weight: bold; color: #eb6161; border-bottom: 1px solid #eb6161;\"><span style=\"margin-right: 6px;\">👉</span>body-parser</a> （Node解析body的中间件）</section></li><li><section style=\"margin-top: 5px; margin-bottom: 5px; text-align: left; font-weight: 500; margin: 4px 0; line-height: 24px; color: #424B5D;\"><a href=\"https://www.npmjs.com/package/ejs\" style=\"text-decoration: none; word-wrap: break-word; font-weight: bold; color: #eb6161; border-bottom: 1px solid #eb6161;\"><span style=\"margin-right: 6px;\">👉</span>ejs</a> （模板引擎，快速开发就不搞前后端分离了，有兴趣的小伙伴可以用Vue/React来搭建小网盘）</section></li><li><section style=\"margin-top: 5px; margin-bottom: 5px; text-align: left; font-weight: 500; margin: 4px 0; line-height: 24px; color: #424B5D;\"><a href=\"https://www.npmjs.com/package/gridfs-stream\" style=\"text-decoration: none; word-wrap: break-word; font-weight: bold; color: #eb6161; border-bottom: 1px solid #eb6161;\"><span style=\"margin-right: 6px;\">👉</span>gridfs-stream</a> （轻松地与MongoDB GridFS之间传输文件。）</section></li><li><section style=\"margin-top: 5px; margin-bottom: 5px; text-align: left; font-weight: 500; margin: 4px 0; line-height: 24px; color: #424B5D;\"><a href=\"https://www.npmjs.com/package/method-override\" style=\"text-decoration: none; word-wrap: break-word; font-weight: bold; color: #eb6161; border-bottom: 1px solid #eb6161;\"><span style=\"margin-right: 6px;\">👉</span>method-override</a> (我们用form表单简单上传，因为form表单不支持put/delete请求方式，所以把它安排上了，小伙伴可自行使用Ajax，就不需要这么麻烦了)</section></li><li><section style=\"margin-top: 5px; margin-bottom: 5px; text-align: left; font-weight: 500; margin: 4px 0; line-height: 24px; color: #424B5D;\"><a href=\"https://www.npmjs.com/package/mongoose\" style=\"text-decoration: none; word-wrap: break-word; font-weight: bold; color: #eb6161; border-bottom: 1px solid #eb6161;\"><span style=\"margin-right: 6px;\">👉</span>mongoose</a> (用于连接mongodb必不可少的插件)</section></li><li><section style=\"margin-top: 5px; margin-bottom: 5px; text-align: left; font-weight: 500; margin: 4px 0; line-height: 24px; color: #424B5D;\"><a href=\"https://www.npmjs.com/package/multer\" style=\"text-decoration: none; word-wrap: break-word; font-weight: bold; color: #eb6161; border-bottom: 1px solid #eb6161;\"><span style=\"margin-right: 6px;\">👉</span>multer</a> (Multer是用于处理多部分/表单数据的node.js中间件，主要用于上传文件。 它被编写在busboy之上，以实现最大效率。)</section></li><li><section style=\"margin-top: 5px; margin-bottom: 5px; text-align: left; font-weight: 500; margin: 4px 0; line-height: 24px; color: #424B5D;\"><a href=\"https://www.npmjs.com/package/multer-gridfs-storage\" style=\"text-decoration: none; word-wrap: break-word; font-weight: bold; color: #eb6161; border-bottom: 1px solid #eb6161;\"><span style=\"margin-right: 6px;\">👉</span>multer-gridfs-storage</a> (Multer的GridFS存储引擎可将上传的文件直接存储到MongoDb。)</section></li><li><section style=\"margin-top: 5px; margin-bottom: 5px; text-align: left; font-weight: 500; margin: 4px 0; line-height: 24px; color: #424B5D;\"><a href=\"https://www.npmjs.com/package/nodemon\" style=\"text-decoration: none; word-wrap: break-word; font-weight: bold; color: #eb6161; border-bottom: 1px solid #eb6161;\"><span style=\"margin-right: 6px;\">👉</span>nodemon</a> (热更新)</section></li></ul>\n<p data-tool=\"mdnice编辑器\" style=\"padding-top: 8px; padding-bottom: 8px; margin: 0; font-size: 16px; line-height: 26px; word-spacing: 3px; letter-spacing: 1px; color: #424B5D;\">以上就是我们需要准备的东西了</p>\n<pre class=\"custom\" data-tool=\"mdnice编辑器\" style=\"margin-top: 10px; margin-bottom: 10px; margin: 12px auto; border-radius: 5px; box-shadow: 0 1px 2px -2px rgba(0,0,0,.16), 0 3px 6px 0 rgba(0,0,0,.12), 0 5px 12px 4px rgba(0,0,0,.09) !important;\"><span style=\"display: block; background: url(https://my-wechat.mdnice.com/point.png); height: 30px; width: 100%; background-size: 40px; background-repeat: no-repeat; background-color: #282c34; margin-bottom: -7px; border-radius: 5px; background-position: 10px 10px;\"></span><code class=\"hljs\" style=\"overflow-x: auto; padding: 16px; color: #abb2bf; display: -webkit-box; font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; font-size: 12px; -webkit-overflow-scrolling: touch; padding-top: 15px; background: #282c34; border-radius: 5px;\">//&nbsp;懒人复制区域<br><br>npm&nbsp;install&nbsp;express&nbsp;body-parser&nbsp;ejs&nbsp;gridfs-stream&nbsp;method-override&nbsp;mongoose&nbsp;multer&nbsp;multer-gridfs-storage<br>//&nbsp;or<br>yarn&nbsp;add&nbsp;express&nbsp;body-parser&nbsp;ejs&nbsp;gridfs-stream&nbsp;method-override&nbsp;mongoose&nbsp;multer&nbsp;multer-gridfs-storage<br></code></pre>\n<h3 data-tool=\"mdnice编辑器\" style=\"padding: 0px; margin-top: 24px; margin-bottom: 12px; font-weight: bold; font-size: 18px; color: #424B5D;\"><span class=\"prefix\" style=\"display: none;\"></span><span class=\"content\">2.3 初始化一个项目</span><span class=\"suffix\" style=\"display: none;\"></span></h3>\n<pre class=\"custom\" data-tool=\"mdnice编辑器\" style=\"margin-top: 10px; margin-bottom: 10px; margin: 12px auto; border-radius: 5px; box-shadow: 0 1px 2px -2px rgba(0,0,0,.16), 0 3px 6px 0 rgba(0,0,0,.12), 0 5px 12px 4px rgba(0,0,0,.09) !important;\"><span style=\"display: block; background: url(https://my-wechat.mdnice.com/point.png); height: 30px; width: 100%; background-size: 40px; background-repeat: no-repeat; background-color: #282c34; margin-bottom: -7px; border-radius: 5px; background-position: 10px 10px;\"></span><code class=\"hljs\" style=\"overflow-x: auto; padding: 16px; color: #abb2bf; display: -webkit-box; font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; font-size: 12px; -webkit-overflow-scrolling: touch; padding-top: 15px; background: #282c34; border-radius: 5px;\">//&nbsp;可自行补充信息<br>//&nbsp;npm&nbsp;init<br></code></pre>\n<p data-tool=\"mdnice编辑器\" style=\"padding-top: 8px; padding-bottom: 8px; margin: 0; font-size: 16px; line-height: 26px; word-spacing: 3px; letter-spacing: 1px; color: #424B5D;\">然后在根目录新建一个入口文件 app.js,和页面  views/index.ejs</p>\n<h2 data-tool=\"mdnice编辑器\" style=\"padding: 0px; color: black; font-weight: bold; font-size: 20px; margin-top: 24px; margin-bottom: 12px;\"><span class=\"prefix\" style=\"display: none;\"></span><span class=\"content\" style=\"color: #e7642b; text-align: center; display: block; background-color: #e7642b; color: white; padding: 3px 11px; border-radius: 1px;\">3 现在项目开始了</span><span class=\"suffix\"></span></h2>\n<h3 data-tool=\"mdnice编辑器\" style=\"padding: 0px; margin-top: 24px; margin-bottom: 12px; font-weight: bold; font-size: 18px; color: #424B5D;\"><span class=\"prefix\" style=\"display: none;\"></span><span class=\"content\">3.1 先将基础部分完事</span><span class=\"suffix\" style=\"display: none;\"></span></h3>\n<p data-tool=\"mdnice编辑器\" style=\"padding-top: 8px; padding-bottom: 8px; margin: 0; font-size: 16px; line-height: 26px; word-spacing: 3px; letter-spacing: 1px; color: #424B5D;\">将我们安装的包引入，再跑跑看看</p>\n<pre class=\"custom\" data-tool=\"mdnice编辑器\" style=\"margin-top: 10px; margin-bottom: 10px; margin: 12px auto; border-radius: 5px; box-shadow: 0 1px 2px -2px rgba(0,0,0,.16), 0 3px 6px 0 rgba(0,0,0,.12), 0 5px 12px 4px rgba(0,0,0,.09) !important;\"><span style=\"display: block; background: url(https://my-wechat.mdnice.com/point.png); height: 30px; width: 100%; background-size: 40px; background-repeat: no-repeat; background-color: #282c34; margin-bottom: -7px; border-radius: 5px; background-position: 10px 10px;\"></span><code class=\"hljs\" style=\"overflow-x: auto; padding: 16px; color: #abb2bf; display: -webkit-box; font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; font-size: 12px; -webkit-overflow-scrolling: touch; padding-top: 15px; background: #282c34; border-radius: 5px;\">const&nbsp;express&nbsp;=&nbsp;require(<span class=\"hljs-string\" style=\"color: #98c379; line-height: 26px;\">'express'</span>)<br>const&nbsp;path&nbsp;=&nbsp;require(<span class=\"hljs-string\" style=\"color: #98c379; line-height: 26px;\">'path'</span>)<br>const&nbsp;crypto&nbsp;=&nbsp;require(<span class=\"hljs-string\" style=\"color: #98c379; line-height: 26px;\">'crypto'</span>)<br>const&nbsp;mongoose&nbsp;=&nbsp;require(<span class=\"hljs-string\" style=\"color: #98c379; line-height: 26px;\">'mongoose'</span>)<br>const&nbsp;multer&nbsp;=&nbsp;require(<span class=\"hljs-string\" style=\"color: #98c379; line-height: 26px;\">'multer'</span>)<br>const&nbsp;GridFsStorage&nbsp;=&nbsp;require(<span class=\"hljs-string\" style=\"color: #98c379; line-height: 26px;\">'multer-gridfs-storage'</span>)<br>const&nbsp;GridFsStream&nbsp;=&nbsp;require(<span class=\"hljs-string\" style=\"color: #98c379; line-height: 26px;\">'gridfs-stream'</span>)<br>const&nbsp;methodOverride&nbsp;=&nbsp;require(<span class=\"hljs-string\" style=\"color: #98c379; line-height: 26px;\">'method-override'</span>)<br>const&nbsp;bodyParser&nbsp;=&nbsp;require(<span class=\"hljs-string\" style=\"color: #98c379; line-height: 26px;\">'body-parser'</span>)<br><br>const&nbsp;app&nbsp;=&nbsp;express()<br><br>app.set(<span class=\"hljs-string\" style=\"color: #98c379; line-height: 26px;\">'view&nbsp;engine'</span>,&nbsp;<span class=\"hljs-string\" style=\"color: #98c379; line-height: 26px;\">'ejs'</span>)&nbsp;//&nbsp;设置模板引擎<br><br>app.use(bodyParser.json())&nbsp;<br>app.use(methodOverride(<span class=\"hljs-string\" style=\"color: #98c379; line-height: 26px;\">'_method'</span>))<br><br>app.get(<span class=\"hljs-string\" style=\"color: #98c379; line-height: 26px;\">'/'</span>,&nbsp;(req,&nbsp;res)&nbsp;=&gt;&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;res.render(<span class=\"hljs-string\" style=\"color: #98c379; line-height: 26px;\">'index'</span>)<br>&nbsp;&nbsp;&nbsp;&nbsp;})<br>})<br><br>const&nbsp;port&nbsp;=&nbsp;5000<br>app.listen(port,&nbsp;()&nbsp;=&gt;&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;console.log(`App&nbsp;listering&nbsp;on&nbsp;port&nbsp;<span class=\"hljs-variable\" style=\"color: #d19a66; line-height: 26px;\">${port}</span>`)<br>})<br></code></pre>\n<p data-tool=\"mdnice编辑器\" style=\"padding-top: 8px; padding-bottom: 8px; margin: 0; font-size: 16px; line-height: 26px; word-spacing: 3px; letter-spacing: 1px; color: #424B5D;\">一般来说启动了app.js的话我们在浏览器访问 http://localhost:5000 就能看到 views/index.ejs 中的界面了，如果没有，自行查看控制台是否报错</p>\n<h3 data-tool=\"mdnice编辑器\" style=\"padding: 0px; margin-top: 24px; margin-bottom: 12px; font-weight: bold; font-size: 18px; color: #424B5D;\"><span class=\"prefix\" style=\"display: none;\"></span><span class=\"content\">3.2 连接我们的Mongodb数据库</span><span class=\"suffix\" style=\"display: none;\"></span></h3>\n<p data-tool=\"mdnice编辑器\" style=\"padding-top: 8px; padding-bottom: 8px; margin: 0; font-size: 16px; line-height: 26px; word-spacing: 3px; letter-spacing: 1px; color: #424B5D;\">我这边用的本地mongodb数据库，线上也是一样的，我们可以用 <strong style=\"font-weight: bold; color: #424B5D;\">NoSQL manager for mongdb</strong> 来查看我们数据库里面的数据，我们新建一个新的集合，我这边叫 grid_uploads。所以连接的话也是连接这个集合</p>\n<pre class=\"custom\" data-tool=\"mdnice编辑器\" style=\"margin-top: 10px; margin-bottom: 10px; margin: 12px auto; border-radius: 5px; box-shadow: 0 1px 2px -2px rgba(0,0,0,.16), 0 3px 6px 0 rgba(0,0,0,.12), 0 5px 12px 4px rgba(0,0,0,.09) !important;\"><span style=\"display: block; background: url(https://my-wechat.mdnice.com/point.png); height: 30px; width: 100%; background-size: 40px; background-repeat: no-repeat; background-color: #282c34; margin-bottom: -7px; border-radius: 5px; background-position: 10px 10px;\"></span><code class=\"hljs\" style=\"overflow-x: auto; padding: 16px; color: #abb2bf; display: -webkit-box; font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; font-size: 12px; -webkit-overflow-scrolling: touch; padding-top: 15px; background: #282c34; border-radius: 5px;\">//&nbsp;数据库的链接<br>const&nbsp;mongoURL&nbsp;=&nbsp;<span class=\"hljs-string\" style=\"color: #98c379; line-height: 26px;\">'mongodb://localhost:27017/grid_uploads'</span><br><br>const&nbsp;connect&nbsp;=&nbsp;mongoose.createConnection(mongoURL,&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;useNewUrlParser:&nbsp;<span class=\"hljs-literal\" style=\"color: #56b6c2; line-height: 26px;\">true</span>,<br>&nbsp;&nbsp;&nbsp;&nbsp;useUnifiedTopology:&nbsp;<span class=\"hljs-literal\" style=\"color: #56b6c2; line-height: 26px;\">true</span><br>})<br></code></pre>\n<p data-tool=\"mdnice编辑器\" style=\"padding-top: 8px; padding-bottom: 8px; margin: 0; font-size: 16px; line-height: 26px; word-spacing: 3px; letter-spacing: 1px; color: #424B5D;\">可以尝试在NoSQL写入一些数据，具体使用可以参考博客<a href=\"https://www.cnblogs.com/TurboWay/p/8213656.html\" style=\"text-decoration: none; word-wrap: break-word; font-weight: bold; color: #eb6161; border-bottom: 1px solid #eb6161;\"><span style=\"margin-right: 6px;\">👉</span>【MongoDB】NoSQL Manager for MongoDB 教程\n</a></p>\n<h3 data-tool=\"mdnice编辑器\" style=\"padding: 0px; margin-top: 24px; margin-bottom: 12px; font-weight: bold; font-size: 18px; color: #424B5D;\"><span class=\"prefix\" style=\"display: none;\"></span><span class=\"content\">3.3 美化一下界面（views/index.ejs）</span><span class=\"suffix\" style=\"display: none;\"></span></h3>\n<p data-tool=\"mdnice编辑器\" style=\"padding-top: 8px; padding-bottom: 8px; margin: 0; font-size: 16px; line-height: 26px; word-spacing: 3px; letter-spacing: 1px; color: #424B5D;\">作为一个小两年的前端工程师，已经练就了像素眼了，我们肯定不能把界面做的辣么丑对吧，眼睛过不去啊，所以我们简单的用bootstrap4来做个界面好了</p>\n<pre class=\"custom\" data-tool=\"mdnice编辑器\" style=\"margin-top: 10px; margin-bottom: 10px; margin: 12px auto; border-radius: 5px; box-shadow: 0 1px 2px -2px rgba(0,0,0,.16), 0 3px 6px 0 rgba(0,0,0,.12), 0 5px 12px 4px rgba(0,0,0,.09) !important;\"><span style=\"display: block; background: url(https://my-wechat.mdnice.com/point.png); height: 30px; width: 100%; background-size: 40px; background-repeat: no-repeat; background-color: #282c34; margin-bottom: -7px; border-radius: 5px; background-position: 10px 10px;\"></span><code class=\"hljs\" style=\"overflow-x: auto; padding: 16px; color: #abb2bf; display: -webkit-box; font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; font-size: 12px; -webkit-overflow-scrolling: touch; padding-top: 15px; background: #282c34; border-radius: 5px;\">&lt;!DOCTYPE&nbsp;html&gt;<br>&lt;html&nbsp;lang=<span class=\"hljs-string\" style=\"color: #98c379; line-height: 26px;\">\"en\"</span>&gt;<br><br>&lt;head&gt;<br>&nbsp;&nbsp;&nbsp;&nbsp;&lt;meta&nbsp;charset=<span class=\"hljs-string\" style=\"color: #98c379; line-height: 26px;\">\"UTF-8\"</span>&gt;<br>&nbsp;&nbsp;&nbsp;&nbsp;&lt;meta&nbsp;name=<span class=\"hljs-string\" style=\"color: #98c379; line-height: 26px;\">\"viewport\"</span>&nbsp;content=<span class=\"hljs-string\" style=\"color: #98c379; line-height: 26px;\">\"width=device-width,&nbsp;initial-scale=1.0\"</span>&gt;<br>&nbsp;&nbsp;&nbsp;&nbsp;&lt;title&gt;文件上传&lt;/title&gt;<br>&nbsp;&nbsp;&nbsp;&nbsp;&lt;link&nbsp;rel=<span class=\"hljs-string\" style=\"color: #98c379; line-height: 26px;\">\"stylesheet\"</span>&nbsp;href=<span class=\"hljs-string\" style=\"color: #98c379; line-height: 26px;\">\"https://cdn.jsdelivr.net/npm/bootstrap@4.5.0/dist/css/bootstrap.min.css\"</span>&nbsp;integrity=<span class=\"hljs-string\" style=\"color: #98c379; line-height: 26px;\">\"sha384-9aIt2nRpC12Uk9gS9baDl411NQApFmC26EwAOH8WgZl5MYYxFfc+NcPb1dKGj7Sk\"</span>&nbsp;crossorigin=<span class=\"hljs-string\" style=\"color: #98c379; line-height: 26px;\">\"anonymous\"</span>&gt;<br>&nbsp;&nbsp;&nbsp;&nbsp;&lt;style&gt;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;img&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;width:&nbsp;100%;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;&nbsp;&nbsp;&lt;/style&gt;<br>&lt;/head&gt;<br><br>&lt;body&gt;<br>&nbsp;&nbsp;&nbsp;&nbsp;&lt;div&nbsp;class=<span class=\"hljs-string\" style=\"color: #98c379; line-height: 26px;\">\"container\"</span>&gt;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;div&nbsp;class=<span class=\"hljs-string\" style=\"color: #98c379; line-height: 26px;\">\"row\"</span>&gt;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;div&nbsp;class=<span class=\"hljs-string\" style=\"color: #98c379; line-height: 26px;\">\"col-md-6&nbsp;m-auto\"</span>&gt;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;h2&nbsp;class=<span class=\"hljs-string\" style=\"color: #98c379; line-height: 26px;\">\"text-center&nbsp;display-4&nbsp;my-4\"</span>&gt;Mongo文件上传&lt;/h2&gt;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;form&nbsp;action=<span class=\"hljs-string\" style=\"color: #98c379; line-height: 26px;\">\"/upload\"</span>&nbsp;method=<span class=\"hljs-string\" style=\"color: #98c379; line-height: 26px;\">\"POST\"</span>&nbsp;enctype=<span class=\"hljs-string\" style=\"color: #98c379; line-height: 26px;\">\"multipart/form-data\"</span>&gt;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;div&nbsp;class=<span class=\"hljs-string\" style=\"color: #98c379; line-height: 26px;\">\"custom-file&nbsp;mb-3\"</span>&gt;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;input&nbsp;<span class=\"hljs-built_in\" style=\"color: #e6c07b; line-height: 26px;\">type</span>=<span class=\"hljs-string\" style=\"color: #98c379; line-height: 26px;\">\"file\"</span>&nbsp;name=<span class=\"hljs-string\" style=\"color: #98c379; line-height: 26px;\">\"file\"</span>&nbsp;id=<span class=\"hljs-string\" style=\"color: #98c379; line-height: 26px;\">\"file\"</span>&nbsp;class=<span class=\"hljs-string\" style=\"color: #98c379; line-height: 26px;\">\"custom-file-input\"</span>&gt;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;label&nbsp;<span class=\"hljs-keyword\" style=\"color: #c678dd; line-height: 26px;\">for</span>=<span class=\"hljs-string\" style=\"color: #98c379; line-height: 26px;\">\"file\"</span>&nbsp;class=<span class=\"hljs-string\" style=\"color: #98c379; line-height: 26px;\">\"custom-file-label\"</span>&gt;选择文件&lt;/label&gt;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;/div&gt;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;input&nbsp;class=<span class=\"hljs-string\" style=\"color: #98c379; line-height: 26px;\">\"btn&nbsp;btn-primary&nbsp;btn-block\"</span>&nbsp;<span class=\"hljs-built_in\" style=\"color: #e6c07b; line-height: 26px;\">type</span>=<span class=\"hljs-string\" style=\"color: #98c379; line-height: 26px;\">\"submit\"</span>&nbsp;value=<span class=\"hljs-string\" style=\"color: #98c379; line-height: 26px;\">\"提交\"</span>&gt;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;/form&gt;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;hr&gt;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;/div&gt;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;/div&gt;<br>&nbsp;&nbsp;&nbsp;&nbsp;&lt;/div&gt;<br>&lt;/body&gt;<br>&lt;script&nbsp;src=<span class=\"hljs-string\" style=\"color: #98c379; line-height: 26px;\">\"https://cdn.jsdelivr.net/npm/jquery@3.5.1/dist/jquery.slim.min.js\"</span>&nbsp;integrity=<span class=\"hljs-string\" style=\"color: #98c379; line-height: 26px;\">\"sha384-DfXdz2htPH0lsSSs5nCTpuj/zy4C+OGpamoFVy38MVBnE+IbbVYUew+OrCXaRkfj\"</span>&nbsp;crossorigin=<span class=\"hljs-string\" style=\"color: #98c379; line-height: 26px;\">\"anonymous\"</span>&gt;&lt;/script&gt;<br>&lt;script&nbsp;src=<span class=\"hljs-string\" style=\"color: #98c379; line-height: 26px;\">\"https://cdn.jsdelivr.net/npm/popper.js@1.16.0/dist/umd/popper.min.js\"</span>&nbsp;integrity=<span class=\"hljs-string\" style=\"color: #98c379; line-height: 26px;\">\"sha384-Q6E9RHvbIyZFJoft+2mJbHaEWldlvI9IOYy5n3zV9zzTtmI3UksdQRVvoxMfooAo\"</span>&nbsp;crossorigin=<span class=\"hljs-string\" style=\"color: #98c379; line-height: 26px;\">\"anonymous\"</span>&gt;&lt;/script&gt;<br>&lt;script&nbsp;src=<span class=\"hljs-string\" style=\"color: #98c379; line-height: 26px;\">\"https://cdn.jsdelivr.net/npm/bootstrap@4.5.0/dist/js/bootstrap.min.js\"</span>&nbsp;integrity=<span class=\"hljs-string\" style=\"color: #98c379; line-height: 26px;\">\"sha384-OgVRvuATP1z7JjHLkuOU7Xw704+h835Lr+6QL9UvYjZE3Ipu6Tp75j7Bh/kR0JKI\"</span>&nbsp;crossorigin=<span class=\"hljs-string\" style=\"color: #98c379; line-height: 26px;\">\"anonymous\"</span>&gt;&lt;/script&gt;<br><br>&lt;/html&gt;<br></code></pre>\n<p data-tool=\"mdnice编辑器\" style=\"padding-top: 8px; padding-bottom: 8px; margin: 0; font-size: 16px; line-height: 26px; word-spacing: 3px; letter-spacing: 1px; color: #424B5D;\">那么我们请求 http://localhost:5000 的话我们看到的应该是这样子的\n<img src=\"https://timegods.oss-cn-shenzhen.aliyuncs.com/markdown/mg01.png\" alt style=\"display: block; max-width: 100%; border-radius: 5px; margin: 12px auto;\"></p>\n<h3 data-tool=\"mdnice编辑器\" style=\"padding: 0px; margin-top: 24px; margin-bottom: 12px; font-weight: bold; font-size: 18px; color: #424B5D;\"><span class=\"prefix\" style=\"display: none;\"></span><span class=\"content\">3.4 做一些必须的处理</span><span class=\"suffix\" style=\"display: none;\"></span></h3>\n<pre class=\"custom\" data-tool=\"mdnice编辑器\" style=\"margin-top: 10px; margin-bottom: 10px; margin: 12px auto; border-radius: 5px; box-shadow: 0 1px 2px -2px rgba(0,0,0,.16), 0 3px 6px 0 rgba(0,0,0,.12), 0 5px 12px 4px rgba(0,0,0,.09) !important;\"><span style=\"display: block; background: url(https://my-wechat.mdnice.com/point.png); height: 30px; width: 100%; background-size: 40px; background-repeat: no-repeat; background-color: #282c34; margin-bottom: -7px; border-radius: 5px; background-position: 10px 10px;\"></span><code class=\"hljs\" style=\"overflow-x: auto; padding: 16px; color: #abb2bf; display: -webkit-box; font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; font-size: 12px; -webkit-overflow-scrolling: touch; padding-top: 15px; background: #282c34; border-radius: 5px;\">//&nbsp;定义gfs变量，后续我们进行数据库文件操作的时候可不能少<br><span class=\"hljs-built_in\" style=\"color: #e6c07b; line-height: 26px;\">let</span>&nbsp;gfs;<br>connect.once(<span class=\"hljs-string\" style=\"color: #98c379; line-height: 26px;\">'open'</span>,&nbsp;()&nbsp;=&gt;&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;监听数据库开启，通过&nbsp;gridfs-stream&nbsp;中间件和数据库进行文件的出入控制<br>&nbsp;&nbsp;&nbsp;&nbsp;gfs&nbsp;=&nbsp;GridFsStream(connect.db,&nbsp;mongoose.mongo)<br>&nbsp;&nbsp;&nbsp;&nbsp;gfs.collection(<span class=\"hljs-string\" style=\"color: #98c379; line-height: 26px;\">'upload'</span>)<br>&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;它会在我们数据库中建立&nbsp;upload.files(记录文件信息)&nbsp;&nbsp;upload.chunks(存储文件块)<br>})<br><br>//&nbsp;使用&nbsp;multer-gridfs-storage&nbsp;Multer&nbsp;中间件来讲我们上传的附件直接存储到MongoDb<br>const&nbsp;storage&nbsp;=&nbsp;new&nbsp;GridFsStorage({<br>&nbsp;&nbsp;&nbsp;&nbsp;url:&nbsp;mongoURL,<br>&nbsp;&nbsp;&nbsp;&nbsp;file:&nbsp;(req,&nbsp;file)&nbsp;=&gt;&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class=\"hljs-built_in\" style=\"color: #e6c07b; line-height: 26px;\">return</span>&nbsp;new&nbsp;Promise((resolve,&nbsp;reject)&nbsp;=&gt;&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;下面注释部分是给文件进行重命名的，如果想要原文件名称可以自行使用&nbsp;file.originalname&nbsp;返回，<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;建议有时间的小伙伴存储两个文档，一个记录原文件名，一个记录加密文件名，然后返回到页面的时候可以将中文名返回去<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;crypto.randomBytes(16,&nbsp;(err,&nbsp;buf)&nbsp;=&gt;&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class=\"hljs-keyword\" style=\"color: #c678dd; line-height: 26px;\">if</span>&nbsp;(err)&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class=\"hljs-built_in\" style=\"color: #e6c07b; line-height: 26px;\">return</span>&nbsp;reject(err)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;const&nbsp;filename&nbsp;=&nbsp;buf.toString(<span class=\"hljs-string\" style=\"color: #98c379; line-height: 26px;\">'hex'</span>)&nbsp;+&nbsp;path.extname(file.originalname)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;const&nbsp;fileinfo&nbsp;=&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;filename,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;bucketName:&nbsp;<span class=\"hljs-string\" style=\"color: #98c379; line-height: 26px;\">'upload'</span><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;resolve(fileinfo)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;})<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;const&nbsp;fileinfo&nbsp;=&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;filename:&nbsp;new&nbsp;Date()&nbsp;+&nbsp;<span class=\"hljs-string\" style=\"color: #98c379; line-height: 26px;\">'-'</span>&nbsp;+&nbsp;file.originalname,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;bucketName:&nbsp;<span class=\"hljs-string\" style=\"color: #98c379; line-height: 26px;\">'upload'</span><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;resolve(fileinfo)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;})<br>&nbsp;&nbsp;&nbsp;&nbsp;}<br>})<br><br>const&nbsp;upload&nbsp;=&nbsp;multer({&nbsp;storage&nbsp;})<br></code></pre>\n<h3 data-tool=\"mdnice编辑器\" style=\"padding: 0px; margin-top: 24px; margin-bottom: 12px; font-weight: bold; font-size: 18px; color: #424B5D;\"><span class=\"prefix\" style=\"display: none;\"></span><span class=\"content\">3.5 写我们上传第一个文件的接口</span><span class=\"suffix\" style=\"display: none;\"></span></h3>\n<pre class=\"custom\" data-tool=\"mdnice编辑器\" style=\"margin-top: 10px; margin-bottom: 10px; margin: 12px auto; border-radius: 5px; box-shadow: 0 1px 2px -2px rgba(0,0,0,.16), 0 3px 6px 0 rgba(0,0,0,.12), 0 5px 12px 4px rgba(0,0,0,.09) !important;\"><span style=\"display: block; background: url(https://my-wechat.mdnice.com/point.png); height: 30px; width: 100%; background-size: 40px; background-repeat: no-repeat; background-color: #282c34; margin-bottom: -7px; border-radius: 5px; background-position: 10px 10px;\"></span><code class=\"hljs\" style=\"overflow-x: auto; padding: 16px; color: #abb2bf; display: -webkit-box; font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; font-size: 12px; -webkit-overflow-scrolling: touch; padding-top: 15px; background: #282c34; border-radius: 5px;\">app.post(<span class=\"hljs-string\" style=\"color: #98c379; line-height: 26px;\">'/upload'</span>,&nbsp;upload.single(<span class=\"hljs-string\" style=\"color: #98c379; line-height: 26px;\">'file'</span>),&nbsp;(req,&nbsp;res)&nbsp;=&gt;&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;res.redirect(<span class=\"hljs-string\" style=\"color: #98c379; line-height: 26px;\">'/'</span>)<br>})<br></code></pre>\n<p data-tool=\"mdnice编辑器\" style=\"padding-top: 8px; padding-bottom: 8px; margin: 0; font-size: 16px; line-height: 26px; word-spacing: 3px; letter-spacing: 1px; color: #424B5D;\">看起来简简单单，请记着这么几件事</p>\n<ul data-tool=\"mdnice编辑器\" style=\"margin-top: 8px; margin-bottom: 8px; list-style-type: disc; font-size: 15px; margin: 0; padding-left: 24px; color: #424B5D;\">\n<li><section style=\"margin-top: 5px; margin-bottom: 5px; text-align: left; font-weight: 500; margin: 4px 0; line-height: 24px; color: #424B5D;\">在views/index.ejs中 <strong style=\"font-weight: bold; color: #424B5D;\">（input type=file</strong> 指定的name得和接口的 <strong style=\"font-weight: bold; color: #424B5D;\">upload.single('file')</strong> 一样</section></li><li><section style=\"margin-top: 5px; margin-bottom: 5px; text-align: left; font-weight: 500; margin: 4px 0; line-height: 24px; color: #424B5D;\">上传完文件我们重定向回我们的首页\n此时我们就可以在NoSql看到我们的两个文档有数据了</section></li></ul>\n<p data-tool=\"mdnice编辑器\" style=\"padding-top: 8px; padding-bottom: 8px; margin: 0; font-size: 16px; line-height: 26px; word-spacing: 3px; letter-spacing: 1px; color: #424B5D;\">这是upload.chunks\n<img src=\"https://timegods.oss-cn-shenzhen.aliyuncs.com/markdown/mg02.png\" alt style=\"display: block; max-width: 100%; border-radius: 5px; margin: 12px auto;\"></p>\n<p data-tool=\"mdnice编辑器\" style=\"padding-top: 8px; padding-bottom: 8px; margin: 0; font-size: 16px; line-height: 26px; word-spacing: 3px; letter-spacing: 1px; color: #424B5D;\">这是upload.files\n<img src=\"https://timegods.oss-cn-shenzhen.aliyuncs.com/markdown/mg03.png\" alt style=\"display: block; max-width: 100%; border-radius: 5px; margin: 12px auto;\"></p>\n<h3 data-tool=\"mdnice编辑器\" style=\"padding: 0px; margin-top: 24px; margin-bottom: 12px; font-weight: bold; font-size: 18px; color: #424B5D;\"><span class=\"prefix\" style=\"display: none;\"></span><span class=\"content\">3.6 获取我们所有的文件信息</span><span class=\"suffix\" style=\"display: none;\"></span></h3>\n<p data-tool=\"mdnice编辑器\" style=\"padding-top: 8px; padding-bottom: 8px; margin: 0; font-size: 16px; line-height: 26px; word-spacing: 3px; letter-spacing: 1px; color: #424B5D;\">获取我们所有的文件</p>\n<pre class=\"custom\" data-tool=\"mdnice编辑器\" style=\"margin-top: 10px; margin-bottom: 10px; margin: 12px auto; border-radius: 5px; box-shadow: 0 1px 2px -2px rgba(0,0,0,.16), 0 3px 6px 0 rgba(0,0,0,.12), 0 5px 12px 4px rgba(0,0,0,.09) !important;\"><span style=\"display: block; background: url(https://my-wechat.mdnice.com/point.png); height: 30px; width: 100%; background-size: 40px; background-repeat: no-repeat; background-color: #282c34; margin-bottom: -7px; border-radius: 5px; background-position: 10px 10px;\"></span><code class=\"hljs\" style=\"overflow-x: auto; padding: 16px; color: #abb2bf; display: -webkit-box; font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; font-size: 12px; -webkit-overflow-scrolling: touch; padding-top: 15px; background: #282c34; border-radius: 5px;\">app.get(<span class=\"hljs-string\" style=\"color: #98c379; line-height: 26px;\">'/files'</span>,&nbsp;(req,&nbsp;res)&nbsp;=&gt;&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;通过查找返回一个数组对象回去<br>&nbsp;&nbsp;&nbsp;&nbsp;gfs.files.find().toArray((err,&nbsp;files)&nbsp;=&gt;&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class=\"hljs-keyword\" style=\"color: #c678dd; line-height: 26px;\">if</span>&nbsp;(!files&nbsp;||&nbsp;files.length&nbsp;===&nbsp;0)&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class=\"hljs-built_in\" style=\"color: #e6c07b; line-height: 26px;\">return</span>&nbsp;res.status(404).json({<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;err:&nbsp;<span class=\"hljs-string\" style=\"color: #98c379; line-height: 26px;\">'文件不存在！'</span><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;})<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class=\"hljs-built_in\" style=\"color: #e6c07b; line-height: 26px;\">return</span>&nbsp;res.json(files)<br>&nbsp;&nbsp;&nbsp;&nbsp;})<br>})<br></code></pre>\n<p data-tool=\"mdnice编辑器\" style=\"padding-top: 8px; padding-bottom: 8px; margin: 0; font-size: 16px; line-height: 26px; word-spacing: 3px; letter-spacing: 1px; color: #424B5D;\">我们可以进行一些美化操作，比如我们可以将上传是图片的，返回到界面的话以图片显示，其他则以 a 标签的格式显示（可点击下载），所以我们可以将 views/index.ejs的界面进行美化改造（ejs语法用起来确实蛮麻烦的），进行重新排版以及添加删除按钮</p>\n<pre class=\"custom\" data-tool=\"mdnice编辑器\" style=\"margin-top: 10px; margin-bottom: 10px; margin: 12px auto; border-radius: 5px; box-shadow: 0 1px 2px -2px rgba(0,0,0,.16), 0 3px 6px 0 rgba(0,0,0,.12), 0 5px 12px 4px rgba(0,0,0,.09) !important;\"><span style=\"display: block; background: url(https://my-wechat.mdnice.com/point.png); height: 30px; width: 100%; background-size: 40px; background-repeat: no-repeat; background-color: #282c34; margin-bottom: -7px; border-radius: 5px; background-position: 10px 10px;\"></span><code class=\"hljs\" style=\"overflow-x: auto; padding: 16px; color: #abb2bf; display: -webkit-box; font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; font-size: 12px; -webkit-overflow-scrolling: touch; padding-top: 15px; background: #282c34; border-radius: 5px;\">&lt;!DOCTYPE&nbsp;html&gt;<br>&lt;html&nbsp;lang=<span class=\"hljs-string\" style=\"color: #98c379; line-height: 26px;\">\"en\"</span>&gt;<br><br>&lt;head&gt;<br>&nbsp;&nbsp;&nbsp;&nbsp;&lt;meta&nbsp;charset=<span class=\"hljs-string\" style=\"color: #98c379; line-height: 26px;\">\"UTF-8\"</span>&gt;<br>&nbsp;&nbsp;&nbsp;&nbsp;&lt;meta&nbsp;name=<span class=\"hljs-string\" style=\"color: #98c379; line-height: 26px;\">\"viewport\"</span>&nbsp;content=<span class=\"hljs-string\" style=\"color: #98c379; line-height: 26px;\">\"width=device-width,&nbsp;initial-scale=1.0\"</span>&gt;<br>&nbsp;&nbsp;&nbsp;&nbsp;&lt;title&gt;文件上传&lt;/title&gt;<br>&nbsp;&nbsp;&nbsp;&nbsp;&lt;link&nbsp;rel=<span class=\"hljs-string\" style=\"color: #98c379; line-height: 26px;\">\"stylesheet\"</span>&nbsp;href=<span class=\"hljs-string\" style=\"color: #98c379; line-height: 26px;\">\"https://cdn.jsdelivr.net/npm/bootstrap@4.5.0/dist/css/bootstrap.min.css\"</span><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;integrity=<span class=\"hljs-string\" style=\"color: #98c379; line-height: 26px;\">\"sha384-9aIt2nRpC12Uk9gS9baDl411NQApFmC26EwAOH8WgZl5MYYxFfc+NcPb1dKGj7Sk\"</span>&nbsp;crossorigin=<span class=\"hljs-string\" style=\"color: #98c379; line-height: 26px;\">\"anonymous\"</span>&gt;<br>&nbsp;&nbsp;&nbsp;&nbsp;&lt;style&gt;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;img&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;width:&nbsp;100%;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;&nbsp;&nbsp;&lt;/style&gt;<br>&lt;/head&gt;<br><br>&lt;body&gt;<br>&nbsp;&nbsp;&nbsp;&nbsp;&lt;div&nbsp;class=<span class=\"hljs-string\" style=\"color: #98c379; line-height: 26px;\">\"container\"</span>&gt;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;div&nbsp;class=<span class=\"hljs-string\" style=\"color: #98c379; line-height: 26px;\">\"row\"</span>&gt;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;div&nbsp;class=<span class=\"hljs-string\" style=\"color: #98c379; line-height: 26px;\">\"col-md-6&nbsp;m-auto\"</span>&gt;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;h2&nbsp;class=<span class=\"hljs-string\" style=\"color: #98c379; line-height: 26px;\">\"text-center&nbsp;display-4&nbsp;my-4\"</span>&gt;Mongo文件上传&lt;/h2&gt;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;form&nbsp;action=<span class=\"hljs-string\" style=\"color: #98c379; line-height: 26px;\">\"/upload\"</span>&nbsp;method=<span class=\"hljs-string\" style=\"color: #98c379; line-height: 26px;\">\"POST\"</span>&nbsp;enctype=<span class=\"hljs-string\" style=\"color: #98c379; line-height: 26px;\">\"multipart/form-data\"</span>&gt;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;div&nbsp;class=<span class=\"hljs-string\" style=\"color: #98c379; line-height: 26px;\">\"custom-file&nbsp;mb-3\"</span>&gt;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;input&nbsp;<span class=\"hljs-built_in\" style=\"color: #e6c07b; line-height: 26px;\">type</span>=<span class=\"hljs-string\" style=\"color: #98c379; line-height: 26px;\">\"file\"</span>&nbsp;name=<span class=\"hljs-string\" style=\"color: #98c379; line-height: 26px;\">\"file\"</span>&nbsp;id=<span class=\"hljs-string\" style=\"color: #98c379; line-height: 26px;\">\"file\"</span>&nbsp;class=<span class=\"hljs-string\" style=\"color: #98c379; line-height: 26px;\">\"custom-file-input\"</span>&gt;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;label&nbsp;<span class=\"hljs-keyword\" style=\"color: #c678dd; line-height: 26px;\">for</span>=<span class=\"hljs-string\" style=\"color: #98c379; line-height: 26px;\">\"file\"</span>&nbsp;class=<span class=\"hljs-string\" style=\"color: #98c379; line-height: 26px;\">\"custom-file-label\"</span>&gt;选择文件&lt;/label&gt;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;/div&gt;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;input&nbsp;class=<span class=\"hljs-string\" style=\"color: #98c379; line-height: 26px;\">\"btn&nbsp;btn-primary&nbsp;btn-block\"</span>&nbsp;<span class=\"hljs-built_in\" style=\"color: #e6c07b; line-height: 26px;\">type</span>=<span class=\"hljs-string\" style=\"color: #98c379; line-height: 26px;\">\"submit\"</span>&nbsp;value=<span class=\"hljs-string\" style=\"color: #98c379; line-height: 26px;\">\"提交\"</span>&gt;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;/form&gt;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;hr&gt;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;/div&gt;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;/div&gt;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;div&nbsp;class=<span class=\"hljs-string\" style=\"color: #98c379; line-height: 26px;\">\"row\"</span>&gt;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;%&nbsp;<span class=\"hljs-keyword\" style=\"color: #c678dd; line-height: 26px;\">if</span>(files){&nbsp;%&gt;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;%&nbsp;files.forEach(<span class=\"hljs-keyword\" style=\"color: #c678dd; line-height: 26px;\">function</span>(file){&nbsp;%&gt;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;div&nbsp;class=<span class=\"hljs-string\" style=\"color: #98c379; line-height: 26px;\">\"col-sm&nbsp;card&nbsp;card-body&nbsp;m-3&nbsp;&nbsp;col-md-2\"</span>&gt;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;%&nbsp;<span class=\"hljs-keyword\" style=\"color: #c678dd; line-height: 26px;\">if</span>(file.isImage){&nbsp;%&gt;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;img&nbsp;src=<span class=\"hljs-string\" style=\"color: #98c379; line-height: 26px;\">\"image/&lt;%=&nbsp;file.filename&nbsp;%&gt;\"</span>&nbsp;/&gt;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;%&nbsp;}&nbsp;<span class=\"hljs-keyword\" style=\"color: #c678dd; line-height: 26px;\">else</span>&nbsp;{&nbsp;%&gt;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;a&nbsp;href=<span class=\"hljs-string\" style=\"color: #98c379; line-height: 26px;\">\"download/&lt;%=&nbsp;file.filename&nbsp;%&gt;\"</span>&gt;&lt;%=&nbsp;file.filename&nbsp;%&gt;&lt;/a&gt;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;%}%&gt;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;form&nbsp;action=<span class=\"hljs-string\" style=\"color: #98c379; line-height: 26px;\">\"/files/&lt;%=&nbsp;file._id%&gt;?_method=DELETE\"</span>&nbsp;method=<span class=\"hljs-string\" style=\"color: #98c379; line-height: 26px;\">\"POST\"</span>&gt;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;button&nbsp;class=<span class=\"hljs-string\" style=\"color: #98c379; line-height: 26px;\">\"btn&nbsp;btn-danger&nbsp;btn-block&nbsp;mt-4\"</span>&gt;删除&lt;/button&gt;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;/form&gt;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;/div&gt;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;%&nbsp;})&nbsp;%&gt;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;%&nbsp;}<span class=\"hljs-keyword\" style=\"color: #c678dd; line-height: 26px;\">else</span>&nbsp;{&nbsp;%&gt;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;p&nbsp;class=<span class=\"hljs-string\" style=\"color: #98c379; line-height: 26px;\">\"card&nbsp;card-body&nbsp;text-center&nbsp;display-4&nbsp;my-4\"</span>&gt;文件不存在&lt;/p&gt;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;%&nbsp;}&nbsp;%&gt;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;/div&gt;<br>&nbsp;&nbsp;&nbsp;&nbsp;&lt;/div&gt;<br>&lt;/body&gt;<br>&lt;script&nbsp;src=<span class=\"hljs-string\" style=\"color: #98c379; line-height: 26px;\">\"https://cdn.jsdelivr.net/npm/jquery@3.5.1/dist/jquery.slim.min.js\"</span><br>&nbsp;&nbsp;&nbsp;&nbsp;integrity=<span class=\"hljs-string\" style=\"color: #98c379; line-height: 26px;\">\"sha384-DfXdz2htPH0lsSSs5nCTpuj/zy4C+OGpamoFVy38MVBnE+IbbVYUew+OrCXaRkfj\"</span><br>&nbsp;&nbsp;&nbsp;&nbsp;crossorigin=<span class=\"hljs-string\" style=\"color: #98c379; line-height: 26px;\">\"anonymous\"</span>&gt;&lt;/script&gt;<br>&lt;script&nbsp;src=<span class=\"hljs-string\" style=\"color: #98c379; line-height: 26px;\">\"https://cdn.jsdelivr.net/npm/popper.js@1.16.0/dist/umd/popper.min.js\"</span><br>&nbsp;&nbsp;&nbsp;&nbsp;integrity=<span class=\"hljs-string\" style=\"color: #98c379; line-height: 26px;\">\"sha384-Q6E9RHvbIyZFJoft+2mJbHaEWldlvI9IOYy5n3zV9zzTtmI3UksdQRVvoxMfooAo\"</span><br>&nbsp;&nbsp;&nbsp;&nbsp;crossorigin=<span class=\"hljs-string\" style=\"color: #98c379; line-height: 26px;\">\"anonymous\"</span>&gt;&lt;/script&gt;<br>&lt;script&nbsp;src=<span class=\"hljs-string\" style=\"color: #98c379; line-height: 26px;\">\"https://cdn.jsdelivr.net/npm/bootstrap@4.5.0/dist/js/bootstrap.min.js\"</span><br>&nbsp;&nbsp;&nbsp;&nbsp;integrity=<span class=\"hljs-string\" style=\"color: #98c379; line-height: 26px;\">\"sha384-OgVRvuATP1z7JjHLkuOU7Xw704+h835Lr+6QL9UvYjZE3Ipu6Tp75j7Bh/kR0JKI\"</span><br>&nbsp;&nbsp;&nbsp;&nbsp;crossorigin=<span class=\"hljs-string\" style=\"color: #98c379; line-height: 26px;\">\"anonymous\"</span>&gt;&lt;/script&gt;<br><br>&lt;/html&gt;<br></code></pre>\n<p data-tool=\"mdnice编辑器\" style=\"padding-top: 8px; padding-bottom: 8px; margin: 0; font-size: 16px; line-height: 26px; word-spacing: 3px; letter-spacing: 1px; color: #424B5D;\">要将 ejs 中的files变量获取到我们应该重写一下 get('/')接口，使其在访问localhost:5000的时候先去读取一下数据库文件信息并输出到页面中去</p>\n<pre class=\"custom\" data-tool=\"mdnice编辑器\" style=\"margin-top: 10px; margin-bottom: 10px; margin: 12px auto; border-radius: 5px; box-shadow: 0 1px 2px -2px rgba(0,0,0,.16), 0 3px 6px 0 rgba(0,0,0,.12), 0 5px 12px 4px rgba(0,0,0,.09) !important;\"><span style=\"display: block; background: url(https://my-wechat.mdnice.com/point.png); height: 30px; width: 100%; background-size: 40px; background-repeat: no-repeat; background-color: #282c34; margin-bottom: -7px; border-radius: 5px; background-position: 10px 10px;\"></span><code class=\"hljs\" style=\"overflow-x: auto; padding: 16px; color: #abb2bf; display: -webkit-box; font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; font-size: 12px; -webkit-overflow-scrolling: touch; padding-top: 15px; background: #282c34; border-radius: 5px;\">app.get(<span class=\"hljs-string\" style=\"color: #98c379; line-height: 26px;\">'/'</span>,&nbsp;(req,&nbsp;res)&nbsp;=&gt;&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;gfs.files.find().toArray((err,&nbsp;files)&nbsp;=&gt;&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class=\"hljs-keyword\" style=\"color: #c678dd; line-height: 26px;\">if</span>&nbsp;(!files&nbsp;||&nbsp;files.length&nbsp;===&nbsp;0)&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;res.render(<span class=\"hljs-string\" style=\"color: #98c379; line-height: 26px;\">'index'</span>,&nbsp;{&nbsp;files:&nbsp;<span class=\"hljs-literal\" style=\"color: #56b6c2; line-height: 26px;\">false</span>&nbsp;})<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class=\"hljs-built_in\" style=\"color: #e6c07b; line-height: 26px;\">return</span><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;files.map(file&nbsp;=&gt;&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;如果是以下图片类型我们就在前端展示出来，其余一律按附件处理，通过&nbsp;isImage&nbsp;来区分图片和非图片<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;const&nbsp;imageType&nbsp;=&nbsp;[<span class=\"hljs-string\" style=\"color: #98c379; line-height: 26px;\">'image/png'</span>,&nbsp;<span class=\"hljs-string\" style=\"color: #98c379; line-height: 26px;\">'image/jpg'</span>,&nbsp;<span class=\"hljs-string\" style=\"color: #98c379; line-height: 26px;\">'image/gif'</span>,&nbsp;<span class=\"hljs-string\" style=\"color: #98c379; line-height: 26px;\">'image/jpeg'</span>]<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class=\"hljs-keyword\" style=\"color: #c678dd; line-height: 26px;\">if</span>&nbsp;(imageType.includes(file.contentType))&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;file.isImage&nbsp;=&nbsp;<span class=\"hljs-literal\" style=\"color: #56b6c2; line-height: 26px;\">true</span><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;<span class=\"hljs-keyword\" style=\"color: #c678dd; line-height: 26px;\">else</span>&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;file.isImage&nbsp;=&nbsp;<span class=\"hljs-literal\" style=\"color: #56b6c2; line-height: 26px;\">false</span><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;})<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;res.render(<span class=\"hljs-string\" style=\"color: #98c379; line-height: 26px;\">'index'</span>,&nbsp;{&nbsp;files:&nbsp;files&nbsp;})<br>&nbsp;&nbsp;&nbsp;&nbsp;})<br>})<br><br></code></pre>\n<p data-tool=\"mdnice编辑器\" style=\"padding-top: 8px; padding-bottom: 8px; margin: 0; font-size: 16px; line-height: 26px; word-spacing: 3px; letter-spacing: 1px; color: #424B5D;\">完成上述的情况我们访问首页的话就行该是如下情况\n<img src=\"https://timegods.oss-cn-shenzhen.aliyuncs.com/markdown/mg04.png\" alt style=\"display: block; max-width: 100%; border-radius: 5px; margin: 12px auto;\"></p>\n<h3 data-tool=\"mdnice编辑器\" style=\"padding: 0px; margin-top: 24px; margin-bottom: 12px; font-weight: bold; font-size: 18px; color: #424B5D;\"><span class=\"prefix\" style=\"display: none;\"></span><span class=\"content\">3.7 单个文件下载</span><span class=\"suffix\" style=\"display: none;\"></span></h3>\n<p data-tool=\"mdnice编辑器\" style=\"padding-top: 8px; padding-bottom: 8px; margin: 0; font-size: 16px; line-height: 26px; word-spacing: 3px; letter-spacing: 1px; color: #424B5D;\">在这里我们通过a标签访问 /download/:filename 接口，filename是文件名，当然可以用其他的比如_id，当查找到有该附件的时候就将它合并成可读留，通过管道返回，这样在前端界面上点击文件标题就可以直接下载了</p>\n<pre class=\"custom\" data-tool=\"mdnice编辑器\" style=\"margin-top: 10px; margin-bottom: 10px; margin: 12px auto; border-radius: 5px; box-shadow: 0 1px 2px -2px rgba(0,0,0,.16), 0 3px 6px 0 rgba(0,0,0,.12), 0 5px 12px 4px rgba(0,0,0,.09) !important;\"><span style=\"display: block; background: url(https://my-wechat.mdnice.com/point.png); height: 30px; width: 100%; background-size: 40px; background-repeat: no-repeat; background-color: #282c34; margin-bottom: -7px; border-radius: 5px; background-position: 10px 10px;\"></span><code class=\"hljs\" style=\"overflow-x: auto; padding: 16px; color: #abb2bf; display: -webkit-box; font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; font-size: 12px; -webkit-overflow-scrolling: touch; padding-top: 15px; background: #282c34; border-radius: 5px;\">app.get(<span class=\"hljs-string\" style=\"color: #98c379; line-height: 26px;\">'/download/:filename'</span>,&nbsp;(req,&nbsp;res)&nbsp;=&gt;&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;gfs.files.findOne({&nbsp;filename:&nbsp;req.params.filename&nbsp;},&nbsp;(err,&nbsp;file)&nbsp;=&gt;&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class=\"hljs-keyword\" style=\"color: #c678dd; line-height: 26px;\">if</span>&nbsp;(!file)&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class=\"hljs-built_in\" style=\"color: #e6c07b; line-height: 26px;\">return</span>&nbsp;res.status(404).json({<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;err:&nbsp;<span class=\"hljs-string\" style=\"color: #98c379; line-height: 26px;\">'文件不存在！'</span><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;})<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;const&nbsp;readstream&nbsp;=&nbsp;gfs.createReadStream(file.filename)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;readstream.pipe(res)<br>&nbsp;&nbsp;&nbsp;&nbsp;})<br>})<br></code></pre>\n<h3 data-tool=\"mdnice编辑器\" style=\"padding: 0px; margin-top: 24px; margin-bottom: 12px; font-weight: bold; font-size: 18px; color: #424B5D;\"><span class=\"prefix\" style=\"display: none;\"></span><span class=\"content\">3.8 单个文件删除</span><span class=\"suffix\" style=\"display: none;\"></span></h3>\n<p data-tool=\"mdnice编辑器\" style=\"padding-top: 8px; padding-bottom: 8px; margin: 0; font-size: 16px; line-height: 26px; word-spacing: 3px; letter-spacing: 1px; color: #424B5D;\">在这里我们通过a标签访问 /files/:id 接口，id对应，点击删除按钮，就直接删除了，并重定向到首页</p>\n<pre class=\"custom\" data-tool=\"mdnice编辑器\" style=\"margin-top: 10px; margin-bottom: 10px; margin: 12px auto; border-radius: 5px; box-shadow: 0 1px 2px -2px rgba(0,0,0,.16), 0 3px 6px 0 rgba(0,0,0,.12), 0 5px 12px 4px rgba(0,0,0,.09) !important;\"><span style=\"display: block; background: url(https://my-wechat.mdnice.com/point.png); height: 30px; width: 100%; background-size: 40px; background-repeat: no-repeat; background-color: #282c34; margin-bottom: -7px; border-radius: 5px; background-position: 10px 10px;\"></span><code class=\"hljs\" style=\"overflow-x: auto; padding: 16px; color: #abb2bf; display: -webkit-box; font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; font-size: 12px; -webkit-overflow-scrolling: touch; padding-top: 15px; background: #282c34; border-radius: 5px;\">app.delete(<span class=\"hljs-string\" style=\"color: #98c379; line-height: 26px;\">'/files/:id'</span>,&nbsp;(req,&nbsp;res)&nbsp;=&gt;&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;gfs.remove({&nbsp;_id:&nbsp;req.params.id,&nbsp;root:&nbsp;<span class=\"hljs-string\" style=\"color: #98c379; line-height: 26px;\">'upload'</span>&nbsp;},&nbsp;(err)&nbsp;=&gt;&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class=\"hljs-keyword\" style=\"color: #c678dd; line-height: 26px;\">if</span>&nbsp;(err)&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class=\"hljs-built_in\" style=\"color: #e6c07b; line-height: 26px;\">return</span>&nbsp;res.status(404).json({<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;err:&nbsp;<span class=\"hljs-string\" style=\"color: #98c379; line-height: 26px;\">'删除的文件不存在！'</span><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;})<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;res.redirect(<span class=\"hljs-string\" style=\"color: #98c379; line-height: 26px;\">'/'</span>)<br>&nbsp;&nbsp;&nbsp;&nbsp;})<br>})<br></code></pre>\n<p data-tool=\"mdnice编辑器\" style=\"padding-top: 8px; padding-bottom: 8px; margin: 0; font-size: 16px; line-height: 26px; word-spacing: 3px; letter-spacing: 1px; color: #424B5D;\">由于我们一直用form做请求，但是form表单没有delete请求方式，所以我们用到了<strong style=\"font-weight: bold; color: #424B5D;\">method-override</strong>插件，当然要是用Ajax就没关系了，我们项目毕竟速成嘛，主要看效果和过程</p>\n<h2 data-tool=\"mdnice编辑器\" style=\"padding: 0px; color: black; font-weight: bold; font-size: 20px; margin-top: 24px; margin-bottom: 12px;\"><span class=\"prefix\" style=\"display: none;\"></span><span class=\"content\" style=\"color: #e7642b; text-align: center; display: block; background-color: #e7642b; color: white; padding: 3px 11px; border-radius: 1px;\">4 完结撒花了</span><span class=\"suffix\"></span></h2>\n<p data-tool=\"mdnice编辑器\" style=\"padding-top: 8px; padding-bottom: 8px; margin: 0; font-size: 16px; line-height: 26px; word-spacing: 3px; letter-spacing: 1px; color: #424B5D;\">简简单单的告一段落了，学了的小伙伴们可以尝试更加深入的操作，所以我们就可以用此项目来做一个图床或者小网盘盘，还是简简单单滴。当然该附件上传也有一定的限制问题，比如大文件可能上传时间更久，我们就需要采用文件分片方式上传了，可以看掘金的<a href=\"https://juejin.im/post/6850037258863673357\" style=\"text-decoration: none; word-wrap: break-word; font-weight: bold; color: #eb6161; border-bottom: 1px solid #eb6161;\"><span style=\"margin-right: 6px;\">👉</span>文件分片</a>的案例。</p>\n<p data-tool=\"mdnice编辑器\" style=\"padding-top: 8px; padding-bottom: 8px; margin: 0; font-size: 16px; line-height: 26px; word-spacing: 3px; letter-spacing: 1px; color: #424B5D;\">最后感谢各位小伙伴的品尝，如有新的好玩的东西，我再来分享一下</p>\n<ul data-tool=\"mdnice编辑器\" style=\"margin-top: 8px; margin-bottom: 8px; list-style-type: disc; font-size: 15px; margin: 0; padding-left: 24px; color: #424B5D;\">\n<li><section style=\"margin-top: 5px; margin-bottom: 5px; text-align: left; font-weight: 500; margin: 4px 0; line-height: 24px; color: #424B5D;\"><a href=\"https://gitee.com/caohuiboss/girdfs_uploads\" style=\"text-decoration: none; word-wrap: break-word; font-weight: bold; color: #eb6161; border-bottom: 1px solid #eb6161;\"><span style=\"margin-right: 6px;\">👉</span><strong style=\"font-weight: bold; color: #424B5D;\">项目地址</strong></a></section></li><li><section style=\"margin-top: 5px; margin-bottom: 5px; text-align: left; font-weight: 500; margin: 4px 0; line-height: 24px; color: #424B5D;\"><a href=\"http://www.chmc.xyz:1314/\" style=\"text-decoration: none; word-wrap: break-word; font-weight: bold; color: #eb6161; border-bottom: 1px solid #eb6161;\"><span style=\"margin-right: 6px;\">👉</span><strong style=\"font-weight: bold; color: #424B5D;\">在线体验地址</strong></a> 本人的土豆服务器，各位小伙伴不要下手太狠哈😅，体验体验就好</section></li></ul>\n<blockquote data-tool=\"mdnice编辑器\" style=\"display: block; font-size: 0.9em; overflow: auto; overflow-scrolling: touch; border-left: 3px solid rgba(0, 0, 0, 0.4); color: #6a737d; padding-top: 10px; padding-bottom: 10px; padding-left: 20px; padding-right: 10px; margin-bottom: 20px; margin-top: 20px; margin: 0 8px; border: none; background: #ffffff; box-shadow: 0 1px 2px -2px rgba(0,0,0,.16), 0 3px 6px 0 rgba(0,0,0,.12), 0 5px 12px 4px rgba(0,0,0,.09);\">\n<p style=\"padding-top: 8px; padding-bottom: 8px; word-spacing: 3px; letter-spacing: 1px; margin: 0px; font-size: 14px; color: #424B5D; line-height: 24px;\">读一本好书，就是在和高尚的人谈话。 ——歌德（我真说过）</p>\n</blockquote>\n</section>", "user_name": "柠檬💫不酸", "description": "最好学的前端崽崽", "got_view_count": 2382, "category_name": "前端", "ctime": 1457483942}
{"tag_name": "Node.js", "concern_user_count": 245462, "user_id": "289926798645575", "title": "2019年的6个JavaScript用户认证库", "mark_content": "“两周内给我建一个用户认证系统”是现在研发团队中常见的一句话。由于种种原因，这个任务一直是留给团队中的一个开发人员去解决的。\n\n一方面，你确实不想浪费很多时间。另一方面，你担心这种信息可能最好由自己内部编写的服务来处理，以便以后更好的扩展。\n\n随着网络上出现新的教程（是一个很好的开始），越来越多的团队试图了解实现自己的解决方案与使用库或服务的成本效益等式，希望这可以节省一些时间，并做出更明智的决定。\n\n## 1. Passport JS\n\n![https://github.com/jaredhanson/passport](http://weixin-storage.oss-cn-shanghai.aliyuncs.com/202007/authentication-libraries/1.png)\n\nPassport不仅仅是一个15k星用户身份验证库，它可能是JS开发人员使用外部库进行用户认证的最常见方式。该库基本上为Node.js提供了相对灵活和模块化的中间件，可以将其集成到任何基于Express的Web应用程序中。它也是一个社区平台，支持各种常见的身份验证，例如用户名和密码，Facebook，Twitter等。如果你不想实施自己的解决方案，则可能是第一个选择。\n\n## 2. Auth0\n\n![https://auth0.com/](http://weixin-storage.oss-cn-shanghai.aliyuncs.com/202007/authentication-libraries/2.png)\n\n虽然这不是库，而是服务，但这是完成工作的可靠而快速的方法。Auth0是一家（颇具规模的）新兴公司，为Web，移动和旧版应用程序提供广泛的通用身份验证和授权平台。有人说这是与Plataformatec的Ruby on Rails Devise最接近的解决方案，除了你可以使用任何语言连接任何应用程序或API。已有超过100个预先建立的集成。\n\n## 3. Permit\n\n![https://github.com/ianstormtaylor/permit](http://weixin-storage.oss-cn-shanghai.aliyuncs.com/202007/authentication-libraries/3.png)\n\nPermit是一个1千颗星的项目，旨在为构建Node.js API提供一个“不受限制的”身份验证库。Permit允许你向任何Node.js API添加身份验证层，并且可以与Express，Koa，Hapi和Fastify等框架一起使用。它可以与从REST到GraphQL的多种类型的API一起使用，因此是“非规范化”的设计。Permit旨在专注于API（无状态请求）和Express以外的支持框架。它也在积极开发中，这使“Permit”成为一个值得考虑的有趣选择。\n\n## 4. Grant\n\n![https://github.com/simov/grant](http://weixin-storage.oss-cn-shanghai.aliyuncs.com/202007/authentication-libraries/4.jpeg)\n\n一个相当新的，很有前途的库，为Express，Koa和Hapi提供OAuth中间件，并提供180多家受支持的提供商和一个实时游乐场。如果你想将其与自己的私有OAuth提供程序一起使用，则可以自己指定所需的密钥。尽管该库已经开始受到关注（超过1K星），但是资源相对稀缺，因此请谨慎尝试。\n\n## 5. Feathers 认证管理\n\n![https://github.com/feathers-plus/feathers-authentication-management](http://weixin-storage.oss-cn-shanghai.aliyuncs.com/202007/authentication-libraries/5.png)\n\nFeathers是一个开源（11K星）的NodeJS实时微服务Web框架，通过RESTful资源、套接字和灵活的插件让你控制数据。\n\nFeathers还提供了认证和认证管理模块，让你在本地Feathers认证中增加注册验证、遗忘密码重置等功能。这个想法是在一个灵活的基础设施中，将不同的认证方法结合在一起。\n\n## 6. 只需使用Firebase身份验证（适用于小型应用程序）\n\n![https://blog.bitsrc.io/react-oauth-authentication-with-firebase-dfe0e8c5d0d4](http://weixin-storage.oss-cn-shanghai.aliyuncs.com/202007/authentication-libraries/6.jpeg)\n\n这可能不一定是在你的扩展平台中管理用户授权的长期解决方案（或者是吗？)，但是，对于通过Firebase部署的应用程序来说，这是一种非常有用的方法，可以快速，轻松地完成工作。\n\nFirebase身份验证提供后端服务，易于使用的SDK和现成的UI库，以对你的应用程序的用户进行身份验证。它支持使用密码、电话号码、流行的联邦身份提供商(如谷歌、Facebook和Twitter)进行身份验证。\n\n****\n\n来源：[https://blog.bitsrc.io](https://blog.bitsrc.io/6-javascript-user-authentication-libraries-for-2019-6c7c45fbe458)，作者：Jonathan Saring，翻译：公众号《前端全栈开发者》", "user_name": "杜尼卜", "description": "Web全栈开发、持续学习者，关注公众号第一时间接收最新文章", "got_view_count": 281912, "category_name": "前端", "ctime": 1457483942}
{"tag_name": "PHP", "concern_user_count": 86819, "user_id": "1266229795106455", "title": "让你深刻了解yii2的九个概念", "mark_content": "<div>\n\n> 与 laravel 相较，Yii2 将配置（依赖关系定义）外化，用行为（更类似于 python 中的织入）类，弥补`Trait`的一些不足，好处是可以动态扩展动作。至于事件处理则大同小异，有趣的是在命名上，yii2 借用了`jquery`事件系统的那一套，`on,off,trigger`。当然也相同之处，比如应用都是建立在容器之上。相比其它的面向领域，面向接口编程，Yii2 使用模块，来分层，分中心小应用，细化大架构。而`getter/setter`，及过滤器，java 痕迹太明显。\n\n</div>\n\n<div>\n\n## 组件 Component\n\n</div>\n\n<div>\n\n*   Yii 应用的主要基石。是`yii\\base\\Component`类或其子类的实例\n    *   主要由 属性（Property)，事件（Event），行为（Behavior）三个功能组成\n    *   比常规的对象（Object）稍微重量级，要使用额外的内存和 CPU 时间来处理 事件 和 行为\n    *   不需要使用事件和行为时，继承`yii\\base\\Object`, 支持属性（Property）功能\n*   重写 Component 或 Object\n    *   永远在重写的构造方法结尾处调用一下父类的构造方法\n    *   传入 $config 作为构造器方法最后一个参数，由父构造方调用，在应用配置之前初始化\n    *   若重写了 BaseObject::init () 方法，确保在 init 方法的开头处调用了父类的 init 方法\n*   组件实例化 2 种方式\n    *   实例化组件类，new 组件类， 组件普通参数 +　组件配置属性参数\n    *   通过`\\Yii::createObject`静态方法，创建组件实例\n        *   第一个数组参数 class 关联组件类名，后续关联元素依次为组件实例属性及值\n        *   第二数组参数 组件的普通参数\n\n</div>\n\n<div>\n\n> `Yii::createObject()`基于依赖注入容器实现\n\n</div>\n\n<div>\n\n*   `yii\\base\\BaseObject` 类执行时的生命周期\n    *   构造方法内的预初始化过程\n    *   通过 $config 配置对象\n    *   在 init () 方法内进行初始化后的收尾工作\n    *   对象方法调用，上述步骤皆在对象的构造方法内完成，即获得实例就已经初始化，可供使用\n\n</div>\n\n<div>\n\n## 属性 Property\n\n</div>\n\n<div>\n\n*   `Yii`引入`yii\\base\\Object`的基类， 支持基于类内的`getter`和 `setter`（读取器和设定器）方法来定义属性\n*   getter 和 setter 定义属性规则和限制\n    *   这类属性的名字是不区分大小写，源于 PHP 方法名是不区分大小写\n    *   若此类属性名和类成员变量相同，以后者为准\n    *   该类属性不支持可见性（访问限制）\n    *   这类属性的 getter 和 setter 方法只能定义为非静态的\n    *   对不确定有无魔术方法`（getter 或 setter` 的属性正常调用 `property_exists()`将不会生效\n        *   若真有此需求，应用`canGetProperty()`或`canSetProperty()`\n\n</div>\n\n<div>\n\n## 事件 Events\n\n</div>\n\n<div>\n\n*   事件可以将自定义代码 “注入” 到现有代码中的特定执行点\n\n    *   附加自定义代码到某个事件，当这个事件被触发时，这些代码就会自动执行\n*   事件处理器`Event Handlers`\n\n    *   事件处理器是一个 PHP 回调函数，也可以是一个可调用对象\n    *   字符串形式指定的 PHP 全局函数 ，如`'trim'`\n    *   对象名和方法名数组形式指定的对象方法，`[$object, $method]`\n    *   类名和方法名数组形式指定的静态类方法，如`[$class, $method]`\n    *   匿名函数，如`function ($event) { ... }`\n*   事件对象 $event\n\n    *   `event name`：事件名\n    *   `event sender`：调用 trigger () 方法的对象\n    *   `custom data` 附加事件处理器时传入的数据，默认为空\n*   附加事件处理器\n\n    *   调用组件类的 on 方法，诸如 \\yii\\base\\Component::on ()\n    *   `public void on ( $name, $handler, $data = null, $append = true )`\n*   事件处理器顺序（Event Handler Order）\n\n    *   当事件被触发，已附加的处理器将按附加次序依次调用\n    *   若需要停止同一事件的后续处理器的调用，可设置 event 参数的`yii\\base\\Event::event参数的‘yii\\base\\Event::handled`属性为真\n    *   第四个参数 $append 为假时，可在处理器队列最前面插入新处理器\n*   触发事件（Triggering Events）\n\n    *   事件通过调用`yii\\base\\Component::trigger()`方法触发\n        *   `public void trigger ( $name, yii\\base\\Event $event = null )`\n    *   推荐使用类常量来表示事件名，事件对象必须是 `yii\\base\\Event`类或其子类的实例\n*   移除事件处理器（Detaching Event Handlers）\n\n    *   `public boolean off ( $name, $handler = null )`\n*   类级别的事件处理器\n\n    *   应用场景 想要一个类的所有实例都响应一个被触发的事件\n    *   调用静态方法`yii\\base\\Event::on()` 在类级别附加处理器\n        *   在事件处理器内，通过 $event->sender 获取触发事件的对象\n        *   当对象触发事件时，它首先调用实例级别的处理器，然后才会调用类级别处理器\n    *   静态方法 yii\\base\\Event::trigger () 来触发一个类级别事件，移除用 off\n    *   移除签名`public static boolean off ( $class, $name, $handler = null )`\n*   接口事件\n\n    *   调用`Event::on()`并将接口类名作为第一个参数\n    *   可在实现接口事件类中触发这个事件，但不能让所有实现这个接口的类都触发事件\n*   全局事件\n\n    *   需要一个全局可访问的单例，如应用实例\n    *   事件触发者不调用其自身的 trigger () 方法，而是调用单例的 trigger () 方法来触发全局事件\n    *   优点 是当附加处理器到一个对象要触发的事件时， 不需要产生该对象\n*   通配符事件 Wildcard Events\n\n    *   foo.event.* , 通配符模式支持实例 或类级别的事件\n\n</div>\n\n<div>\n\n## 行为\n\n</div>\n\n<div>\n\n*   行为是`yii\\base\\Behavior`或其子类的实例，也称为 mixins, 类似于原生的 Trait\n\n    *   作用 无须改变类继承关系即可增强一个已有的 组件 类功能\n    *   当行为附加到组件后，它将 “注入” 它的方法和属性到组件\n    *   行为通过组件能响应被触发的事件，从而自定义或调整组件正常执行的代码\n*   处理事件\n\n    *   让行为响应对应组件的事件触发， 应覆写 `yii\\base\\Behavior::events()`方法\n        *   行为的 events () 方法返回事件列表和相应的处理器，指定事件处理器格式如下\n            *   指向行为类的方法名的字符串\n            *   对象或类名和方法名的数组，如 [$object, ‘methodName’]；\n            *   匿名方法\n*   附加行为\n\n    *   静态附加行为\n        *   覆写行为要附加的组件类的 behaviors () 方法即可\n        *   behaviors () 方法返回行为配置列表，每个行为配置可以是行为类名也可以是配置数组\n        *   过指定行为配置数组相应的键可以给行为关联一个名称，这种行为称为命名行为，反之匿名行为或命名行为\n    *   动态附加行为\n        *   在对应组件里调用`yii\\base\\Component::attachBehavior()`方法\n        *   或`yii\\base\\Component::attachBehaviors()`方法一次附加多个行为\n            *   `public void attachBehaviors (array $behaviors )`\n        *   通过配置附加行为\n            *   [‘as myBehavior2’ => MyBehavior::className()]\n*   使用行为\n\n    *   必须先将为附加到 component 类或其子类组件，然后可通过访问组件访问行为的公共成员变量\n    *   若两个行为都定义了一样的属性或方法，并且它们都附加到同一个组件，先附加者有优先权\n    *   附加行为到组件时的命名行为，可以使用这个名称来访问行为对象，`$component->getBehavior('myBehavior');`\n    *   获取附加到这个组件的所有行为 `getBehaviors()`\n*   移除行为\n\n    *   可以调用`yii\\base\\Component::detachBehavior()`方法用行为相关联的名字实现\n*   Yii2 内置行为类\n\n    *   `yii\\behaviors\\TimestampBehavior`在 Active Record 存储时自动更新它的时间戳属性\n    *   `yii\\behaviors\\BlameableBehavior`使用当前用户 ID 自动填充指定的属性\n    *   `yii\\behaviors\\SluggableBehavior`自动填充指定的属性，其值可以在 URL 中用作 slug\n    *   `yii\\behaviors\\AttributeBehavior`在发生特定事件时自动为 ActiveRecord 对象的一个或多个属性 指定一个指定的值\n    *   `yii2tech\\ar\\softdelete\\SoftDeleteBehavior`提供软删除和软恢复 ActiveRecord 的 方法\n    *   `yii2tech\\ar\\position\\PositionBehavior`允许通过提供重新排序方法来 管理整数字段中的记录顺序\n*   行为 VS Traits\n\n    *   都将自己的属性和方法 “注入” 到主类中，二者类似互补类而非替代类\n    *   行为类优点\n        *   行为类像普通类支持继承\n        *   行为无须修改组件类就可动态附加到组件或移除\n        *   行为是可配置的，而 traits 则不可行\n        *   行为可以通过响应事件来定制组件的代码执行\n    *   traits 的原因\n        *   Traits 比行为更有效，因为行为是既需要时间又需要内存的对象\n    *   名称冲突解决方案\n        *   当附属于同一组件的不同行为之间可能存在名称冲突时， 通过优先考虑附加到该组件的行为\n        *   不同 traits 引起的名称冲突需要通过 重命名受影响的属性或方法进行手动解决\n\n</div>\n\n<div>\n\n## 配置 Configurations\n\n</div>\n\n<div>\n\n*   概述\n\n    *   在创建新对象和初始化已存在对象时使用配置\n    *   配置通常包含被创建对象的类名和一组将要赋值给对象 属性的初始值\n    *   亦可包含一组将被附加到对象事件上的句柄，和一组将被附加到对象上的行为\n*   使用\n\n    *   Yii::createObject () 方法接受一个配置数组并根据数组中指定的类名创建对象\n    *   对于已存在的对象，可以使用 `Yii::configure()`方法根据配置去初始化其属性\n        *   `Yii::configure($object, $config)`\n        *   注若配置一个已存在的对象，那么配置数组中不应该包含指定类名的 class 元素\n*   配置的格式\n\n    *   `class`元素指定了将要创建的对象的完全限定类名\n    *   `propertyName`元素指定了对象属性的初始值，键名是属性名，值是该属性对应的初始值\n        *   只有公共成员变量以及通过 getter/setter 定义的 属性可以被配置\n    *   `on eventName`元素指定了附加到对象事件上的句柄，数组的键名由 on 前缀加事件名组成\n    *   `as behaviorName` 元素指定了附加到对象的行为，值表示创建行为的配置信息\n*   应用的配置\n\n    *   application 类拥有很多可配置的属性和事件\n    *   components 属性可以接收配置数组并通过应用注册为组件\n    *   yii2.0.11+ 系统配置支持使用 container 属性来配置依赖注入容器\n*   小部件的配置\n\n    *   `yii\\base\\Widget::widget()` 和`yii\\base\\Widget::begin()`方法都可以用来创建小部件\n    *   通过用配置来自定义其属性，注意 给出类名的情况下，配置数组不需要再包含 class 键\n*   默认配置\n\n    *   `Yii::createObject()`方法基于依赖注入容器实现\n    *   使用`Yii::creatObject()`创建对象时，可以附加一系列默认配置到指定类的任何实例\n    *   默认配置可以在入口脚本 中调用`Yii::$container->set()`来定义\n\n</div>\n\n<div>\n\n## 别名\n\n</div>\n\n<div>\n\n*   设置与解析\n    *   使用`Yii::setAlias()`来给文件路径或 URL 定义别名\n    *   调用`Yii::getAlias()`命令来解析根别名到对应的文件路径或 URL\n*   应用提供了一个名为 aliases 的可写属性， 可在应用配置中设置它\n*   使用别名 Yii 内路径属性接受别名\n*   Yii2 预定义别名\n*   扩展的别名\n    *   一个通过 Composer 安装的 扩展 都自动添加了一个别名，定义于引导启动阶段\n\n</div>\n\n<div>\n\n## 类的自动加载\n\n</div>\n\n<div>\n\n*   Yii 自动加载器\n    *   每个类都必须置于命名空间之下\n    *   每个类都必须保存为单独文件\n    *   要将自定义命名空间添加到自动加载器，需要使用 Yii::setAlias () 为命名空间的根目录定义别名\n*   类映射表\n    *   类映射表功能，建立一个从类的名字到类文件路径的映射\n    *   当自动加载器加载一个文件时，他首先检查映射表里有没有该类\n    *   可以用`Yii::$classMap`方法向映射表中添加类\n*   其他自动加载器\n    *   在其他自动加载器安装成功之后， 再包含 Yii.php (yii 的自动加载器)\n    *   目的使 Yii 成为第一个响应任何类自动加载请求的自动加载器\n*   Yii 自动加载器支持自动加载扩展的类，需要在 composer.json 文件里正确地定义 autoload 部分\n\n</div>\n\n<div>\n\n## 服务定位器（Service Locator）\n\n</div>\n\n<div>\n\n*   定义\n    *   提供各种应用所需的服务（或组件）的对象\n    *   在服务定位器中， 每个组件都只有一个单独的实例，并通过 ID 唯一地标识\n    *   在 Yii 中，服务定位器是`yii\\di\\ServiceLocator`或其子类的一个实例\n*   应用场景\n    *   最常用的服务定位器是 application（应用）对象，可以通过 \\Yii::$app 访问\n    *   每个模块对象本身也是一个服务定位器，模板可视为一个子应用\n*   使用服务定位器\n    *   注册相关组件\n        *   通过`yii\\di\\ServiceLocator::set()`方法进行相关组件注册。\n        *   `public void set ( $id, $definition )`\n        *   `$definition`可以是类名，配置数组，php 可调用对象，或者本身就是一个对象实例\n    *   允许通过组件 ID 像访问一个属性值那样访问一个组件\n        *   服务定位器会返回同一个组件的单例\n        *   `yii\\di\\ServiceLocator::has()`检查某组件 ID 是否被注册\n        *   `yii\\di\\ServiceLocator::get()`\n*   遍历树（Tree traversal）\n    *   模块允许任意嵌套；Yii 应用程序本质上是一个模块树\n*   模块中组件的配置决不会与来自父模块中组件的配置合并\n\n</div>\n\n<div>\n\n## 依赖注入容器\n\n</div>\n\n<div>\n\n*   依赖注入容器是一个对象，知道怎样初始化并配置对象及其依赖的所有对象\n*   `Yii 通过 yii\\di\\Container`类提供 DI 容器特性\n    *   构造方法注入\n        *   容器会尝试获取它所依赖的类或接口的实例，然后通过构造器将其注入新的对象\n    *   方法注入\n        *   可以提供仅由类的单个方法需要的依赖关系\n    *   Setter 和属性注入\n        *   Setter 和属性注入是通过配置提供，该配置会提供给容器用于通过相应的 Setter 或属性注入依赖\n    *   PHP 回调注入 (PHP Callable Injection)\n        *   容器将使用已注册的 PHP 回调来构建类的新实例\n\n</div>\n\n<div>\n\n> `yii\\di\\Container::get()`方法将其第三个参数作为配置数组应用于正在创建的对象 如果该类实现`yii\\base\\Configurable`接口（例如 yii\\base\\BaseObject），则配置数组将作为最后一个参数传递给类构造函数\n\n</div>\n\n<div>\n\n*   注册依赖关系\n    *   用`yii\\di\\Container::set()`注册依赖关系\n    *   注册会用到一个依赖关系名称和一个依赖关系的定义， 键值对可递归，方便容器管理实例，类似 laravel 的别名系统\n    *   依赖关系名称可为类名，接口名或一个别名，依赖关系的定义可以是类名，配置数组，一个 PHP 回调\n    *   通过`set()`注册的依赖关系，在每次使用时都会产生一个新实例\n    *   使用`yii\\di\\Container::setSingleton()`注册一个单例的依赖关系\n*   解析依赖关系\n    *   依赖关系解析是递归式进行\n    *   注册依赖关系后，容器会自动解析依赖关系， 将依赖实例化并注入新创建的对象\n    *   依赖关系名，可以是通过`set()`或 `setSingleton()`注册的，也可以是一个类构造器参数列表和一个`configuration`用于配置新创建的对象\n*   使用依赖注入\n    *   在应用程序的入口脚本中引入`Yii.php`文件时，`Yii`就创建了一个 DI 容器\n    *   该 DI 容器可以通过`Yii::$container`访问\n    *   当调用`Yii::createObject()` 时，此方法实际上会调用这个容器的 get () 方法创建新对象\n    *   在部件调用中给出的属性将始终覆盖 DI 容器中的定义，若报错无法被实例化，需要告知容器如何处理依赖关系\n*   高级实用性\n    *   可一次配置多个定义 , 将配置数组传递给`setDefinitions()`或 `setSingletons()`方法\n    *   配置数组格式\n        *   `key`：类名称，接口名称或别名\n        *   `value`：与 class 关联的定义，`class关联的定义，‘identifies`参数值将传递给 set () 方法\n        *   可以选择将依赖项的构造函数参数作为第三个参数\n        *   `Instance::of('tempFileStorage')`符号，`Container` 将隐含地提供一个用`tempFileStorage`名称注册的依赖项\n            *   应用场景 内部配置依赖项\n    *   通过 set () 注册的依赖项将在每次需要时实例化\n*   依赖关系注册使用\n    *   应用开发在入口注册依赖关系\n    *   扩展开发，则在扩展引导类中注册依赖关系\n*   小结\n    *   Yii 在依赖住入（DI）容器之上实现了它的服务定位器\n    *   当一个服务定位器尝试创建一个新的对象实例时，它会把调用转发到 DI 容器\n\n</div>\n\n更多学习内容可以访问[【对标大厂】精品PHP架构师教程目录大全，只要你能看完保证薪资上升一个台阶（持续更新）](https://zhuanlan.zhihu.com/p/165932664)\n\n**以上内容希望帮助到大家**，很多PHPer在进阶的时候总会遇到一些问题和瓶颈，业务代码写多了没有方向感，不知道该从那里入手去提升，对此我整理了一些资料，包括但不限于：**分布式架构、高可扩展、高性能、高并发、服务器性能调优、TP6，laravel，YII2，Redis，Swoole、Swoft、Kafka、Mysql优化、shell脚本、Docker、微服务、Nginx**等多个知识点高级进阶干货需要的可以免费分享给大家，需要的可以加入我的PHP技术交流群[953224940](https://jq.qq.com/?_wv=1027&k=VlP8r6aS)\n\n[进阶PHP月薪30k>>>架构师成长路线【视频、面试文档免费获取】](https://shimo.im/docs/Jky8td8RTvHTG6k9)\n\n![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/307b8bb481ef43ca97f8212845db2626~tplv-k3u1fbpfcp-zoom-1.image)", "user_name": "阿布阿布", "description": "", "got_view_count": 652, "category_name": "阅读", "ctime": 1457483895}
{"tag_name": "Java", "concern_user_count": 252044, "user_id": "325111173878983", "title": "刚体验完RabbitMQ？一文带你SpringBoot+RabbitMQ方式收发消息", "mark_content": ">人生终将是场单人旅途，孤独之前是迷茫，孤独过后是成长。\n\n## 楔子\n \n本篇是消息队列RabbitMQ的第二弹。\n\n[上一篇](https://juejin.im/post/6856571028496351239)的结尾我也预告了本篇的内容：利用RabbitTemplate和注解进行收发消息，还有一个我临时加上的内容：消息的序列化转换。\n\n本篇会和SpringBoot做整合，采用自动配置的方式进行开发，我们只需要声明RabbitMQ地址就可以了，关于各种创建连接关闭连接的事都由Spring帮我们了~\n\n交给Spring帮我们管理连接可以让我们专注于业务逻辑，就像声明式事务一样易用，方便又高效。\n\n---\n\n[祝有好收获，先赞后看，快乐无限。](https://juejin.im/user/5cc53c8251882524f72ccef6/posts)\n\n**本文代码：** [码云地址](https://gitee.com/he-erduo/spring-boot-learning-demo)&emsp;[GitHub地址](https://github.com/he-erduo/spring-boot-learning-demo)\n\n**Tip**：上一篇的代码都放在`prototype`包下，本篇的代码都放在`auto`包下面。\n\n## 1. 🔍环境配置\n\n第一节我们先来搞一下环境的配置，上一篇中我们已经引入了自动配置的包，我们既然使用了自动配置的方式，那`RabbitMQ`的连接信息我们直接放在配置文件中就行了，就像我们需要用到JDBC连接的时候去配置一下`DataSource`一样。\n\n![rabbitmq-yml配置](https://gitee.com/he-erduo/Home/raw/master/picture/rabbitmq/rabbitmq%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6.png)\n\n如图所示，我们只需要指明一下连接的IP+端口号和用户名密码就行了，这里我用的是默认的用户名与密码，不写的话默认也都是guest，端口号也是默认5672。\n\n主要我们需要看一下手动确认消息的配置，需要配置成`manual`才是手动确认，日后还会有其他的配置项，眼下我们配置这一个就可以了。\n\n---\n\n接下来我们要配置一个`Queue`，上一篇中我们往一个名叫`erduo`的队列中发送消息，当时是我们手动定义的此队列，这里我们也需要手动配置，声明一个`Bean`就可以了。\n\n```java\n@Configuration\npublic class RabbitmqConfig {\n    @Bean\n    public Queue erduo() {\n        // 其三个参数：durable exclusive autoDelete\n        // 一般只设置一下持久化即可\n        return new Queue(\"erduo\",true);\n    }\n\n}\n```\n\n就这么简单声明一下就可以了，当然了`RabbitMQ`毕竟是一个独立的组件，如果你在`RabbitMQ`中通过其他方式已经创建过一个名叫`erduo`的队列了，你这里也可以不声明，这里起到的一个效果就是如果你没有这个队列，会按照你声明的方式帮你创建这个队列。\n\n配置完环境之后，我们就可以以SpringBoot的方式来编写生产者和消费者了。\n\n## 2. 📕生产者与RabbitTemplate\n\n和上一篇的节奏一样，我们先来编写生产者，不过这次我要引入一个新的工具：`RabbitTemplate`。\n\n听它的这个名字就知道，又是一个拿来即用的工具类，Spring家族这点就很舒服，什么东西都给你封装一遍，让你用起来更方便更顺手。\n\n`RabbitTemplate`实现了标准AmqpTemplate接口，功能大致可以分为发送消息和接受消息。\n\n我们这里是在生产者中来用，主要就是使用它的发送消息功能：`send`和`convertAndSend`方法。\n\n```java\n// 发送消息到默认的Exchange，使用默认的routing key\nvoid send(Message message) throws AmqpException;\n\n// 使用指定的routing key发送消息到默认的exchange\nvoid send(String routingKey, Message message) throws AmqpException;\n\n// 使用指定的routing key发送消息到指定的exchange\nvoid send(String exchange, String routingKey, Message message) throws AmqpException;\n```\n\n`send`方法是发送byte数组的数据的模式，这里代表消息内容的对象是`Message`对象，它的构造方法就是传入byte数组数据，所以我们需要把我们的数据转成byte数组然后构造成一个`Message`对象再进行发送。\n\n```java\n// Object类型，可以传入POJO\nvoid convertAndSend(Object message) throws AmqpException;\n\nvoid convertAndSend(String routingKey, Object message) throws AmqpException;\n\nvoid convertAndSend(String exchange, String routingKey, Object message) throws AmqpException;\n```\n\n`convertAndSend`方法是可以传入POJO对象作为参数，底层是有一个`MessageConverter`帮我们自动将数据转换成byte类型或String或序列化类型。\n\n所以这里支持的传入对象也只有三种：byte类型，String类型和实现了`Serializable`接口的POJO。\n\n---\n\n介绍完了，我们可以看一下代码：\n\n```java\n@Slf4j\n@Component(\"rabbitProduce\")\npublic class RabbitProduce {\n    @Autowired\n    private RabbitTemplate rabbitTemplate;\n\n    public void send() {\n        String message = \"Hello 我是作者和耳朵，欢迎关注我。\" + LocalDateTime.now().toString();\n\n        System.out.println(\"Message content : \" + message);\n\n        // 指定消息类型\n        MessageProperties props = MessagePropertiesBuilder.newInstance()\n                .setContentType(MessageProperties.CONTENT_TYPE_TEXT_PLAIN).build();\n\n        rabbitTemplate.send(Producer.QUEUE_NAME,new Message(message.getBytes(StandardCharsets.UTF_8),props));\n        System.out.println(\"消息发送完毕。\");\n    }\n\n    public void convertAndSend() {\n        User user = new User();\n\n        System.out.println(\"Message content : \" + user);\n\n        rabbitTemplate.convertAndSend(Producer.QUEUE_NAME,user);\n        System.out.println(\"消息发送完毕。\");\n    }\n\n}\n```\n\n这里我特意写明了两个例子，一个用来测试send，另一个用来测试convertAndSend。\n\n`send`方法里我们看下来和之前的代码是几乎一样的，定义一个消息，然后直接send，但是这个构造消息的构造方法可能比我们想的要多一个参数，我们原来说的只要把数据转成二进制数组放进去即可，现在看来还要多放一个参数了。\n\n`MessageProperties`，是的我们需要多放一个`MessageProperties`对象，从他的名字我们也可以看出它的功能就是附带一些参数，但是某些参数是少不了的，不带不行。\n\n比如我的代码这里就是设置了一下消息的类型，消息的类型有很多种可以是二进制类型，文本类型，或者序列化类型，JSON类型，我这里设置的就是文本类型，指定类型是必须的，也可以为我们拿到消息之后要将消息转换成什么样的对象提供一个参考。\n\n`convertAndSend`方法就要简单太多，这里我放了一个User对象拿来测试用，直接指定队列然后放入这个对象即可。\n\n**Tips**：User必须实现`Serializable`接口，不然的话调用此方法的时候会抛出`IllegalArgumentException`异常。\n\n---\n\n代码完成之后我们就可以调用了，这里我写一个测试类进行调用：\n\n```java\n@SpringBootTest\npublic class RabbitProduceTest {\n    @Autowired\n    private RabbitProduce rabbitProduce;\n\n    @Test\n    public void sendSimpleMessage() {\n        rabbitProduce.send();\n        rabbitProduce.convertAndSend();\n    }\n}\n```\n\n效果如下图~\n\n![生产者测试](https://gitee.com/he-erduo/Home/raw/master/picture/rabbitmq/%E7%94%9F%E4%BA%A7%E8%80%85test02.png)\n\n同时在控制台使用命令`rabbitmqctl.bat list_queues`查看队列-`erduo`现在的情况：\n\n![查看队列情况](https://gitee.com/he-erduo/Home/raw/master/picture/rabbitmq/%E6%9F%A5%E7%9C%8B%E9%98%9F%E5%88%9703.png)\n\n如此一来，我们的生产者测试就算完成了，现在消息队列里两条消息了，而且消息类型肯定不一样，一个是我们设置的文本类型，一个是自动设置的序列化类型。\n\n## 3. 📗消费者与RabbitListener\n\n既然队列里面已经有消息了，接下来我们就要看我们该如何通过新的方式拿到消息并消费与确认了。\n\n消费者这里我们要用到`@RabbitListener`来帮我们拿到指定队列消息，它的用法很简单也很复杂，我们可以先来说简单的方式，直接放到方法上，指定监听的队列就行了。\n\n```java\n@Slf4j\n@Component(\"rabbitConsumer\")\npublic class RabbitConsumer {\n\n    @RabbitListener(queues = Producer.QUEUE_NAME)\n    public void onMessage(Message message, Channel channel) throws Exception {\n        System.out.println(\"Message content : \" + message);\n        channel.basicAck(message.getMessageProperties().getDeliveryTag(),false);\n        System.out.println(\"消息已确认\");\n    }\n\n}\n```\n\n这段代码就代表`onMessage`方法会处理`erduo`(Producer.QUEUE_NAME是常量字符串\"erduo\")队列中的消息。\n\n我们可以看到这个方法里面有两个参数，`Message`和`Channel`，如果用不到`Channel`可以不写此参数，但是`Message`消息一定是要的，它代表了消息本身。\n\n我们可以想想，我们的程序从`RabbitMQ`之中拉回一条条消息之后，要以怎么样的方式展示给我们呢？\n\n没错，就是封装为一个个`Message`对象，这里面放入了一条消息的所有信息，数据结构是什么样一会我一run你就能看到了。\n\n同时这里我们使用`Channel`做一个消息确认的操作，这里的DeliveryTag代表的是这个消息在队列中的序号，这个信息存放在`MessageProperties`中。\n\n## 4. 📖SpringBoot 启动！\n\n编写完生产者和消费者，同时已经运行过生产者往消息队列里面放了两条信息，接下来我们可以直接启动消息，查看消费情况：\n\n![SpringBoot启动查看消费者](https://gitee.com/he-erduo/Home/raw/master/picture/rabbitmq/rabbitmq%E5%90%AF%E5%8A%A8%E6%B6%88%E8%B4%B9%E8%80%85.png)\n\n在我红色框线标记的地方可以看到，因为我们有了消费者所以项目启动后先和RabbitMQ建立了一个连接进行监听队列。\n\n随后就开始消费我们队列中的两条消息：\n\n第一条信息是`contentType=text/plain`类型，所以直接就在控制台上打印出了具体内容。\n\n第二条信息是`contentType=application/x-java-serialized-object`，在打印的时候只打印了一个内存地址+字节大小。\n\n不管怎么说，数据我们是拿到了，也就是代表我们的消费是没有问题的，同时也都进行了消息确认操作，从数据上看，整个消息可以分为两部分：`body`和`MessageProperties`。\n\n我们可以单独使用一个注解拿到这个body的内容 - `@Payload`\n\n```java\n@RabbitListener(queues = Producer.QUEUE_NAME)\npublic void onMessage(@Payload String body, Channel channel) throws Exception {\n    System.out.println(\"Message content : \" + body);\n}\n```\n\n也可以单独使用一个注解拿到`MessageProperties`的headers属性，headers属性在截图里也可以看到，只不过是个空的 - @Headers。\n\n```java\n@RabbitListener(queues = Producer.QUEUE_NAME)\npublic void onMessage(@Payload String body, @Headers Map<String,Object> headers) throws Exception {\n    System.out.println(\"Message content : \" + body);\n    System.out.println(\"Message headers : \" + headers);\n}\n```\n\n这两个注解都算是扩展知识，我还是更喜欢直接拿到全部，全都要！！！\n\n上面我们已经完成了消息的发送与消费，整个过程我们可以再次回想一下，一切都和我画的这张图上一样的轨迹：\n\n![rabbit架构图](https://gitee.com/he-erduo/Home/raw/master/picture/rabbitmq/RabbitMQ%E6%9E%B6%E6%9E%84%E5%9B%BE.png)\n\n只不过我们一直没有指定`Exchage`一直使用的默认路由，希望大家好好记住这张图。\n\n## 5. 📘@RabbitListener与@RabbitHandler\n\n下面再来补一些知识点，有关`@RabbitListener`与`@RabbitHandler`。\n\n`@RabbitListener`上面我们已经简单的进行了使用，稍微扩展一下它其实是可以监听多个队列的，就像这样：\n\n```\n@RabbitListener(queues = { \"queue1\", \"queue2\" })\npublic void onMessage(Message message, Channel channel) throws Exception {\n    System.out.println(\"Message content : \" + message);\n    channel.basicAck(message.getMessageProperties().getDeliveryTag(),false);\n    System.out.println(\"消息已确认\");\n}\n```\n\n还有一些其他的特性如绑定之类的，这里不再赘述因为太硬编码了一般用不上。\n\n下面来说说这节要主要讲的一个特性：@RabbitListener和@RabbitHandler的搭配使用。\n\n前面我们没有提到，`@RabbitListener`注解其实是可以注解在类上的，这个注解在类上标志着这个类监听某个队列或某些队列。\n\n这两个注解的搭配使用就要让`@RabbitListener`注解在类上，然后用`@RabbitHandler`注解在方法上，根据方法参数的不同自动识别并去消费，写个例子给大家看一看更直观一些。\n\n```java\n@Slf4j\n@Component(\"rabbitConsumer\")\n@RabbitListener(queues = Producer.QUEUE_NAME)\npublic class RabbitConsumer {\n\n    @RabbitHandler\n    public void onMessage(@Payload String message){\n        System.out.println(\"Message content : \" + message);\n    }\n\n    @RabbitHandler\n    public void onMessage(@Payload User user) {\n        System.out.println(\"Message content : \" + user);\n    }\n}\n```\n\n大家可以看看这个例子，我们先用`@RabbitListener`监听`erduo`队列中的消息，然后使用`@RabbitHandler`注解了两个方法。\n\n* **第一个**方法的body类型是String类型，这就代表着这个方法只能处理文本类型的消息。\n\n* **第二个方法**的body类型是User类型，这就代表着这个方法只能处理序列化类型且为User类型的消息。\n\n这两个方法正好对应着我们第二节中测试类会发送的两种消息，所以我们往RabbitMQ中发送两条测试消息，用来测试这段代码，看看效果：\n\n![RabbitHandler效果](https://gitee.com/he-erduo/Home/raw/master/picture/rabbitmq/rabbitHandle%E6%95%88%E6%9E%9C.png)\n\n都在控制台上如常打印了，如果`@RabbitHandler`注解的方法中没有一个的类型可以和你消息的类型对的上，比如消息都是byte数组类型，这里没有对应的方法去接收，系统就会在控制台不断的报错，如果你出现这个情况就证明你类型写的不正确。\n\n假设你的`erduo`队列中会出现三种类型的消息：byte，文本和序列化，那你就必须要有对应的处理这三种消息的方法，不然消息发过来的时候就会因为无法正确转换而报错。\n\n而且使用了`@RabbitHandler`注解之后就不能再和之前一样使用`Message`做接收类型。\n\n```java\n@RabbitHandler\npublic void onMessage(Message message, Channel channel) throws Exception {\n    System.out.println(\"Message content : \" + message);\n    channel.basicAck(message.getMessageProperties().getDeliveryTag(),false);\n    System.out.println(\"消息已确认\");\n}\n```\n\n这样写的话会报类型转换异常的，所以二者选其一。\n\n同时上文我的`@RabbitHandler`没有进行消息确认，大家可以自己试一下进行消息确认。\n\n## 6. 📙消息的序列化转换\n\n通过上文我们已经知道，能被自动转换的对象只有`byte[]`、`String`、`java序列化对象`(实现了Serializable接口的对象)，但是并不是所有的Java对象都会去实现Serializable接口，而且序列化的过程中使用的是JDK自带的序列化方法，效率低下。\n\n所以我们更普遍的做法是：使用Jackson先将数据转换成JSON格式发送给`RabbitMQ`，再接收消息的时候再用Jackson将数据反序列化出来。\n\n这样做可以完美解决上面的痛点：消息对象既不必再去实现Serializable接口，也有比较高的效率(Jackson序列化效率业界应该是最好的了)。\n\n默认的消息转换方案是消息转换顶层接口-`MessageConverter`的一个子类：`SimpleMessageConverter`，我们如果要换到另一个消息转换器只需要替换掉这个转换器就行了。\n\n![MessageConverter结构树](https://gitee.com/he-erduo/Home/raw/master/picture/rabbitmq/MessageConvert%E7%BB%93%E6%9E%84%E6%A0%91.png)\n\n上图是`MessageConverter`结构树的结构树，可以看到除了`SimpleMessageConverter`之外还有一个`Jackson2JsonMessageConverter`，我们只需要将它定义为Bean，就可以直接使用这个转换器了。\n\n```java\n@Bean\n    public MessageConverter jackson2JsonMessageConverter() {\n        return new Jackson2JsonMessageConverter(jacksonObjectMapper);\n    }\n```\n\n这样就可以了，这里的`jacksonObjectMapper`可以不传入，但是默认的`ObjectMapper`方案对JDK8的时间日期序列化会不太友好，具体可以参考我的上一篇文章：[从LocalDateTime序列化探讨全局一致性序列化](https://juejin.im/post/6854573211528249357)，总的来说就是定义了自己的`ObjectMapper`。\n\n同时为了接下来测试方便，我又定义了一个专门测试JSON序列化的队列：\n\n```java\n@Bean\npublic Queue erduoJson() {\n    // 其三个参数：durable exclusive autoDelete\n    // 一般只设置一下持久化即可\n    return new Queue(\"erduo_json\",true);\n}\n```\n\n---\n\n如此之后就可以进行测试了，先是**生产者代码**：\n\n```java\npublic void sendObject() {\n        Client client = new Client();\n\n        System.out.println(\"Message content : \" + client);\n\n        rabbitTemplate.convertAndSend(RabbitJsonConsumer.JSON_QUEUE,client);\n        System.out.println(\"消息发送完毕。\");\n    }\n```\n\n我又重新定义了一个`Client`对象，它和之前测试使用的User对象成员变量都是一样的，不一样的是它没有实现Serializable接口。\n\n同时为了保留之前的测试代码，我又新建了一个`RabbitJsonConsumer`，用于测试JSON序列化的相关消费代码，里面定义了一个静态变量：`JSON_QUEUE = \"erduo_json\"`;\n\n所以这段代码是将`Client`对象作为消息发送到`\"erduo_json\"`队列中去，随后我们在测试类中run一下进行一次发送。\n\n紧着是**消费者代码**：\n\n```java\n@Slf4j\n@Component(\"rabbitJsonConsumer\")\n@RabbitListener(queues = RabbitJsonConsumer.JSON_QUEUE)\npublic class RabbitJsonConsumer {\n    public static final String JSON_QUEUE = \"erduo_json\";\n\n    @RabbitHandler\n    public void onMessage(Client client, @Headers Map<String,Object> headers, Channel channel) throws Exception {\n        System.out.println(\"Message content : \" + client);\n        System.out.println(\"Message headers : \" + headers);\n        channel.basicAck((Long) headers.get(AmqpHeaders.DELIVERY_TAG),false);\n        System.out.println(\"消息已确认\");\n    }\n\n}\n```\n\n有了上文的经验之后，这段代码理解起来也是很简单了吧，同时给出了上一节没写的如何在`@RabbitHandler`模式下进行消息签收。\n\n我们直接来看看效果：\n\n![json模式消息发送](https://gitee.com/he-erduo/Home/raw/master/picture/rabbitmq/JSON%E5%AF%B9%E8%B1%A1%E5%8F%91%E9%80%81.png)\n\n![json模式消息消费](https://gitee.com/he-erduo/Home/raw/master/picture/rabbitmq/JSON%E5%AF%B9%E8%B1%A1%E6%B6%88%E8%B4%B9.png)\n\n在打印的Headers里面，往后翻可以看到`contentType=application/json`，这个`contentType`是表明了消息的类型，这里正是说明我们新的消息转换器生效了，将所有消息都转换成了JSON类型。\n\n## 后记\n\n这两篇讲完了`RabbitMQ`的基本收发消息，包括手动配置和自动配置的两种方式，这些大家仔细研读之后应该会对`RabbitMQ`收发消息没什么疑问了~\n\n不过我们一直以来发消息时都是使用默认的交换机，下篇将会讲述一下`RabbitMQ`的几种交换机类型，以及其使用方式。\n\n讲完了交换机之后，这些`RabbitMQ`的常用概念基本就完善了。\n\n---\n\n最近这段时间压力挺大，优狐令我八月底之前升级到三级，所以各位读者的赞对我很重要，希望大家能够高抬贵手，帮我一哈~\n\n好了，以上就是本期的全部内容，感谢你能看到这里，欢迎对本文点赞收藏与评论，👍你们的每个点赞都是我创作的最大动力。\n\n我是耳朵，一个一直想做知识输出的伪文艺程序员，我们下期见。\n\n**本文代码：**[码云地址](https://gitee.com/he-erduo/spring-boot-learning-demo)&emsp;[GitHub地址](https://github.com/he-erduo/spring-boot-learning-demo)\n\n\n\n", "user_name": "和耳朵", "description": "纸上得来终觉浅，绝知此事要躬行。", "got_view_count": 18082, "category_name": "后端", "ctime": 1457483880}
{"tag_name": "Spring Cloud", "concern_user_count": 6078, "user_id": "3702810892045095", "title": "微服务系列之ZooKeeper注册中心02：CAP 原则与 BASE 理论", "mark_content": "上篇我们说了[什么是注册中心和常见的注册中心](https://blog.csdn.net/shsxt_c0m/article/details/107885625)，本文将讲述CAP 原则与 BASE 理论。作者是公众号：哈喽沃德先生，请多关注。\n\n# 一、CAP 原则\n\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20200810113612798.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3Noc3h0X2MwbQ==,size_16,color_FFFFFF,t_70)  \nCAP 原则又称 CAP 定理，指的是在一个分布式系统中， Consistency（一致性）、 Availability（可用性）、Partition tolerance（分区容错性），三者不可得兼。\n\nCAP 由 Eric Brewer 在 2000 年 PODC 会议上提出。该猜想在提出两年后被证明成立，成为我们熟知的 CAP 定理。CAP 三者不可兼得。\n\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20200810113709573.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3Noc3h0X2MwbQ==,size_16,color_FFFFFF,t_70)\n\n## 1、取舍策略\n\nCAP 三个特性只能满足其中两个，那么取舍的策略就共有三种：\n\n*   **「CA without P」**：如果不要求P（不允许分区），则C（强一致性）和A（可用性）是可以保证的。但放弃 P 的同时也就意味着放弃了系统的扩展性，也就是分布式节点受限，没办法部署子节点，这是违背分布式系统设计的初衷的。\n*   **「CP without A」**：如果不要求A（可用），相当于每个请求都需要在服务器之间保持强一致，而P（分区）会导致同步时间无限延长（也就是等待数据同步完才能正常访问服务），一旦发生网络故障或者消息丢失等情况，就要牺牲用户的体验，等待所有数据全部一致了之后再让用户访问系统。设计成 CP 的系统其实不少，最典型的就是分布式数据库，如 Redis、HBase等。对于这些分布式数据库来说，数据的一致性是最基本的要求，因为如果连这个标准都达不到，那么直接采用关系型数据库就好，没必要再浪费资源来部署分布式数据库。\n*   **「AP without C」**：要高可用并允许分区，则需放弃一致性。一旦分区发生，节点之间可能会失去联系，为了高可用，每个节点只能用本地数据提供服务，而这样会导致全局数据的不一致性。典型的应用就如某米的抢购手机场景，可能前几秒你浏览商品的时候页面提示是有库存的，当你选择完商品准备下单的时候，系统提示你下单失败，商品已售完。这其实就是先在A（可用性）方面保证系统可以正常的服务，然后在数据的一致性方面做了些牺牲，虽然多少会影响一些用户体验，但也不至于造成用户购物流程的严重阻塞。\n\n## 2、总结\n\n现如今，对于多数大型互联网应用的场景，主机众多、部署分散，而且现在的集群规模越来越大，节点只会越来越多，所以节点故障、网络故障是常态，因此分区容错性也就成为了一个分布式系统必然要面对的问题。那么就只能在 C 和 A 之间进行取舍。但对于传统的项目就可能有所不同，拿银行的转账系统来说，涉及到金钱的对于数据一致性不能做出一丝的让步，C 必须保证，出现网络故障的话，宁可停止服务，可以在 A 和 P 之间做取舍。\n\n总而言之，没有最好的策略，好的系统应该是根据业务场景来进行架构设计的，只有适合的才是最好的。\n\n## 二、BASE 理论\n\nCAP 理论已经提出好多年了，难道真的没有办法解决这个问题吗？也许可以做些改变。比如 C 不必使用那么强的一致性，可以先将数据存起来，稍后再更新，实现所谓的 “最终一致性”。\n\n这个思路又是一个庞大的问题，同时也引出了第二个理论 BASE 理论。\n\n> BASE：全称 Basically Available（基本可用），Soft state（软状态），和 Eventually  \n> consistent（最终一致性）三个短语的缩写，来自 ebay 的架构师提出。\n\nBASE 理论是对 CAP 中一致性和可用性权衡的结果，其来源于对大型互联网分布式实践的总结，是基于 CAP 定理逐步演化而来的。其核心思想是：\n\n> 既然无法做到强一致性（Strong consistency），但每个应用都可以根据自身的业务特点，采用适当的方式来使系统达到最终一致性（Eventual consistency）。\n\n## 1、Basically Available（基本可用）\n\n基本可用是指分布式系统在出现故障的时候，允许损失部分可用性（例如响应时间、功能上的可用性）。需要注意的是，基本可用绝不等价于系统不可用。\n\n响应时间上的损失：正常情况下搜索引擎需要在 0.5 秒之内返回给用户相应的查询结果，但由于出现故障（比如系统部分机房发生断电或断网故障），查询结果的响应时间增加到了 1~2 秒。  \n功能上的损失：购物网站在购物高峰（如双十一）时，为了保护系统的稳定性，部分消费者可能会被引导到一个降级页面。\n\n## 2、Soft state（软状态）\n\n什么是软状态呢？相对于原子性而言，要求多个节点的数据副本都是一致的，这是一种 “硬状态”。\n\n软状态是指允许系统存在中间状态，而该中间状态不会影响系统整体可用性。分布式存储中一般一份数据会有多个副本，允许不同副本数据同步的延时就是软状态的体现。\n\n## 3、Eventually consistent（最终一致性）\n\n系统不可能一直是软状态，必须有个时间期限。在期限过后，应当保证所有副本保持数据一致性。从而达到数据的最终一致性。这个时间期限取决于网络延时，系统负载，数据复制方案设计等等因素。\n\n实际上，不只是分布式系统使用最终一致性，关系型数据库在某个功能上，也是使用最终一致性的，比如备份，数据库的复制都是需要时间的，这个复制过程中，业务读取到的值就是旧值。当然，最终还是达成了数据一致性。这也算是一个最终一致性的经典案例。\n\n## 4、总结\n\n总的来说，BASE 理论面向的是大型高可用可扩展的分布式系统，和传统事务的 ACID 是相反的，它完全不同于 ACID 的强一致性模型，而是通过牺牲强一致性来获得可用性，并允许数据在一段时间是不一致的。更多[Java微服务架构](https://item.taobao.com/item.htm?spm=a2oq0.12575281.0.0.4edf1deb3a71zS&ft=t&id=618747445832)，[spring全家桶教程](https://item.taobao.com/item.htm?spm=a2oq0.12575281.0.0.4edf1deb3a71zS&ft=t&id=623869400668) 欢迎点击获取。", "user_name": "明月及时有", "description": "网络，编程，培训，游山玩水", "got_view_count": 14699, "category_name": "后端", "ctime": 1457483880}
{"tag_name": "Webpack", "concern_user_count": 181325, "user_id": "4142615543688120", "title": "自定义 webpack 配置：基础配置", "mark_content": "> 参考 webpack教程、create-react-app（eject后）配置，自定义一个适合的、可维护的webpack配置\n\n## 1.初始化\n\n```\nyarn init\n```\n\n初始化成功\n```\nyarn init v1.17.3\nquestion name (my-webpack-config): \nquestion version (1.0.0): \nquestion description: \nquestion entry point (index.js): \nquestion repository url (https://github.com/1071942338/my-webpack-config.git): \nquestion author (张文旗 <1071942338@qq.com>): \nquestion license (MIT): \nquestion private: \nsuccess Saved package.json\n✨  Done in 10.97s.\n```\n\n## 2.安装 webpack webpack-cli\n\n```\nyarn add webpack webpack-cli -D\n```\n\n## 3. package.json 添加 build 脚本\n### 3.1 添加 index.js 文件\n1. 新建 src 文件夹\n2. 新建 index.js 文件\n\n```\nconsole.log(\"Hello Webpack !\");\n\n```\n\n### 3.2 添加 webpack.config.js 文件\n1. 新建 config 文件夹\n2. 新建 webpack.config.js 文件\n\n```\nmodule.exports = {\n  //指定入口文件\n  entry: \"./src/index.js\",\n  output: {\n    //输入文件夹名称\n    filename: \"main.js\",\n  },\n  //暂时指定开发模式\n  mode: \"development\",\n};\n\n```\n\n### 3.3 package.json 添加 scripts:build\n\n```\n  \"scripts\": {\n    \"build\": \"webpack --config ./config/webpack.config.js\"\n  },\n```\n\n### 3.4 执行构建脚本\n\n```\nyarn build\n```\n\n```\nyarn run v1.17.3\n$ webpack --config ./config/webpack.config.js\nHash: 33226b34c0395d779dc7\nVersion: webpack 4.44.1\nTime: 47ms\nBuilt at: 2020/08/10 下午2:31:51\n  Asset     Size  Chunks             Chunk Names\nmain.js  3.8 KiB    main  [emitted]  main\nEntrypoint main = main.js\n[./src/index.js] 32 bytes {main} [built]\n✨  Done in 0.60s.\n```\n### 3.5 执行结果\n1. 生成 dist 文件夹\n2. dist 目录下生成 main.js 文件\n3. dist 目录添加 index.html 文件并使用 main.js ，可在控制台看到打印内容：Hello Webpack !\n\n## 4. 拆分 webpack.config.js\n\n### 4.1 拆分目的\n- 开发和生产环境需求不同，例如开发需要热更新及时查看代码效果，生成需要压缩代码\n- 便于维护\n\n\n### 4.2 拆分结果\n\n- webpack.base.js 公共配置\n- webpack.dev.js 开发开发配置\n- webpack.prod.js 生成环境配置\n\n\n### 4.3 拆分工具\n需要用到webpack-merge\n\n```\nyarn add webpack-merge -D\n```\n### 4.3 然后修改文件内容\n\n```\n<!-- webpack.base.js -->\nmodule.exports = {\n  //指定入口文件\n  entry: \"./src/index.js\",\n  output: {\n    //输入文件夹名称\n    filename: \"main.js\",\n  },\n};\n\n<!-- webpack.dev.js -->\nconst { merge } = require(\"webpack-merge\");\nconst baseConfig = require(\"./webpack.base\");\nmodule.exports = merge(baseConfig, {\n  mode: \"development\",\n});\n\n<!-- webpack.prod.js -->\nconst { merge } = require(\"webpack-merge\");\nconst baseConfig = require(\"./webpack.base\");\nmodule.exports = merge(baseConfig, {\n  mode: \"production\",\n});\n```\n\n### 4.3 修改 package.json 文件内容\n\n\n```\n  \"scripts\": {\n    \"dev\": \"webpack --config ./config/webpack.dev.js\",\n    \"build\": \"webpack --config ./config/webpack.prod.js\"\n  },\n```\n\n### 4.4 分别执行指令\n\n\n```\nyarn dev\n<!-- 或 -->\nyarn build\n```\n都可以生成`dist/main.js`文件，区别就是dev为 develpotment 模式代码未压缩。\n\n## 5. 使用 html 模板\n\n```\nyarn add html-webpack-plugin -D\n```\n### 5.1 添加 index.html 文件\n\n1. 新建 public 文件夹\n2. 新建 index.html 文件\n\n```\n<!DOCTYPE html>\n<html>\n  <head>\n    <meta charset=\"utf-8\" />\n    <meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\" />\n    <title>my-webpack-config</title>\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1\" />\n  </head>\n  <body></body>\n</html>\n\n```\n\n### 5.2 修改 webpack.base.js 文件\n\n```\nconst pathsUtil = require(\"./pathsUtil\");\nconst HtmlWebpackPlugin = require(\"html-webpack-plugin\");\n\nmodule.exports = {\n  //指定入口文件\n  entry: pathsUtil.appIndexJs,\n  output: {\n    //输入文件夹名称\n    filename: \"main.js\",\n  },\n  plugins: [\n    new HtmlWebpackPlugin({\n      template: pathsUtil.appHtml,\n      inject: true,\n    }),\n  ],\n};\n\n\n```\n### 5.3 然后执行构建命令即可看到自动生成的index.html文件\n\n```\n<!DOCTYPE html>\n<html>\n  <head>\n    <meta charset=\"utf-8\" />\n    <meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\" />\n    <title>my-webpack-config</title>\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1\" />\n  </head>\n  <body><script src=\"main.js\"></script></body>\n</html>\n\n```\n\n\n## 6.添加 CSS 支持\n\n```\nyarn add style-loader css-loader -D\n```\n### 6.1 添加index.css文件\n\n```\n.color {\n  color: rebeccapurple;\n}\n```\n\n### 6.2 修改index.js文件\n\n```\nimport \"./index.css\";\n\nconst colorElement = document.createElement(\"div\");\ncolorElement.setAttribute(\"class\", \"color\");\ncolorElement.innerText = \"my-webpack-config\";\ndocument.body.appendChild(colorElement);\n```\n\n### 6.3 修改 webpack.base.js 文件\n```\nconst pathsUtil = require(\"./pathsUtil\");\nconst HtmlWebpackPlugin = require(\"html-webpack-plugin\");\n\nmodule.exports = {\n  //指定入口文件\n  entry: pathsUtil.appIndexJs,\n  output: {\n    //输入文件夹名称\n    filename: \"main.js\",\n  },\n  module: {\n    rules: [\n      {\n        test: /\\.css$/,\n        use: [\"style-loader\", \"css-loader\"],\n      },\n    ],\n  },\n  plugins: [\n    new HtmlWebpackPlugin({\n      template: pathsUtil.appHtml,\n      inject: true,\n    }),\n  ],\n};\n\n```\n\n\n## 7.添加图片支持\n```\nyarn add url-loader file-loader -D\n```\n\n### 7.1 添加尺寸不同的图片\n- small 47K\n- big 4.4M\n\n\n### 7.2 修改 webpack.base.js 文件\n\n```\nconst pathsUtil = require(\"./pathsUtil\");\nconst HtmlWebpackPlugin = require(\"html-webpack-plugin\");\n\nmodule.exports = {\n  //指定入口文件\n  entry: pathsUtil.appIndexJs,\n  output: {\n    //输入文件夹名称\n    filename: \"main.js\",\n  },\n  module: {\n    rules: [\n      {\n        test: /\\.css$/,\n        use: [\"style-loader\", \"css-loader\"],\n      },\n      {\n        test: [/\\.bmp$/, /\\.gif$/, /\\.jpe?g$/, /\\.png$/],\n        use: [\n          {\n            loader: \"url-loader\",\n            options: {\n              limit: 51200,//50k\n            },\n          },\n        ],\n      },\n    ],\n  },\n  plugins: [\n    new HtmlWebpackPlugin({\n      template: pathsUtil.appHtml,\n      inject: true,\n    }),\n  ],\n};\n\n```\n### 7.3 修改 index.js 文件\n\n```\nimport \"./index.css\";\nimport smallImage from \"./image/small.png\";\nimport bigImage from \"./image/big.png\";\n\nconst colorElement = document.createElement(\"div\");\ncolorElement.setAttribute(\"class\", \"color\");\ncolorElement.innerText = \"my-webpack-config\";\ndocument.body.appendChild(colorElement);\n\nconst smallImageElement = document.createElement(\"img\");\nsmallImageElement.setAttribute(\"src\", smallImage);\ndocument.body.appendChild(smallImageElement);\n\nconst bigImageElement = document.createElement(\"img\");\nbigImageElement.setAttribute(\"src\", bigImage);\ndocument.body.appendChild(bigImageElement);\n\n```\n\n### 7.4 执行构建打包后在浏览器中查看\n- small 以 base64字符串显示\n- big 4.4M 以路径加载图片显示\n\n## 8.添加字体解析\n\n```\nyarn add file-loader -D\n```\n\n### 8.1 修改 index.css\n\n```\n.color {\n  color: rebeccapurple;\n}\n@font-face {\n  font-family: myFirstFont;\n  src: url(\"./font/font.ttf\");\n}\n.font {\n  font-family: myFirstFont;\n}\n\n```\n\n### 8.2 修改 index.js\n\n\n```\nimport \"./index.css\";\nimport smallImage from \"./image/small.png\";\nimport bigImage from \"./image/big.png\";\n\nconst colorElement = document.createElement(\"div\");\ncolorElement.setAttribute(\"class\", \"color\");\ncolorElement.innerText = \"my-webpack-config\";\ndocument.body.appendChild(colorElement);\n\nconst fontElement = document.createElement(\"div\");\nfontElement.setAttribute(\"class\", \"color font\");\nfontElement.innerText = \"my-webpack-config\";\ndocument.body.appendChild(fontElement);\n\nconst smallImageElement = document.createElement(\"img\");\nsmallImageElement.setAttribute(\"src\", smallImage);\ndocument.body.appendChild(smallImageElement);\n\nconst bigImageElement = document.createElement(\"img\");\nbigImageElement.setAttribute(\"src\", bigImage);\ndocument.body.appendChild(bigImageElement);\n\n```\n### 8.3 修改 webpack.base.js\n\n\n```\nconst pathsUtil = require(\"./pathsUtil\");\nconst HtmlWebpackPlugin = require(\"html-webpack-plugin\");\n\nmodule.exports = {\n  //指定入口文件\n  entry: pathsUtil.appIndexJs,\n  output: {\n    //输入文件夹名称\n    filename: \"main.js\",\n  },\n  module: {\n    rules: [\n      {\n        test: /\\.css$/,\n        use: [\"style-loader\", \"css-loader\"],\n      },\n      {\n        test: [/\\.bmp$/, /\\.gif$/, /\\.jpe?g$/, /\\.png$/],\n        use: [\n          {\n            loader: \"url-loader\",\n            options: {\n              limit: 51200, //50k\n            },\n          },\n        ],\n      },\n      {\n        test: /\\.(woff|woff2|eot|ttf|otf)$/,\n        use: [\"file-loader\"],\n      },\n    ],\n  },\n  plugins: [\n    new HtmlWebpackPlugin({\n      template: pathsUtil.appHtml,\n      inject: true,\n    }),\n  ],\n};\n\n```\n\n### 8.4 构建打包 查看效果\n\n## 9. 添加 React 支持\n\n### 9.1 添加 babel 支持\n\n```\nyarn add @babel/core @babel/preset-env @babel/preset-react -D\n```\n\n### 9.2 添加 babel-loader 支持\n\n```\nyarn add babel-loader -D\n```\n\n### 9.3 添加 React 支持\n```\nyarn add react react-dom \n```\n### 9.4 修改 webpack.base.js\n\n```\nyarn add react react-dom \n```\n\n### 9.5 修改 index.html\n\n```\n<!DOCTYPE html>\n<html>\n  <head>\n    <meta charset=\"utf-8\" />\n    <meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\" />\n    <title>my-webpack-config</title>\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1\" />\n  </head>\n  <body>\n    <div id=\"root\"></div>\n  </body>\n</html>\n\n\n```\n### 9.6 修改 index.js\n\n```\nimport React from \"react\";\nimport ReactDom from \"react-dom\";\nimport \"./index.css\";\nimport App from \"./App.jsx\";\n\nReactDom.render(<App />, document.getElementById(\"root\"));\n\n```\n\n\n### 9.7 新增 App.jsx\n\n```\nimport React from \"react\";\nimport smallImage from \"./image/small.png\";\nimport bigImage from \"./image/big.png\";\nexport default class App extends React.Component {\n  render() {\n    return (\n      <div>\n        <div className=\"color\">my-webpack-config</div>\n        <div className=\"color font\">my-webpack-config</div>\n        <img src={smallImage} alt=\"\"></img>\n        <img src={bigImage} alt=\"\"></img>\n      </div>\n    );\n  }\n}\n\n```\n\n\n### 9.9 执行构建脚本，查看效果\n\n## 10. 自动编译代码\n```\nyarn add webpack-dev-server -D\n\n```\n### 10.1 添加 scripts 文件夹\n- 新增 dev.js\n- 新增 build.js\n### 10.2 编辑 dev.js\n\n```\n\"use strict\";\nconst webpack = require(\"webpack\");\nconst prodConfig = require(\"../config/webpack.dev.js\");\nconst webpackDevServer = require(\"webpack-dev-server\");\n\nconst compiler = webpack(prodConfig);\nconst devServerOptions = Object.assign({}, prodConfig.devServer, {\n  open: true,\n  stats: {\n    colors: true,\n  },\n});\nconst server = new webpackDevServer(compiler, devServerOptions);\n\nserver.listen(3000, \"127.0.0.1\", () => {\n  console.log(\"Starting server on http://localhost:3000\");\n});\n\n```\n\n### 10.3 编辑 build.js\n```\n\"use strict\";\nconst webpack = require(\"webpack\");\nconst prodConfig = require(\"../config/webpack.prod.js\");\nwebpack(prodConfig, (err, stats) => {\n  if (err || stats.hasErrors()) {\n    // 在这里处理错误\n    console.log(\"err:\", err);\n    console.log(\"stats:\", stats);\n  }\n  // 处理完成\n  console.log(\"处理完成\");\n});\n\n```\n### 10.4 编辑 package.json 文件\n\n```\n  \"scripts\": {\n    \"dev\": \"node ./scripts/dev.js\",\n    \"build\": \"node ./scripts/build.js\"\n  },\n```\n\n### 10.5 执行构建脚本，查看效果\n\n```\nyarn dev\n```\n然后自动打开 http://localhost:3000 页面，编辑页面保存后，页面自动刷新\n\n\n---\n> 代码仓库\n\n- [my-webpack-config](https://github.com/1071942338/my-webpack-config)\n\n> 参考链接\n- [安装](https://www.webpackjs.com/guides/installation/)\n- [起步](https://www.webpackjs.com/guides/getting-started/)\n- [管理资源](https://www.webpackjs.com/guides/asset-management/)\n- [开发](https://www.webpackjs.com/guides/development/)\n- [开发中 Server(devServer)](https://www.webpackjs.com/configuration/dev-server/)\n- [webpack webpack-dev-server](https://github.com/webpack/webpack-dev-server/blob/master/examples/api/simple/server.js)\n- [url-loader](https://github.com/webpack/url-loader)\n- [file-loader](https://github.com/webpack/file-loader)\n- [css-loader](https://github.com/webpack/css-loader)\n- [style-loader](https://github.com/webpack/style-loader)\n- [css-loader](https://github.com/webpack/css-loader)\n- [babel-loader](https://github.com/babel/babel-loader)\n- [Babel Usage Guide](https://www.babeljs.cn/docs/usage)\n- [babel-preset-react](https://www.babeljs.cn/docs/babel-preset-react)\n- [html-webpack-plugin](https://github.com/ampedandwired/html-webpack-plugin)\n\n", "user_name": "好_快", "description": "iOS React Vue", "got_view_count": 6516, "category_name": "前端", "ctime": 1457483942}
{"tag_name": "强化学习", "concern_user_count": 3017, "user_id": "3421335916914791", "title": "强化学习 8 —— DQN 代码 Tensorflow 2.0 实现", "mark_content": "\n\n在上一篇文章[强化学习——DQN介绍](https://blog.csdn.net/november_chopin/article/details/107912720) 中我们详细介绍了DQN 的来源，以及对于强化学习难以收敛的问题DQN算法提出的两个处理方法：经验回放和固定目标值。这篇文章我们就用代码来实现 DQN 算法\n\n## 一、环境介绍\n\n### 1、Gym 介绍\n\n本算法以及以后文章要介绍的算法都会使用 由 $OpenAI$ 推出的[$Gym$](http://gym.openai.com/)仿真环境， $Gym$ 是一个研究和开发强化学习相关算法的仿真平台，了许多问题和环境（或游戏）的接口，而用户无需过多了解游戏的内部实现，通过简单地调用就可以用来测试和仿真，并兼容常见的数值运算库如 $TensorFlow$ 。\n\n```python\nimport gym\nenv = gym.make('CartPole-v1')\nenv.reset()\nfor _ in range(1000):\n    env.render()\n    env.step(env.action_space.sample()) # take a random action\nenv.close()\n```\n\n运行结果如下：\n\n<img src=\"https://s1.ax1x.com/2020/07/31/aMXZ7Q.gif\" alt=\"aMXZ7Q.gif\" style=\"zoom:80%;\" />\n\n以上代码中可以看出，`gym`的核心接口是`Env`。作为统一的环境接口，`Env`包含下面几个核心方法：\n\n- `reset(self)`：重置环境的状态，返回观察。如果回合结束，就要调用此函数，重置环境信息\n- `step(self, action)`：执行动作 `action` 推进一个时间步长，返回`observation`,` reward`, `done`, `info`。\n  - `observation`表示环境观测，也就是`state`\n  - `reward` 表示获得的奖励\n  - `done`表示当前回个是否结束\n  - `info` 返回一些诊断信息，一般不经常用\n- `render(self, mode=‘human’, close=False)`：重新绘制环境的一帧。\n- `close(self)`：关闭环境，并清除内存。\n\n以上代码首先导入`gym`库，第2行创建`CartPole-v01`环境，并在第3行重置环境状态。在  for 循环中进行*1000*个时间步长(*timestep)的控制，第5行刷新每个时间步长环境画面，第6行对当前环境状态采取一个随机动作（0或1），最后第7行循环结束后关闭仿真环境。\n\n### 2、CartPole-v1 环境介绍\n\nCartPole 是gym提供的一个基础的环境，即车杆游戏，游戏里面有一个小车，上有竖着一根杆子，每次重置后的初始状态会有所不同。小车需要左右移动来保持杆子竖直，为了保证游戏继续进行需要满足以下两个条件：\n\n- 杆子倾斜的角度 $\\theta$ 不能大于15°\n- 小车移动的位置 x 需保持在一定范围（中间到两边各2.4个单位长度）\n\n对于 `CartPole-v1` 环境，其动作是两个离散的动作左移（0）和右移（1），环境包括小车位置、小车速度、杆子夹角及角变化率四个变量。如下代码所示：\n\n```python\nimport gym\nenv = gym.make('CartPole-v0')\nprint(env.action_space)  # Discrete(2)\nobservation = env.reset()\nprint(observation)  # [-0.0390601  -0.04725411  0.0466889   0.02129675]\n```\n\n下面以`CartPole-v1` 环境为例，来介绍 DQN 的实现\n\n## 二、代码实现\n\n### 1、经验回放池的实现\n\n```python\nclass ReplayBuffer:\n    def __init__(self, capacity=10000):\n        self.capacity = capacity\n        self.buffer = []\n        self.position = 0\n\n    def push(self, state, action, reward, next_state, done):\n        if len(self.buffer) < self.capacity:\n            self.buffer.append(None)\n        self.buffer[self.position] = (state, action, reward, next_state, done)\n        self.position = int((self.position + 1) % self.capacity)\n\n    def sample(self, batch_size = args.batch_size):\n        batch = random.sample(self.buffer, batch_size)\n        state, action, reward, next_state, done = map(np.stack, zip(*batch))\n        return state, action, reward, next_state, done\n```\n\n首先定义一个经验回放池，其容量为 10000，函数 `push` 就是把智能体与环境交互的到的信息添加到经验池中，这里使用的循环队列的实现方式，注意 `position` 指针的运算。当需要用数据来更新算法 时，使用 `sample` 从经验队列中随机挑选 一个 `batch_size` 的数据，使用 zip 函数把每一条数据打包到一起：\n\n```python\nzip: a=[1,2], b=[2,3], zip(a,b) => [(1, 2), (2, 3)]\n```\n\n然后对每一列数据使用 stack 函数转化为列表后返回\n\n### 2、网络构造\n\n本系列强化学习的代码，都是使用的 `tensorlayer` ，就是对 `tensorflow` 做了一些封装，使其更加易用，重点是还**专门为强化学习**内置了一些接口，下面是[官网](https://tensorlayercn.readthedocs.io/zh/latest/)介绍：\n\n> TensorLayer 是为研究人员和工程师设计的一款基于Google TensorFlow开发的深度学习与强化学习库。 它提供高级别的（Higher-Level）深度学习API，这样不仅可以加快研究人员的实验速度，也能够减少工程师在实际开发当中的重复工作。 TensorLayer非常易于修改和扩展，这使它可以同时用于机器学习的研究与应用。\n\n定义网络模型：\n\n```python\ndef create_model(input_state_shape):\n    input_layer = tl.layers.Input(input_state_shape)\n    layer_1 = tl.layers.Dense(n_units=32, act=tf.nn.relu)(input_layer)\n    layer_2 = tl.layers.Dense(n_units=16, act=tf.nn.relu)(layer_1)\n    output_layer = tl.layers.Dense(n_units=self.action_dim)(layer_2)\n    return tl.models.Model(inputs=input_layer, outputs=output_layer)\n\nself.model = create_model([None, self.state_dim])\nself.target_model = create_model([None, self.state_dim])\nself.model.train()\nself.target_model.eval()\n```\n\n可以看到`tensorlayer` 使用起来与`tensorflow` 大同小异，只要有`tensorflow`基础一眼就能明白，在上面代码中我们定义一个函数用来生成网络模型。然后创建一个当前网络`model`和一个目标网络`target_model` ，我们知道DQN中的目标网络是起到一个“靶子”的作用，用来评估当前的 target 值，所以我们把它设置为评估模式，调用 `eval()` 函数即可。而 `model` 网络是我们要训练的网络，调用函数 `train()` 设置为训练模式。\n\n### 3、算法控制流程\n\n```python\nfor episode in range(train_episodes):\n    total_reward, done = 0, False\n    while not done:\n        action = self.choose_action(state)\n        next_state, reward, done, _ = self.env.step(action)\n        self.buffer.push(state, action, reward, next_state, done)\n        total_reward += reward\n        state = next_state\n        # self.render()\n    if len(self.buffer.buffer) > args.batch_size:\n        self.replay()\n        self.target_update()\n```\n\n关于与环境交互过程在上面已经介绍过了，这里重点看 第 10 行的 if 语句，当经验池的长度大于一个`batch_size` 时，就开始调用`replay()` 函数来更新网络 `model` 的网络参数，然后调用`target_update()` 函数把 `model` 网络参数复制给 `target_model` 网络。\n\n### 4、网络参数更新\n\n```python\ndef replay(self):\n    for _ in range(10):\n        states, actions, rewards, next_states, done = self.buffer.sample()\n        # compute the target value for the sample tuple\n        # target [batch_size, action_dim]\n        # target represents the current fitting level\n        target = self.target_model(states).numpy()\n        next_q_value = tf.reduce_max(self.target_model(next_states), axis=1)\n        target_q = rewards + (1 - done) * args.gamma * next_q_value\n        target[range(args.batch_size), actions] = target_q\n\n        with tf.GradientTape() as tape:\n            q_pred = self.model(states)\n            loss = tf.losses.mean_squared_error(target, q_pred)\n        grads = tape.gradient(loss, self.model.trainable_weights)\n        self.model_optim.apply_gradients(zip(grads, self.model.trainable_weights))\n```\n\n这部分应该就是 DQN 的核心代码了，在`replay()` 函数中，我们循环更新更新当前网络十次，目的就是改变两个网络的更新频率，有利于网络收敛。\n\n具体的更新部分：我们知道，DQN就是把Q-Learning中的Q表格换成了神经网络，两者之间有很多 相似之处，我们可以类比Q-Learning 的更新方式。对于Q表格形式，我们获取某一个状态的动作价值Q是直接通过下标得到的，那么在神经网络中就需要把状态输入神经网络，经过前向计算得到。\n$$\n\\Delta w = \\alpha (r + \\gamma\\;max_{a'}\\; \\hat{Q}(s', a', w) - \\hat{Q}{(s, a, w)})\\cdot \\nabla_w\\hat{Q}{(s, a, w)}\n$$\n第三行首先获取一个`batch_size`的数据，这个过程称为 `sample` 。第7行我们首先获取当前的动作价值，target 表示的是根据当前的网络参数计算得到的动作价值。然后第8行先获取当前网络参数下 的下一个状态的所有动作，然后使用`reduce_max()` 函数找出最大的动作价值。然后第9行和第10行利用下一个状态最大的动作价值来计算出 `target_q` ，也就是 $r + \\gamma\\;max_{a'}\\; \\hat{Q}(s', a', w)$ 部分，然后更新`target` 。注意上面我们计算target时一直在使用 `target_model` 网络，target网络只有在评估网络状态时才使用。\n\n接着我们使用 `q_pred = self.model(states)` 网络获取当前 网络的状态，也就是 公式中的 $\\hat{Q}{(s, a, w)}$ ，利用MSE函数计算其损失函数，最后更新 `model` 网络。\n\n完整代码请参考[强化学习——DQN代码地址](https://github.com/NovemberChopin/RL_Tutorial/blob/master/code/DQN.py) 还请给个 `star` ，谢谢各位了\n\n## 三、DQN 小结\n\n虽然 DQN 提出的这两个解决方案不错，但是仍然还有问题没有解决，比如：\n\n-  目标 Q 值（Q Target ）计算是否准确？全部通过 $max\\;Q$ 来计算有没有问题？\n-  Q 值代表动作价值，那么单纯的动作价值评估会不会不准确？\n\n对应第一个问题的改进就是 Double DQN ，第二个问题的改进是 Dueling DQN。他们都属与DQN的改进版，我们下篇文章介绍。", "user_name": "盐的甜", "description": "修之于身，其德乃真", "got_view_count": 3224, "category_name": "人工智能", "ctime": 1500876664}
{"tag_name": "Vue.js", "concern_user_count": 263220, "user_id": "1521379822544157", "title": "vue3.x reactive、effect、computed、watch依赖关系及实现原理", "mark_content": "首先来了解2个全局变量和1个变量。\n\n- **targetMap [new WeakMap]** : 在track()、trigger()的时候，冲当中间关联容器\n- **effectStack [Array]** : 顾名思义就是存放effect的容器\n- **activeEffect** : 在track()的时候作为Target的收集对象,可以当作一个临时作用的变量\n\n## 1、reactive(target)\n\nreactive实现原理，不废话(bb)直接上图\n![reactive实现原理](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8a7c52ce676a433287f6524e44ae2884~tplv-k3u1fbpfcp-zoom-1.image)\n\n- 原理大致就是通过 [new Proxy()](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Proxy) 重写getter、setter方法来实现自己需要的逻辑\n- 重写getter实现track收集effect\n- 重写setter现实trigger触发effect\n\n## 2、effect(fn,options)\n\n![effect实现原理](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d9ec21bfa0594376851cddbb976f754f~tplv-k3u1fbpfcp-zoom-1.image)\n\neffect是作为track()过程中最重要的环节，是唯一提供activeEffect的地方\n\n## 3、computed(getterOrOptions)\n\n![computed实现原理](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/230c39f0175b4c778ce48609085c665d~tplv-k3u1fbpfcp-zoom-1.image)\n\n通过上面流程图不难看出computed的实现本质是effect.\n- 1.通过处理getterOrOptions参数得到一个匿名函数 getter\n- 2.把getter作为 **effect()** 参数得到一个延迟执行的runner函数\n- 3.把runner封装成一个 **ref** 对象并且返回。\n\n## 4、watch(source,cb,options)\n\n![watch实现原理](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f32f8c07a03c4bf6b0b34b6ff9313363~tplv-k3u1fbpfcp-zoom-1.image)\n\n相比 **computed** ，watch的实现逻辑相对复杂一些。这里只讲解大致实现原理。通过分析源码发现，watch的大致原理也是建立在 **effect** 的实现上。\n\n- 1.首先一些列处理把source 封装成为 effect的fn参数，例如：const getter = ()=> source;\n- 2.通过effect得到一个延迟的runner函数\n- 3.首次执行runner完成track()\n- 4.返回一个停止监听的匿名函数\n\n\n## 5、简单实现\n**重点说明：** 以下代码( *省略了很多逻辑* )的实现仅供原理理解，具体实现请移步[vue-next](https://github.com/vuejs/vue-next)源码。\n\n### 5.1、reactive\n\n通过1、reactive(target)的分析和理解，reactive大致实现就是这样：\n```javascript\nfunction reactive(obj) {\n    return new Proxy(obj, {\n        get: function(target, key, receiver) {\n        \t// getter\n            track(target, key); // 收集effect函数\n            return Reflect.get(target, key, receiver);\n        },\n        set: function(target, key, value, receiver) {\n        \t// setter\n            let oldValue = target[key]; // 原始值\n            if (oldValue === value) {\n                return;\n            }\n            let res = Reflect.set(target, key, value, receiver);\n            trigger(target, key); // 触发effect函数\n            return res;\n        },\n    });\n}\n```\n不了解[Reflect](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Reflect)的同学自行百度，这里不讲述。接下来实现track、trigger函数\n```javascript\n//...\nconst targetMap = new WeakMap();\nconst effectStack = [];\nlet activeEffect = null;\n\nfunction track(target, key) {\n    if (!activeEffect) {\n        return;\n    }\n\n    // 收集\n    let depsMap = targetMap.get(target);\n    if (!depsMap) {\n        targetMap.set(target, (depsMap = new Map()));\n    }\n    let dep = depsMap.get(key);\n    if (!dep) {\n        depsMap.set(key, (dep = new Set()));\n    }\n    if (!dep.has(activeEffect)) {\n        dep.add(activeEffect);\n    }\n}\n\nfunction trigger(target, key) {\n    // 触发\n    const depsMap = targetMap.get(target);\n    if (!depsMap) {\n        return;\n    }\n\n    let dep = depsMap.get(key);\n\n    let effects = new Set();\n    dep && dep.forEach((effect) => effects.add(effect));\n\n    // 执行\n    effects.forEach((effect) => {\n        if (effect.options.scheduler) {\n            effect.options.scheduler(effect);\n        } else {\n            effect();\n        }\n    });\n}\n```\n上面就是整个reactive实现的大致代码。虽然不够完整，但是够理解了。想要深入了解的同学可以直接移步[vue-next](https://github.com/vuejs/vue-next)源码。\n\n### 5.2、effect\n\n接下来就是 **effect(fn,options)** 的实现。代码如下：\n```javascript\nconst effectStack = [];\nlet activeEffect = null;\n//...\nfunction effect(fn, options = {}) {\n    let effect = createEffect(fn, options);\n    if (!options.lazy) {\n        effect();\n    }\n    return effect;\n}\n\nlet uid = 0;\nfunction createEffect(fn, options) {\n    const effect = () => {\n        if (!effectStack.includes(effect)) {\n            try {\n                effectStack.push(effect);\n                activeEffect = effect;\n                // 默认执行收集\n                return fn();\n            } finally {\n                // 处理完成\n                effectStack.pop();\n                activeEffect = effectStack[effectStack.length - 1];\n            }\n        }\n    };\n    effect.raw = fn;\n    effect.id = uid++;\n    effect.options = options;\n    //...\n    return effect;\n}\n```\n\n通过 **effect(fn,options)** 可以分析出effect的执行返回的是fn()的结果。如果吧reactive、effect放在一起你回发现他们的依赖关系。Proxy 通过getter收集activeEffect、setter触发activeEffect。看似两个完成独立的方法，中间通过全局变量activeEffect联系在一起。\n\n\n### 5.3、computed\nreactive和effect的实现之后computed就相对简单多了。computed的实现代码：\n\n```javascript\n//...\nfunction computed(fn) {\n    let runner = effect(fn, {\n        lazy: true,\n    });\n\n    return {\n        get value() {\n            // 执行收集\n            return runner();\n        },\n        set value(value) {},\n    };\n}\n\n// 使用\nlet data = reactive({ count : 0 })\n\nlet text = computed(() => {\n    return `count:${data.count}`;\n});\n\nconsole.log(text.value) // count:0\n```\n\n对，没错。computed的实现就是这么简单。相比computed、watch的实现就复杂多了。\n\n### 5.3、watch\n\n```javascript\n// 这里只是简单的实现watch以供理解\n\nfunction watch(source, cb) {\n    let getter = () => {};\n    if (isFunction(source)) {\n        getter = source;\n    }\n    // 收集信息\n    let runner = effect(getter, {\n        lazy: true,\n        scheduler: () => {\n            // 执行回调\n            let value = runner();\n            if (value !== oldValue) {\n                cb(oldValue, value);\n            }\n            oldValue = value;\n        },\n    });\n    // 第一次执行收集\n    let oldValue = runner();\n    //停止监听\n    return ()=>{\n    \tstop(runner)\n        //...\n    }\n}\n\n// 使用\nlet stopWatcher = watch(\n    () => data.count,\n    (oldValue, value) => {\n        // 执行\n        console.log(\"========watch========\", oldValue, value);\n    }\n);\n\n// 可以停止watch\n// stopWatcher()\n\ndata.count = 100;\n// ========watch======== 0 100\n\n```\n### 5.4、完整的代码\n\n```javascript\n// reactive\nfunction reactive(obj) {\n    return new Proxy(obj, {\n        get: function(target, key, receiver) {\n            track(target, key);\n            // getter\n            return Reflect.get(target, key, receiver);\n        },\n        set: function(target, key, value, receiver) {\n            let oldValue = target[key]; // 原始值\n            if (oldValue === value) {\n                return;\n            }\n\n            // setter\n            let res = Reflect.set(target, key, value, receiver);\n            trigger(target, key);\n            return res;\n        },\n    });\n}\n\nconst targetMap = new WeakMap();\nconst effectStack = [];\nlet activeEffect = null;\n// track\nfunction track(target, key) {\n    if (!activeEffect) {\n        return;\n    }\n\n    // 收集\n    let depsMap = targetMap.get(target);\n    if (!depsMap) {\n        targetMap.set(target, (depsMap = new Map()));\n    }\n    let dep = depsMap.get(key);\n    if (!dep) {\n        depsMap.set(key, (dep = new Set()));\n    }\n    if (!dep.has(activeEffect)) {\n        dep.add(activeEffect);\n    }\n}\n// trigger\nfunction trigger(target, key) {\n    // 触发\n    const depsMap = targetMap.get(target);\n    if (!depsMap) {\n        return;\n    }\n\n    let dep = depsMap.get(key);\n\n    let effects = new Set();\n    dep && dep.forEach((effect) => effects.add(effect));\n\n    // 执行\n    effects.forEach((effect) => {\n        if (effect.options.scheduler) {\n            effect.options.scheduler(effect);\n        } else {\n            effect();\n        }\n    });\n}\n// effect\nfunction effect(fn, options = {}) {\n    let effect = createEffect(fn, options);\n    if (!options.lazy) {\n        // 执行手机\n        effect();\n    }\n\n    return effect;\n}\n\nlet uid = 0;\nfunction createEffect(fn, options) {\n    const effect = () => {\n        if (!effectStack.includes(effect)) {\n            try {\n                effectStack.push(effect);\n                activeEffect = effect;\n                // 首次执行收集\n                return fn();\n            } finally {\n                // 处理完成\n                effectStack.pop();\n                activeEffect = effectStack[effectStack.length - 1];\n            }\n        }\n    };\n    effect.raw = fn;\n    effect.id = uid++;\n    effect.options = options;\n    return effect;\n}\n// computed\nfunction computed(fn) {\n    let runner = effect(fn, {\n        lazy: true,\n    });\n\n    return {\n        get value() {\n            // 执行收集\n            return runner();\n        },\n        set value(value) {},\n    };\n}\n// watch\nfunction watch(source, cb) {\n    let getter = () => {};\n    if (typeof source === \"function\") {\n        getter = source;\n    }\n    // 收集信息\n    let runner = effect(getter, {\n        lazy: true,\n        scheduler: () => {\n            // 执行回调\n            let value = runner();\n            if (value !== oldValue) {\n                cb(oldValue, value);\n            }\n            oldValue = value\n        },\n    });\n    // 第一次执行收集\n    let oldValue = runner();\n}\n```\n\n## 6、总结\n\n通过简单的实现可以总结出一下几点:\n- vue核心是重写new Proxy()的getter、setter来实现数据驱动的核心\n- computed和watch的实现可以看出实际原理都依赖effect()工厂\n- activeEffect可以看作是new Proxy()和effec()的交通枢纽\n\n\n**再次声明**：上述实现代码仅供理解实现原理，具体详细实现请移步[vue-next](https://github.com/vuejs/vue-next)源码。\n\n\n\n萌新，如有错误欢迎指正 (ง •_•)ง\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n", "user_name": "__此间少年", "description": "", "got_view_count": 114, "category_name": "前端", "ctime": 1457483942}
{"tag_name": "前端框架", "concern_user_count": 218926, "user_id": "1398234520230989", "title": "前端页面可视化搭建工具业界的轮子", "mark_content": "<section id=\"nice\" data-tool=\"mdnice编辑器\" data-website=\"https://www.mdnice.com\" style=\"padding: 0 10px; line-height: 1.6; word-spacing: 0px; word-break: break-word; word-wrap: break-word; text-align: left; font-family: Optima-Regular, Optima, PingFangSC-light, PingFangTC-light, 'PingFang SC', Cambria, Cochin, Georgia, Times, 'Times New Roman', serif; font-size: 15px; letter-spacing: 0.05em; color: #595959;\"><h1 data-tool=\"mdnice编辑器\" style=\"margin-top: 30px; margin-bottom: 15px; font-size: 24px; margin: 1.2em 0 1em; padding: 0; font-weight: bold; color: #35b378;\"><span class=\"prefix\" style=\"display: none;\"></span><span class=\"content\">页面可视化搭建工具业界的轮子</span><span class=\"suffix\"></span></h1>\n<p data-tool=\"mdnice编辑器\" style=\"font-size: 16px; padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: black; margin: 1em 4px;\">无论大公司还是小公司，我们开发前端工程时候，项目工程又很多类似的功能或者页面，开发经常是加班加点搬砖去做一些无成长反复操作的工作，看键盘上 Ctrl 键已经被磨掉了漆，C 和 V 也马上磨白了，那对于开发如何把这些重复的工作用机器去解决？在前端资源紧缺的情况下，是否可直接有工具直接就可以搭建出我想要的前端页面？于是业界的页面可视化搭建工具就出现了，本文会介绍目前最流行的页面可视化搭建工具，也会提供一些业界开源的可视化搭建项目供大家参考（Copy）。</p>\n<h2 data-tool=\"mdnice编辑器\" style=\"margin-top: 30px; margin-bottom: 15px; bmin-height: 32px; line-height: 32px; border-bottom: solid 1px #000000; color: #35b378; display: inline-block; border-bottom-width: 0px; border-bottom-style: solid; border-color: #35b378; padding-top: 5px; padding-right: 0.5em; padding-left: 0.5em; font-size: 23px; margin: 1em 0 0rem 0; padding: 0.5em 0; text-align: leftt; font-weight: bold;\"><span class=\"prefix\" style=\"display: none;\"></span><span class=\"content\">1 页面可视化搭建 简介</span><span class=\"suffix\"></span></h2>\n<p data-tool=\"mdnice编辑器\" style=\"font-size: 16px; padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: black; margin: 1em 4px;\"><strong style=\"font-weight: bold; color: #35b378;\">编程开发页面</strong>：动态逻辑页面分解为 HTML Tree, Data 和 Dynamic Logic. 前端开发工程师开发前端页面的过程, 本质上是用编程工具(IDE)对页面的 HTML Tree, Data 和 Dynamic Logic 进行增删和修改.</p>\n<p data-tool=\"mdnice编辑器\" style=\"font-size: 16px; padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: black; margin: 1em 4px;\"><strong style=\"font-weight: bold; color: #35b378;\">页面可视化搭建</strong>：是用可视化交互的方式对页面的 HTML Tree, Data 和 Dynamic Logic 进行增删和修改, 从而实现页面的生成. 页面可视化搭建工具是实现页面可视化编辑的软件工具</p>\n<p data-tool=\"mdnice编辑器\" style=\"font-size: 16px; padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: black; margin: 1em 4px;\"><strong style=\"font-weight: bold; color: #35b378;\">目的</strong>：任何工具的存在都是更高效地解决问题. 页面可视化搭建工具, 用于解决页面生成的效率问题.\n可能前端工程师会觉得最有效率的页面生成方式是打代码, 但有搭建页面需求的不只是前端工程师. 而可视化页面搭建工具, 恰恰是面向\"就缺一个前端工程师\"的人员, 用于提升他们生成页面的效率.</p>\n<section class=\"table-container\" data-tool=\"mdnice编辑器\" style=\"overflow-x: auto;\"><table style=\"display: table; text-align: left;\">\n<thead>\n<tr style=\"border: 0; border-top: 1px solid #ccc; background-color: white;\">\n<th style=\"font-size: 16px; border: 1px solid #ccc; padding: 5px 10px; text-align: left; font-weight: bold; background-color: #f0f0f0; min-width: 85px;\">差异点</th>\n<th style=\"font-size: 16px; border: 1px solid #ccc; padding: 5px 10px; text-align: left; font-weight: bold; background-color: #f0f0f0; min-width: 85px;\">编程开发页面</th>\n<th style=\"font-size: 16px; border: 1px solid #ccc; padding: 5px 10px; text-align: left; font-weight: bold; background-color: #f0f0f0; min-width: 85px;\">可视化搭建页面</th>\n</tr>\n</thead>\n<tbody style=\"border: 0;\">\n<tr style=\"border: 0; border-top: 1px solid #ccc; background-color: white;\">\n<td style=\"font-size: 16px; border: 1px solid #ccc; padding: 5px 10px; text-align: left; min-width: 85px;\">技能要求</td>\n<td style=\"font-size: 16px; border: 1px solid #ccc; padding: 5px 10px; text-align: left; min-width: 85px;\">需要编程基础</td>\n<td style=\"font-size: 16px; border: 1px solid #ccc; padding: 5px 10px; text-align: left; min-width: 85px;\">可以没有编程基础</td>\n</tr>\n<tr style=\"border: 0; border-top: 1px solid #ccc; background-color: #F8F8F8;\">\n<td style=\"font-size: 16px; border: 1px solid #ccc; padding: 5px 10px; text-align: left; min-width: 85px;\">操作方式</td>\n<td style=\"font-size: 16px; border: 1px solid #ccc; padding: 5px 10px; text-align: left; min-width: 85px;\">在代码编辑器中编写代码</td>\n<td style=\"font-size: 16px; border: 1px solid #ccc; padding: 5px 10px; text-align: left; min-width: 85px;\">在可视化搭建工具中拖拉/填表/编写代码</td>\n</tr>\n</tbody>\n</table>\n</section><h2 data-tool=\"mdnice编辑器\" style=\"margin-top: 30px; margin-bottom: 15px; bmin-height: 32px; line-height: 32px; border-bottom: solid 1px #000000; color: #35b378; display: inline-block; border-bottom-width: 0px; border-bottom-style: solid; border-color: #35b378; padding-top: 5px; padding-right: 0.5em; padding-left: 0.5em; font-size: 23px; margin: 1em 0 0rem 0; padding: 0.5em 0; text-align: leftt; font-weight: bold;\"><span class=\"prefix\" style=\"display: none;\"></span><span class=\"content\">2 业界调研（20+）</span><span class=\"suffix\"></span></h2>\n<section class=\"table-container\" data-tool=\"mdnice编辑器\" style=\"overflow-x: auto;\"><table style=\"display: table; text-align: left;\">\n<thead>\n<tr style=\"border: 0; border-top: 1px solid #ccc; background-color: white;\">\n<th style=\"font-size: 16px; border: 1px solid #ccc; padding: 5px 10px; text-align: left; font-weight: bold; background-color: #f0f0f0; min-width: 85px;\">项目名称</th>\n<th style=\"font-size: 16px; border: 1px solid #ccc; padding: 5px 10px; text-align: left; font-weight: bold; background-color: #f0f0f0; min-width: 85px;\">项目简介</th>\n<th style=\"font-size: 16px; border: 1px solid #ccc; padding: 5px 10px; text-align: left; font-weight: bold; background-color: #f0f0f0; min-width: 85px;\">能解决什么</th>\n</tr>\n</thead>\n<tbody style=\"border: 0;\">\n<tr style=\"border: 0; border-top: 1px solid #ccc; background-color: white;\">\n<td style=\"font-size: 16px; border: 1px solid #ccc; padding: 5px 10px; text-align: left; min-width: 85px;\"><a href=\"https://github.com/baidu/amis\" style=\"text-decoration: none; word-wrap: break-word; font-weight: bold; color: #35b378; border-bottom: 1px solid #35b378;\">百度amis</a>（开源）</td>\n<td style=\"font-size: 16px; border: 1px solid #ccc; padding: 5px 10px; text-align: left; min-width: 85px;\">前端低代码框架，通过 JSON 配置就能生成各种后台页面，极大减少开发成本，甚至可以不需要了解前端</td>\n<td style=\"font-size: 16px; border: 1px solid #ccc; padding: 5px 10px; text-align: left; min-width: 85px;\">不需要懂前端就能做出专业且复杂的后台界面，不受前端技术更新的影响，可以完全使用可视化页面编辑器来制作页面</td>\n</tr>\n<tr style=\"border: 0; border-top: 1px solid #ccc; background-color: #F8F8F8;\">\n<td style=\"font-size: 16px; border: 1px solid #ccc; padding: 5px 10px; text-align: left; min-width: 85px;\"><a href=\"https://juejin.im/post/5d8774bff265da03ae78b2a1\" style=\"text-decoration: none; word-wrap: break-word; font-weight: bold; color: #35b378; border-bottom: 1px solid #35b378;\">政采云-鲁班</a>（未开源）</td>\n<td style=\"font-size: 16px; border: 1px solid #ccc; padding: 5px 10px; text-align: left; min-width: 85px;\">鲁班是一个基于业务组件快速生成页面的搭建系统（站点、页面、组件、数据、权限） ，JSON Schema将业务转成数据→将数据转为定义→将定义规范成结构</td>\n<td style=\"font-size: 16px; border: 1px solid #ccc; padding: 5px 10px; text-align: left; min-width: 85px;\">提升用户体验：页面采用静态化方案，渲染及访问速度更快；提高稳定性：采用 Nginx 直接转发的方案，页面路由可用性保障及响应性能更具优势，同时支持更健壮的容灾方案，支持快速发版、回滚。；快速响应业务需求：通过组件化复用，能够快速响应业务需求、提高研发人效；更好的业务赋能：使得产品、运营等同学也能参与页面的搭建，提升业务迭代效率和数据可用性。；更好的系统化能力：基于搭建系统，便于横向和性能检测系统、稳定性保障系统、运维部署系统、线上监控系统进行打通，形成系统级合力、复利。</td>\n</tr>\n<tr style=\"border: 0; border-top: 1px solid #ccc; background-color: white;\">\n<td style=\"font-size: 16px; border: 1px solid #ccc; padding: 5px 10px; text-align: left; min-width: 85px;\"><a href=\"https://imgcook.taobao.org/\" style=\"text-decoration: none; word-wrap: break-word; font-weight: bold; color: #35b378; border-bottom: 1px solid #35b378;\">淘宝-imgcook</a>（未开源）</td>\n<td style=\"font-size: 16px; border: 1px solid #ccc; padding: 5px 10px; text-align: left; min-width: 85px;\">由设计稿一键智能生成代码Skecher、ps、图片、原型图通过算法UI智能识别表达式转成DSL，再解析DSL为前端页面</td>\n<td style=\"font-size: 16px; border: 1px solid #ccc; padding: 5px 10px; text-align: left; min-width: 85px;\">还原设计稿；Skecher、ps、图片、原型图直接生成代码；精准还原；所见所得生；成代码可维护强；机器智能识别理解；DSL / Plugin可自定义</td>\n</tr>\n<tr style=\"border: 0; border-top: 1px solid #ccc; background-color: #F8F8F8;\">\n<td style=\"font-size: 16px; border: 1px solid #ccc; padding: 5px 10px; text-align: left; min-width: 85px;\"><a href=\"http://note.youdao.com/s/EDn5RopC\" style=\"text-decoration: none; word-wrap: break-word; font-weight: bold; color: #35b378; border-bottom: 1px solid #35b378;\">阿里-iceluna、Paas  </a></td>\n<td style=\"font-size: 16px; border: 1px solid #ccc; padding: 5px 10px; text-align: left; min-width: 85px;\">配置生成搭建描述协议 - 标准规范 - Schema再生成页面及逻辑、低代码编辑器 - 开发生态</td>\n<td style=\"font-size: 16px; border: 1px solid #ccc; padding: 5px 10px; text-align: left; min-width: 85px;\">改变生产关系，提升生产力（赋能）- 中后台通用搭建产品--所有人；降低研发成本（提效）- 低代码开发平台--开发人员（工程创建、开发、调试、发布全链路）；孵化领域产品（搭建生态）- PaaS平台--开发人员（基础设施，基于标准搭建协议生产搭建物料，为各业务场景提供搭建服务的运行和开发环境）</td>\n</tr>\n<tr style=\"border: 0; border-top: 1px solid #ccc; background-color: white;\">\n<td style=\"font-size: 16px; border: 1px solid #ccc; padding: 5px 10px; text-align: left; min-width: 85px;\"><a href=\"https://www.yunfengdie.com/intro\" style=\"text-decoration: none; word-wrap: break-word; font-weight: bold; color: #35b378; border-bottom: 1px solid #35b378;\">阿里-云凤蝶</a>（未开源）/<a href=\"https://github.com/page-pipepline/pipeline-editor\" style=\"text-decoration: none; word-wrap: break-word; font-weight: bold; color: #35b378; border-bottom: 1px solid #35b378;\">pipeline</a> （类似开源）</td>\n<td style=\"font-size: 16px; border: 1px solid #ccc; padding: 5px 10px; text-align: left; min-width: 85px;\">像做PPT一样去做web前；页面&nbsp;Data&nbsp;编辑</td>\n<td style=\"font-size: 16px; border: 1px solid #ccc; padding: 5px 10px; text-align: left; min-width: 85px;\">支持页面 Data 编辑, 面向运营、产品人员, 编辑自由度为无嵌套的组件.；目前制作运营、活动页面功能上最好的工具.；提供页面搭建的模板, 并支持自定义模板.；配置表单基于 Schema 生成, 配置表单操作功能完善.</td>\n</tr>\n<tr style=\"border: 0; border-top: 1px solid #ccc; background-color: #F8F8F8;\">\n<td style=\"font-size: 16px; border: 1px solid #ccc; padding: 5px 10px; text-align: left; min-width: 85px;\"><a href=\"https://ice.work/docs/guide/about\" style=\"text-decoration: none; word-wrap: break-word; font-weight: bold; color: #35b378; border-bottom: 1px solid #35b378;\">阿里-飞冰</a>（未开源）/<a href=\"https://github.com/jaweii/Vue-Layout\" style=\"text-decoration: none; word-wrap: break-word; font-weight: bold; color: #35b378; border-bottom: 1px solid #35b378;\">vue-layout</a>（类似开源）</td>\n<td style=\"font-size: 16px; border: 1px solid #ccc; padding: 5px 10px; text-align: left; min-width: 85px;\">Component Tree&nbsp;编辑；针对中后台开发人员；针对组件化的页面, 主要实现 Component Tree 的可视化编辑. 其核心功能在于页面布局设计: 在 UI 组件列表中选择合适的组件, 通过拖拉的方式将组件嵌入到页面中, 生成带布局和样式的页面.</td>\n<td style=\"font-size: 16px; border: 1px solid #ccc; padding: 5px 10px; text-align: left; min-width: 85px;\">支持 Component Tree 编辑, 面向中后台开发人员, 编辑自由度为无嵌套的组件；使用\"物料-区块\", 非前端开发人员可以快速搭建出可用、符合规范的页面.；页面以源码方式输出.；前端服务化的一种方式.</td>\n</tr>\n<tr style=\"border: 0; border-top: 1px solid #ccc; background-color: white;\">\n<td style=\"font-size: 16px; border: 1px solid #ccc; padding: 5px 10px; text-align: left; min-width: 85px;\"><a href=\"https://zhuanlan.zhihu.com/p/137470317\" style=\"text-decoration: none; word-wrap: break-word; font-weight: bold; color: #35b378; border-bottom: 1px solid #35b378;\">淘宝-天马</a>（未开源）</td>\n<td style=\"font-size: 16px; border: 1px solid #ccc; padding: 5px 10px; text-align: left; min-width: 85px;\">跨端页面搭建</td>\n<td style=\"font-size: 16px; border: 1px solid #ccc; padding: 5px 10px; text-align: left; min-width: 85px;\">跨终端搭建页面；面向标准数据研发schema.json；对模块的props入参描述；数据标准化；数据驱动展示；编写模块代码（解耦、模块既代码）；打包每个模块单独打包；从页面视角seed动态加载；跨终端的缓存方案（phone tm tb缓存副本、对应访问、代码标识）；服务端渲染SSR</td>\n</tr>\n<tr style=\"border: 0; border-top: 1px solid #ccc; background-color: #F8F8F8;\">\n<td style=\"font-size: 16px; border: 1px solid #ccc; padding: 5px 10px; text-align: left; min-width: 85px;\">淘宝-方舟</td>\n<td style=\"font-size: 16px; border: 1px solid #ccc; padding: 5px 10px; text-align: left; min-width: 85px;\">设计实现toC营销搭建</td>\n<td style=\"font-size: 16px; border: 1px solid #ccc; padding: 5px 10px; text-align: left; min-width: 85px;\">终端秒开；采用前端优化手段实现终端秒开</td>\n</tr>\n<tr style=\"border: 0; border-top: 1px solid #ccc; background-color: white;\">\n<td style=\"font-size: 16px; border: 1px solid #ccc; padding: 5px 10px; text-align: left; min-width: 85px;\"><a href=\"https://chuangyi.taobao.com/pages/teemo?spm=a2esx.12365734.kbheader00.15.d7134f2aS4e0tW\" style=\"text-decoration: none; word-wrap: break-word; font-weight: bold; color: #35b378; border-bottom: 1px solid #35b378;\">阿里妈妈-淘积木</a>（未开源）</td>\n<td style=\"font-size: 16px; border: 1px solid #ccc; padding: 5px 10px; text-align: left; min-width: 85px;\">从基础组件搭建完整的营销页面的方案设计</td>\n<td style=\"font-size: 16px; border: 1px solid #ccc; padding: 5px 10px; text-align: left; min-width: 85px;\"></td>\n</tr>\n<tr style=\"border: 0; border-top: 1px solid #ccc; background-color: #F8F8F8;\">\n<td style=\"font-size: 16px; border: 1px solid #ccc; padding: 5px 10px; text-align: left; min-width: 85px;\"><a href=\"https://mp.weixin.qq.com/s/faL4y2N7lqMi4ldrMJBaPg\" style=\"text-decoration: none; word-wrap: break-word; font-weight: bold; color: #35b378; border-bottom: 1px solid #35b378;\">阿里@维奇</a></td>\n<td style=\"font-size: 16px; border: 1px solid #ccc; padding: 5px 10px; text-align: left; min-width: 85px;\">文档即代码;文档转换成部分代码</td>\n<td style=\"font-size: 16px; border: 1px solid #ccc; padding: 5px 10px; text-align: left; min-width: 85px;\"></td>\n</tr>\n<tr style=\"border: 0; border-top: 1px solid #ccc; background-color: white;\">\n<td style=\"font-size: 16px; border: 1px solid #ccc; padding: 5px 10px; text-align: left; min-width: 85px;\"><a href=\"https://github.com/alibaba/alist\" style=\"text-decoration: none; word-wrap: break-word; font-weight: bold; color: #35b378; border-bottom: 1px solid #35b378;\">阿里alist</a> /<a href=\"https://github.com/alibaba/formily\" style=\"text-decoration: none; word-wrap: break-word; font-weight: bold; color: #35b378; border-bottom: 1px solid #35b378;\">Formily</a>（开源）</td>\n<td style=\"font-size: 16px; border: 1px solid #ccc; padding: 5px 10px; text-align: left; min-width: 85px;\">Formily&nbsp;表单方案作为搜索区域的不二之选时，通过对这些方案的整合，可以快速实现标准化的列表场景。;同时AList支持&nbsp;JSON Schema&nbsp;协议渲染，可通过数据驱动快速开发。</td>\n<td style=\"font-size: 16px; border: 1px solid #ccc; padding: 5px 10px; text-align: left; min-width: 85px;\">内置Formily作为搜索区域方案，性能及功能强大;支持 Ant Design/Fusion Next 组件体系;支持JSON Schema 数据驱动方案;副作用逻辑独立管理，涵盖各种复杂联动校验逻辑;支持各种复杂布局方案</td>\n</tr>\n<tr style=\"border: 0; border-top: 1px solid #ccc; background-color: #F8F8F8;\">\n<td style=\"font-size: 16px; border: 1px solid #ccc; padding: 5px 10px; text-align: left; min-width: 85px;\"><a href style=\"text-decoration: none; word-wrap: break-word; font-weight: bold; color: #35b378; border-bottom: 1px solid #35b378;\">京东-MPM</a>（未开源）</td>\n<td style=\"font-size: 16px; border: 1px solid #ccc; padding: 5px 10px; text-align: left; min-width: 85px;\">采用ComData的数据配置方式解析成前端页面，是本系统的核心，7PageData 是⻚⾯的抽象描述层</td>\n<td style=\"font-size: 16px; border: 1px solid #ccc; padding: 5px 10px; text-align: left; min-width: 85px;\">搭建物料丰富:MPM 现有 30+ 个组件、500+ 个模板，业务能⼒覆盖商品、导购、营销等多个场景。配置功能强⼤:三端渲染是 MPM 的强⼤能⼒，除此之外，MPM 还⽀持⻚⾯配置 BI 排序、⾃动化埋点、⾃动化测试、⻚⾯测速等。系统能⼒全⾯:MPM 为⻚⾯保驾护航，不但配备了流畅的拖拽编辑器、实时预览和⻚⾯健康诊断能⼒，还对系统和⻚⾯做了全⽅⾯的监控和容灾降级⽅案。</td>\n</tr>\n<tr style=\"border: 0; border-top: 1px solid #ccc; background-color: white;\">\n<td style=\"font-size: 16px; border: 1px solid #ccc; padding: 5px 10px; text-align: left; min-width: 85px;\"><a href=\"https://cube.sankuai.com/#/admin/team/list/all\" style=\"text-decoration: none; word-wrap: break-word; font-weight: bold; color: #35b378; border-bottom: 1px solid #35b378;\">美团魔方</a>（未开源）</td>\n<td style=\"font-size: 16px; border: 1px solid #ccc; padding: 5px 10px; text-align: left; min-width: 85px;\">从基础组件搭建完整的营销页面的方案设计</td>\n<td style=\"font-size: 16px; border: 1px solid #ccc; padding: 5px 10px; text-align: left; min-width: 85px;\"></td>\n</tr>\n<tr style=\"border: 0; border-top: 1px solid #ccc; background-color: #F8F8F8;\">\n<td style=\"font-size: 16px; border: 1px solid #ccc; padding: 5px 10px; text-align: left; min-width: 85px;\"><a href=\"http://lego.waimai.sankuai.com/template\" style=\"text-decoration: none; word-wrap: break-word; font-weight: bold; color: #35b378; border-bottom: 1px solid #35b378;\">美团乐高</a>（未开源）</td>\n<td style=\"font-size: 16px; border: 1px solid #ccc; padding: 5px 10px; text-align: left; min-width: 85px;\">从基础组件搭建完整的营销页面的方案设计</td>\n<td style=\"font-size: 16px; border: 1px solid #ccc; padding: 5px 10px; text-align: left; min-width: 85px;\"></td>\n</tr>\n<tr style=\"border: 0; border-top: 1px solid #ccc; background-color: white;\">\n<td style=\"font-size: 16px; border: 1px solid #ccc; padding: 5px 10px; text-align: left; min-width: 85px;\"><a href=\"https://chuangyi.taobao.com/pages/teemo?spm=a2esx.12365734.kbheader00.15.d7134f2aS4e0tW\" style=\"text-decoration: none; word-wrap: break-word; font-weight: bold; color: #35b378; border-bottom: 1px solid #35b378;\">esview</a>(模仿乐高开源）</td>\n<td style=\"font-size: 16px; border: 1px solid #ccc; padding: 5px 10px; text-align: left; min-width: 85px;\">Drag vue dynamic components to build your page，generate vue code.</td>\n<td style=\"font-size: 16px; border: 1px solid #ccc; padding: 5px 10px; text-align: left; min-width: 85px;\">esview开源项目, 模仿美团点评的乐高.完整的可视化页面搭建框架, 面向中后台开发人员.页面布局结果看起来比较乱, 自定义组件写法比较诡异; 没有融合业务逻辑, 不支持在框架中写页面的代码逻辑.</td>\n</tr>\n<tr style=\"border: 0; border-top: 1px solid #ccc; background-color: #F8F8F8;\">\n<td style=\"font-size: 16px; border: 1px solid #ccc; padding: 5px 10px; text-align: left; min-width: 85px;\"><a href=\"https://github.com/JakHuang/form-generator\" style=\"text-decoration: none; word-wrap: break-word; font-weight: bold; color: #35b378; border-bottom: 1px solid #35b378;\">Element UI表单设计及代码生成器</a>（开源）</td>\n<td style=\"font-size: 16px; border: 1px solid #ccc; padding: 5px 10px; text-align: left; min-width: 85px;\">Element UI表单设计及代码生成器，可将生成的代码直接运行在基于Element的vue项目中；也可导出JSON表单，使用配套的解析器将JSON解析成真实的表单。</td>\n<td style=\"font-size: 16px; border: 1px solid #ccc; padding: 5px 10px; text-align: left; min-width: 85px;\"></td>\n</tr>\n<tr style=\"border: 0; border-top: 1px solid #ccc; background-color: white;\">\n<td style=\"font-size: 16px; border: 1px solid #ccc; padding: 5px 10px; text-align: left; min-width: 85px;\"><a href=\"https://github.com/jaweii/Vue-Layout\" style=\"text-decoration: none; word-wrap: break-word; font-weight: bold; color: #35b378; border-bottom: 1px solid #35b378;\">Vue-Layout</a>（开源）</td>\n<td style=\"font-size: 16px; border: 1px solid #ccc; padding: 5px 10px; text-align: left; min-width: 85px;\">从基础组件搭建完整的营销页面的方案设计 基于UI组件的Vue可视化布局、生成.vue代码的工具。https://github.com/JakHuang/form-generator</td>\n<td style=\"font-size: 16px; border: 1px solid #ccc; padding: 5px 10px; text-align: left; min-width: 85px;\">支持 Component Tree 编辑, 面向中后台开发人员, 编辑自由度为可嵌套的组件.页面的拖拉生成, 实现得很完整.用于页面设计, 所以偏向页面元素的样式控制.技术文章对可视化搭建工具数据流有深刻理解: 可视化在线编辑器架构设计.</td>\n</tr>\n<tr style=\"border: 0; border-top: 1px solid #ccc; background-color: #F8F8F8;\">\n<td style=\"font-size: 16px; border: 1px solid #ccc; padding: 5px 10px; text-align: left; min-width: 85px;\"><a href=\"https://github.com/ascoders/gaea-editor\" style=\"text-decoration: none; word-wrap: break-word; font-weight: bold; color: #35b378; border-bottom: 1px solid #35b378;\">gaea-editor</a>（开源）</td>\n<td style=\"font-size: 16px; border: 1px solid #ccc; padding: 5px 10px; text-align: left; min-width: 85px;\">开源项目.支持 Component Tree 编辑, 面向中后台开发人员, 编辑自由度为可嵌套的组件.页面的拖拉生成, 实现得很完整.用于页面设计, 所以偏向页面元素的样式控制.技术文章对可视化搭建工具数据流有深刻理解: 可视化在线编辑器架构设计.</td>\n<td style=\"font-size: 16px; border: 1px solid #ccc; padding: 5px 10px; text-align: left; min-width: 85px;\"></td>\n</tr>\n<tr style=\"border: 0; border-top: 1px solid #ccc; background-color: white;\">\n<td style=\"font-size: 16px; border: 1px solid #ccc; padding: 5px 10px; text-align: left; min-width: 85px;\"><a href=\"https://page-pipepline.github.io/pipeline-editor/dist/#/\" style=\"text-decoration: none; word-wrap: break-word; font-weight: bold; color: #35b378; border-bottom: 1px solid #35b378;\">pipeline</a>（开源）</td>\n<td style=\"font-size: 16px; border: 1px solid #ccc; padding: 5px 10px; text-align: left; min-width: 85px;\">运营/产品活动页面</td>\n<td style=\"font-size: 16px; border: 1px solid #ccc; padding: 5px 10px; text-align: left; min-width: 85px;\"></td>\n</tr>\n<tr style=\"border: 0; border-top: 1px solid #ccc; background-color: #F8F8F8;\">\n<td style=\"font-size: 16px; border: 1px solid #ccc; padding: 5px 10px; text-align: left; min-width: 85px;\"><a href=\"https://github.com/daycool/gen\" style=\"text-decoration: none; word-wrap: break-word; font-weight: bold; color: #35b378; border-bottom: 1px solid #35b378;\">gen</a>gen（开源）</td>\n<td style=\"font-size: 16px; border: 1px solid #ccc; padding: 5px 10px; text-align: left; min-width: 85px;\">根据接口生成页面，减少重复性工作</td>\n<td style=\"font-size: 16px; border: 1px solid #ccc; padding: 5px 10px; text-align: left; min-width: 85px;\"></td>\n</tr>\n<tr style=\"border: 0; border-top: 1px solid #ccc; background-color: white;\">\n<td style=\"font-size: 16px; border: 1px solid #ccc; padding: 5px 10px; text-align: left; min-width: 85px;\"><a href=\"https://www.ih5.cn/not-logged-in\" style=\"text-decoration: none; word-wrap: break-word; font-weight: bold; color: #35b378; border-bottom: 1px solid #35b378;\">H5.cn</a></td>\n<td style=\"font-size: 16px; border: 1px solid #ccc; padding: 5px 10px; text-align: left; min-width: 85px;\">https://www.ih5.cn/not-logged-in</td>\n<td style=\"font-size: 16px; border: 1px solid #ccc; padding: 5px 10px; text-align: left; min-width: 85px;\"></td>\n</tr>\n<tr style=\"border: 0; border-top: 1px solid #ccc; background-color: #F8F8F8;\">\n<td style=\"font-size: 16px; border: 1px solid #ccc; padding: 5px 10px; text-align: left; min-width: 85px;\"><a href=\"https://anye931123.gitee.io/react-visual-editor/\" style=\"text-decoration: none; word-wrap: break-word; font-weight: bold; color: #35b378; border-bottom: 1px solid #35b378;\">Brick Design</a>（开源）</td>\n<td style=\"font-size: 16px; border: 1px solid #ccc; padding: 5px 10px; text-align: left; min-width: 85px;\">拖拽区块内可直接编辑,生成前端页面并预览</td>\n<td style=\"font-size: 16px; border: 1px solid #ccc; padding: 5px 10px; text-align: left; min-width: 85px;\"></td>\n</tr>\n<tr style=\"border: 0; border-top: 1px solid #ccc; background-color: white;\">\n<td style=\"font-size: 16px; border: 1px solid #ccc; padding: 5px 10px; text-align: left; min-width: 85px;\"><a href=\"https://h5.baidu.com/\" style=\"text-decoration: none; word-wrap: break-word; font-weight: bold; color: #35b378; border-bottom: 1px solid #35b378;\">百度H5</a>（未开源）</td>\n<td style=\"font-size: 16px; border: 1px solid #ccc; padding: 5px 10px; text-align: left; min-width: 85px;\">https://h5.bce.baidu.com/docs/intro营销活动页面搭建</td>\n<td style=\"font-size: 16px; border: 1px solid #ccc; padding: 5px 10px; text-align: left; min-width: 85px;\"></td>\n</tr>\n<tr style=\"border: 0; border-top: 1px solid #ccc; background-color: #F8F8F8;\">\n<td style=\"font-size: 16px; border: 1px solid #ccc; padding: 5px 10px; text-align: left; min-width: 85px;\">其他（开源）</td>\n<td style=\"font-size: 16px; border: 1px solid #ccc; padding: 5px 10px; text-align: left; min-width: 85px;\">1.<a href=\"https://github.com/topics/website-builder\" style=\"text-decoration: none; word-wrap: break-word; font-weight: bold; color: #35b378; border-bottom: 1px solid #35b378;\">website-builder</a> 2.<a href=\"https://github.com/topics/site-builder\" style=\"text-decoration: none; word-wrap: break-word; font-weight: bold; color: #35b378; border-bottom: 1px solid #35b378;\">site-builder</a> 3.<a href=\"https://github.com/givanz/VvvebJs\" style=\"text-decoration: none; word-wrap: break-word; font-weight: bold; color: #35b378; border-bottom: 1px solid #35b378;\">VvvebJs</a> 4.<a href=\"https://github.com/artf/grapesjs\" style=\"text-decoration: none; word-wrap: break-word; font-weight: bold; color: #35b378; border-bottom: 1px solid #35b378;\">grapesjs</a> 5.<a href=\"http://maka.im/store\" style=\"text-decoration: none; word-wrap: break-word; font-weight: bold; color: #35b378; border-bottom: 1px solid #35b378;\">Maha</a> 6.<a href=\"https://www.youzan.com/\" style=\"text-decoration: none; word-wrap: break-word; font-weight: bold; color: #35b378; border-bottom: 1px solid #35b378;\">有赞微页面</a> 7.<a href=\"https://github.com/OXOYO/X-Page-Editor-Vue\" style=\"text-decoration: none; word-wrap: break-word; font-weight: bold; color: #35b378; border-bottom: 1px solid #35b378;\">X-Page-Editor-Vue</a></td>\n<td style=\"font-size: 16px; border: 1px solid #ccc; padding: 5px 10px; text-align: left; min-width: 85px;\"></td>\n</tr>\n</tbody>\n</table>\n</section><h2 data-tool=\"mdnice编辑器\" style=\"margin-top: 30px; margin-bottom: 15px; bmin-height: 32px; line-height: 32px; border-bottom: solid 1px #000000; color: #35b378; display: inline-block; border-bottom-width: 0px; border-bottom-style: solid; border-color: #35b378; padding-top: 5px; padding-right: 0.5em; padding-left: 0.5em; font-size: 23px; margin: 1em 0 0rem 0; padding: 0.5em 0; text-align: leftt; font-weight: bold;\"><span class=\"prefix\" style=\"display: none;\"></span><span class=\"content\">3 业界调研要点总结</span><span class=\"suffix\"></span></h2>\n<p data-tool=\"mdnice编辑器\" style=\"font-size: 16px; padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: black; margin: 1em 4px;\">基于对以上页面可视化搭建工具调研，业界有很多看法，拿出两个比较有代表性的文章供大家参考：</p>\n<ul data-tool=\"mdnice编辑器\" style=\"margin-top: 8px; margin-bottom: 8px; padding-left: 25px; color: black; list-style-type: disc;\">\n<li><section style=\"margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500; margin: 10px 0;\"><a href=\"https://www.zhihu.com/question/338929219\" style=\"text-decoration: none; word-wrap: break-word; font-weight: bold; color: #35b378; border-bottom: 1px solid #35b378;\">基于现代的前端框架，为什么没有成熟的支持控件拖拽布局，并可以自动生成前端代码的设计器出现？</a></section></li><li><section style=\"margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500; margin: 10px 0;\"><a href=\"https://www.cnblogs.com/sskyy/p/6496287.html\" style=\"text-decoration: none; word-wrap: break-word; font-weight: bold; color: #35b378; border-bottom: 1px solid #35b378;\">前端服务化——页面搭建工具的死与生</a></section></li></ul>\n<p data-tool=\"mdnice编辑器\" style=\"font-size: 16px; padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: black; margin: 1em 4px;\">以上调研了那么多业界比较牛的前端可视化的框架工程，大致思路是类似的，百家争鸣，尽管阿里的飞冰云凤蝶很完善了但还是存在以下两点问题：</p>\n<ul data-tool=\"mdnice编辑器\" style=\"margin-top: 8px; margin-bottom: 8px; padding-left: 25px; color: black; list-style-type: disc;\">\n<li><section style=\"margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500; margin: 10px 0;\">无法自动生成交互逻辑</section></li><li><section style=\"margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500; margin: 10px 0;\">只能在受限、具体的业务场景下发挥作用</section></li></ul>\n<p data-tool=\"mdnice编辑器\" style=\"font-size: 16px; padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: black; margin: 1em 4px;\">这两个问题存在就会导致我们生产设计出来的东西需要low code，如果是low code开发人员不愿意用，因为生成的代码不易维护且臃肿；如果给非开发人员用，他们又不会写代码，一点代码都不想写，所以他们也不愿意用；</p>\n<p data-tool=\"mdnice编辑器\" style=\"font-size: 16px; padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: black; margin: 1em 4px;\">而我们站在巨人的肩膀上，能否把上面两个问题解决呢？目前我没有什么好的办法，但是我们可以先去把他们实现思路研究明白，才有可能去处上面的最难以解决的问题。</p>\n<h3 data-tool=\"mdnice编辑器\" style=\"margin-top: 30px; margin-bottom: 15px; font-size: 20px; margin: 1.2em 0 1em; padding: 0; font-weight: bold; color: #35b378;\"><span class=\"prefix\" style=\"display: none;\"></span><span class=\"content\">3.1 业界的工具总结要点</span><span class=\"suffix\" style=\"display: none;\"></span></h3>\n<section class=\"table-container\" data-tool=\"mdnice编辑器\" style=\"overflow-x: auto;\"><table style=\"display: table; text-align: left;\">\n<thead>\n<tr style=\"border: 0; border-top: 1px solid #ccc; background-color: white;\">\n<th style=\"font-size: 16px; border: 1px solid #ccc; padding: 5px 10px; text-align: left; font-weight: bold; background-color: #f0f0f0; min-width: 85px;\">相通之处</th>\n<th style=\"font-size: 16px; border: 1px solid #ccc; padding: 5px 10px; text-align: left; font-weight: bold; background-color: #f0f0f0; min-width: 85px;\">不同之处</th>\n<th style=\"font-size: 16px; border: 1px solid #ccc; padding: 5px 10px; text-align: left; font-weight: bold; background-color: #f0f0f0; min-width: 85px;\">可借鉴之处</th>\n<th style=\"font-size: 16px; border: 1px solid #ccc; padding: 5px 10px; text-align: left; font-weight: bold; background-color: #f0f0f0; min-width: 85px;\">应该避免问题</th>\n<th style=\"font-size: 16px; border: 1px solid #ccc; padding: 5px 10px; text-align: left; font-weight: bold; background-color: #f0f0f0; min-width: 85px;\">开源代码可借鉴</th>\n</tr>\n</thead>\n<tbody style=\"border: 0;\">\n<tr style=\"border: 0; border-top: 1px solid #ccc; background-color: white;\">\n<td style=\"font-size: 16px; border: 1px solid #ccc; padding: 5px 10px; text-align: left; min-width: 85px;\">1、DSL方式解析拖拽或者配置好的伪代码生成所需前端页面，大部分使用的是JSON Schema形式；2、从配置要生成页面整个处理步骤类似</td>\n<td style=\"font-size: 16px; border: 1px solid #ccc; padding: 5px 10px; text-align: left; min-width: 85px;\">1、处理方法不同；2、定义的DSL字段不同；3、优化程度不同；4、针对的业务场景不同</td>\n<td style=\"font-size: 16px; border: 1px solid #ccc; padding: 5px 10px; text-align: left; min-width: 85px;\">1、从配置到生成DSL方式的伪代码再到如何解析最后生成前端页面的整体架构设计及思想可借鉴；2、如何定时DSL字段schema的模式，如何处理转移编译打包上线及优化</td>\n<td style=\"font-size: 16px; border: 1px solid #ccc; padding: 5px 10px; text-align: left; min-width: 85px;\">1、定位准用户群；2、后期维护问题</td>\n<td style=\"font-size: 16px; border: 1px solid #ccc; padding: 5px 10px; text-align: left; min-width: 85px;\">1、<a href=\"https://github.com/baidu/amis\" style=\"text-decoration: none; word-wrap: break-word; font-weight: bold; color: #35b378; border-bottom: 1px solid #35b378;\">百度amis</a>（开源可借鉴 react）2、<a href=\"https://github.com/jaweii/Vue-Layout\" style=\"text-decoration: none; word-wrap: break-word; font-weight: bold; color: #35b378; border-bottom: 1px solid #35b378;\">vue-layout</a>（类似飞冰开源 vue） 3、<a href=\"https://github.com/page-pipepline/pipeline-editor\" style=\"text-decoration: none; word-wrap: break-word; font-weight: bold; color: #35b378; border-bottom: 1px solid #35b378;\">pipeline</a> （类似飞冰开源 react）4、<a href=\"http://lego.waimai.sankuai.com/template\" style=\"text-decoration: none; word-wrap: break-word; font-weight: bold; color: #35b378; border-bottom: 1px solid #35b378;\">美团乐高</a>（可参考 vue）5、<a href=\"https://cube.sankuai.com/#/admin/team/list/all\" style=\"text-decoration: none; word-wrap: break-word; font-weight: bold; color: #35b378; border-bottom: 1px solid #35b378;\">美团魔方</a>（可参考react 6、<a href=\"https://github.com/furioussoul/esview\" style=\"text-decoration: none; word-wrap: break-word; font-weight: bold; color: #35b378; border-bottom: 1px solid #35b378;\">esview</a>(模仿乐高开源) 7、<a href=\"https://anye931123.gitee.io/react-visual-editor/\" style=\"text-decoration: none; word-wrap: break-word; font-weight: bold; color: #35b378; border-bottom: 1px solid #35b378;\">Brick Design</a>（开源可借鉴 react） 8、<a href=\"https://github.com/daycool/gen\" style=\"text-decoration: none; word-wrap: break-word; font-weight: bold; color: #35b378; border-bottom: 1px solid #35b378;\">gen</a>（开源）9、<a href=\"https://github.com/ascoders/gaea-editor\" style=\"text-decoration: none; word-wrap: break-word; font-weight: bold; color: #35b378; border-bottom: 1px solid #35b378;\">gaea-editor</a>（开源） 10、<a href=\"https://github.com/alibaba/alist\" style=\"text-decoration: none; word-wrap: break-word; font-weight: bold; color: #35b378; border-bottom: 1px solid #35b378;\">阿里alist</a>/<a href=\"https://github.com/alibaba/formily\" style=\"text-decoration: none; word-wrap: break-word; font-weight: bold; color: #35b378; border-bottom: 1px solid #35b378;\">Formily</a>（开源）11、<a href=\"https://github.com/ly525/luban-h5\" style=\"text-decoration: none; word-wrap: break-word; font-weight: bold; color: #35b378; border-bottom: 1px solid #35b378;\">鲁班H5</a>(开源)</td>\n</tr>\n</tbody>\n</table>\n</section><h3 data-tool=\"mdnice编辑器\" style=\"margin-top: 30px; margin-bottom: 15px; font-size: 20px; margin: 1.2em 0 1em; padding: 0; font-weight: bold; color: #35b378;\"><span class=\"prefix\" style=\"display: none;\"></span><span class=\"content\">3.2 DSL方式</span><span class=\"suffix\" style=\"display: none;\"></span></h3>\n<p data-tool=\"mdnice编辑器\" style=\"font-size: 16px; padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: black; margin: 1em 4px;\">JSON Schem数据结构特点：</p>\n<ul data-tool=\"mdnice编辑器\" style=\"margin-top: 8px; margin-bottom: 8px; padding-left: 25px; color: black; list-style-type: disc;\">\n<li><section style=\"margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500; margin: 10px 0;\">扁平化</section></li><li><section style=\"margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500; margin: 10px 0;\">树状化</section></li></ul>\n<p data-tool=\"mdnice编辑器\" style=\"font-size: 16px; padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: black; margin: 1em 4px;\">demo1：</p>\n<pre class=\"custom\" data-tool=\"mdnice编辑器\" style=\"margin-top: 10px; margin-bottom: 10px;\"><code class=\"hljs\" style=\"overflow-x: auto; padding: 16px; color: #333; background: #f8f8f8; display: -webkit-box; font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; border-radius: 0px; font-size: 12px; -webkit-overflow-scrolling: touch;\">{<br>&nbsp;&nbsp;<span class=\"hljs-string\" style=\"color: #d14; line-height: 26px;\">\"type\"</span>:&nbsp;<span class=\"hljs-string\" style=\"color: #d14; line-height: 26px;\">\"object\"</span>,<br>&nbsp;&nbsp;<span class=\"hljs-string\" style=\"color: #d14; line-height: 26px;\">\"properties\"</span>:&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;<span class=\"hljs-string\" style=\"color: #d14; line-height: 26px;\">\"<span class=\"hljs-variable\" style=\"color: #008080; line-height: 26px;\">$attr</span>\"</span>:&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class=\"hljs-string\" style=\"color: #d14; line-height: 26px;\">\"type\"</span>:&nbsp;<span class=\"hljs-string\" style=\"color: #d14; line-height: 26px;\">\"object\"</span>,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class=\"hljs-string\" style=\"color: #d14; line-height: 26px;\">\"properties\"</span>:&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class=\"hljs-string\" style=\"color: #d14; line-height: 26px;\">\"hidden\"</span>:&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class=\"hljs-string\" style=\"color: #d14; line-height: 26px;\">\"type\"</span>:&nbsp;<span class=\"hljs-string\" style=\"color: #d14; line-height: 26px;\">\"boolean\"</span><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;&nbsp;&nbsp;},<br>&nbsp;&nbsp;&nbsp;&nbsp;<span class=\"hljs-string\" style=\"color: #d14; line-height: 26px;\">\"<span class=\"hljs-variable\" style=\"color: #008080; line-height: 26px;\">$theme</span>\"</span>:&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class=\"hljs-string\" style=\"color: #d14; line-height: 26px;\">\"type\"</span>:&nbsp;<span class=\"hljs-string\" style=\"color: #d14; line-height: 26px;\">\"object\"</span>,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class=\"hljs-string\" style=\"color: #d14; line-height: 26px;\">\"properties\"</span>:&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class=\"hljs-string\" style=\"color: #d14; line-height: 26px;\">\"themeColor\"</span>:&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class=\"hljs-string\" style=\"color: #d14; line-height: 26px;\">\"type\"</span>:&nbsp;<span class=\"hljs-string\" style=\"color: #d14; line-height: 26px;\">\"string\"</span><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;&nbsp;&nbsp;},<br>&nbsp;&nbsp;&nbsp;&nbsp;<span class=\"hljs-string\" style=\"color: #d14; line-height: 26px;\">\"items\"</span>:&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class=\"hljs-string\" style=\"color: #d14; line-height: 26px;\">\"type\"</span>:&nbsp;<span class=\"hljs-string\" style=\"color: #d14; line-height: 26px;\">\"array\"</span>,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class=\"hljs-string\" style=\"color: #d14; line-height: 26px;\">\"items\"</span>:&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class=\"hljs-string\" style=\"color: #d14; line-height: 26px;\">\"type\"</span>:&nbsp;<span class=\"hljs-string\" style=\"color: #d14; line-height: 26px;\">\"object\"</span>,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class=\"hljs-string\" style=\"color: #d14; line-height: 26px;\">\"properties\"</span>:&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;“itemId”:&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class=\"hljs-string\" style=\"color: #d14; line-height: 26px;\">\"type\"</span>:&nbsp;<span class=\"hljs-string\" style=\"color: #d14; line-height: 26px;\">\"string\"</span><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;}<br>}<br></code></pre>\n<p data-tool=\"mdnice编辑器\" style=\"font-size: 16px; padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: black; margin: 1em 4px;\">demo2：</p>\n<pre class=\"custom\" data-tool=\"mdnice编辑器\" style=\"margin-top: 10px; margin-bottom: 10px;\"><code class=\"hljs\" style=\"overflow-x: auto; padding: 16px; color: #333; background: #f8f8f8; display: -webkit-box; font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; border-radius: 0px; font-size: 12px; -webkit-overflow-scrolling: touch;\">{<br>&nbsp;&nbsp;&nbsp;&nbsp;<span class=\"hljs-string\" style=\"color: #d14; line-height: 26px;\">\"type\"</span>:&nbsp;<span class=\"hljs-string\" style=\"color: #d14; line-height: 26px;\">\"page\"</span>,<br>&nbsp;&nbsp;&nbsp;&nbsp;<span class=\"hljs-string\" style=\"color: #d14; line-height: 26px;\">\"body\"</span>:&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class=\"hljs-string\" style=\"color: #d14; line-height: 26px;\">\"title\"</span>:&nbsp;<span class=\"hljs-string\" style=\"color: #d14; line-height: 26px;\">\"\"</span>,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class=\"hljs-string\" style=\"color: #d14; line-height: 26px;\">\"type\"</span>:&nbsp;<span class=\"hljs-string\" style=\"color: #d14; line-height: 26px;\">\"form\"</span>,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class=\"hljs-string\" style=\"color: #d14; line-height: 26px;\">\"autoFocus\"</span>:&nbsp;<span class=\"hljs-literal\" style=\"color: #008080; line-height: 26px;\">false</span>,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class=\"hljs-string\" style=\"color: #d14; line-height: 26px;\">\"api\"</span>:&nbsp;<span class=\"hljs-string\" style=\"color: #d14; line-height: 26px;\">\"https://houtai.baidu.com/api/mock2/saveForm?waitSeconds=1\"</span>,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class=\"hljs-string\" style=\"color: #d14; line-height: 26px;\">\"mode\"</span>:&nbsp;<span class=\"hljs-string\" style=\"color: #d14; line-height: 26px;\">\"horizontal\"</span>,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class=\"hljs-string\" style=\"color: #d14; line-height: 26px;\">\"controls\"</span>:&nbsp;[<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class=\"hljs-string\" style=\"color: #d14; line-height: 26px;\">\"type\"</span>:&nbsp;<span class=\"hljs-string\" style=\"color: #d14; line-height: 26px;\">\"fieldSet\"</span>,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class=\"hljs-string\" style=\"color: #d14; line-height: 26px;\">\"title\"</span>:&nbsp;<span class=\"hljs-string\" style=\"color: #d14; line-height: 26px;\">\"基本配置\"</span>,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class=\"hljs-string\" style=\"color: #d14; line-height: 26px;\">\"controls\"</span>:&nbsp;[<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class=\"hljs-string\" style=\"color: #d14; line-height: 26px;\">\"name\"</span>:&nbsp;<span class=\"hljs-string\" style=\"color: #d14; line-height: 26px;\">\"a\"</span>,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class=\"hljs-string\" style=\"color: #d14; line-height: 26px;\">\"type\"</span>:&nbsp;<span class=\"hljs-string\" style=\"color: #d14; line-height: 26px;\">\"text\"</span>,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class=\"hljs-string\" style=\"color: #d14; line-height: 26px;\">\"label\"</span>:&nbsp;<span class=\"hljs-string\" style=\"color: #d14; line-height: 26px;\">\"文本1\"</span><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;},<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class=\"hljs-string\" style=\"color: #d14; line-height: 26px;\">\"name\"</span>:&nbsp;<span class=\"hljs-string\" style=\"color: #d14; line-height: 26px;\">\"a\"</span>,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class=\"hljs-string\" style=\"color: #d14; line-height: 26px;\">\"type\"</span>:&nbsp;<span class=\"hljs-string\" style=\"color: #d14; line-height: 26px;\">\"text\"</span>,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class=\"hljs-string\" style=\"color: #d14; line-height: 26px;\">\"label\"</span>:&nbsp;<span class=\"hljs-string\" style=\"color: #d14; line-height: 26px;\">\"文本2\"</span><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;]<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;},<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class=\"hljs-string\" style=\"color: #d14; line-height: 26px;\">\"type\"</span>:&nbsp;<span class=\"hljs-string\" style=\"color: #d14; line-height: 26px;\">\"fieldSet\"</span>,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class=\"hljs-string\" style=\"color: #d14; line-height: 26px;\">\"title\"</span>:&nbsp;<span class=\"hljs-string\" style=\"color: #d14; line-height: 26px;\">\"其他配置\"</span>,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class=\"hljs-string\" style=\"color: #d14; line-height: 26px;\">\"collapsable\"</span>:&nbsp;<span class=\"hljs-literal\" style=\"color: #008080; line-height: 26px;\">true</span>,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class=\"hljs-string\" style=\"color: #d14; line-height: 26px;\">\"collapsed\"</span>:&nbsp;<span class=\"hljs-literal\" style=\"color: #008080; line-height: 26px;\">true</span>,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class=\"hljs-string\" style=\"color: #d14; line-height: 26px;\">\"controls\"</span>:&nbsp;[<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class=\"hljs-string\" style=\"color: #d14; line-height: 26px;\">\"name\"</span>:&nbsp;<span class=\"hljs-string\" style=\"color: #d14; line-height: 26px;\">\"c\"</span>,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class=\"hljs-string\" style=\"color: #d14; line-height: 26px;\">\"type\"</span>:&nbsp;<span class=\"hljs-string\" style=\"color: #d14; line-height: 26px;\">\"text\"</span>,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class=\"hljs-string\" style=\"color: #d14; line-height: 26px;\">\"label\"</span>:&nbsp;<span class=\"hljs-string\" style=\"color: #d14; line-height: 26px;\">\"文本3\"</span><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;},<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class=\"hljs-string\" style=\"color: #d14; line-height: 26px;\">\"name\"</span>:&nbsp;<span class=\"hljs-string\" style=\"color: #d14; line-height: 26px;\">\"d\"</span>,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class=\"hljs-string\" style=\"color: #d14; line-height: 26px;\">\"type\"</span>:&nbsp;<span class=\"hljs-string\" style=\"color: #d14; line-height: 26px;\">\"text\"</span>,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class=\"hljs-string\" style=\"color: #d14; line-height: 26px;\">\"label\"</span>:&nbsp;<span class=\"hljs-string\" style=\"color: #d14; line-height: 26px;\">\"文本4\"</span><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;]<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;],<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class=\"hljs-string\" style=\"color: #d14; line-height: 26px;\">\"submitText\"</span>:&nbsp;null,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class=\"hljs-string\" style=\"color: #d14; line-height: 26px;\">\"actions\"</span>:&nbsp;[]<br>&nbsp;&nbsp;&nbsp;&nbsp;}<br>}<br></code></pre>\n<hr data-tool=\"mdnice编辑器\" style=\"height: 1px; margin-top: 10px; margin-bottom: 10px; border-top: 1px solid black; border: 1px solid #35b378; margin: 1.5em auto;\">\n<h2 data-tool=\"mdnice编辑器\" style=\"margin-top: 30px; margin-bottom: 15px; bmin-height: 32px; line-height: 32px; border-bottom: solid 1px #000000; color: #35b378; display: inline-block; border-bottom-width: 0px; border-bottom-style: solid; border-color: #35b378; padding-top: 5px; padding-right: 0.5em; padding-left: 0.5em; font-size: 23px; margin: 1em 0 0rem 0; padding: 0.5em 0; text-align: leftt; font-weight: bold;\"><span class=\"prefix\" style=\"display: none;\"></span><span class=\"content\">4. 说明</span><span class=\"suffix\"></span></h2>\n<blockquote data-tool=\"mdnice编辑器\" style=\"display: block; font-size: 0.9em; overflow: auto; overflow-scrolling: touch; padding-top: 10px; padding-bottom: 10px; padding-left: 20px; padding-right: 10px; margin-bottom: 20px; margin-top: 20px; margin: 10px 5px; border-left: 3px solid #35b378; border-right: 0px solid #35b378; color: #616161; quotes: none; background: #FBF9FD;\">\n<p style=\"font-size: 16px; padding-top: 8px; padding-bottom: 8px; margin: 0px; color: black; line-height: 26px;\">说明：业界调研中每个项目点击标题都可查看项目详情，markDown文档插入图片太麻烦了，于是小圆脸儿同学放弃了图片介绍，有需要了解的同学我后面再来补（copy过来）各个我知道的设计架构及详设的图，哈哈哈。</p>\n</blockquote>\n<p data-tool=\"mdnice编辑器\" style=\"font-size: 16px; padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: black; margin: 1em 4px;\">更多前端文档请参考 <span class=\"footnote-word\" style=\"font-weight: bold; color: #35b378;\">小圆脸儿</span><sup class=\"footnote-ref\" style=\"line-height: 0; font-weight: bold; color: #35b378;\">[1]</sup></p>\n<h3 class=\"footnotes-sep\" data-tool=\"mdnice编辑器\" style=\"margin-top: 30px; margin-bottom: 15px; font-size: 20px; margin: 1.2em 0 1em; padding: 0; font-weight: bold; color: #35b378;\"><span style=\"display: block;\">参考资料</span></h3>\n<section class=\"footnotes\" data-tool=\"mdnice编辑器\">\n<span id=\"fn1\" class=\"footnote-item\" style=\"display: flex;\"><span class=\"footnote-num\" style=\"display: inline; width: 10%; background: none; font-size: 80%; opacity: 0.6; line-height: 26px; font-family: ptima-Regular, Optima, PingFangSC-light, PingFangTC-light, 'PingFang SC', Cambria, Cochin, Georgia, Times, 'Times New Roman', serif;\">[1] </span><p style=\"padding-top: 8px; padding-bottom: 8px; display: inline; font-size: 14px; width: 90%; padding: 0px; margin: 0; line-height: 26px; color: black; word-break: break-all; width: calc(100%-50);\">更多文档: <em style=\"font-style: italic; color: black;\">https://juejin.im/user/1398234520230989/posts</em></p>\n</span>\n</section>\n</section>", "user_name": "小圆脸儿", "description": "程序媛", "got_view_count": 5087, "category_name": "前端", "ctime": 1457483942}
{"tag_name": "Redis", "concern_user_count": 125718, "user_id": "3051900007890648", "title": "「最强」Lettuce 已支持 Redis6 客户端缓存", "mark_content": "<section id=\"nice\" data-tool=\"mdnice编辑器\" data-website=\"https://www.mdnice.com\" style=\"font-size: 16px; padding: 0 10px; word-spacing: 0px; word-break: break-word; word-wrap: break-word; text-align: left; line-height: 1.25; color: #2b2b2b; font-family: Optima-Regular, Optima, PingFangTC-Light, PingFangSC-light, PingFangTC-light; letter-spacing: 2px; background-image: linear-gradient(90deg, rgba(50, 0, 0, 0.04) 3%, rgba(0, 0, 0, 0) 3%), linear-gradient(360deg, rgba(50, 0, 0, 0.04) 3%, rgba(0, 0, 0, 0) 3%); background-size: 20px 20px; background-position: center center;\"><h2 data-tool=\"mdnice编辑器\" style=\"margin-top: 30px; margin-bottom: 15px; padding: 0px; font-weight: bold; color: black; font-size: 22px; display: block; border-bottom: 4px solid #40B8FA;\"><span class=\"prefix\" style=\"display: flex; width: 20px; height: 20px; background-size: 20px 20px; background-image: url(https://my-wechat.mdnice.com/fullstack-1.png); margin-bottom: -22px;\"></span><span class=\"content\" style=\"display: flex; color: #40B8FA; font-size: 20px; margin-left: 25px;\">Redis 客户端缓存</span><span class=\"suffix\" style=\"display: flex; box-sizing: border-box; width: 200px; height: 10px; border-top-left-radius: 20px; background: RGBA(64, 184, 250, .5); color: rgb(255, 255, 255); font-size: 16px; letter-spacing: 0.544px; justify-content: flex-end; float: right; margin-top: -10px; box-sizing: border-box !important; overflow-wrap: break-word !important;\"></span></h2>\n<p data-tool=\"mdnice编辑器\" style=\"padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: #2b2b2b; margin: 10px 0px; letter-spacing: 2px; font-size: 14px; word-spacing: 2px;\">缓存的解决方案一般有两种：</p>\n<p data-tool=\"mdnice编辑器\" style=\"padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: #2b2b2b; margin: 10px 0px; letter-spacing: 2px; font-size: 14px; word-spacing: 2px;\">【L1】 内存缓存（如 Caffeine、Ehcache） —— 速度快，进程内可用，但重启缓存丢失，出现缓存雪崩的问题。</p>\n<p data-tool=\"mdnice编辑器\" style=\"padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: #2b2b2b; margin: 10px 0px; letter-spacing: 2px; font-size: 14px; word-spacing: 2px;\">【L2】集中式缓存（如 Redis）—— 可同时为多节点提供服务，但高并发下，带宽成为瓶颈。</p>\n<p data-tool=\"mdnice编辑器\" style=\"padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: #2b2b2b; margin: 10px 0px; letter-spacing: 2px; font-size: 14px; word-spacing: 2px;\">业内有很多开源框架来解决以上问题，既能有 L1 速度，并且拥有 L2 集群态。如下</p>\n<p data-tool=\"mdnice编辑器\" style=\"padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: #2b2b2b; margin: 10px 0px; letter-spacing: 2px; font-size: 14px; word-spacing: 2px;\"><a href=\"https://gitee.com/ld/J2Cache\" style=\"text-decoration: none; word-wrap: break-word; color: #40B8FA; font-weight: normal; border-bottom: 1px solid #3BAAFA;\">J2Cache 两级缓存框架</a></p>\n<p data-tool=\"mdnice编辑器\" style=\"padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: #2b2b2b; margin: 10px 0px; letter-spacing: 2px; font-size: 14px; word-spacing: 2px;\"><a href=\"https://gitee.com/jd-platform-opensource/hotkey\" style=\"text-decoration: none; word-wrap: break-word; color: #40B8FA; font-weight: normal; border-bottom: 1px solid #3BAAFA;\">hotkey 热点数据实时同步</a></p>\n<p data-tool=\"mdnice编辑器\" style=\"padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: #2b2b2b; margin: 10px 0px; letter-spacing: 2px; font-size: 14px; word-spacing: 2px;\">在 <strong style=\"color: #3594F7; font-weight: bold;\"><span>「</span>redis 6.0<span>」</span></strong> 版本中，已经默认支持了客户端缓存功能，Java 中主流的连接客户端 <strong style=\"color: #3594F7; font-weight: bold;\"><span>「</span>lettuce<span>」</span></strong> 在最新的快照版本 (6.0.0.BUILD-SNAPSHOT) 已经提供支持。 下边就通过代码来体验一下客户端缓存的神奇功能。</p>\n<h2 data-tool=\"mdnice编辑器\" style=\"margin-top: 30px; margin-bottom: 15px; padding: 0px; font-weight: bold; color: black; font-size: 22px; display: block; border-bottom: 4px solid #40B8FA;\"><span class=\"prefix\" style=\"display: flex; width: 20px; height: 20px; background-size: 20px 20px; background-image: url(https://my-wechat.mdnice.com/fullstack-1.png); margin-bottom: -22px;\"></span><span class=\"content\" style=\"display: flex; color: #40B8FA; font-size: 20px; margin-left: 25px;\">Redis 6.0 安装</span><span class=\"suffix\" style=\"display: flex; box-sizing: border-box; width: 200px; height: 10px; border-top-left-radius: 20px; background: RGBA(64, 184, 250, .5); color: rgb(255, 255, 255); font-size: 16px; letter-spacing: 0.544px; justify-content: flex-end; float: right; margin-top: -10px; box-sizing: border-box !important; overflow-wrap: break-word !important;\"></span></h2>\n<p data-tool=\"mdnice编辑器\" style=\"padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: #2b2b2b; margin: 10px 0px; letter-spacing: 2px; font-size: 14px; word-spacing: 2px;\">安装 <code style=\"font-size: 14px; word-wrap: break-word; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #3594F7; background: RGBA(59, 170, 250, .1); padding: 0 2px; border-radius: 2px; height: 21px; line-height: 22px;\">redis 6</code>,这里通过 Docker 安装命令如下</p>\n<pre class=\"custom\" data-tool=\"mdnice编辑器\" style=\"margin-top: 10px; margin-bottom: 10px;\"><code class=\"hljs\" style=\"overflow-x: auto; padding: 16px; color: #333; background: #f8f8f8; display: -webkit-box; font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; border-radius: 0px; font-size: 12px; -webkit-overflow-scrolling: touch; letter-spacing: 0px;\">docker&nbsp;run&nbsp;--name&nbsp;redis6&nbsp;-p&nbsp;6379:6379&nbsp;--restart=always&nbsp;-d&nbsp;redis:6.0.6<br></code></pre>\n<h2 data-tool=\"mdnice编辑器\" style=\"margin-top: 30px; margin-bottom: 15px; padding: 0px; font-weight: bold; color: black; font-size: 22px; display: block; border-bottom: 4px solid #40B8FA;\"><span class=\"prefix\" style=\"display: flex; width: 20px; height: 20px; background-size: 20px 20px; background-image: url(https://my-wechat.mdnice.com/fullstack-1.png); margin-bottom: -22px;\"></span><span class=\"content\" style=\"display: flex; color: #40B8FA; font-size: 20px; margin-left: 25px;\">Jar 依赖</span><span class=\"suffix\" style=\"display: flex; box-sizing: border-box; width: 200px; height: 10px; border-top-left-radius: 20px; background: RGBA(64, 184, 250, .5); color: rgb(255, 255, 255); font-size: 16px; letter-spacing: 0.544px; justify-content: flex-end; float: right; margin-top: -10px; box-sizing: border-box !important; overflow-wrap: break-word !important;\"></span></h2>\n<p data-tool=\"mdnice编辑器\" style=\"padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: #2b2b2b; margin: 10px 0px; letter-spacing: 2px; font-size: 14px; word-spacing: 2px;\">注意： 这里使用 lettuce 客户端，注意当前使用 6.0 的快照版本 ，需要在 pom 增加 lettuce 快照仓库</p>\n<ul data-tool=\"mdnice编辑器\" style=\"margin-top: 8px; margin-bottom: 8px; padding-left: 25px; font-size: 15px; color: #595959; list-style-type: circle;\">\n<li><section style=\"margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; font-size: 14px; font-weight: normal; color: #595959;\">1.lettuce 6.0 快照依赖</section></li></ul>\n<pre class=\"custom\" data-tool=\"mdnice编辑器\" style=\"margin-top: 10px; margin-bottom: 10px;\"><code class=\"hljs\" style=\"overflow-x: auto; padding: 16px; color: #333; background: #f8f8f8; display: -webkit-box; font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; border-radius: 0px; font-size: 12px; -webkit-overflow-scrolling: touch; letter-spacing: 0px;\"><span class=\"hljs-tag\" style=\"color: #000080; font-weight: normal; line-height: 26px;\">&lt;<span class=\"hljs-name\" style=\"color: #000080; font-weight: normal; line-height: 26px;\">dependency</span>&gt;</span><br>&nbsp;&nbsp;&nbsp;&nbsp;<span class=\"hljs-tag\" style=\"color: #000080; font-weight: normal; line-height: 26px;\">&lt;<span class=\"hljs-name\" style=\"color: #000080; font-weight: normal; line-height: 26px;\">groupId</span>&gt;</span>io.lettuce<span class=\"hljs-tag\" style=\"color: #000080; font-weight: normal; line-height: 26px;\">&lt;/<span class=\"hljs-name\" style=\"color: #000080; font-weight: normal; line-height: 26px;\">groupId</span>&gt;</span><br>&nbsp;&nbsp;&nbsp;&nbsp;<span class=\"hljs-tag\" style=\"color: #000080; font-weight: normal; line-height: 26px;\">&lt;<span class=\"hljs-name\" style=\"color: #000080; font-weight: normal; line-height: 26px;\">artifactId</span>&gt;</span>lettuce-core<span class=\"hljs-tag\" style=\"color: #000080; font-weight: normal; line-height: 26px;\">&lt;/<span class=\"hljs-name\" style=\"color: #000080; font-weight: normal; line-height: 26px;\">artifactId</span>&gt;</span><br>&nbsp;&nbsp;&nbsp;&nbsp;<span class=\"hljs-tag\" style=\"color: #000080; font-weight: normal; line-height: 26px;\">&lt;<span class=\"hljs-name\" style=\"color: #000080; font-weight: normal; line-height: 26px;\">version</span>&gt;</span>6.0.0.BUILD-SNAPSHOT<span class=\"hljs-tag\" style=\"color: #000080; font-weight: normal; line-height: 26px;\">&lt;/<span class=\"hljs-name\" style=\"color: #000080; font-weight: normal; line-height: 26px;\">version</span>&gt;</span><br><span class=\"hljs-tag\" style=\"color: #000080; font-weight: normal; line-height: 26px;\">&lt;/<span class=\"hljs-name\" style=\"color: #000080; font-weight: normal; line-height: 26px;\">dependency</span>&gt;</span><br></code></pre>\n<ul data-tool=\"mdnice编辑器\" style=\"margin-top: 8px; margin-bottom: 8px; padding-left: 25px; font-size: 15px; color: #595959; list-style-type: circle;\">\n<li><section style=\"margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; font-size: 14px; font-weight: normal; color: #595959;\"><ol start=\"2\" style=\"margin-top: 8px; margin-bottom: 8px; padding-left: 25px; list-style-type: decimal; font-size: 15px; color: #595959;\">\n<li><section style=\"margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; font-size: 14px; font-weight: normal; color: #595959;\">配置快照仓库</section></li></ol>\n</section></li></ul>\n<pre class=\"custom\" data-tool=\"mdnice编辑器\" style=\"margin-top: 10px; margin-bottom: 10px;\"><code class=\"hljs\" style=\"overflow-x: auto; padding: 16px; color: #333; background: #f8f8f8; display: -webkit-box; font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; border-radius: 0px; font-size: 12px; -webkit-overflow-scrolling: touch; letter-spacing: 0px;\"><span class=\"hljs-tag\" style=\"color: #000080; font-weight: normal; line-height: 26px;\">&lt;<span class=\"hljs-name\" style=\"color: #000080; font-weight: normal; line-height: 26px;\">repositories</span>&gt;</span><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class=\"hljs-tag\" style=\"color: #000080; font-weight: normal; line-height: 26px;\">&lt;<span class=\"hljs-name\" style=\"color: #000080; font-weight: normal; line-height: 26px;\">repository</span>&gt;</span><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class=\"hljs-tag\" style=\"color: #000080; font-weight: normal; line-height: 26px;\">&lt;<span class=\"hljs-name\" style=\"color: #000080; font-weight: normal; line-height: 26px;\">id</span>&gt;</span>sonatype-snapshots<span class=\"hljs-tag\" style=\"color: #000080; font-weight: normal; line-height: 26px;\">&lt;/<span class=\"hljs-name\" style=\"color: #000080; font-weight: normal; line-height: 26px;\">id</span>&gt;</span><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class=\"hljs-tag\" style=\"color: #000080; font-weight: normal; line-height: 26px;\">&lt;<span class=\"hljs-name\" style=\"color: #000080; font-weight: normal; line-height: 26px;\">name</span>&gt;</span>Sonatype&nbsp;Snapshot&nbsp;Repository<span class=\"hljs-tag\" style=\"color: #000080; font-weight: normal; line-height: 26px;\">&lt;/<span class=\"hljs-name\" style=\"color: #000080; font-weight: normal; line-height: 26px;\">name</span>&gt;</span><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class=\"hljs-tag\" style=\"color: #000080; font-weight: normal; line-height: 26px;\">&lt;<span class=\"hljs-name\" style=\"color: #000080; font-weight: normal; line-height: 26px;\">url</span>&gt;</span>https://oss.sonatype.org/content/repositories/snapshots/<span class=\"hljs-tag\" style=\"color: #000080; font-weight: normal; line-height: 26px;\">&lt;/<span class=\"hljs-name\" style=\"color: #000080; font-weight: normal; line-height: 26px;\">url</span>&gt;</span><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class=\"hljs-tag\" style=\"color: #000080; font-weight: normal; line-height: 26px;\">&lt;<span class=\"hljs-name\" style=\"color: #000080; font-weight: normal; line-height: 26px;\">snapshots</span>&gt;</span><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class=\"hljs-tag\" style=\"color: #000080; font-weight: normal; line-height: 26px;\">&lt;<span class=\"hljs-name\" style=\"color: #000080; font-weight: normal; line-height: 26px;\">enabled</span>&gt;</span>true<span class=\"hljs-tag\" style=\"color: #000080; font-weight: normal; line-height: 26px;\">&lt;/<span class=\"hljs-name\" style=\"color: #000080; font-weight: normal; line-height: 26px;\">enabled</span>&gt;</span><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class=\"hljs-tag\" style=\"color: #000080; font-weight: normal; line-height: 26px;\">&lt;/<span class=\"hljs-name\" style=\"color: #000080; font-weight: normal; line-height: 26px;\">snapshots</span>&gt;</span><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class=\"hljs-tag\" style=\"color: #000080; font-weight: normal; line-height: 26px;\">&lt;/<span class=\"hljs-name\" style=\"color: #000080; font-weight: normal; line-height: 26px;\">repository</span>&gt;</span><br>&nbsp;&nbsp;&nbsp;&nbsp;<span class=\"hljs-tag\" style=\"color: #000080; font-weight: normal; line-height: 26px;\">&lt;/<span class=\"hljs-name\" style=\"color: #000080; font-weight: normal; line-height: 26px;\">repositories</span>&gt;</span><br></code></pre>\n<h2 data-tool=\"mdnice编辑器\" style=\"margin-top: 30px; margin-bottom: 15px; padding: 0px; font-weight: bold; color: black; font-size: 22px; display: block; border-bottom: 4px solid #40B8FA;\"><span class=\"prefix\" style=\"display: flex; width: 20px; height: 20px; background-size: 20px 20px; background-image: url(https://my-wechat.mdnice.com/fullstack-1.png); margin-bottom: -22px;\"></span><span class=\"content\" style=\"display: flex; color: #40B8FA; font-size: 20px; margin-left: 25px;\">代码操作</span><span class=\"suffix\" style=\"display: flex; box-sizing: border-box; width: 200px; height: 10px; border-top-left-radius: 20px; background: RGBA(64, 184, 250, .5); color: rgb(255, 255, 255); font-size: 16px; letter-spacing: 0.544px; justify-content: flex-end; float: right; margin-top: -10px; box-sizing: border-box !important; overflow-wrap: break-word !important;\"></span></h2>\n<ul data-tool=\"mdnice编辑器\" style=\"margin-top: 8px; margin-bottom: 8px; padding-left: 25px; font-size: 15px; color: #595959; list-style-type: circle;\">\n<li><section style=\"margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; font-size: 14px; font-weight: normal; color: #595959;\">使用 lettuce 连接 redis ，并循环查看 k1 的值</section></li></ul>\n<pre class=\"custom\" data-tool=\"mdnice编辑器\" style=\"margin-top: 10px; margin-bottom: 10px;\"><code class=\"hljs\" style=\"overflow-x: auto; padding: 16px; color: #333; background: #f8f8f8; display: -webkit-box; font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; border-radius: 0px; font-size: 12px; -webkit-overflow-scrolling: touch; letter-spacing: 0px;\"><span class=\"hljs-comment\" style=\"color: #998; font-style: italic; line-height: 26px;\">//&nbsp;&lt;1&gt;&nbsp;创建单机连接的连接信息</span><br>RedisURI&nbsp;redisUri&nbsp;=&nbsp;RedisURI.builder()&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class=\"hljs-comment\" style=\"color: #998; font-style: italic; line-height: 26px;\">//</span><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;.withHost(<span class=\"hljs-string\" style=\"color: #d14; line-height: 26px;\">\"127.0.0.1\"</span>)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;.withPort(<span class=\"hljs-number\" style=\"color: #008080; line-height: 26px;\">6379</span>)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;.build();<br>RedisClient&nbsp;redisClient&nbsp;=&nbsp;RedisClient.create(redisUri);<br>StatefulRedisConnection&lt;String,&nbsp;String&gt;&nbsp;otherParty&nbsp;=&nbsp;redisClient.connect();<br>RedisCommands&lt;String,&nbsp;String&gt;&nbsp;commands&nbsp;=&nbsp;otherParty.sync();<br>StatefulRedisConnection&lt;String,&nbsp;String&gt;&nbsp;connection&nbsp;=&nbsp;redisClient.connect();<br><span class=\"hljs-comment\" style=\"color: #998; font-style: italic; line-height: 26px;\">//&nbsp;&lt;2&gt;&nbsp;创建缓存访问器</span><br>Map&lt;String,&nbsp;String&gt;&nbsp;clientCache&nbsp;=&nbsp;<span class=\"hljs-keyword\" style=\"color: #333; font-weight: bold; line-height: 26px;\">new</span>&nbsp;ConcurrentHashMap&lt;&gt;();&nbsp;<span class=\"hljs-comment\" style=\"color: #998; font-style: italic; line-height: 26px;\">//map&nbsp;自动保存所有操作key的&nbsp;key=value</span><br>CacheFrontend&lt;String,&nbsp;String&gt;&nbsp;frontend&nbsp;=&nbsp;ClientSideCaching.enable(CacheAccessor.forMap(clientCache),&nbsp;connection,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;TrackingArgs.Builder.enabled());<br><br><span class=\"hljs-comment\" style=\"color: #998; font-style: italic; line-height: 26px;\">//&nbsp;&lt;3&gt;&nbsp;客户端正常写入测试数据&nbsp;k1&nbsp;v1</span><br>String&nbsp;key&nbsp;=&nbsp;<span class=\"hljs-string\" style=\"color: #d14; line-height: 26px;\">\"k1\"</span>;<br>commands.set(key,&nbsp;<span class=\"hljs-string\" style=\"color: #d14; line-height: 26px;\">\"v1\"</span>);<br><span class=\"hljs-comment\" style=\"color: #998; font-style: italic; line-height: 26px;\">//&nbsp;&lt;4&gt;&nbsp;循环读取</span><br><span class=\"hljs-keyword\" style=\"color: #333; font-weight: bold; line-height: 26px;\">while</span>&nbsp;(<span class=\"hljs-keyword\" style=\"color: #333; font-weight: bold; line-height: 26px;\">true</span>)&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;<span class=\"hljs-comment\" style=\"color: #998; font-style: italic; line-height: 26px;\">//&nbsp;&lt;4.1&gt;&nbsp;缓存访问器中的值，查看是否和&nbsp;Redis&nbsp;服务端同步</span><br>&nbsp;&nbsp;&nbsp;&nbsp;String&nbsp;cachedValue&nbsp;=&nbsp;frontend.get(key);<br>&nbsp;&nbsp;&nbsp;&nbsp;System.out.println(<span class=\"hljs-string\" style=\"color: #d14; line-height: 26px;\">\"当前&nbsp;k1&nbsp;的值为:---&gt;\"</span>&nbsp;+&nbsp;cachedValue);<br>&nbsp;&nbsp;&nbsp;&nbsp;Thread.sleep(<span class=\"hljs-number\" style=\"color: #008080; line-height: 26px;\">3000</span>);<br>}<br></code></pre>\n<ul data-tool=\"mdnice编辑器\" style=\"margin-top: 8px; margin-bottom: 8px; padding-left: 25px; font-size: 15px; color: #595959; list-style-type: circle;\">\n<li><section style=\"margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; font-size: 14px; font-weight: normal; color: #595959;\">redis-cli 客户端同时操作 k1 修改 k1 的值</section></li></ul>\n<pre class=\"custom\" data-tool=\"mdnice编辑器\" style=\"margin-top: 10px; margin-bottom: 10px;\"><code class=\"hljs\" style=\"overflow-x: auto; padding: 16px; color: #333; background: #f8f8f8; display: -webkit-box; font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; border-radius: 0px; font-size: 12px; -webkit-overflow-scrolling: touch; letter-spacing: 0px;\"><br>./redis-cli&nbsp;-h&nbsp;127.0.0.1&nbsp;-p&nbsp;6379<br><span class=\"hljs-meta\" style=\"color: #999; font-weight: bold; line-height: 26px;\"><br>&gt;</span><span class=\"bash\" style=\"line-height: 26px;\">&nbsp;<span class=\"hljs-built_in\" style=\"color: #0086b3; line-height: 26px;\">set</span>&nbsp;k1&nbsp;v2</span><br></code></pre>\n<ul data-tool=\"mdnice编辑器\" style=\"margin-top: 8px; margin-bottom: 8px; padding-left: 25px; font-size: 15px; color: #595959; list-style-type: circle;\">\n<li><section style=\"margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; font-size: 14px; font-weight: normal; color: #595959;\">注意查看 控制台日志</section></li></ul>\n<pre class=\"custom\" data-tool=\"mdnice编辑器\" style=\"margin-top: 10px; margin-bottom: 10px;\"><code class=\"hljs\" style=\"overflow-x: auto; padding: 16px; color: #333; background: #f8f8f8; display: -webkit-box; font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; border-radius: 0px; font-size: 12px; -webkit-overflow-scrolling: touch; letter-spacing: 0px;\">...<br>当前&nbsp;k1&nbsp;的值为:---&gt;v1<br>当前&nbsp;k1&nbsp;的值为:---&gt;v1<br>当前&nbsp;k1&nbsp;的值为:---&gt;v1<br>当前&nbsp;k1&nbsp;的值为:---&gt;v2<br>当前&nbsp;k1&nbsp;的值为:---&gt;v2<br>当前&nbsp;k1&nbsp;的值为:---&gt;v2<br>....<br></code></pre>\n<p data-tool=\"mdnice编辑器\" style=\"padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: #2b2b2b; margin: 10px 0px; letter-spacing: 2px; font-size: 14px; word-spacing: 2px;\">如上： k1 的值在其他客户端（redis-cli）修改，lettuce 客户端确实感知到了数据变化。 但 lettuce 到底 <code style=\"font-size: 14px; word-wrap: break-word; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #3594F7; background: RGBA(59, 170, 250, .1); padding: 0 2px; border-radius: 2px; height: 21px; line-height: 22px;\">CacheFrontend.get</code> 到底有没有查询 redis 呢？</p>\n<p data-tool=\"mdnice编辑器\" style=\"padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: #2b2b2b; margin: 10px 0px; letter-spacing: 2px; font-size: 14px; word-spacing: 2px;\">我们可以通过以下监控看下客户端具体的操作细节</p>\n<h2 data-tool=\"mdnice编辑器\" style=\"margin-top: 30px; margin-bottom: 15px; padding: 0px; font-weight: bold; color: black; font-size: 22px; display: block; border-bottom: 4px solid #40B8FA;\"><span class=\"prefix\" style=\"display: flex; width: 20px; height: 20px; background-size: 20px 20px; background-image: url(https://my-wechat.mdnice.com/fullstack-1.png); margin-bottom: -22px;\"></span><span class=\"content\" style=\"display: flex; color: #40B8FA; font-size: 20px; margin-left: 25px;\">监控</span><span class=\"suffix\" style=\"display: flex; box-sizing: border-box; width: 200px; height: 10px; border-top-left-radius: 20px; background: RGBA(64, 184, 250, .5); color: rgb(255, 255, 255); font-size: 16px; letter-spacing: 0.544px; justify-content: flex-end; float: right; margin-top: -10px; box-sizing: border-box !important; overflow-wrap: break-word !important;\"></span></h2>\n<pre class=\"custom\" data-tool=\"mdnice编辑器\" style=\"margin-top: 10px; margin-bottom: 10px;\"><code class=\"hljs\" style=\"overflow-x: auto; padding: 16px; color: #333; background: #f8f8f8; display: -webkit-box; font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; border-radius: 0px; font-size: 12px; -webkit-overflow-scrolling: touch; letter-spacing: 0px;\"><br>./redis-cli&nbsp;-h&nbsp;127.0.0.1&nbsp;-p&nbsp;6379<br><span class=\"hljs-meta\" style=\"color: #999; font-weight: bold; line-height: 26px;\"><br>&gt;</span><span class=\"bash\" style=\"line-height: 26px;\">&nbsp;MONITOR</span><br>OK<br>1595922453.165088&nbsp;[0&nbsp;172.16.1.96:57482]&nbsp;\"SET\"&nbsp;\"k1\"&nbsp;\"v1\"&nbsp;&nbsp;&nbsp;#&nbsp;对应&nbsp;&lt;3&gt;&nbsp;写入测试数据<br>1595922453.168238&nbsp;[0&nbsp;172.16.1.96:57483]&nbsp;\"GET\"&nbsp;\"k1\"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;&lt;4.1&gt;&nbsp;缓存访问器中的值，由于第一次查询为空需要穿透去查询&nbsp;redis-server<br>1595922466.525942&nbsp;[0&nbsp;172.16.1.96:57498]&nbsp;\"COMMAND\"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;其他客户端&nbsp;redis-cli&nbsp;接入&nbsp;提醒<br>1595922472.046488&nbsp;[0&nbsp;172.16.1.96:57498]&nbsp;\"set\"&nbsp;\"k1\"&nbsp;\"v2\"&nbsp;&nbsp;&nbsp;#&nbsp;其他客户端&nbsp;操作&nbsp;k1<br>1595922474.208214&nbsp;[0&nbsp;172.16.1.96:57483]&nbsp;\"GET\"&nbsp;\"k1\"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;由于k1&nbsp;值发生变化，循环&nbsp;&lt;4.1&gt;&nbsp;会重新查询redis-server<br></code></pre>\n<p data-tool=\"mdnice编辑器\" style=\"padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: #2b2b2b; margin: 10px 0px; letter-spacing: 2px; font-size: 14px; word-spacing: 2px;\">如上： 虽然是个死循环，但是关于 redis 操作只有以上注释的几条，说明客户端缓存生效。</p>\n<h2 data-tool=\"mdnice编辑器\" style=\"margin-top: 30px; margin-bottom: 15px; padding: 0px; font-weight: bold; color: black; font-size: 22px; display: block; border-bottom: 4px solid #40B8FA;\"><span class=\"prefix\" style=\"display: flex; width: 20px; height: 20px; background-size: 20px 20px; background-image: url(https://my-wechat.mdnice.com/fullstack-1.png); margin-bottom: -22px;\"></span><span class=\"content\" style=\"display: flex; color: #40B8FA; font-size: 20px; margin-left: 25px;\">总结</span><span class=\"suffix\" style=\"display: flex; box-sizing: border-box; width: 200px; height: 10px; border-top-left-radius: 20px; background: RGBA(64, 184, 250, .5); color: rgb(255, 255, 255); font-size: 16px; letter-spacing: 0.544px; justify-content: flex-end; float: right; margin-top: -10px; box-sizing: border-box !important; overflow-wrap: break-word !important;\"></span></h2>\n<ul data-tool=\"mdnice编辑器\" style=\"margin-top: 8px; margin-bottom: 8px; padding-left: 25px; font-size: 15px; color: #595959; list-style-type: circle;\">\n<li><section style=\"margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; font-size: 14px; font-weight: normal; color: #595959;\">当前仅有 lettuce 支持此功能，jedis 还未支持</section></li><li><section style=\"margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; font-size: 14px; font-weight: normal; color: #595959;\">spring-boot-data-redis 暂未支持此功能，估计需要 spring boot 2.5 版本</section></li></ul>\n</section>\n\n![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d7624c14879a4d96ad07e0d8189230dd~tplv-k3u1fbpfcp-zoom-1.image)", "user_name": "冷冷zz", "description": "Javaer | Spring Boot Committer | Spring Cloud Commiter", "got_view_count": 210410, "category_name": "后端", "ctime": 1457483880}
{"tag_name": "Java", "concern_user_count": 252044, "user_id": "3509296845313741", "title": "新一代垃圾回收器ZGC的探索与实践", "mark_content": "> 很多低延迟高可用Java服务的系统可用性经常受GC停顿的困扰，作为新一代的低延迟垃圾回收器，ZGC在大内存低延迟服务的内存管理和回收方面，有着非常不错的表现。本文从GC之痛、ZGC原理、ZGC调优实践、升级ZGC效果等维度展开，详述了ZGC在美团低延时场景中的应用，以及在生产环境中取得的一些成果。希望这些实践对大家有所帮助或者启发。\n\n[ZGC](https://wiki.openjdk.java.net/display/zgc/Main)（The Z Garbage Collector）是JDK 11中推出的一款低延迟垃圾回收器，它的设计目标包括：\n\n* 停顿时间不超过10ms；\n* 停顿时间不会随着堆的大小，或者活跃对象的大小而增加；\n* 支持8MB~4TB级别的堆（未来支持16TB）。\n\n从设计目标来看，我们知道ZGC适用于大内存低延迟服务的内存管理和回收。本文主要介绍ZGC在低延时场景中的应用和卓越表现，文章内容主要分为四部分：\n\n* **GC之痛**：介绍实际业务中遇到的GC痛点，并分析CMS收集器和G1收集器停顿时间瓶颈；\n* **ZGC原理**：分析ZGC停顿时间比G1或CMS更短的本质原因，以及背后的技术原理；\n* **ZGC调优实践**：重点分享对ZGC调优的理解，并分析若干个实际调优案例；\n* **升级ZGC效果**：展示在生产环境应用ZGC取得的效果。\n\n## GC之痛\n\n很多低延迟高可用Java服务的系统可用性经常受GC停顿的困扰。GC停顿指垃圾回收期间STW（Stop The World），当STW时，所有应用线程停止活动，等待GC停顿结束。以美团风控服务为例，部分上游业务要求风控服务65ms内返回结果，并且可用性要达到99.99%。但因为GC停顿，我们未能达到上述可用性目标。当时使用的是CMS垃圾回收器，单次Young GC 40ms，一分钟10次，接口平均响应时间30ms。通过计算可知，有（40ms + 30ms) * 10次 / 60000ms = 1.12%的请求的响应时间会增加0 ~ 40ms不等，其中30ms * 10次 / 60000ms = 0.5%的请求响应时间会增加40ms。可见，GC停顿对响应时间的影响较大。为了降低GC停顿对系统可用性的影响，我们从降低单次GC时间和降低GC频率两个角度出发进行了调优，还测试过G1垃圾回收器，但这三项措施均未能降低GC对服务可用性的影响。\n\n### CMS与G1停顿时间瓶颈\n\n在介绍ZGC之前，首先回顾一下CMS和G1的GC过程以及停顿时间的瓶颈。CMS新生代的Young GC、G1和ZGC都基于标记-复制算法，但算法具体实现的不同就导致了巨大的性能差异。\n\n标记-复制算法应用在CMS新生代（ParNew是CMS默认的新生代垃圾回收器）和G1垃圾回收器中。标记-复制算法可以分为三个阶段：\n\n* 标记阶段，即从GC Roots集合开始，标记活跃对象；\n* 转移阶段，即把活跃对象复制到新的内存地址上；\n* 重定位阶段，因为转移导致对象的地址发生了变化，在重定位阶段，所有指向对象旧地址的指针都要调整到对象新的地址上。\n\n下面以G1为例，通过G1中标记-复制算法过程（G1的Young GC和Mixed GC均采用该算法），分析G1停顿耗时的主要瓶颈。G1垃圾回收周期如下图所示：\n\n![](https://p0.meituan.net/travelcube/2f56a9a249bc8d74f4f455782abce6be147997.png@1832w_848h_80q)\n\nG1的混合回收过程可以分为标记阶段、清理阶段和复制阶段。\n\n**标记阶段停顿分析**\n\n* 初始标记阶段：初始标记阶段是指从GC Roots出发标记全部直接子节点的过程，该阶段是STW的。由于GC Roots数量不多，通常该阶段耗时非常短。\n* 并发标记阶段：并发标记阶段是指从GC Roots开始对堆中对象进行可达性分析，找出存活对象。该阶段是并发的，即应用线程和GC线程可以同时活动。并发标记耗时相对长很多，但因为不是STW，所以我们不太关心该阶段耗时的长短。\n* 再标记阶段：重新标记那些在并发标记阶段发生变化的对象。该阶段是STW的。\n\n**清理阶段停顿分析**\n\n* 清理阶段清点出有存活对象的分区和没有存活对象的分区，该阶段不会清理垃圾对象，也不会执行存活对象的复制。该阶段是STW的。\n\n**复制阶段停顿分析**\n\n* 复制算法中的转移阶段需要分配新内存和复制对象的成员变量。转移阶段是STW的，其中内存分配通常耗时非常短，但对象成员变量的复制耗时有可能较长，这是因为复制耗时与存活对象数量与对象复杂度成正比。对象越复杂，复制耗时越长。\n\n四个STW过程中，初始标记因为只标记GC Roots，耗时较短。再标记因为对象数少，耗时也较短。清理阶段因为内存分区数量少，耗时也较短。转移阶段要处理所有存活的对象，耗时会较长。因此，G1停顿时间的瓶颈主要是标记-复制中的转移阶段STW。为什么转移阶段不能和标记阶段一样并发执行呢？主要是G1未能解决转移过程中准确定位对象地址的问题。\n\nG1的Young GC和CMS的Young GC，其标记-复制全过程STW，这里不再详细阐述。\n\n## ZGC原理\n\n### 全并发的ZGC\n\n与CMS中的ParNew和G1类似，ZGC也采用标记-复制算法，不过ZGC对该算法做了重大改进：ZGC在标记、转移和重定位阶段几乎都是并发的，这是ZGC实现停顿时间小于10ms目标的最关键原因。\n\nZGC垃圾回收周期如下图所示：\n\n![](https://p0.meituan.net/travelcube/40838f01e4c29cfe5423171f08771ef8156393.png@1812w_940h_80q)\n\nZGC只有三个STW阶段：**初始标记**，**再标记**，**初始转移**。其中，初始标记和初始转移分别都只需要扫描所有GC Roots，其处理时间和GC Roots的数量成正比，一般情况耗时非常短；再标记阶段STW时间很短，最多1ms，超过1ms则再次进入并发标记阶段。即，ZGC几乎所有暂停都只依赖于GC Roots集合大小，停顿时间不会随着堆的大小或者活跃对象的大小而增加。与ZGC对比，G1的转移阶段完全STW的，且停顿时间随存活对象的大小增加而增加。\n\n### ZGC关键技术\n\nZGC通过着色指针和读屏障技术，解决了转移过程中准确访问对象的问题，实现了并发转移。大致原理描述如下：并发转移中“并发”意味着GC线程在转移对象的过程中，应用线程也在不停地访问对象。假设对象发生转移，但对象地址未及时更新，那么应用线程可能访问到旧地址，从而造成错误。而在ZGC中，应用线程访问对象将触发“读屏障”，如果发现对象被移动了，那么“读屏障”会把读出来的指针更新到对象的新地址上，这样应用线程始终访问的都是对象的新地址。那么，JVM是如何判断对象被移动过呢？就是利用对象引用的地址，即着色指针。下面介绍着色指针和读屏障技术细节。\n\n**着色指针**\n\n> 着色指针是一种将信息存储在指针中的技术。\n\nZGC仅支持64位系统，它把64位虚拟地址空间划分为多个子空间，如下图所示：\n\n![](https://p0.meituan.net/travelcube/f620aa44eb0a756467889e64e13ee86338446.png@1568w_322h_80q)\n\n其中，[0~4TB) 对应Java堆，[4TB ~ 8TB) 称为M0地址空间，[8TB ~ 12TB) 称为M1地址空间，[12TB ~ 16TB) 预留未使用，[16TB ~ 20TB) 称为Remapped空间。\n\n当应用程序创建对象时，首先在堆空间申请一个虚拟地址，但该虚拟地址并不会映射到真正的物理地址。ZGC同时会为该对象在M0、M1和Remapped地址空间分别申请一个虚拟地址，且这三个虚拟地址对应同一个物理地址，但这三个空间在同一时间有且只有一个空间有效。ZGC之所以设置三个虚拟地址空间，是因为它使用“空间换时间”思想，去降低GC停顿时间。“空间换时间”中的空间是虚拟空间，而不是真正的物理空间。后续章节将详细介绍这三个空间的切换过程。           \n\n与上述地址空间划分相对应，ZGC实际仅使用64位地址空间的第0~41位，而第42~45位存储元数据，第47~63位固定为0。\n\n![](https://p0.meituan.net/travelcube/507f599016eafffa0b98de7585a1c80b338346.png@2080w_624h_80q)\n\nZGC将对象存活信息存储在42~45位中，这与传统的垃圾回收并将对象存活信息放在对象头中完全不同。\n\n**读屏障** \n\n> 读屏障是JVM向应用代码插入一小段代码的技术。当应用线程从堆中读取对象引用时，就会执行这段代码。需要注意的是，仅“从堆中读取对象引用”才会触发这段代码。\n\n读屏障示例：\n\n```Java\nObject o = obj.FieldA   // 从堆中读取引用，需要加入屏障\n<Load barrier>\nObject p = o  // 无需加入屏障，因为不是从堆中读取引用\no.dosomething() // 无需加入屏障，因为不是从堆中读取引用\nint i =  obj.FieldB  //无需加入屏障，因为不是对象引用\n```\n\nZGC中读屏障的代码作用：在对象标记和转移过程中，用于确定对象的引用地址是否满足条件，并作出相应动作。\n\n### ZGC并发处理演示 \n\n接下来详细介绍ZGC一次垃圾回收周期中地址视图的切换过程：\n\n* **初始化**：ZGC初始化之后，整个内存空间的地址视图被设置为Remapped。程序正常运行，在内存中分配对象，满足一定条件后垃圾回收启动，此时进入标记阶段。\n* **并发标记阶段**：第一次进入标记阶段时视图为M0，如果对象被GC标记线程或者应用线程访问过，那么就将对象的地址视图从Remapped调整为M0。所以，在标记阶段结束之后，对象的地址要么是M0视图，要么是Remapped。如果对象的地址是M0视图，那么说明对象是活跃的；如果对象的地址是Remapped视图，说明对象是不活跃的。\n* **并发转移阶段**：标记结束后就进入转移阶段，此时地址视图再次被设置为Remapped。如果对象被GC转移线程或者应用线程访问过，那么就将对象的地址视图从M0调整为Remapped。\n\n其实，在标记阶段存在两个地址视图M0和M1，上面的过程显示只用了一个地址视图。之所以设计成两个，是为了区别前一次标记和当前标记。也即，第二次进入并发标记阶段后，地址视图调整为M1，而非M0。\n\n着色指针和读屏障技术不仅应用在并发转移阶段，还应用在并发标记阶段：将对象设置为已标记，传统的垃圾回收器需要进行一次内存访问，并将对象存活信息放在对象头中；而在ZGC中，只需要设置指针地址的第42~45位即可，并且因为是寄存器访问，所以速度比访问内存更快。\n\n![](https://p0.meituan.net/travelcube/a621733099b8fda2a0f38a8859e6a114213563.png@2070w_806h_80q)\n\n## ZGC调优实践\n\nZGC不是“银弹”，需要根据服务的具体特点进行调优。网络上能搜索到实战经验较少，调优理论需自行摸索，我们在此阶段也耗费了不少时间，最终才达到理想的性能。本文的一个目的是列举一些使用ZGC时常见的问题，帮助大家使用ZGC提高服务可用性。\n\n### 调优基础知识\n\n**理解ZGC重要配置参数**\n\n以我们服务在生产环境中ZGC参数配置为例，说明各个参数的作用：\n\n重要参数配置样例：\n\n```Shell\n-Xms10G -Xmx10G \n-XX:ReservedCodeCacheSize=256m -XX:InitialCodeCacheSize=256m \n-XX:+UnlockExperimentalVMOptions -XX:+UseZGC \n-XX:ConcGCThreads=2 -XX:ParallelGCThreads=6 \n-XX:ZCollectionInterval=120 -XX:ZAllocationSpikeTolerance=5 \n-XX:+UnlockDiagnosticVMOptions -XX:-ZProactive \n-Xlog:safepoint,classhisto*=trace,age*,gc*=info:file=/opt/logs/logs/gc-%t.log:time,tid,tags:filecount=5,filesize=50m \n```\n\n**-Xms -Xmx**：堆的最大内存和最小内存，这里都设置为10G，程序的堆内存将保持10G不变。\n**-XX:ReservedCodeCacheSize -XX:InitialCodeCacheSize**：设置CodeCache的大小， JIT编译的代码都放在CodeCache中，一般服务64m或128m就已经足够。我们的服务因为有一定特殊性，所以设置的较大，后面会详细介绍。\n**-XX:+UnlockExperimentalVMOptions -XX:+UseZGC**：启用ZGC的配置。\n**-XX:ConcGCThreads**：并发回收垃圾的线程。默认是总核数的12.5%，8核CPU默认是1。调大后GC变快，但会占用程序运行时的CPU资源，吞吐会受到影响。\n**-XX:ParallelGCThreads**：STW阶段使用线程数，默认是总核数的60%。\n**-XX:ZCollectionInterval**：ZGC发生的最小时间间隔，单位秒。\n**-XX:ZAllocationSpikeTolerance**：ZGC触发自适应算法的修正系数，默认2，数值越大，越早的触发ZGC。\n**-XX:+UnlockDiagnosticVMOptions -XX:-ZProactive**：是否启用主动回收，默认开启，这里的配置表示关闭。\n**-Xlog**：设置GC日志中的内容、格式、位置以及每个日志的大小。\n\n**理解ZGC触发时机**\n\n相比于CMS和G1的GC触发机制，ZGC的GC触发机制有很大不同。ZGC的核心特点是并发，GC过程中一直有新的对象产生。如何保证在GC完成之前，新产生的对象不会将堆占满，是ZGC参数调优的第一大目标。因为在ZGC中，当垃圾来不及回收将堆占满时，会导致正在运行的线程停顿，持续时间可能长达秒级之久。\n\nZGC有多种GC触发机制，总结如下：\n\n* 阻塞内存分配请求触发：当垃圾来不及回收，垃圾将堆占满时，会导致部分线程阻塞。我们应当避免出现这种触发方式。日志中关键字是“Allocation Stall”。\n* 基于分配速率的自适应算法：最主要的GC触发方式，其算法原理可简单描述为”ZGC根据近期的对象分配速率以及GC时间，计算出当内存占用达到什么阈值时触发下一次GC”。自适应算法的详细理论可参考彭成寒《新一代垃圾回收器ZGC设计与实现》一书中的内容。通过ZAllocationSpikeTolerance参数控制阈值大小，该参数默认2，数值越大，越早的触发GC。我们通过调整此参数解决了一些问题。日志中关键字是“Allocation Rate”。\n* 基于固定时间间隔：通过ZCollectionInterval控制，适合应对突增流量场景。流量平稳变化时，自适应算法可能在堆使用率达到95%以上才触发GC。流量突增时，自适应算法触发的时机可能会过晚，导致部分线程阻塞。我们通过调整此参数解决流量突增场景的问题，比如定时活动、秒杀等场景。日志中关键字是“Timer”。\n* 主动触发规则：类似于固定间隔规则，但时间间隔不固定，是ZGC自行算出来的时机，我们的服务因为已经加了基于固定时间间隔的触发机制，所以通过-ZProactive参数将该功能关闭，以免GC频繁，影响服务可用性。 日志中关键字是“Proactive”。\n* 预热规则：服务刚启动时出现，一般不需要关注。日志中关键字是“Warmup”。\n* 外部触发：代码中显式调用System.gc()触发。 日志中关键字是“System.gc()”。\n* 元数据分配触发：元数据区不足时导致，一般不需要关注。 日志中关键字是“Metadata GC Threshold”。\n\n**理解ZGC日志**\n\n一次完整的GC过程，需要注意的点已在图中标出。\n\n![](https://p0.meituan.net/travelcube/33b1feaa5a9fdd44fa6c53a4704d2fc7362864.png@2146w_783h_80q)\n\n注意：该日志过滤了进入安全点的信息。正常情况，在一次GC过程中还穿插着进入安全点的操作。\n\nGC日志中每一行都注明了GC过程中的信息，关键信息如下：\n\n* **Start**：开始GC，并标明的GC触发的原因。上图中触发原因是自适应算法。\n* **Phase-Pause Mark Start**：初始标记，会STW。\n* **Phase-Pause Mark End**：再次标记，会STW。\n* **Phase-Pause Relocate Start**：初始转移，会STW。\n* **Heap信息**：记录了GC过程中Mark、Relocate前后的堆大小变化状况。High和Low记录了其中的最大值和最小值，我们一般关注High中Used的值，如果达到100%，在GC过程中一定存在内存分配不足的情况，需要调整GC的触发时机，更早或者更快地进行GC。\n* **GC信息统计**：可以定时的打印垃圾收集信息，观察10秒内、10分钟内、10个小时内，从启动到现在的所有统计信息。利用这些统计信息，可以排查定位一些异常点。\n\n日志中内容较多，关键点已用红线标出，含义较好理解，更详细的解释大家可以自行在网上查阅资料。\n\n![](https://p1.meituan.net/travelcube/af918165262afd59ee8331c014953f381190232.png@2771w_2500h_80q)\n\n**理解ZGC停顿原因**\n\n我们在实战过程中共发现了6种使程序停顿的场景，分别如下：\n\n- **GC时，初始标记**：日志中Pause Mark Start。\n- **GC时，再标记**：日志中Pause Mark End。\n- **GC时，初始转移**：日志中Pause Relocate Start。\n- **内存分配阻塞**：当内存不足时线程会阻塞等待GC完成，关键字是\"Allocation Stall\"。\n\n![](https://p0.meituan.net/travelcube/85c67c1ed8e8ab789760df164d62475181355.png@1188w_260h_80q)\n\n- **安全点**：所有线程进入到安全点后才能进行GC，ZGC定期进入安全点判断是否需要GC。先进入安全点的线程需要等待后进入安全点的线程直到所有线程挂起。\n- **dump线程、内存**：比如jstack、jmap命令。\n\n![](https://p0.meituan.net/travelcube/b9ad0cb5bc55c3d5796f3bb347b3989166875.png@1926w_114h_80q)\n![](https://p0.meituan.net/travelcube/a837e745bb412074b550bfcd5d596fc020071.png@1050w_87h_80q)\n\n### 调优案例\n\n我们维护的服务名叫Zeus，它是美团的规则平台，常用于风控场景中的规则管理。规则运行是基于开源的表达式执行引擎[Aviator](https://github.com/killme2008/aviator)。Aviator内部将每一条表达式转化成Java的一个类，通过调用该类的接口实现表达式逻辑。\n\nZeus服务内的规则数量超过万条，且每台机器每天的请求量几百万。这些客观条件导致Aviator生成的类和方法会产生很多的ClassLoader和CodeCache，这些在使用ZGC时都成为过GC的性能瓶颈。接下来介绍两类调优案例。\n\n**内存分配阻塞，系统停顿可达到秒级**\n\n**案例一：秒杀活动中流量突增，出现性能毛刺**\n\n**日志信息**：对比出现性能毛刺时间点的GC日志和业务日志，发现JVM停顿了较长时间，且停顿时GC日志中有大量的“Allocation Stall”日志。\n\n**分析**：这种案例多出现在“自适应算法”为主要GC触发机制的场景中。ZGC是一款并发的垃圾回收器，GC线程和应用线程同时活动，在GC过程中，还会产生新的对象。GC完成之前，新产生的对象将堆占满，那么应用线程可能因为申请内存失败而导致线程阻塞。当秒杀活动开始，大量请求打入系统，但自适应算法计算的GC触发间隔较长，导致GC触发不及时，引起了内存分配阻塞，导致停顿。\n\n**解决方法：**\n\n（1）开启”基于固定时间间隔“的GC触发机制：-XX:ZCollectionInterval。比如调整为5秒，甚至更短。  \n（2）增大修正系数-XX:ZAllocationSpikeTolerance，更早触发GC。ZGC采用正态分布模型预测内存分配速率，模型修正系数ZAllocationSpikeTolerance默认值为2，值越大，越早的触发GC，Zeus中所有集群设置的是5。\n\n**案例二：压测时，流量逐渐增大到一定程度后，出现性能毛刺**\n\n**日志信息**：平均1秒GC一次，两次GC之间几乎没有间隔。\n\n**分析**：GC触发及时，但内存标记和回收速度过慢，引起内存分配阻塞，导致停顿。\n\n**解决方法**：增大-XX:ConcGCThreads， 加快并发标记和回收速度。ConcGCThreads默认值是核数的1/8，8核机器，默认值是1。该参数影响系统吞吐，如果GC间隔时间大于GC周期，不建议调整该参数。\n\n**GC Roots 数量大，单次GC停顿时间长**\n\n**案例三： 单次GC停顿时间30ms，与预期停顿10ms左右有较大差距**\n\n**日志信息**：观察ZGC日志信息统计，“Pause Roots ClassLoaderDataGraph”一项耗时较长。\n\n**分析**：dump内存文件，发现系统中有上万个ClassLoader实例。我们知道ClassLoader属于GC Roots一部分，且ZGC停顿时间与GC Roots成正比，GC Roots数量越大，停顿时间越久。再进一步分析，ClassLoader的类名表明，这些ClassLoader均由Aviator组件生成。分析Aviator源码，发现Aviator对每一个表达式新生成类时，会创建一个ClassLoader，这导致了ClassLoader数量巨大的问题。在更高Aviator版本中，该问题已经被修复，即仅创建一个ClassLoader为所有表达式生成类。\n\n**解决方法**：升级Aviator组件版本，避免生成多余的ClassLoader。\n\n**案例四：服务启动后，运行时间越长，单次GC时间越长，重启后恢复**\n\n**日志信息**：观察ZGC日志信息统计，“Pause Roots CodeCache”的耗时会随着服务运行时间逐渐增长。\n\n**分析**：CodeCache空间用于存放Java热点代码的JIT编译结果，而CodeCache也属于GC Roots一部分。通过添加-XX:+PrintCodeCacheOnCompilation参数，打印CodeCache中的被优化的方法，发现大量的Aviator表达式代码。定位到根本原因，每个表达式都是一个类中一个方法。随着运行时间越长，执行次数增加，这些方法会被JIT优化编译进入到Code Cache中，导致CodeCache越来越大。\n\n**解决方法**：JIT有一些参数配置可以调整JIT编译的条件，但对于我们的问题都不太适用。我们最终通过业务优化解决，删除不需要执行的Aviator表达式，从而避免了大量Aviator方法进入CodeCache中。\n\n值得一提的是，我们并不是在所有这些问题都解决后才全量部署所有集群。即使开始有各种各样的毛刺，但计算后发现，有各种问题的ZGC也比之前的CMS对服务可用性影响小。所以从开始准备使用ZGC到全量部署，大概用了2周的时间。在之后的3个月时间里，我们边做业务需求，边跟进这些问题，最终逐个解决了上述问题，从而使ZGC在各个集群上达到了一个更好表现。\n\n## 升级ZGC效果\n\n### 延迟降低\n\n> TP(Top Percentile)是一项衡量系统延迟的指标：TP999表示99.9%请求都能被响应的最小耗时；TP99表示99%请求都能被响应的最小耗时。\n\n在Zeus服务不同集群中，ZGC在低延迟（TP999 < 200ms）场景中收益较大：\n\n- **TP999**：下降12~142ms，下降幅度18%~74%。\n- **TP99**：下降5~28ms，下降幅度10%~47%。\n\n超低延迟（TP999 < 20ms）和高延迟（TP999 > 200ms）服务收益不大，原因是这些服务的响应时间瓶颈不是GC，而是外部依赖的性能。\n\n### 吞吐下降\n\n对吞吐量优先的场景，ZGC可能并不适合。例如，Zeus某离线集群原先使用CMS，升级ZGC后，系统吞吐量明显降低。究其原因有二：第一，ZGC是单代垃圾回收器，而CMS是分代垃圾回收器。单代垃圾回收器每次处理的对象更多，更耗费CPU资源；第二，ZGC使用读屏障，读屏障操作需耗费额外的计算资源。\n\n## 总结\n\nZGC作为下一代垃圾回收器，性能非常优秀。ZGC垃圾回收过程几乎全部是并发，实际STW停顿时间极短，不到10ms。这得益于其采用的着色指针和读屏障技术。\n\nZeus在升级JDK 11+ZGC中，通过将风险和问题分类，然后各个击破，最终顺利实现了升级目标，GC停顿也几乎不再影响系统可用性。\n\n最后推荐大家升级ZGC，Zeus系统因为业务特点，遇到了较多问题，而风控其他团队在升级时都非常顺利。欢迎大家加入“ZGC使用交流”群。\n\n\n## 参考文献\n\n* [ZGC官网](https://wiki.openjdk.java.net/display/zgc/Main)\n* 彭成寒.《新一代垃圾回收器ZGC设计与实现》. 机械工业出版社, 2019.\n* [从实际案例聊聊Java应用的GC优化](https://tech.meituan.com/2017/12/29/jvm-optimize.html)\n* [Java Hotspot G1 GC的一些关键技术](https://tech.meituan.com/2016/09/23/g1.html)\n\n## 附录\n\n### 如何使用新技术\n\n在生产环境升级JDK 11，使用ZGC，大家最关心的可能不是效果怎么样，而是这个新版本用的人少，网上实践也少，靠不靠谱，稳不稳定。其次是升级成本会不会很大，万一不成功岂不是白白浪费时间。所以，在使用新技术前，首先要做的是评估收益、成本和风险。\n\n**评估收益**\n\n对于JDK这种世界关注的程序，大版本升级所引入的新技术一般已经在理论上经过验证。我们要做的事情就是确定当前系统的瓶颈是否是新版本JDK可解决的问题，切忌问题未诊断清楚就采取措施。评估完收益之后再评估成本和风险，收益过大或者过小，其他两项影响权重就会小很多。\n\n以本文开头提到的案例为例，假设GC次数不变（10次/分钟)，且单次GC时间从40ms降低10ms。通过计算，一分钟内有100/60000 = 0.17%的时间在进行GC，且期间所有请求仅停顿10ms，GC期间影响的请求数和因GC增加的延迟都有所减少。\n\n**评估成本**\n\n这里主要指升级所需要的人力成本。此项相对比较成熟，根据新技术的使用手册判断改动点。跟做其他项目区别不大，不再具体细说。\n\n在我们的实践中，两周时间完成线上部署，达到安全稳定运行的状态。后续持续迭代3个月，根据业务场景对ZGC进行了更契合的优化适配。\n\n**评估风险**\n\n升级JDK的风险可以分为三类：\n\n- **兼容性风险**：Java程序JAR包依赖很多，升级JDK版本后程序是否能运行起来。例如我们的服务是从JDK 7升级到JDK 11，需要解决较多JAR包不兼容的问题。\n- **功能风险**：运行起来后，是否会有一些组件逻辑变更，影响现有功能的逻辑。\n- **性能风险**：功能如果没有问题，性能是否稳定，能稳定的在线上运行。\n\n经过分类后，每类风险的应对转化成了常见的测试问题，不再属于未知风险。风险是指不确定的事情，如果不确定的事情都能转化成可确定的事情，意味着风险已消除。\n\n### 升级JDK 11\n\n选择JDK 11，是因为在JDK 11中首次支持ZGC，而且JDK 11属于长期支持（Long Term Support，LTS）版本，至少会被维护三年，普通版本（如JDK 12、JDK 13和JDK 14）只有6个月的维护周期，不建议使用。\n\n**本地测试环境安装**\n\n从两个源[OpenJDK](https://jdk.java.net/archive/)和[OracleJDK](https://www.oracle.com/java/technologies/javase-jdk11-downloads.html) 下载JDK 11，二个版本的JDK主要区别是长时期的免费和付费，短期内都免费。注意JDK 11版本中的ZGC不支持Mac OS系统，在Mac OS系统上使用JDK 11只能用其他垃圾回收器，如G1。\n\n**生产环境安装**\n\n升级JDK 11不仅仅是升级自己项目的JDK版本，还需要编译、发布部署、运行、监控、性能内存分析工具等项目支持。美团内部的实践：\n\n**编译打包**：美团发布系统支持选择JDK 11进行编译打包。\n**线上运行 & 全量部署**：要求线上机器已安装JDK11，有3种方式：\n\n1.新申请默认安装JDK 11的虚拟机：试用JDK 11时可用这种方式；全量部署时，如果新申请机器数量过多，可能没有足够机器资源。\n2.通过手写脚本给存量虚拟机安装JDK 11：不推荐，业务同学过多参与到运维当中。\n3.使用容器提供的镜像部署功能，在打包镜像时安装JDK 11：推荐方式，不需要新申请资源。\n\n**监控指标**：主要是GC的时间和频率，我们通过美团的CAT监控系统支持ZGC数据的收集（[CAT已开源](https://tech.meituan.com/2018/11/01/cat-in-depth-java-application-monitoring.html)）。\n**性能内存分析**：线上遇到性能问题时，还需要借助Profiling工具，美团的性能诊断优化平台Scalpel已支持JDK 11的性能内存分析。如果你的公司没有相关工具，推荐使用JProfier。\n\n**解决组件兼容性**\n\n我们的项目包含二十多万行代码，需要从JDK 7升级到JDK 11，依赖组件众多。虽然看起来升级会比较复杂，但实际只花了两天时间即解决了兼容性问题。具体过程如下：\n\n1.编译，需要修改pom文件中的build配置，根据报错作修改，主要有两类：\n\na.一些类被删除：比如“sun.misc.BASE64Encoder”，找到替换类java.util.Base64即可。\n\nb.组件依赖版本不兼容JDK 11问题：找到对应依赖组件，搜索最新版本，一般都支持JDK 11。\n\n2.编译成功后，启动运行，此时仍有可能组件依赖版本问题，按照编译时的方式处理即可。\n\n升级所修改的依赖：\n\n```XML\n<dependency>\n    <groupId>javax.annotation</groupId>\n    <artifactId>javax.annotation-api</artifactId>\n    <version>1.3.2</version>\n</dependency>\n<dependency>\n    <groupId>javax.validation</groupId>\n    <artifactId>validation-api</artifactId>\n    <version>2.0.1.Final</version>\n</dependency>\n<dependency>\n    <groupId>org.projectlombok</groupId>\n    <artifactId>lombok</artifactId>\n    <version>1.18.4</version>\n</dependency>\n<dependency>\n    <groupId>org.hibernate.validator</groupId>\n    <artifactId>hibernate-validator-parent</artifactId>\n    <version>6.0.16.Final</version>\n</dependency>\n<dependency>\n    <groupId>com.sankuai.inf</groupId>\n    <artifactId>patriot-sdk</artifactId>\n    <version>1.2.1</version>\n</dependency>\n<dependency>\n    <groupId>org.apache.commons</groupId>\n    <artifactId>commons-lang3</artifactId>\n    <version>3.9</version>\n</dependency>\n<dependency>\n    <groupId>commons-lang</groupId>\n    <artifactId>commons-lang</artifactId>\n    <version>2.6</version>\n</dependency>\n<dependency>\n    <groupId>io.netty</groupId>\n    <artifactId>netty-all</artifactId>\n    <version>4.1.39.Final</version>\n</dependency>\n<dependency>\n    <groupId>junit</groupId>\n    <artifactId>junit</artifactId>\n    <version>4.12</version>\n</dependency>\n```\n\nJDK 11已经出来两年，常见的依赖组件都有兼容性版本。但是，如果是公司内部提供的公司级组件，可能会不兼容JDK 11，需要推动相关组件进行升级。如果对方升级较为困难，可以考虑拆分功能，将依赖这些组件的功能单独部署，继续使用低版本JDK。随着JDK11的卓越性能被大家悉知，相信会有更多团队会用JDK 11解决GC问题，使用者越多，各个组件升级的动力也会越大。\n\n**验证功能正确性**\n\n通过完备的单测、集成和回归测试，保证功能正确性。\n\n## 作者简介\n\n- 王东，美团信息安全资深工程师。\n- 王伟，美团信息安全技术专家。\n\n**阅读更多技术文章，请扫码关注微信公众号-美团技术团队！**\n\n![](https://p0.meituan.net/travelcube/98e7c3ecacb37a88560b8d87bd79dba3414591.png)", "user_name": "美团技术团队", "description": "在美团，我们信仰耐心和坚持的力量，愿意持续去做一些正确、有积累、可", "got_view_count": 396830, "category_name": "后端", "ctime": 1457483880}
{"tag_name": "Webpack", "concern_user_count": 181325, "user_id": "2717648473034823", "title": "Webpack配置全解析（优化篇）", "mark_content": "\n　　在上一篇文章[Webpack配置全解析](http://xieyufei.com/2020/06/06/Webpack-Learned.html)介绍了Webpack中loader和plugins的一些基本用法，当loader和plugins使用较多后项目也会越来越耗时，因此这次我们继续学习如何优化webpack的配置来让我们的项目运行的更快耗时更短。\n\n　　本文将从缩小文件搜索范围、减少打包文件、缓存和多进程四个方面来了解Webpack的优化配置。\n\n\n# 缩小文件搜索范围\n\n　　Webpack会从Entry入口出发，解析文件中的导入模块语句，再递归解析；每次遇到导入语法时会做两件事情：\n\n1. 查找导入模块的位置，比如``require('vue')``就去引入``/node_modules/vue/dist/vue.runtime.common.js``文件\n2. 通过相应的loader来解析导入的模块，比如引入的js就调用babel-loader来转换代码\n\n　　当项目只有几个文件时，解析文件流程只有几百毫秒，然而随着项目规模的增大，解析文件会越来越耗时，因此我们通过webpack的配置来缩小我们搜索模块的范围\n\n\n## 优化loader配置\n\n　　在上一篇中，我们介绍了使用``include/exclude``将node_modules中的文件进行包括/排除。\n\n```js\n{\n    rules: [{\n        test: /\\.js$/,\n        use: {\n            loader: 'babel-loader'\n        },\n        // exclude: /node_modules/,\n        include: [path.resolve(__dirname, 'src')]\n    }]\n}\n```\n\n　　``include``表示哪些目录中的文件需要进行babel-loader，``exclude``表示哪些目录中的文件不要进行babel-loader。这是因为在引入第三方模块的时候，很多模块已经是打包后的，不需要再被处理，比如vue、jQuery等；如果不设置``include/exclude``就会被loader处理，增加打包时间。\n\n\n## 优化module.noParse配置\n\n\n　　如果一些第三方模块没有使用AMD/CommonJs规范，可以使用``noParse``来标记这个模块，这样Webpack在导入模块时，就不进行解析和转换，提升Webpack的构建速度；noParse可以接受一个正则表达式或者一个函数：\n\n```js\n{\n    module: {\n        //noParse: /jquery|lodash|chartjs/,\n        noParse: function(content){\n            return /jquery|lodash|chartjs/.test(content)\n        }\n    }\n}\n```\n\n\n　　对于jQuery、lodash、chartjs等一些库，庞大且没有采用模块化标准，因此我们可以选择不解析他们。\n\n> 注：被不解析的模块文件中不应该包含``require``、``import``等模块语句\n\n![noParse.png](https://xieyufei.com/images/Webpack-Optimize/noParse.png)\n\n　　经过多次打包尝试，打包性能大概能提升10%~20%；本实例完整代码[demo](https://github.com/acexyf/WebpackDemo/tree/master/demo13)，\n\n\n## 优化resolve.modules配置\n\n　　modules用于告诉webpack去哪些目录下查找引用的模块，默认值是``[\"node_modules\"]``，意思是在``./node_modules``查找模块，找不到再去``../node_modules``，以此类推。\n\n　　我们代码中也会有大量的模块被其他模块依赖和引入，由于这些模块位置分布不固定，路径有时候会很长，比如``import '../../src/components/button'``、``import '../../src/utils'``；这时我们可以利用modules进行优化\n\n```js\n{\n  resolve: {\n    modules: [\n      path.resolve(__dirname, \"src\"),\n      path.resolve(__dirname, \"node_modules\"),\n      \"node_modules\",\n    ],\n  },\n}\n```\n\n　　这样我们可以简单的通过``import 'components/button'``、``import 'utils'``进行导入，webpack会会优先从``src``目录下进行查找\n\n\n## 优化resolve.alias配置\n\n\n　　alias通过创建import或者require的别名，把原来导入模块的路径映射成一个新的导入路径；它和``resolve.modules``不同的的是，它的作用是用别名代替前面的路径，不是省略；这样的好处就是webpack直接会去对应别名的目录查找模块，减少了搜索时间。\n\n```js\n{\n  resolve: {\n    alias: {\n      '@': path.resolve(__dirname, 'src'),\n    },\n  },\n}\n```\n\n　　这样我们就能通过``import Buttom from '@/Button'``来引入组件了；我们不光可以给自己写的模块设置别名，还可以给第三方模块设置别名：\n\n```js\n{\n  resolve: {\n    alias: {\n      'vue$': isDev ? 'vue/dist/vue.runtime.js' : 'vue/dist/vue.runtime.min.js',\n    },\n  },\n}\n```\n\n　　我们在``import Vue from 'vue'``时，webpack就会帮我们去vue依赖包的dist文件下面引入对应的文件，减少了搜索package.json的时间。\n\n\n## 优化resolve.mainFields配置\n\n　　mainFields用来告诉webpack使用第三方模块中的哪个字段来导入模块；第三方模块中都会有一个``package.json``文件用来描述这个模块的一些属性，比如模块名(name)、版本号(version)、作者(auth)等等；其中最重要的就是有多个特殊的字段用来告诉webpack导入文件的位置，有多个字段的原因是因为有些模块可以同时用于多个环境，而每个环境可以使用不同的文件。\n\n\n　　mainFields的默认值和当前webpack配置的``target``属性有关：\n\n* 如果target为``webworker``或``web``（默认），mainFields默认值为``[\"browser\", \"module\", \"main\"]``\n* 如果target为其他（包括node），mainFields默认值为``[\"module\", \"main\"]``\n\n\n　　这就是说当我们``require('vue')``的时候，webpack先去vue下面搜索browser字段，没有找到再去搜索module字段，最后搜索main字段。\n\n　　为了减少搜索的步骤，在明确第三方模块入口文件描述字段时，我们可以将这个字段设置尽量少；一般第三方模块都采用``main``字段，因此我们可以这样配置：\n\n```js\n{\n    resolve: {\n        mainFields: [\"main\"],\n    }\n}\n```\n\n\n## 优化resolve.extensions配置\n\n　　extensions字段用来在导入模块时，自动带入后缀尝试去匹配对应的文件，它的默认值是：\n\n```js\n{\n    resolve: {\n        extensions: ['.js', '.json']\n    }\n}\n```\n\n　　也就是说我们在``require('./utils')``时，Webpack先匹配``utils.js``，匹配不到再去匹配``utils.json``，如果还找不到就报错。\n\n　　因此``extensions``数组越长，或者正确后缀的文件越靠后，匹配的次数越多也就越耗时，因此我们可以从以下几点来优化：\n\n\n1. extensions数组尽量少，项目中不存在的文件后缀不要列进去\n2. 出现频率比较高的文件后缀优先放到最前面\n3. 在代码中导入文件的时候，要尽量把后缀名带上，避免查找\n\n　　以上实例完整代码[demo](https://github.com/acexyf/WebpackDemo/tree/master/demo9)。\n\n\n\n\n# 减少打包文件\n\n　　在我们项目中不可避免会引入第三方模块，webpack打包时也会将第三方模块作为依赖打包进bundle中，这样就会增加打包文件尺寸和增加耗时，如果能合理得处理这些模块就能提升不少webpack的性能。\n\n\n## 提取公共代码\n\n　　我们的项目通常有多个页面或者多个页面模块（单页面），多个页面之间通常都有公用的函数或者第三方模块，在每个页面中都打包这些模块会造成以下问题：\n\n* 资源重复加载，浪费用户流量\n* 每个页面加载资源多，首屏展示慢\n\n　　在Webpack4之前，都是通过CommonsChunkPlugin插件来提取公共代码，然而存在着以下问题\n\n* 产出的chunk在引入的时候，会包含重复的代码\n* 无法优化异步chunk\n\n　　Webpack4引入了``SplitChunksPlugin``插件进行公共模块的抽取；由于webpack4开箱即用的特性，它不用单独安装，通过``optimization.splitChunks``进行配置即可，官方给的默认配置参数如下：\n\n```js\nmodule.exports = {\n  optimization: {\n    splitChunks: {\n      // 代码分割时默认对异步代码生效，all：所有代码有效，inital：同步代码有效\n      chunks: 'async',\n      // 代码分割最小的模块大小，引入的模块大于 20000B 才做代码分割\n      minSize: 20000,\n      // 代码分割最大的模块大小，大于这个值要进行代码分割，一般使用默认值\n      maxSize: 0, \n      // 引入的次数大于等于1时才进行代码分割\n      minChunks: 1,\n      // 最大的异步请求数量,也就是同时加载的模块最大模块数量\n      maxAsyncRequests: 30,\n      // 入口文件做代码分割最多分成 30 个 js 文件\n      maxInitialRequests: 30, \n      // 文件生成时的连接符\n      automaticNameDelimiter: '~', \n      enforceSizeThreshold: 5000,\n      cacheGroups: {\n        vendors: {\n          // 位于node_modules中的模块做代码分割\n          test: /[\\\\/]node_modules[\\\\/]/, \n          // 根据优先级决定打包到哪个组里，例如一个 node_modules 中的模块进行代码\n          priority: -10 \n        }, \n        // 既满足 vendors，又满足 default，那么根据优先级会打包到 vendors 组中。\n        default: { \n          // 没有 test 表明所有的模块都能进入 default 组，但是注意它的优先级较低。\n          //  根据优先级决定打包到哪个组里,打包到优先级高的组里。\n          priority: -20, \n           //如果一个模块已经被打包过了,那么再打包时就忽略这个上模块\n          reuseExistingChunk: true \n        }\n      }\n    }\n  }\n};\n```\n\n\n　　我们在home、list、detail三个页面分别引入了vue.js、axios.js和公用的工具函数模块utils.js；我们首先将使用到的第三方模块提取到一个单独的文件，这个文件包含了项目的基础运行环境，一般称为``vendors.js``；在抽离第三方模块后我们将每个页面都依赖的公共代码提取出来，放到``common.js``中。\n\n\n```js\nmodule.exports = {\n  optimization: {\n    splitChunks: {\n      chunks: 'initial',\n      cacheGroups: {\n        vendors: {\n          test: /[\\\\/]node_modules[\\\\/]/,\n          priority: 10,\n          name: 'vendors'\n        },\n        common: {\n          test: /[\\\\/]src[\\\\/]/,\n          priority: 5,\n          name: 'common'\n        }\n      }\n    }\n  }\n}\n```\n\n\n　　有时候项目依赖模块比较多，``vendors.js``文件会特别大，我们还可以对它进一步拆分，按照模块划分：\n\n```js\n\n{\n  //省略其他配置\n  cacheGroups: {\n    //涉及vue的模块\n    vue: {\n      test: /[\\\\/]node_modules[\\\\/](vue|vuex|vue-router)/,\n      priority: 10,\n      name: 'vue'\n    },\n    //其他模块\n    vendors: {\n      test: /[\\\\/]node_modules[\\\\/]/,\n      priority: 9,\n      name: 'vendors'\n    },\n    common: {\n      test: /[\\\\/]src[\\\\/]/,\n      priority: 5,\n      name: 'common'\n    }\n  }\n}\n```\n\n\n## 动态链接DllPlugin\n\n　　DLL即动态链接库（Dynamic-Link Library）的缩写，熟悉Windows系统的童鞋在电脑中也经常能看到后缀是dll的文件，偶尔电脑弹框警告也是因为电脑中缺失了某些dll文件；DLL最初用于节约应用程序所需的磁盘和内存空间，当多个程序使用同一个函数库时，DLL可以减少在磁盘和内存中加载代码的重复量，有助于代码的复用。\n\n　　在Webpack中也引入了DLL的思想，把我们用到的模块抽离出来，打包到单独的动态链接库中去，一个动态链接库中可以有多个模块；当我们在多个页面中用到某一个模块时，不再重复打包，而是直接去引入动态链接库中的模块。\n\n　　Webpack中集成了对动态链接库的支持，主要用到的两个插件：\n\n* DllPlugin：创建动态链接库文件\n* DllReferencePlugin：在主配置中引入打包好的动态链接库文件\n\n\n　　我们首先使用DllPlugin来创建动态链接库文件，在项目下新建``webpack.dll.js``文件：\n\n```js\nconst path = require(\"path\");\nconst webpack = require(\"webpack\");\n\nmodule.exports = {\n  mode: \"production\",\n  entry: {\n    vue: [\"vue\", \"vuex\", \"vue-router\"],\n    vendor: [\"dayjs\", \"axios\", \"mint-ui\"],\n  },\n  output: {\n    path: path.resolve(__dirname, \"public/vendor\"),\n    // 指定文件名\n    filename: \"[name].dll.js\",\n    //暴露全局变量的名称\n    library: \"[name]_dll_lib\",\n  },\n  plugins: [\n    new webpack.DllPlugin({\n      path: path.join(__dirname, \"public\", \"vendor\", \"[name].manifest.json\"),\n      name: \"[name]_dll_lib\",\n    }),\n  ],\n};\n```\n\n　　这里``entry``设置了多个入口，每个入口也有多个模块文件；然后在``package.json``添加打包命令\n\n```json\n{\n    \"scripts\":{\n        \"build:dll\": \"webpack --config=webpack.dll.js\"\n    }\n}\n```\n\n\n　　执行``npm run build:dll``后，我们在``/public/vendor``目录下得到了我们打包后的动态链接库的文件：\n\n```\n├── vendor.dll.js\n├── vendor.manifest.json\n├── vue.dll.js\n└── vue.manifest.json\n```\n\n\n　　生成出来的打包文件正好是以两个入口名来命名的，以vue为例，看一下``vue.dll.js``的内容：\n\n\n```js\nvar vue_dll_lib =\n/******/ (function(modules) { \n    // 省略webpackBootstrap代码\n/******/ })\n/******/ ({\n\n/***/ \"./node_modules/vue-router/dist/vue-router.esm.js\":\n/***/ (function(module, exports, __webpack_require__) {\n    //省略vue-router模块代码\n/***/ }),\n\n/***/ \"./node_modules/vue/dist/vue.runtime.esm.js\":\n/***/ (function(module, exports, __webpack_require__) {\n    //省略vue模块代码\n/***/ }),\n\n/***/ \"./node_modules/vuex/dist/vuex.esm.js\":\n/***/ (function(module, exports, __webpack_require__) {\n    //省略vuex模块代码\n/***/ }),\n\n/******/ });\n```\n\n\n　　可以看出，动态链接库中包含了引入模块的所有代码，这些代码存在一个对象中，通过模块路径作为键名来进行引用；并且通过vue_dll_lib暴露到全局；vue.manifest.json则是用来描述动态链接库文件中包含了哪些模块：\n\n\n```json\n{\n    \"name\": \"vue_dll_lib\",\n    \"content\": {\n        \"./node_modules/vue-router/dist/vue-router.esm.js\": {\n            \"id\": \"./node_modules/vue-router/dist/vue-router.esm.js\",\n            \"buildMeta\": {}\n        },\n        \"./node_modules/vue/dist/vue.runtime.esm.js\": {\n            \"id\": \"./node_modules/vue/dist/vue.runtime.esm.js\",\n            \"buildMeta\": {}\n        },\n        \"./node_modules/vuex/dist/vuex.esm.js\": {\n            \"id\": \"./node_modules/vuex/dist/vuex.esm.js\",\n            \"buildMeta\": {}\n        },\n    }\n}\n```\n\n　　manifest.json描述了对应js文件包含哪些模块，以及对应模块的键名（id），这样我们在模板页面中就可以将动态链接库作为外链引入，当Webpack解析到对应模块时就通过全局变量来获取模块：\n\n\n```html\n<!-- public/index.html -->\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n    <title>Document</title>\n</head>\n<body>\n    <div id=\"app\"></div>\n    <!-- 引入动态链接库 -->\n    <script src=\"./vendor/vendor.dll.js\"></script>\n    <script src=\"./vendor/vue.dll.js\"></script>\n</body>\n</html>\n```\n\n　　最后我们在打包时，通过``DllReferencePlugin``将动态链接库引入到主配置中：\n\n```js\n//webpack.config.js\n{\n    plugins: [\n        new webpack.DllReferencePlugin({\n            context: path.join(__dirname),\n            manifest: require('./public/vendor/vendor.manifest.json')\n        }),\n        new webpack.DllReferencePlugin({\n            context: path.join(__dirname),\n            manifest: require('./public/vendor/vue.manifest.json')\n        }),\n    ]\n}\n```\n\n> 注：动态链接库打包到``/public/vendor``目录下，还需要通过``CopyWebpackPlugin``插件将它拷贝到生成后的目录中，否则会出现引用失败的报错；打包动态链接库文件只需要执行一次，除非以后模块升级或者引入新的模块。\n\n\n　　引入动态链接库可以将项目中一些不经常更新的模块放到外部文件中，我们再次打包页面逻辑代码时会发现构建速度有了比较大的提升，大概30%~40%，相关代码在[demo10](https://github.com/acexyf/WebpackDemo/tree/master/demo10)。\n\n## externals\n\n\n　　我们在项目打包时，有一些第三方的库会从CDN引入（比如jQuery等），如果在bundle中再次打包项目就过于臃肿，我们就可以通过配置``externals``将这些库在打包的时候排除在外。\n\n\n```js\n{\n  externals: {\n    'jquery': \"jQuery\",\n    'react': 'React',\n    'react-dom': 'ReactDOM',\n    'vue': 'Vue'\n  }\n}\n```\n\n　　这样就表示当我们遇到``require('jquery')``时，从全局变量去引用``jQuery``，其他几个包也同理；这样打包时就把jquery、react、vue和react-dom从bundle中剔除了，本实例完整代码[demo](https://github.com/acexyf/WebpackDemo/tree/master/demo15)。\n\n\n\n## Tree Shaking\n\n　　Tree Shaking最早由rollup实现，后来webpack2页实现了这项功能；Tree Shaking的字面意思是摇树，一棵树上有一些树叶虽然还挂着，但是它可能已经死掉了，通过摇树方式把这些死掉的树叶去除。\n\n![tree_shake.gif](https://xieyufei.com/images/Webpack-Optimize/tree_shake.gif)\n\n\n　　我们项目中也是同样的，我们并没有用到文件的所有模块，但是webpack仍会将整个文件打包进来，文件中一直用不到的代码就是“死代码”；这种情况就用用到``Tree Shaking``帮我们剔除这些用不到的代码模块。\n\n\n　　比如我们定义了一个``utils.js``文件导出了很多工具模块，然后在``index.js``中只引用了某些模块：\n\n```js\n//utils.js\nvar toString = Object.prototype.toString;\n\nexport function isArray(val) {\n  return toString.call(val) === '[object Array]';\n}\nexport function isFunction(val) {\n  return toString.call(val) === '[object Function]';\n}\nexport function isDate(val) {\n  return toString.call(val) === '[object Date]';\n}\n//index.js\nimport { isArray } from './utils'\nisArray()\n```\n\n　　我们希望在代码中只打包``isArray``函数到bundle中；需要注意的是，为了让Tree Shaking生效，我们需要使用ES6模块化的语法，因为ES6模块语法是静态化加载模块，它有以下特点：\n\n1. 静态加载模块，效率比CommonJS 模块的加载方式高\n2. ES6 模块是编译时加载，使得静态分析成为可能进一步拓宽JS的语法\n\n　　如果是``require``，在运行时确定模块，那么将无法去分析模块是否可用，只有在编译时分析，才不会影响运行时的状态。\n\n\n　　使用ES6模块后还有一个问题，因为我们的代码一般都采用babel进行编译，而babel的preset默认会将任何模块类型编译成Commonjs，因此我们还需要修改``.babelrc``配置文件：\n\n```js\n{\n  \"presets\": [\n    [\n      \"@babel/preset-env\",\n      {\n        //添加modules：false\n        \"modules\": false\n      }\n    ]\n  ]\n}\n```\n\n　　配置好babel后我们需要让webpack先将“死代码”标识出来：\n\n```js\n{\n  //其他配置\n  optimization: {\n    usedExports: true,\n    sideEffects: true,\n  }\n}\n```\n\n　　运行打包命令后，当我们打开输出的bundle文件时，我们发现虽然一些“死代码”还存在里面，但是加上了一个``unused harmony export``的标识\n\n\n```js\n/* unused harmony export isFunction */\n/* unused harmony export isDate */\nvar toString = Object.prototype.toString;\nfunction isFunction(val) {\n  return toString.call(val) === '[object Function]';\n}\nfunction isDate(val) {\n  return toString.call(val) === '[object Date]';\n}\n```\n\n　　虽然webpack给我们指出了哪些函数用不上，但是还需要我们通过插件来剔除；由于``uglifyjs-webpack-plugin``不支持ES6语法，这里我们使用``terser-webpack-plugin``的插件来代替它：\n\n```js\nconst TerserJSPlugin = require(\"terser-webpack-plugin\");\nmodule.exports = {\n  optimization: {\n    usedExports: true,\n    sideEffects: true,\n    minimize: true,\n    minimizer: [\n      new TerserJSPlugin({\n        cache: true,\n        parallel: true, \n        sourceMap: false,\n      }),\n    ],\n  }\n}\n```\n\n　　这样我们发现打包出来的文件就没有多余的代码了。\n\n> 注： Tree Shaking在生产环境（production）是默认开启的\n\n　　对于我们常用的一些第三方模块，我们也可以实现Tree Shaking；以``lodash``为例，它整个包有非常多的函数，但并不是所有的函数都是我们所用到的，因此我们也需要对它没有用到的代码进行剔除。\n\n\n```js\n//index.js\nimport { chunk } from 'lodash'\nconsole.log(chunk([1,2,3,4], 2))\n```\n\n　　打包出来发现包的大小还是能达到70+kb，如果只引用了chunk不应该有这么大；我们打开``/node_modules/lodash/index.js``发现他还是使用了require的模式导入导出模块，因此导致Tree Shaking失败；我们先安装使用ES6模块版本的lodash：``npm i -S lodash-es``，然后修改引入包：\n\n```js\n//index.js\nimport { chunk } from 'lodash-es'\nconsole.log(chunk([1,2,3,4], 2))\n```\n\n　　这样我们生成的bundle包就小很多；本实例完整代码[demo](https://github.com/acexyf/WebpackDemo/tree/master/demo12)。\n\n# 缓存\n\n\n　　我们知道webpack会对不同的文件调用不同的loader进行解析处理，解析的过程也是最耗性能的过程；我们每次改代码也只是修改项目中的少数文件，项目中的大部分文件改动的次数不是那么频繁；那么如果我们将解析文件的结果缓存下来，下次发现同样的文件只需要读取缓存就能极大的提升解析的性能。\n\n\n## cache-loader\n\n　　cache-loader可以将一些对性能消耗比较大的loader生产的结果缓存在磁盘中，等下次再次打包时如果是相同的代码就可以直接读取缓存，减少性能消耗。\n\n> 注：保存和读取缓存也会产生额外的性能开销，因此cache-loader适合用于对性能消耗较大的loader，否则反而会增加性能消耗\n\n　　cache-loader的使用也非常简单，安装后在所需要缓存的loader前面添加即可（因为loader加载的顺序是反向的），比如我们需要给``babel-loader``添加缓存：\n\n```js\n{\n  //省略其他代码\n  rules: [\n    {\n      test: /\\.js/,\n      use: [\n        {\n          loader: 'cache-loader'\n        },\n        {\n          loader: \"babel-loader\",\n        },\n      ],\n    },\n  ],\n}\n```\n\n　　然而我们发现第一次打包的速度并没有发生明显变化，甚至可能还比原来打包的更慢了；同时还多了``/node_modules/.cache/cache-loader/``这个目录，看名字就是一个缓存文件；我们继续打包，下面图表记录了我几次打包的耗时：\n\n![cache-loader-time.png](https://xieyufei.com/images/Webpack-Optimize/cache-loader-time.png)\n\n\n　　我们发现第一次打包时间都差不多，但是第二次开始缓存文件就开始发挥了重要的作用了，直接减少了75%的耗时。\n\n\n　　除了使用cache-loader，babel-loader也提供缓存功能，通过``cacheDirectory``进行配置：\n\n```js\n{\n  rules: [\n    {\n      test: /\\.js/,\n      use: [\n        {\n          loader: \"babel-loader\",\n          options: {\n            cacheDirectory: true\n          }\n        },\n      ],\n    },\n  ],\n}\n```\n\n\n　　在``/node_modules/.cache/babel-loader``也多了缓存文件。经过两个使用结果的对比，cache-loader的性能提升更加出色一些；本实例完整代码[demo](https://github.com/acexyf/WebpackDemo/tree/master/demo16)。\n\n\n## HardSourceWebpackPlugin\n\n　　HardSourceWebpackPlugin也可以为模块提供缓存功能，同意也是将文件缓存在磁盘中\n\n　　首先通过``npm i -D hard-source-webpack-plugin``来安装插件，并且在配置中添加插件：\n\n\n```js\nvar HardSourceWebpackPlugin = \n    require('hard-source-webpack-plugin');\nmodule.exports = {\n  plugins: [\n    new HardSourceWebpackPlugin()\n  ]\n}\n```\n\n　　一般HardSourceWebpackPlugin默认缓存是在``/node_modules/.cache/hard-source/[hash]``目录下，我们可以设置它的缓存目录和何时创建新的缓存哈希值。\n\n```js\nmodule.exports = {\n  plugins: [\n    new HardSourceWebpackPlugin({\n      //设置缓存目录的路径\n      //相对路径或者绝对路径\n      cacheDirectory: 'node_modules/.cache/hard-source/[confighash]',\n      //构建不同的缓存目录名称\n      //也就是cacheDirectory中的[confighash]值\n      configHash: function(webpackConfig) {\n        return require('node-object-hash')({sort: false}).hash(webpackConfig);\n      },\n      //环境hash\n      //当loader、plugin或者其他npm依赖改变时进行替换缓存\n      environmentHash: {\n        root: process.cwd(),\n        directories: [],\n        files: ['package-lock.json', 'yarn.lock'],\n      },\n      //自动清除缓存\n      cachePrune: {\n        //缓存最长时间（默认2天）\n        maxAge: 2 * 24 * 60 * 60 * 1000,\n        //所有的缓存大小超过size值将会被清除\n        //默认50MB\n        sizeThreshold: 50 * 1024 * 1024\n      },\n    })\n  ]\n}\n```\n\n![hard-source.png](https://xieyufei.com/images/Webpack-Optimize/hard-source.png)\n\n　　通过尝试多次打包，发现能节省大概90%的时间；本实例完整代码[demo](https://github.com/acexyf/WebpackDemo/tree/master/demo17)。\n\n\n\n# 多进程\n\n　　我们在[事件循环中](http://xieyufei.com/2019/12/30/Quiz-Eventloop.html)讲到过，js是一门单线程的语言，在同一事件线上只有一个线程在处理任务；因此在webpack解析到JS、CSS、图片或者字体文件时，它需要一个个的去解析编译，不能同时处理多个任务；我们可以通过插件来将任务分给多个子进程去并发执行，子进程处理完成后再将结果发送给主进程。\n\n\n## happypack\n\n　　happypack会自动帮我们分解任务和管理进程，通过名字我们也能看出来，这是一款能够带来快乐的插件。\n\n![enough.gif](https://xieyufei.com/images/Webpack-Optimize/enough.gif)\n\n　　我们通过``npm i -D happypack``后就能在webpack中进行配置了：\n\n```js\nconst happypack = require(\"happypack\");\nmodule.exports = {\n  module: {\n    rules: [\n      {\n        test: /\\.js/,\n        exclude: /node_modules/,\n        //将js文件处理给id为js的happypack实例\n        use: \"happypack/loader?id=js\",\n      }\n    ],\n  },\n  plugins: [\n    //通过id标识当前happypack是处理什么文件的\n    new happypack({\n      id: \"js\",\n      //调用处理文件的loader，用法和rules中一致\n      loaders: [{\n          loader: \"babel-loader\",\n        },\n        {\n          loader: \"eslint-loader\",\n        },\n      ],\n    }),\n  ],\n}\n```\n\n　　我们将``rules/loader``的处理全部交给了happypack进行处理，并且通过id来调用具体的实例，然后在实例中配置具体的loader进行处理；在happypack的实例中除了id和loaders我们还可以配置进程数量：\n\n\n```js\n//共享进程池，进程池中包含5个子进程\nvar happyThreadPool = happypack.ThreadPool({\n  size: 5\n});\n{\n  plugins: [\n    new happypack({\n      id: \"js\",\n      //开启几个子进程，默认3个\n      threads: 3,\n      //共享进程池\n      threadPool: happyThreadPool,\n      //是否允许 HappyPack 输出日志\n      verbose: true,\n      loaders: [{\n          loader: \"babel-loader\",\n        },\n        {\n          loader: \"eslint-loader\",\n        },\n      ],\n    }),\n  ],\n}\n```\n\n> 注：threads和threadPool字段只需要配置一个即可。\n\n\n　　我们通过``happypack.ThreadPool``创建了一个包含5个子进程的共享进程池，每个happypack实例可以通过共享进程池来处理文件；相对于给每个happypack实例分配进程，这样可以防止占用过多无用的进程；我们打包看一下所耗时间：\n\n\n\n![happypack.png](https://xieyufei.com/images/Webpack-Optimize/happypack.png)\n\n\n　　我们发现有了happypack耗时居然还增加了20%~30%，说好的多进程带来快乐呢。\n\n![catch_up.png](https://xieyufei.com/images/Webpack-Optimize/catch_up.png)\n\n　　由于我们的项目不够庞大，而加载多进程也需要耗费时间和性能，因此我们才会出现使用了happypack反而增加耗时的情况；所以一般happypack适用于比较大的项目中；本实例完整代码[demo](https://github.com/acexyf/WebpackDemo/tree/master/demo11)。\n\n\n\n## thread-loader\n\n\n　　把thread-loader放置在其他loader之前，在它之后的loader就会在一个单独的进程池中运行，但是在进程池中运行的loader有以下限制：\n\n\n* 这些 loader 不能产生新的文件。\n* 这些 loader 不能使用定制的 loader API（也就是说，通过插件）。\n* 这些 loader 无法获取 webpack 的选项设置。\n\n\n　　因此，也就是说像``MiniCssExtractPlugin.loader``等一些提取css的loader是不能使用thread-loader的；跟happypack一样，它也只适合用于文件较多的大项目：\n\n```js\nmodule.exports = {\n  module: {\n    rules: [\n      {\n        test: /\\.js$/,\n        use: [\n          \"thread-loader\",\n          \"babel-loader\"\n        ]\n      }\n    ]\n  }\n}\n```\n\n　　本实例完整代码[demo](https://github.com/acexyf/WebpackDemo/tree/master/demo18)。\n\n作者好文推荐：\n\n[Webpack配置全解析（基础篇）](https://xieyufei.com/2020/06/06/Webpack-Learned.html)\n\n[从零开始手写Promise](https://xieyufei.com/2020/05/20/Handwrite-Promise.html)\n\n[面试完50个人后我写下这篇总结](https://xieyufei.com/2019/11/08/Front-Summary.html)\n\n更多前端资料请关注公众号``【前端壹读】``。\n\n<img src=\"https://user-gold-cdn.xitu.io/2019/12/12/16ef8eedca3f7ac8?w=820&h=1148&f=png&s=207033\" style=\"width:50%;margin:0 auto;\" class=\"follow_img\" />\n\n如果觉得写得还不错，请关注我的<a href=\"//juejin.im/user/580038cebf22ec0064bd0b2d\" style=\"color:#f63;text-decoration:none;\">掘金主页</a>。更多文章请访问<a href=\"http://xieyufei.com\" style=\"color:#f63;text-decoration:none;\">谢小飞的博客</a>\n\n\n\n", "user_name": "谢小飞", "description": "没事喜欢写写代码看看书", "got_view_count": 209183, "category_name": "前端", "ctime": 1457483942}
{"tag_name": "LeakCanary", "concern_user_count": 1250, "user_id": "4441682709326958", "title": "LeakCanary源码分析以及ContentProvider的优化方案", "mark_content": "#### 1.使用\n\nLeakCancary 2.0使用，只需要配置如下代码，便可以进行使用，比LeakCanary1.0不知道高到哪里去了~\n\n```Java\ndebugImplementation 'com.squareup.leakcanary:leakcanary-android:2.0-alpha-2'\n```\n\n#### 2.源码分析\n\n阅读源码后可以看到leakcancary-leaksentry模块的Androidmanifest文件，可以看到下面的内容：\n\n```java\n<?xml version=\"1.0\" encoding=\"utf-8\"?>\n<manifest\n    xmlns:android=\"http://schemas.android.com/apk/res/android\"\n    package=\"com.squareup.leakcanary.leaksentry\"\n    >\n\n  <application>\n    <provider\n        android:name=\"leakcanary.internal.LeakSentryInstaller\"\n        android:authorities=\"${applicationId}.leak-sentry-installer\"\n        android:exported=\"false\"/>\n  </application>\n</manifest>\n```\n\n然后我们可以看到LeakSentryInstaller这个类到底做了什么\n\n```java\ninternal class LeakSentryInstaller : ContentProvider() {\n\n  override fun onCreate(): Boolean {\n    CanaryLog.logger = DefaultCanaryLog()\n    val application = context!!.applicationContext as Application\n    //利用系统自动调用ContentProvider的onCreate来进行安装\n    InternalLeakSentry.install(application)\n    return true\n  }\n  ...\n```\n\n至于为什么系统会调用ContentProvider的onCreate方法，我们可以看看源码，在ActivityThread中的H中的handleMessage可以看到\n\n```Java\npublic void handleMessage(Message msg) {\n    if (DEBUG_MESSAGES) Slog.v(TAG, \">>> handling: \" + codeToString(msg.what));\n    switch (msg.what) {\n        case BIND_APPLICATION:\n            Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, \"bindApplication\");\n            AppBindData data = (AppBindData)msg.obj;\n            //关键方法\n            handleBindApplication(data);\n            Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);\n            break;\n```\n\n然后在handleBindApplication中可以看到\n\n```java\n// don't bring up providers in restricted mode; they may depend on the\n// app's custom Application class\nif (!data.restrictedBackupMode) {\n    if (!ArrayUtils.isEmpty(data.providers)) {\n        //contentprovider初始化，里面会调用onCreate方法\n        installContentProviders(app, data.providers);\n    }\n}\n\n// Do this after providers, since instrumentation tests generally start their\n// test thread at this point, and we don't want that racing.\ntry {\n    mInstrumentation.onCreate(data.instrumentationArgs);\n}\ncatch (Exception e) {\n    throw new RuntimeException(\n        \"Exception thrown in onCreate() of \"\n        + data.instrumentationName + \": \" + e.toString(), e);\n}\ntry {\n    //app的onCreate方法调用\n    mInstrumentation.callApplicationOnCreate(app);\n} catch (Exception e) {\n```\n\n具体调用contentprovider的onCreate代码逻辑如下\n\n```java\n@UnsupportedAppUsage\nprivate void installContentProviders(\n        Context context, List<ProviderInfo> providers) {\n    final ArrayList<ContentProviderHolder> results = new ArrayList<>();\n\n    for (ProviderInfo cpi : providers) {\n        ···\n        //installProvider方法\n        ContentProviderHolder cph = installProvider(context, null, cpi,\n                false /*noisy*/, true /*noReleaseNeeded*/, true /*stable*/);\n        if (cph != null) {\n            cph.noReleaseNeeded = true;\n            results.add(cph);\n        }\n    }\n  //installProvider方法，然后一步步跟进\n  //1\n  //XXX Need to create the correct context for this provider.\n  localProvider.attachInfo(c, info);\n  //2\n\tpublic void attachInfo(Context context, ProviderInfo info) {\n        attachInfo(context, info, false);\n   }\n  //3\n  private void attachInfo(Context context, ProviderInfo info, boolean testing) {\n        mNoPerms = testing;\n        mCallingPackage = new ThreadLocal<>();\n        if (mContext == null) {\n            ···\n            ContentProvider.this.onCreate();\n        }\n    }\n```\n\n通过上面的分析，可以知道在我们引入依赖后，依赖包中的AndroidMainfest.xml文件便会主动合并到主AndroidManifest.xml文件中，然后在程序启动过程中便会自动创建ContentProvider，然后进行InternalLeakSentry.install(application)，接下来进行一些列的监控和dump操作等。\n\n##### 2.1 InternalLeakSentry.install(application)\n\n下面来分析InternalLeakSentry.install(application)里面都做了一些什么，可以看到\n\n```java\nfun install(application: Application) {\n    CanaryLog.d(\"Installing LeakSentry\")\n    checkMainThread()\n    if (this::application.isInitialized) {\n      return\n    }\n    InternalLeakSentry.application = application\n\n    val configProvider = { LeakSentry.config }\n    // 1.监听 Activity.onDestroy()\n    ActivityDestroyWatcher.install(\n        application, refWatcher, configProvider\n    )\n    // 2.监听 Fragment.onDestroy()\n    FragmentDestroyWatcher.install(\n        application, refWatcher, configProvider\n    )\n    // 3.监听完成后进行一些初始化工作\n    listener.onLeakSentryInstalled(application)\n  }\n```\n\n从命名上可以看到在Activity和Fragment进行destory的时候进行watch\n\n1. ActivityDestroyWatcher\n\n```java\ninternal class ActivityDestroyWatcher private constructor(\n  private val refWatcher: RefWatcher,\n  private val configProvider: () -> Config\n) {\n\n  private val lifecycleCallbacks = object : ActivityLifecycleCallbacksAdapter() {\n    override fun onActivityDestroyed(activity: Activity) {\n      if (configProvider().watchActivities) {\n        // 监听到 onDestroy() 之后，通过 refWatcher 监测 Activity\n        refWatcher.watch(activity)\n      }\n    }\n  }\n\n  companion object {\n    fun install(\n      application: Application,\n      refWatcher: RefWatcher,\n      configProvider: () -> Config\n    ) {\n      val activityDestroyWatcher =\n        ActivityDestroyWatcher(refWatcher, configProvider)\n      application.registerActivityLifecycleCallbacks(activityDestroyWatcher.lifecycleCallbacks)\n    }\n  }\n}\n```\n\n2. FragmentDestroyWatcher\n\n```java\ninternal interface FragmentDestroyWatcher {\n\n  fun watchFragments(activity: Activity)\n\n  companion object {\n\n    private const val SUPPORT_FRAGMENT_CLASS_NAME = \"androidx.fragment.app.Fragment\"\n\n    fun install(\n      application: Application,\n      refWatcher: RefWatcher,\n      configProvider: () -> LeakSentry.Config\n    ) {\n      val fragmentDestroyWatchers = mutableListOf<FragmentDestroyWatcher>()\n\n      //大于等于android O  \n      if (SDK_INT >= O) {\n        fragmentDestroyWatchers.add(\n            AndroidOFragmentDestroyWatcher(refWatcher, configProvider)\n        )\n      }\n\n      if (classAvailable(\n              SUPPORT_FRAGMENT_CLASS_NAME\n          )\n      ) {\n        // androidx 使用 SupportFragmentDestroyWatcher\n        fragmentDestroyWatchers.add(\n            SupportFragmentDestroyWatcher(refWatcher, configProvider)\n        )\n      }\n\n      if (fragmentDestroyWatchers.size == 0) {\n        return\n      }\n\n      application.registerActivityLifecycleCallbacks(object : ActivityLifecycleCallbacksAdapter() {\n        override fun onActivityCreated(\n          activity: Activity,\n          savedInstanceState: Bundle?\n        ) {\n          for (watcher in fragmentDestroyWatchers) {\n            watcher.watchFragments(activity)\n          }\n        }\n      })\n    }\n\n    private fun classAvailable(className: String): Boolean {\n      return try {\n        Class.forName(className)\n        true\n      } catch (e: ClassNotFoundException) {\n        false\n      }\n    }\n  }\n}\n```\n\nAndroid O 及以后，androidx 都具备对 Fragment 生命周期的监听功能。为什么不监听Android O之前的呢？？？（待解决）\n在版本为1.5.4之前是不支持Fragment内存泄漏监听的，后面版本才加了进来。\n\n3. listener.onLeakSentryInstalled(application)\n\n该listener的最终实现类是leakcanary-android-core中的InternalLeakCanary类\n\n```java\noverride fun onLeakSentryInstalled(application: Application) {\n    this.application = application\n\n    val heapDumper = AndroidHeapDumper(application, leakDirectoryProvider)\n\t\t//用于发现可能的内存泄漏之后手动调用 GC 确认是否真的为内存泄露\n    val gcTrigger = GcTrigger.Default\n\n    val configProvider = { LeakCanary.config }\n\n    val handlerThread = HandlerThread(HeapDumpTrigger.LEAK_CANARY_THREAD_NAME)\n    handlerThread.start()\n    val backgroundHandler = Handler(handlerThread.looper)\n\t\t//用于确认内存泄漏之后进行 heap dump 工作。\n    heapDumpTrigger = HeapDumpTrigger(\n        application, backgroundHandler, LeakSentry.refWatcher, gcTrigger, heapDumper, configProvider\n    )\n    application.registerVisibilityListener { applicationVisible ->\n      this.applicationVisible = applicationVisible\n      heapDumpTrigger.onApplicationVisibilityChanged(applicationVisible)\n    }\n    addDynamicShortcut(application)\n  }\n```\n\n这里有个关于GC回收的知识点，我们可以看看优秀的第三方框架都是怎么写的\n\n```java\ninterface GcTrigger {\n  fun runGc()\n  object Default : GcTrigger {\n    override fun runGc() {\n      // Code taken from AOSP FinalizationTest:\n      // https://android.googlesource.com/platform/libcore/+/master/support/src/test/java/libcore/\n      // java/lang/ref/FinalizationTester.java\n      // System.gc() does not garbage collect every time. Runtime.gc() is\n      // more likely to perform a gc.\n      Runtime.getRuntime()\n          .gc()\n      enqueueReferences()\n      System.runFinalization()\n    }\n    private fun enqueueReferences() {\n      // Hack. We don't have a programmatic way to wait for the reference queue daemon to move\n      // references to the appropriate queues.\n      try {\n        Thread.sleep(100)\n      } catch (e: InterruptedException) {\n        throw AssertionError()\n      }\n    }\n  }\n}\n```\n\n可以看到，它使用了Runtime.getRuntime().gc()而不是System.gc()，进入System.gc源码一看\n\n```java\npublic static void gc() {\n    boolean shouldRunGC;\n    synchronized (LOCK) {\n        shouldRunGC = justRanFinalization;\n        if (shouldRunGC) {\n            justRanFinalization = false;\n        } else {\n            runGC = true;\n        }\n    }\n    if (shouldRunGC) {\n        Runtime.getRuntime().gc();\n    }\n}\n```\n\n可以看到System.gc源码的还是最终实现是Runtime.getRuntime().gc()；但是需要一系列的判断条件，我们手动调用System.runFinalization()可以使gc方法中的justRanFinalizationw为true，从而保证Runtime.getRuntime().gc()会被执行。\n\n\n\n#### 3.如何判断对象可能泄露：ReferenceQueue含义及作用\n\n在Activity/Fragment销毁后，会进行一系列的对象回收，我们把这些对象分别和引用队列进行关联，当某个对象被回收时，**（弱引用一旦变成弱可达(可达性算法分析)，引用就会加到引用队列中，然后再进行回收）**我们对象的引用就会被加入到引用队列中。根据该原理进行一系列的操作，最终判断是否内存泄漏。\n\n##### 3.1 引用队列\n\n通常我们将其ReferenceQueue翻译为引用队列，换言之就是存放引用的队列，保存的是Reference对象。其作用在于Reference对象所引用的对象被GC回收时，该Reference对象将会被加入引用队列中（ReferenceQueue）的队列末尾。\n\nReferenceQueue常用的方法：\n\npublic Reference poll()：从队列中取出一个元素，队列为空则返回null；\n\npublic Reference remove()：从队列中出对一个元素，若没有则阻塞至有可出队元素；\n\npublic Reference remove(long timeout)：从队列中出对一个元素，若没有则阻塞至有可出对元素或阻塞至超过timeout毫秒；\n\n1. 强引用\n\n2. 软引用\n\n3. 弱引用\n\n4. 虚引用（Phantom Reference）\n\n   虚引等同于没有引用，这意味着在任何时候都可能被GC回收，设置虚引用的目的是为了被虚引用关联的对象在被垃圾回收器回收时，能够收到一个系统通知。（被用来跟踪对象被GC回收的活动）虚引用和弱引用的区别在于：虚引用在使用时必须和引用队列（ReferenceQueue）联合使用，其在GC回收期间的活动如下：\n\n   ReferenceQueue queue=new ReferenceQueue();\n\n   PhantomReference pr=new PhantomReference(object,queue);\n\n   也即是GC在回收一个对象时，如果发现该对象具有虚引用，那么在回收之前会首先该对象的虚引用加入到与之关联的引用队列中。程序可以通过判断引用队列中是否已经加入虚引用来了解被引用的对象是否被GC回收。\n\n##### 3.2 GC Root对象\n\n![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9d85a9e294634be0b95ffff8e3b6bd4b~tplv-k3u1fbpfcp-zoom-1.image)\n\n##### 3.3 内存是否泄漏\n\n知道引用队列的原理后，先大概描述一下如何判断是否泄漏，首先创建三个队列\n\n```java\n  /**\n   * References passed to [watch] that haven't made it to [retainedReferences] yet.\n   * watch() 方法传进来的引用，尚未判定为泄露\n   */\n  private val watchedReferences = mutableMapOf<String, KeyedWeakReference>()\n  /**\n   * References passed to [watch] that we have determined to be retained longer than they should\n   * have been.\n   * watch() 方法传进来的引用，已经被判定为泄露\n   */\n  private val retainedReferences = mutableMapOf<String, KeyedWeakReference>()\n  private val queue = ReferenceQueue<Any>() // 引用队列，配合弱引用使用\n    \n//KeyedWeakReference，对象和引用队列进行弱引用关联，所以这个对象一定会被回收    \nclass KeyedWeakReference(\n  referent: Any,\n  val key: String,\n  val name: String,\n  val watchUptimeMillis: Long,\n  referenceQueue: ReferenceQueue<Any>\n) : WeakReference<Any>(\n    referent, referenceQueue\n) {\n  @Volatile\n  var retainedUptimeMillis = -1L\n\n  companion object {\n    @Volatile\n    @JvmStatic var heapDumpUptimeMillis = 0L\n  }\n\n}    \n```\n\n如果一个obj对象，它和队列queue进行弱引用关联，在进行垃圾收集时，发现该对象具有弱引用，会把引用加入到引用队列中，我们如果在该队列中拿到引用，则说明该对象被回收了，**如果拿不到，则说明该对象还有强/软引用未释放，那么就说明对象还未回收，发生内存泄漏了，然后dump内存快照，使用第三方库进行引用链分析**。\n\n这里重点强调一点**一个对象可能被多个引用持有，比如强引用，软引用，弱引用，只要这个对象还有强引用/软引用，与这个对象关联的任意引用队列就拿不到引用，引用队列就相当于一个通知，多个引用队列和一个对象关联，对象被回收时，多个队列都会受到通知**。\n\n##### 3.4 watch()\n\n```java\n@Synchronized fun watch(\n  watchedReference: Any,\n  referenceName: String\n) {\n  if (!isEnabled()) {\n    return\n  }\n  //移除队列中将要被 GC 的引用\n  removeWeaklyReachableReferences()\n  val key = UUID.randomUUID()\n      .toString()\n  val watchUptimeMillis = clock.uptimeMillis()\n  val reference = // 构建当前引用的弱引用对象，并关联引用队列 queue\n    KeyedWeakReference(watchedReference, key, referenceName, watchUptimeMillis, queue)\n  if (referenceName != \"\") {\n    CanaryLog.d(\n        \"Watching instance of %s named %s with key %s\", reference.className,\n        referenceName, key\n    )\n  } else {\n    CanaryLog.d(\n        \"Watching instance of %s with key %s\", reference.className, key\n    )\n  }\n\n  watchedReferences[key] = reference\n  checkRetainedExecutor.execute {\n    //如果引用未被移除，则可能存在内存泄漏\n    moveToRetained(key)\n  }\n}\n```\n\nremoveWeaklyReachableReferences()\n\n```java\n  private fun removeWeaklyReachableReferences() {\n    // WeakReferences are enqueued as soon as the object to which they point to becomes weakly\n    // reachable. This is before finalization or garbage collection has actually happened.\n    // 弱引用一旦变得弱可达，就会立即入队。这将在 finalization 或者 GC 之前发生。\n    var ref: KeyedWeakReference?\n    do {\n      ref = queue.poll() as KeyedWeakReference? // 队列 queue 中的对象都是会被 GC 的\n      if (ref != null) {\n        val removedRef = watchedReferences.remove(ref.key)\n        if (removedRef == null) {\n          retainedReferences.remove(ref.key)\n        }\n        // 移除 watchedReferences 队列中的会被 GC 的 ref 对象，剩下的就是可能泄露的对象\n      }\n    } while (ref != null)\n  }\n\n```\n\nmoveToRetained()\n\n```java\n  @Synchronized private fun moveToRetained(key: String) {\n    removeWeaklyReachableReferences() // 再次调用，防止遗漏\n    val retainedRef = watchedReferences.remove(key)\n    if (retainedRef != null) {\n      retainedReferences[key] = retainedRef\n      onReferenceRetained()\n    }\n  }\n\n```\n\n最后会回调到InternalLeakCanary的onReferenceRetained()方法\n\n```java\noverride fun onReferenceRetained() {\n  if (this::heapDumpTrigger.isInitialized) {\n    heapDumpTrigger.onReferenceRetained()\n  }\n}\n\n//1.HeapDumpTrigger 的 onReferenceRetained()\nfun onReferenceRetained() {\n  scheduleRetainedInstanceCheck(\"found new instance retained\")\n}\n\n//2.scheduleRetainedInstanceCheck\nprivate fun scheduleRetainedInstanceCheck(reason: String) {\n  backgroundHandler.post {\n    checkRetainedInstances(reason)\n  }\n}\n  \n//3.checkRetainedInstances\nprivate fun checkRetainedInstances(reason: String) {\n  CanaryLog.d(\"Checking retained instances because %s\", reason)\n    val config = configProvider()\n    // A tick will be rescheduled when this is turned back on.\n    if (!config.dumpHeap) {\n      return\n    }\n\n  var retainedKeys = refWatcher.retainedKeys\n\t\t//当前泄露实例个数小于 5 个，不进行 heap dump\n    if (checkRetainedCount(retainedKeys, config.retainedVisibleThreshold)) return\n\n      if (!config.dumpHeapWhenDebugging && DebuggerControl.isDebuggerAttached) {\n        showRetainedCountWithDebuggerAttached(retainedKeys.size)\n          scheduleRetainedInstanceCheck(\"debugger was attached\", WAIT_FOR_DEBUG_MILLIS)\n          CanaryLog.d(\n          \"Not checking for leaks while the debugger is attached, will retry in %d ms\",\n          WAIT_FOR_DEBUG_MILLIS\n        )\n          return\n      }\n\t\t// 可能存在被观察的引用将要变得弱可达，但是还未入队引用队列。\n    // 这时候应该主动调用一次 GC，可能可以避免一次 heap dump\n  gcTrigger.runGc()\n\n    retainedKeys = refWatcher.retainedKeys\n\n    if (checkRetainedCount(retainedKeys, config.retainedVisibleThreshold)) return\n\n      HeapDumpMemoryStore.setRetainedKeysForHeapDump(retainedKeys)\n\n      CanaryLog.d(\"Found %d retained references, dumping the heap\", retainedKeys.size)\n      HeapDumpMemoryStore.heapDumpUptimeMillis = SystemClock.uptimeMillis()\n      dismissNotification()\n      val heapDumpFile = heapDumper.dumpHeap()\n      if (heapDumpFile == null) {\n        CanaryLog.d(\"Failed to dump heap, will retry in %d ms\", WAIT_AFTER_DUMP_FAILED_MILLIS)\n          scheduleRetainedInstanceCheck(\"failed to dump heap\", WAIT_AFTER_DUMP_FAILED_MILLIS)\n          showRetainedCountWithHeapDumpFailed(retainedKeys.size)\n          return\n      }\n\n  refWatcher.removeRetainedKeys(retainedKeys)\n\n    HeapAnalyzerService.runAnalysis(application, heapDumpFile)\n}\n```\n\n一些细节可以看看代码注释，checkRetainedCount满足个数的话，就要发起head dump，具体的逻辑在AndroidHeapDumper.dumpHeap()中：\n\n```java\n  override fun dumpHeap(): File? {\n    val heapDumpFile = leakDirectoryProvider.newHeapDumpFile() ?: return null\n\t\t···\n    return try {\n     //Dump出文件\n      Debug.dumpHprofData(heapDumpFile.absolutePath)\n      heapDumpFile\n    } catch (e: Exception) {\n      CanaryLog.d(e, \"Could not dump heap\")\n      // Abort heap dump\n      null\n    } finally {\n      cancelToast(toast)\n      notificationManager.cancel(R.id.leak_canary_notification_dumping_heap)\n    }\n  }\n```\n\n最后启动一个前台服务 `HeapAnalyzerService` 来分析 heap dump 文件。老版本中是使用 Square 自己的 haha 库来解析的，这个库已经废弃了，Square 完全重写了解析库，主要逻辑都在 moudle `leakcanary-analyzer` 中。这部分我还没有阅读，就不在这里分析了。对于新的解析器，官网是这样介绍的：\n\n> Uses 90% less memory and 6 times faster than the prior heap parser.\n\n减少了 90% 的内存占用，而且比原来快了 6 倍。后面有时间单独来分析一下这个解析库。\n\n后面的过程就不再赘述了，通过解析库找到最短 GC Roots 引用路径，然后展示给用户。\n\n#### 4.手动写内存泄漏检测\n\n下面是参考Zero的Demo写的内存泄漏检测的一个例子，思路和LeakCanary一样\n\n```kotlin\nfun main() {\n\n    class MyKeyedWeakReference(\n            referent: Any,\n            val key: String,\n            val name: String,\n            referenceQueue: ReferenceQueue<Any>\n    ) : WeakReference<Any>(\n            referent, referenceQueue\n    ) {\n        val className: String = referent.javaClass.name\n        override fun toString(): String {\n            return \"{key=$key,className=$className}\"\n        }\n    }\n    //需要观察的对象\n    val watchedReferences = mutableMapOf<String,MyKeyedWeakReference>()\n    //如果最后retainedReferences还存在引用，说明泄漏了\n    val retainedReferences = mutableMapOf<String,MyKeyedWeakReference>()\n    //当与之关联的弱引用中的实例被回收，则会加入到queue\n    val gcQueue = ReferenceQueue<Any>()\n\n    fun sleep(mills: Long){\n        try {\n            Thread.sleep(mills)\n        }catch (e: Exception){\n            e.printStackTrace()\n        }\n    }\n\n    fun gc(){\n        println(\"执行gc...\")\n        Runtime.getRuntime().gc()\n        sleep(100)\n        System.runFinalization()\n    }\n\n    fun removeWeaklyReachableReferences(){\n        println(\"removeWeaklyReachableReferences\")\n        var ref: MyKeyedWeakReference?\n        do {\n            ref = gcQueue.poll() as MyKeyedWeakReference? //队列queue中的对象都是会被GC的\n            println(\"ref=$ref,如果ref为null,说明对象还有强引用\")\n            if (ref != null){ //说明被释放了\n                println(\"ref=$ref, 对象被释放了,key=${ref.key}\")\n                val removedRef = watchedReferences.remove(ref.key)\n                println(\"removedRef=$removedRef, 如果removedRef为null,说明已经不在watchedReferences了,key=${ref.key}\")\n                if (removedRef == null){\n                    //不在watchedReferences则说明在retainedReferences\n                    retainedReferences.remove(ref.key)\n                }\n            }\n        }while (ref != null)\n    }\n\n    @Synchronized\n    fun moveToRetained(key: String){\n        println(\"5.moveToRetained,key=$key\")\n        removeWeaklyReachableReferences()\n        val retainedRef = watchedReferences.remove(key)\n        println(\"retainedRef =$retainedRef 如果还有值说明没有被释放\")\n        if (retainedRef != null){ //添加到retainedReferences\n            retainedReferences[key] = retainedRef\n        }\n\n    }\n\n    fun watch(\n            obj: Any,\n            referenceName: String = \"\"){\n        println(\"2.watch...\")\n        removeWeaklyReachableReferences()\n        val key = UUID.randomUUID().toString()\n        println(\"3.key=$key\")\n        val reference = MyKeyedWeakReference(obj,key,referenceName,gcQueue)\n        println(\"4.reference=$reference\")\n        //加入观察列表\n        watchedReferences[key] = reference\n        //过段时间查看是否释放\n        thread(start = true){\n            sleep(5000)\n            moveToRetained(key)\n        }\n\n    }\n\n    var obj : Any? = Object()\n    println(\"1.创建一个对象obj=$obj\")\n    watch(obj!!,\"\")\n    sleep(2000)\n    obj = null\n    if (obj == null){\n        println(\"obj=$obj 释放了\")\n    }\n    gc()\n    sleep(5000)\n    println(\"watchedReferences=$watchedReferences\")\n    println(\"retainedReferences=$retainedReferences\")\n    println(\"执行完毕\")\n```\n\n#### 5. ContentProvider的优化\n\n##### 5.1 Content的初始化顺序\n\n​\t通过ContentProvider来进行初始化确实能给使用者带来便利，但是会影响启动速度，如果有多个ContentProvider，如何控制这些ContentProvider初始化的顺序呢，可以参考下面这篇文章[https://sivanliu.github.io/2017/12/16/provider%E5%88%9D%E5%A7%8B%E5%8C%96/](https://sivanliu.github.io/2017/12/16/provider初始化/)，如果一些第三方值只提供ContentProvider的初始化方式，我们又不想影响我们APP的启动时间，该如何处理呢？\n\n##### 5.2 \n\n​\t如果一些第三方库只提供ContentProvider的初始化方式，我们又不想影响我们APP的启动时间，该如何处理呢？**我们可以使用AOP方式进行插桩，通过Gradle+Transform+ASM进行修改ContentProvider的onCreate方法，提前返回，然后手动去调用初始化代码**，如果这些初始化代码是私有的或者只限制包内使用的，也可以通过ASM去修改访问权限，然后在我们想初始化的地方再进行初始化，这可能涉及到一个先后的问题，需要先修改完然后再在某个地方初始化，这里只是提供一个思路。如果一个库初始化耗时很长，又在ContentProvider中进行初始化，ContentProvider中初始化的代码又臭又长，又没有提供其他初始化方法，这样的垃圾库你要它干嘛！\n\n#### 6.总结\n\n1. 利用ContentProvider自动初始化，无需用户手动初始化\n\n2. GC回收，引用队列\n\n3. 1.5.4之后支持fragment，支持androidx\n\n4. 当泄露引用到达 5 个时才会发起 heap dump\n\n5. 全新的 heap parser，减少 90% 内存占用，提升 6 倍速度\n\n6. ContentProvider的优劣，以及优化方案\n\n    \n\n参考文章\n\n[https://sivanliu.github.io/2017/12/16/provider%E5%88%9D%E5%A7%8B%E5%8C%96/](https://sivanliu.github.io/2017/12/16/provider初始化/)\n\nhttps://juejin.im/post/5d1225546fb9a07ecd3d6b71\n\n\n\n\n\n", "user_name": "伤心的猪大肠", "description": "热爱编码，台球，看书，旅游", "got_view_count": 1720, "category_name": "Android", "ctime": 1461266353}
{"tag_name": "Go", "concern_user_count": 75376, "user_id": "2471357868680376", "title": "Go的两级线程模型", "mark_content": "***\n# 线程实现模型\n- 用户级线程模型\n- 内核级线程模型\n- 两级线程模型\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2c346d7cdccc4fbaaeae3c9aa818abca~tplv-k3u1fbpfcp-zoom-1.image)\n\n***\n\n\n# Go线程模型核心元素 MPG\n在操作系统提供的内核线程之上，Go搭建了一个特有的两级线程模型。\n\n一个G的执行需要P和M的支持。P和M关联之后，就形成了一个有效的G运行环境（内核线程+上下文环境）。  \n每个P都会包含一个可运行的G的队列，该队列中的G会被依次传递给本地P关联的当前M,并获得运行时机。  \n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9c4de4056a1745f7988e402f6774152f~tplv-k3u1fbpfcp-zoom-1.image)\n\n- M  \n>1. machine的缩写，一个M代表一个用户空间的内核线程，与内核线程（KSE）总是一一对应,在M的声明周期内，会且仅会与一个KSE产生关联。 \n>2. M刚创建之初，就会被加入到**全局M列表**。  \n>3. 有些时候，M会被停止（比如找不到可运行G时等），M会被加入到**调度器的空闲M列表**，在需要一个未被使用的M时，调度器会先尝试从该列表中获取。\n>4. 单个Go程序所使用的M的最大值可以设置，初始值是10000\n>5. M的启动和停止：  \n 当M的因系统调用而阻塞（更确切的说，是他运行的G进入了系统调用）,运行时系统会把M和关联的P分离开来，如果这个P的可运行队列中还有未被运行的G，那么运行时系统会去**调度器的空闲M列表**中找一个空闲的M,如果找不到就新建，然后这个p关联起来，使得剩下的这些G得以运行。\n \n ![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/39cf0f1b0ab44bfe95c1e60bc3f845b0~tplv-k3u1fbpfcp-zoom-1.image)\n- p  \n>1. processor的缩写，一个P代表执行一个Go代码片段所必需的资源（上下文环境）\n>2. 调度器会适时的让P与不同的M建立或断开关联，使得P中的可运行G能够及时获得运行时机。\n>3. P的数量默认等于当前cpu核数,可以利用函数runtime.GOMAXPROCS来改变P的数量。P的数量即为可运行G队列的数量。\n>4. 当一个P不再与任何M关联时，且它的可运行G队列为空，会被放入**调度器的空闲P列表**，在需要一个空闲的P关联M时，会从此列表取出。\n>5. P的包含一个自由G列表，存放一些已经运行完成的G。当增长到一定程度，运行时系统会把其中的部分G转移到**调度器的自由G列表**中。\n>5. P的状态：\n    - Pidel：初始化完成，当前p未与m关联，放入**调度器的空闲P列表**里。  \n    - Prunning：当前p已经和某个m关联，m在执行某个g。  \n    - Psyscall:当前p中的被运行的g正在被系统调用  \n    - Pgcstop:调度器停止调度。runtime正在进行GC(runtime会在gc时试图把全局P列表中的P都处于此种状态)；有串行运行时任务正在等执行-->停止当前M-->释放本地P-->p为pgcstop  \n    - Pdead：当前P不再被使用（在调用runtime.GOMAXPROCS减少P数量时，多余的P就处于这种状态）  \n> - 任何非Pdead状态的p都会在运行时系统欲停止调度室被置于Pgcstop，其在启用调度的时候并不会恢复到原有状态，而是处在Pidle（同一起跑线上）  \n> - 任何非Pgcstop的P都可能因为全局P列表的缩小而被认为是多余的，被置于Pdead状态，其可运行G队列都会被转移到**调度器的可运行G队列**，它的自由G列表中的G也会被转移到**调度器的自由G队列**中。\n\n![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/87119807c78f4265b6e7d1c050738bff~tplv-k3u1fbpfcp-zoom-1.image)\n    \n- G  \n>1. goroutine的缩写，一个G代表一个go代码片段，G是对go代码的一种封装.Go的编译器会把go语句变成对内部函数newproc的调用，并把go函数及其参数都作为参数传递给这个函数。\n>2. 新建的G会被首先加入**全局G列表**，初始化之后，会被加入到本地P的可运行队列，还会被存储到本地P的runnext字段，该字段用户存放新鲜出炉的G，以便更早的运行它。如果runnext已经有一个G，那么这个已有G会被踢到**该P的可运行G队列**的末尾。如果该队列已满，那么这个G就只能追加到**调度器的可运行G队列**中。\n>2. 当go语句欲启用一个G的时候，运行时系统会先试图从相应的**P的自由G列表**中获取一个现成的G，来封装这个go函数。仅当获取不到G才有可能创建一个新G。\n>2. 运行时系统会在发现本地P自由G太少，会尝试从调度器的自由G列表中转移一些过来。如果发现本地P的自由G队列满了，会转移一些到**调度器的自由G列表**。\n>2. 所有的**自由G列表** 都是先进后出的。\n>2. 一个G在被启用之后，会先被追加到某个P的可运行G队列中，以等待运行时机。\n>2. G的状态：\n    - Gidle（刚被分配，还未初始化）\n    - Grunnable(初始化之后，一般在在p本地的可运行队列中等待运行；如果是退出系统调用且能运行的，放入**调度器的可运行G队列**，不能直接运行的G，则放入**调度器的自由G列表**等待被运行)\n    - Grunning(正在运行)\n    - Gsyscall(正在执行系统调用，转出系统调用状态且能运行的，放入**调度器的可运行G队列**；不能直接运行的G，则放入**调度器的自由G列表**等待被运行)\n    - Gwaiting（正在阻塞,被 channel、IO操作、定时器(time.Timer)、time.Sleep等阻塞）,在事件到来之后，G被唤醒，进入       - Grunnable，等待被调用，有些被放入**本地p的可运行G队列**，有些被放入**调度器的本地可运行G队列**，还有些被直接运行（如刚进行网络I/O）。\n    - Gdead（正在闲置，被放入**本地p的自由G队列**）\n    - Gcopystack(表示G的栈正被移动，为啥移动？因为栈的扩展或收缩)\n    - Gscan(该状态不能单独存在，和其他状态组合在一起形成一个新状态，在GC扫描时发生)\n\n![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1b2bddff42584b6991591f7fe4d97718~tplv-k3u1fbpfcp-zoom-1.image)\n\n\n\n\n\n# 容器元素  \n\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ad50beb8e85449a8bc8451b1c9ddfebe~tplv-k3u1fbpfcp-zoom-1.image)\n\n没特别标注的列表都是单向链表  \n\n| 作用域 |M列表 | P列表 |G队列/列表|\n| :----: |:----: | :----: | :----: |\n| 运行时系统 | 全局M列表 | 全局P列表（一个数组） | 全局G列表（一个切片） |\n| 调度器 | 空闲M列表 | 空闲P列表 | 可运行G队列、自由G列表（2个） |\n| 本地p ||   |可运行G队列、 自由G列表(1个)  |\n \n\n# 调度器的一轮调度\n两级线程模型中的一部分调度任务会由操作系统内核之外的程序承担，在Go中，调度器就负责这一部分的调度任务，调度的对象就是MPG。  \n一轮调度是Go调度器最核心的流程，在很多情况下都会被触发，在用户程序启动时的一系列初始化工作之后，一轮调度会首次启动并使封装main的那个G被调度运行。某个G的运行的阻塞、结束、退出系统调用，都会进行一轮调度。\n\n> 1. 调度器会判断当前M是否已被锁定，如果是，就会立即停止调度并停止当前M,也不会为当前M寻找可运行的G。当与它锁定的G处于可运行状态，M就会被唤醒并继续执行G。\n> 2. 如果未与任务G锁定，检查是否有运行时串行任务（需要停止Go调度器）正在等待执行，停止当前M-等待运行时串行任务执行完成。一但串行任务执行完成，该M会被唤醒，再次进行一轮调度。\n> 3. 无锁定、无运行时串行任务，开始寻找G,一旦找到G，就判断该G是否有与其他M锁定，有的话，会然与其锁定的M运行G；没有的话，直接运行G。\n\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2764d2eb8b214a568a09ff54546af5f8~tplv-k3u1fbpfcp-zoom-1.image)\n\n## 查找G\n### 第一阶段\n#### 全力查找可运行的G：runtime.findrunnable函数，返回一个处于Grunnable状态的G。流程分为2个阶段，10个步骤\n>+ step1：\n获取执行终结器的G，放入本地P的可运行G队列\n终结器是一个其关联的对象呗垃圾回收器收集之前会执行的一个终结函数，该函数的执行会有个专门的G负责。\n调度器会判断该G已经完成任务之后获取它，把它置为Grunable状态并放入本地P的可运行G队列。  \n>+ step2：\n从本地P的可执行G队列获取G，返回该G\n>+ step3：\n从调度器的可执行G队列获取G,返回该G\n>+ step4：\n从网络I/O轮询器（netpoller）处获取G，返回该G\n调度器从netpoller那里获取一个G列表，把表头G返回，把其余的G都放入调度器的可运行G队列里。\n当一个G试图在一个网络连接上进行读写操作时，底层程序会为此做准备，并把该G转为Gwaiting状态。\n一旦准备就绪，底层程序就会返回相应的事件，这会让netpoller立即通知为此等待的G。从netpoller获取G的意思就是获取那些已经接收到通知的G，让他们转入Grunnable状态并等待运行。\n这类型的G是不会被放入某个P的可运行G队列\n>+ step5：\n从其他P的可运行G队列中获取G，返回G\n利用一种伪随机算法从全局P列表中选取P,然后从它的可运行G队列中盗取一半的G到本地P的可运行G队列。并把盗取的第一个G作为结果返回。\n选取P和盗取G的过程会重复多次。\n前提条件：除了本地P还有非空闲的P\n\n第一阶段结束\n ![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/513c3955d65d42bebdcb0478707e35b8~tplv-k3u1fbpfcp-zoom-1.image)\n \n ### 第二阶段\n>+ step6：\n获取本地P中的可执行GC标记任务的G:返回该G\n如果系统是正处在GC标记阶段，且本地P可用于GC标记任务，就会把本地P持有的GC标记专用的G置为Grunnable并返回该G\n>+ step7：\n从调度器的可运行G队列中获取G，返回该G\n(为什么还要找一次？step3、4不是已经找不到了嘛，是3、4之后还有什么情况会有G新增到调度器的可运行G队列里吗？)\n如果依然找不到可运行G，就会解除本地P与当前M的关联，并把P放入调度器的空闲P列表里。\n>+ step8：\n从全局P列表中的每个P的可运行G队列获取G，返回该G\n遍历全局P列表，只要发现某个P的可运行G队列不是空的，就从调度器的空闲p列表中取出一个P,并与当前M关联在一起，然后返回第一阶段去搜索G。\n>+ step9：\n获取执行GC标记任务的G，关联持有GC标记专用G的P到当前M\n如果系统正处于GC标记阶段，与GC标记任务相关的全局资源可用，调度器从其空闲P列表拿出一个P,如果这个P持有一个GC标记专用G，关联该P与当前M,然后再其次支持第二阶段\n>+ step10：\n从网络I/O(netpoller)处获取G，并返回\n调取器从netpoller那获取一个G列表，与step4不同的是，netpoller已被初始化，并且有I/O操作过，会阻塞等到有可用G出现。但是如果netpoller还未初始化，或者没有过I/O操作，这一步就会跳过。\n\n ![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/91911a9abfc54ed0be063d8b7c613c83~tplv-k3u1fbpfcp-zoom-1.image)\n \n\n \n # 名词简解\n- KSE: 核调度实体，可以被内核的调度器调度对象，也称为内核级线程，是操作系统内核最小调度单元。  \n- 系统调用：是操作系统内核提供给用户空间程序的一套标准接口。通过这套接口，用户态程序可以受限地访问硬件设备，从而实现申请系统资源，读写设备，创建新进程等操作\n \n ", "user_name": "slpond", "description": "", "got_view_count": 89, "category_name": "后端", "ctime": 1457483880}
{"tag_name": "Java", "concern_user_count": 252044, "user_id": "465848661449693", "title": "Java开源框架中的设计模式以及应用场景", "mark_content": "## 前言\n\n设计模式是软件设计中常见问题的典型解决方案，你可以通过对其进行定制来解决代码中的特定设计问题。\n\n关于设计模式，网上有很多讲解。但大部分都是Demo示例，看完有可能还是不知道怎么用。\n\n本文笔者将从设计模式入手，看一看在优秀的Java框架/中间件产品中，不同的设计模式应用场景在哪里。\n\n\n## 一、单例模式\n\n单例模式是 Java 中最简单的设计模式之一，它提供了一种创建对象的最佳方式。这种模式涉及到一个单一的类，该类负责创建自己的对象，同时确保只有单个对象被创建。这个类提供了一种访问其唯一的对象的方式，可以直接访问，不需要实例化该类的对象。\n\n单例模式虽然很简单，但它的花样一点都不少，我们一一来看。\n\n#### 1、饿汉式\n\n饿汉式，顾名思义，就是我很饿，迫不及待。不管有没有人用，我先创建了再说。\n\n比如在Dubbo中的这段代码，创建一个配置管理器。\n```\npublic class ConfigManager {\n    private static final ConfigManager configManager = new ConfigManager();\t\n    private ConfigManager() {}\n    public static ConfigManager getInstance() {\n        return configManager;\n    }\n}\n```\n又或者在RocketMQ中，创建一个MQ客户端实例的时候。\n```\npublic class MQClientManager {\n\n    private static MQClientManager instance = new MQClientManager();\n    private MQClientManager() {}\n    public static MQClientManager getInstance() {\n        return instance;\n    }\n}\n```\n\n#### 2、懒汉式\n\n懒汉式是对应饿汉式而言的。它旨在第一次调用才初始化，避免内存浪费。但为了线程安全和性能，一般都会使用双重检查锁的方式来创建。\n\n我们来看Seata框架中，通过这种方式来创建一个配置类。\n```\npublic class ConfigurationFactory{\n\n    private static volatile Configuration CONFIG_INSTANCE = null;\n    public static Configuration getInstance() {\n        if (CONFIG_INSTANCE == null) {\n            synchronized (Configuration.class) {\n                if (CONFIG_INSTANCE == null) {\n                    CONFIG_INSTANCE = buildConfiguration();\n                }\n            }\n        }\n        return CONFIG_INSTANCE;\n    }\n}\n```\n\n#### 3、静态内部类\n\n可以看到，通过双重检查锁的方式来创建单例对象，还是比较复杂的。又是加锁，又是判断两次，还需要加volatile修饰的。\n\n使用静态内部类的方式，可以达到双重检查锁相同的功效，但实现上简单了。\n\n在Seata框架中，创建RM事件处理程序器的时候，就使用了静态内部类的方式来创建单例对象。\n```\npublic class DefaultRMHandler extends AbstractRMHandler{\n\n    protected DefaultRMHandler() {\n        initRMHandlers();\n    }\n    private static class SingletonHolder {\n        private static AbstractRMHandler INSTANCE = new DefaultRMHandler();\n    }\n    public static AbstractRMHandler get() {\n        return DefaultRMHandler.SingletonHolder.INSTANCE;\n    }\n}\n```\n\n还有可以通过枚举的方式来创建单例对象，但这种方式并没有被广泛采用，至少笔者在常见的开源框架中没见过，所以就不再列举。\n\n有人说，饿汉式的单例模式不好，不能做到延迟加载，浪费内存。但笔者认为似乎过于吹毛求疵，事实上很多开源框架中，用的最多的就是这种方式。\n\n如果明确希望实现懒加载效果时，可以考虑用静态内部类的方式；如果还有其他特殊的需求，比如创建对象的过程比较繁琐，可以用双重检查锁的方式。\n\n## 二、工厂模式\n\n工厂模式是 Java 中最常用的设计模式之一。这种类型的设计模式属于创建型模式，它提供了一种创建对象的最佳方式。\n\n简单来说，在工厂模式中，就是代替new实例化具体类的一种模式。\n\n#### 1、简单工厂\n\n简单工厂，的确比较简单，它的作用就是把对象的创建放到一个工厂类中，通过参数来创建不同的对象。\n\n在分布式事务框架Seata中，如果发生异常，则需要进行二阶段回滚。\n\n它的过程是，通过事务id找到undoLog记录，然后解析里面的数据生成SQL，将一阶段执行的SQL给撤销掉。\n\n问题是SQL的种类包含了比如``INSERT、UPDATE、DELETE``，所以它们反解析的过程也不一样，就需要不同的执行器去解析。\n\n在Seata中，有一个抽象的撤销执行器，可以生成一条SQL。\n```\npublic abstract class AbstractUndoExecutor{\n    //生成撤销SQL\n    protected abstract String buildUndoSQL();\n}\n```\n\n然后有一个获取撤销执行器的工厂，根据SQL的类型，创建不同类型的执行器并返回。\n```\npublic class UndoExecutorFactory {\n\n    public static AbstractUndoExecutor getUndoExecutor(String dbType, SQLUndoLog sqlUndoLog) {\n        switch (sqlUndoLog.getSqlType()) {\n            case INSERT:\n                return new MySQLUndoInsertExecutor(sqlUndoLog);\n            case UPDATE:\n                return new MySQLUndoUpdateExecutor(sqlUndoLog);\n            case DELETE:\n                return new MySQLUndoDeleteExecutor(sqlUndoLog);\n            default:\n                throw new ShouldNeverHappenException();\n        }\n    }\n}\t\n```\n\n使用的时候，直接通过工厂类获取执行器。\n```\nAbstractUndoExecutor undoExecutor = UndoExecutorFactory.getUndoExecutor(dataSourceProxy.getDbType(),sqlUndoLog);\nundoExecutor.executeOn(conn);\n```\n\n简单工厂模式的优点，想必各位都能领会，我们不再赘述。但它还有个小小的缺点：\n\n一旦有了新的实现类，就需要修改工厂实现，有可能造成工厂逻辑过于复杂，不利于系统的扩展和维护。\n\n#### 2、工厂方法\n\n工厂方法模式解决了上面那个问题。它可以创建一个工厂接口和多个工厂实现类，这样如果增加新的功能，只需要添加新的工厂类就可以，不需要修改之前的代码。\n\n另外，工厂方法模式还可以和模板方法模式结合一起，将他们共同的基础逻辑抽取到父类中，其它的交给子类去实现。\n\n在Dubbo中，有一个关于缓存的设计完美的体现了工厂方法模式+模板方法模式。\n\n首先，有一个缓存的接口，它提供了设置缓存和获取缓存两个方法。\n```\npublic interface Cache {\n    void put(Object key, Object value);\n    Object get(Object key);\n}\n```\n\n然后呢，还有一个缓存工厂，它返回一个缓存的实现。\n```\npublic interface CacheFactory {\n    Cache getCache(URL url, Invocation invocation);\n}\n```\n\n由于结合了模板方法模式，所以Dubbo又搞了个抽象的缓存工厂类，它实现了缓存工厂的接口。\n\n```\npublic abstract class AbstractCacheFactory implements CacheFactory {\n    \n    //具体的缓存实现类\n    private final ConcurrentMap<String, Cache> caches = new ConcurrentHashMap<String, Cache>();\n    \n    @Override\n    public Cache getCache(URL url, Invocation invocation) {\n        url = url.addParameter(Constants.METHOD_KEY, invocation.getMethodName());\n        String key = url.toFullString();\n        Cache cache = caches.get(key);\n        if (cache == null) {\n            //创建缓存实现类，交给子类实现\n            caches.put(key, createCache(url));\n            cache = caches.get(key);\n        }\n        return cache;\n    }\n    //抽象方法，交给子类实现\n    protected abstract Cache createCache(URL url);\n}\n```\n\n在这里，公共的逻辑就是通过getCahce()创建缓存实现类，那具体创建什么样的缓存实现类，就由子类去决定。\n\n所以，每个子类都是一个个具体的缓存工厂类，比如包括：\n\nExpiringCacheFactory、JCacheFactory、LruCacheFactory、ThreadLocalCacheFactory。\n\n这些工厂类，只有一个方法，就是创建具体的缓存实现类。\n\n```\npublic class ThreadLocalCacheFactory extends AbstractCacheFactory {\n    @Override\n    protected Cache createCache(URL url) {\n        return new ThreadLocalCache(url);\n    }\n}\n```\n\n这里的ThreadLocalCache就是具体的缓存实现类，比如它是通过ThreadLocal来实现缓存功能。\n```\npublic class ThreadLocalCache implements Cache {\n\n    private final ThreadLocal<Map<Object, Object>> store;\n\n    public ThreadLocalCache(URL url) {\n        this.store = new ThreadLocal<Map<Object, Object>>() {\n            @Override\n            protected Map<Object, Object> initialValue() {\n                return new HashMap<Object, Object>();\n            }\n        };\n    }\n    @Override\n    public void put(Object key, Object value) {\n        store.get().put(key, value);\n    }\n    @Override\n    public Object get(Object key) {\n        return store.get().get(key);\n    }\n}\n```\n\n那在客户端使用的时候，还是通过工厂来获取缓存对象。\n```\npublic static void main(String[] args) {\n    URL url = URL.valueOf(\"http://localhost:8080/cache=jacache&.cache.write.expire=1\");\n    Invocation invocation = new RpcInvocation();\n    CacheFactory cacheFactory = new ThreadLocalCacheFactory();\n    Cache cache = cacheFactory.getCache(url, invocation);\n    cache.put(\"java\",\"java\");\n    System.out.println(cache.get(\"java\"));\n}\n```\n\n这样做的好处有两点。\n\n第一，如果增加新的缓存实现，只要添加一个新的缓存工厂类就可以，别的都无需改动。\n\n第二，通过模板方法模式，封装不变部分，扩展可变部分。 提取公共代码，便于维护。\n\n另外，在Dubbo中，注册中心的获取也是通过工厂方法来实现的。\n\n#### 3、抽象工厂\n\n抽象工厂模式，它能创建一系列相关的对象， 而无需指定其具体类。\n\n工厂方法模式和抽象工厂模式，它们之间最大的区别在于：\n\n- 工厂方法模式只有一个抽象产品类，具体工厂类只能创建一个具体产品类的实例；\n- 抽象工厂模式有多个抽象产品类，具体工厂类可以创建多个具体产品类的实例。\n\n\n我们拿上面缓存的例子来继续往下说。\n\n如果我们现在有一个数据访问程序，需要同时操作缓存和数据库，那就需要多个抽象产品和多个具体产品实现。\n\n缓存相关的产品类都已经有了，我们接着来创建数据库相关的产品实现。\n\n首先，有一个数据库接口，它是抽象产品类。\n```\npublic interface DataBase {\n    void insert(Object tableName, Object record);\n    Object select(Object tableName);\n}\n```\n\n然后，我们创建两个具体产品类MysqlDataBase和OracleDataBase。\n```\npublic class MysqlDataBase implements DataBase{\n    Map<Object,Object> mysqlDb = new HashMap<>();\n    @Override\n    public void insert(Object tableName, Object record) {\n        mysqlDb.put(tableName,record);\n    }\n    @Override\n    public Object select(Object tableName) {\n        return mysqlDb.get(tableName);\n    }\n}\n\npublic class OracleDataBase implements DataBase {\n    Map<Object,Object> oracleDb = new HashMap<>();\n    @Override\n    public void insert(Object tableName, Object record) {\n        oracleDb.put(tableName,record);\n    }\n    @Override\n    public Object select(Object tableName) {\n        return oracleDb.get(tableName);\n    }\n}\n```\n\n其次，创建抽象的工厂类，它可以返回一个缓存对象和数据库对象。\n```\npublic interface DataAccessFactory {\n    Cache getCache(URL url);\n    DataBase getDb();\n}\n```\n\n最后是具体的工厂类，可以根据实际的需求，任意组合每一个具体的产品。\n\n比如我们需要一个基于ThreadLocal的缓存实现和基于Mysql的数据库对象。\n```\npublic class DataAccessFactory1 implements DataAccessFactory {\n    @Override\n    public Cache getCache(URL url) {\n        return new ThreadLocalCache(url);\n    }\n    @Override\n    public DataBase getDb() {\n        return new MysqlDataBase();\n    }\n}\n```\n\n如果需要一个基于Lru的缓存实现和基于Oracle的数据库对象。\n```\n\npublic class DataAccessFactory2 implements DataAccessFactory {\n    @Override\n    public Cache getCache(URL url) {\n        return new LruCache(url);\n    }\n    @Override\n    public DataBase getDb() {\n        return new OracleDataBase();\n    }\n}\n```\n\n可以看到，抽象工厂模式隔离了具体类的生成，使得客户并不需要知道什么被创建。由于这种隔离，更换一个具体工厂就变得相对容易，所有的具体工厂都实现了抽象工厂中定义的那些公共接口，因此只需改变具体工厂的实例，就可以在某种程度上改变整个软件系统的行为。\n\n## 三、模板方法模式\n\n在模板模式中，一个抽象类公开定义了执行它的方法的方式/模板。它的子类可以按需要重写方法实现，但调用将以抽象类中定义的方式进行。\n\n简单来说，有多个子类共有的方法，且逻辑相同，可以考虑作为模板方法。\n\n在上面Dubbo缓存的例子中，我们已经看到了模板方法模式的应用。但那个是和工厂方法模式结合在一块的，我们再单独找找模板方法模式的应用。\n\n我们知道，当我们的Dubbo应用出现多个服务提供者时，服务消费者需要通过负载均衡算法，选择其中一个服务来进行调用。\n\n首先，有一个LoadBalance接口，返回一个Invoker。\n```\npublic interface LoadBalance {\n    <T> Invoker<T> select(List<Invoker<T>> invokers, URL url, Invocation invocation) throws RpcException;\n}\n```\n\n然后定义一个抽象类，AbstractLoadBalance，实现LoadBalance接口。\n```\npublic abstract class AbstractLoadBalance implements LoadBalance {\n\n    @Override\n    public <T> Invoker<T> select(List<Invoker<T>> invokers, URL url, Invocation invocation) {\n        if (invokers == null || invokers.isEmpty()) {\n            return null;\n        }\n        if (invokers.size() == 1) {\n            return invokers.get(0);\n        }\n        return doSelect(invokers, url, invocation);\n    }\n    //抽象方法，由子类选择一个Invoker\n    protected abstract <T> Invoker<T> doSelect(List<Invoker<T>> invokers, URL url, Invocation invocation);\n}\n```\n\n这里的公共逻辑就是两个判断，判断invokers集合是否为空或者是否只有一个实例。如果是的话，就无需调用子类，直接返回就好了。\n\n具体的负载均衡实现有四个：\n\n- 基于权重随机算法的 RandomLoadBalance\n- 基于最少活跃调用数算法的 LeastActiveLoadBalance\n- 基于 hash 一致性的 ConsistentHashLoadBalance\n- 基于加权轮询算法的 RoundRobinLoadBalance\n\n\n```\npublic class RandomLoadBalance extends AbstractLoadBalance {\n    @Override\n    protected <T> Invoker<T> doSelect(List<Invoker<T>> invokers, URL url, Invocation invocation) {\n        //省略逻辑....\n        return invokers.get(ThreadLocalRandom.current().nextInt(length));\n    }\n}\n```\n\n它们根据不同的算法实现，来返回一个具体的Invoker对象。\n\n\n## 四、构造器模式\n\n构造器模式使用多个简单的对象一步一步构建成一个复杂的对象。这种类型的设计模式属于创建型模式，它提供了一种创建对象的最佳方式。\n\n这种模式，常见于在构建一个复杂的对象，里面可能包含一些业务逻辑，比如检查，属性转换等。如果都在客户端手动去设置，那么会产生大量的冗余代码。那么这时候，我们就可以考虑使用构造器模式。\n\n比如，在Mybatis中，MappedStatement的创建过程就使用了构造器模式。\n\n我们知道，XML文件中的每一个SQL标签就要生成一个MappedStatement对象，它里面包含很多个属性，我们要构造的对象也是它。\n```\npublic final class MappedStatement {\n    private String resource;\n    private Configuration configuration;\n    private String id;\n    private SqlSource sqlSource;\n    private ParameterMap parameterMap;\n    private List<ResultMap> resultMaps;\n    //.....省略大部分属性\n}\n```\n\n然后有一个内部类Builder，它负责完成MappedStatement对象的构造。\n\n首先，这个Builder类，通过默认的构造函数，先完成对MappedStatement对象，部分的构造。\n```\npublic static class Builder {\n\n    private MappedStatement mappedStatement = new MappedStatement();\n    \n    public Builder(Configuration configuration, String id, SqlSource sqlSource, SqlCommandType sqlCommandType) {\n        mappedStatement.configuration = configuration;\n        mappedStatement.id = id;\n        mappedStatement.sqlSource = sqlSource;\n        mappedStatement.statementType = StatementType.PREPARED;\n        mappedStatement.resultSetType = ResultSetType.DEFAULT;\n        //.....省略大部分过程\n    }\n}\n```\n\n然后，通过一系列方法，可以设置特定的属性，并返回这个Builder类，这里的方法适合处理一些业务逻辑。\n```\npublic static class Builder {\n\n    public Builder parameterMap(ParameterMap parameterMap) {\n      mappedStatement.parameterMap = parameterMap;\n      return this;\n    }\n    \n    public Builder resultMaps(List<ResultMap> resultMaps) {\n      mappedStatement.resultMaps = resultMaps;\n      for (ResultMap resultMap : resultMaps) {\n        mappedStatement.hasNestedResultMaps = mappedStatement.hasNestedResultMaps || resultMap.hasNestedResultMaps();\n      }\n      return this;\n    }\n    \n    public Builder statementType(StatementType statementType) {\n      mappedStatement.statementType = statementType;\n      return this;\n    }\n\n    public Builder resultSetType(ResultSetType resultSetType) {\n      mappedStatement.resultSetType = resultSetType == null ? ResultSetType.DEFAULT : resultSetType;\n      return this;\n    }\n}\n```\n\n最后呢，就是提供一个build方法，返回构建完成的对象就好了。\n```\npublic MappedStatement build() {\n    assert mappedStatement.configuration != null;\n    assert mappedStatement.id != null;\n    assert mappedStatement.sqlSource != null;\n    assert mappedStatement.lang != null;\n    mappedStatement.resultMaps = Collections.unmodifiableList(mappedStatement.resultMaps);\n    return mappedStatement;\n}\n```\n\n在客户端使用的时候，先创建一个 Builder，然后链式的调用一堆方法，最后再调用一次 build() 方法，我们需要的对象就有了，这就是构造器模式的应用。\n```\nMappedStatement.Builder statementBuilder = new MappedStatement.Builder(configuration, id, sqlSource, sqlCommandType)\n\t.resource(resource)\n\t.fetchSize(fetchSize)\n\t.timeout(timeout)\n\t.statementType(statementType)\n\t.keyGenerator(keyGenerator)\n\t.keyProperty(keyProperty)\n\t.keyColumn(keyColumn)\n\t.databaseId(databaseId)\n\t.lang(lang)\n\t.resultOrdered(resultOrdered)\n\t.resultSets(resultSets)\n\t.resultMaps(getStatementResultMaps(resultMap, resultType, id))\n\t.resultSetType(resultSetType)\n\t.flushCacheRequired(valueOrDefault(flushCache, !isSelect))\n\t.useCache(valueOrDefault(useCache, isSelect))\n\t.cache(currentCache);\n\nParameterMap statementParameterMap = getStatementParameterMap(parameterMap, parameterType, id);\nMappedStatement statement = statementBuilder.build();\nconfiguration.addMappedStatement(statement);\nreturn statement;\n```\n\n\n## 五、适配器模式\n\n适配器模式是作为两个不兼容的接口之间的桥梁。这种类型的设计模式属于结构型模式，它结合了两个独立接口的功能。\n\n适配器模式一般用于屏蔽业务逻辑与第三方服务的交互，或者是新老接口之间的差异。\n\n我们知道，在Dubbo中，所有的数据都是通过Netty来负责传输的，然后这就涉及了消息编解码的问题。\n\n所以，首先它有一个编解码器的接口，负责编码和解码。\n```\n@SPI\npublic interface Codec2 {\n\n    @Adaptive({Constants.CODEC_KEY})\n    void encode(Channel channel, ChannelBuffer buffer, Object message) throws IOException;\n    \n    @Adaptive({Constants.CODEC_KEY})\n    Object decode(Channel channel, ChannelBuffer buffer) throws IOException;\n    \n    enum DecodeResult {\n        NEED_MORE_INPUT, SKIP_SOME_INPUT\n    }\n}\n```\n\n然后，有几个实现类，比如DubboCountCodec、DubboCodec、ExchangeCodec等。\n\n但是，当我们打开这些类的时候，就会发现，他们都是Dubbo中普通的类，只是实现了Codec2接口，其实不能直接作用于Netty编解码。\n\n这是因为，Netty编解码需要实现ChannelHandler接口，这样才会被声明成Netty的处理组件。比如像MessageToByteEncoder、ByteToMessageDecoder那样。\n\n鉴于此，Dubbo搞了一个适配器，专门来适配编解码器接口。\n\n```\nfinal public class NettyCodecAdapter {\n\n    private final ChannelHandler encoder = new InternalEncoder();\n    private final ChannelHandler decoder = new InternalDecoder();\n    private final Codec2 codec;\n    private final URL url;\n    private final org.apache.dubbo.remoting.ChannelHandler handler;\n    \n    public NettyCodecAdapter(Codec2 codec, URL url, org.apache.dubbo.remoting.ChannelHandler handler) {\n        this.codec = codec;\n        this.url = url;\n        this.handler = handler;\n    }\n    public ChannelHandler getEncoder() {\n        return encoder;\n    }\n    public ChannelHandler getDecoder() {\n        return decoder;\n    }\n    \n    private class InternalEncoder extends MessageToByteEncoder {\n        @Override\n        protected void encode(ChannelHandlerContext ctx, Object msg, ByteBuf out) throws Exception {\n            org.apache.dubbo.remoting.buffer.ChannelBuffer buffer = new NettyBackedChannelBuffer(out);\n            Channel ch = ctx.channel();\n            NettyChannel channel = NettyChannel.getOrAddChannel(ch, url, handler);\n            codec.encode(channel, buffer, msg);\n        }\n    }\n    private class InternalDecoder extends ByteToMessageDecoder {\n        @Override\n        protected void decode(ChannelHandlerContext ctx, ByteBuf input, List<Object> out) throws Exception {\n            ChannelBuffer message = new NettyBackedChannelBuffer(input);\n            NettyChannel channel = NettyChannel.getOrAddChannel(ctx.channel(), url, handler);\n            //解码对象\n            codec.decode(channel, message);\n            //省略部分代码...\n        }\n    }\n}\n```\n\n上面的代码中，我们看到，NettyCodecAdapter类适配的是Codec2接口，通过构造函数传递实现类，然后定义了内部的编码器实现和解码器实现，同时它们都是ChannelHandler。\n\n这样的话，在内部类里面的编码和解码逻辑，真正调用的还是Codec2接口。\n\n最后我们再来看看，该适配器的调用方式。\n\n```\n//通过SPI方式获取编解码器的实现类，比如这里是DubboCountCodec\nCodec2 codec = ExtensionLoader.getExtensionLoader(Codec2.class).getExtension(\"dubbo\");\nURL url = new URL(\"dubbo\", \"localhost\", 22226);\n//创建适配器\nNettyCodecAdapter adapter = new NettyCodecAdapter(codec, url, NettyClient.this);\n//向ChannelPipeline中添加编解码处理器\nch.pipeline()\n    .addLast(\"decoder\", adapter.getDecoder())\n    .addLast(\"encoder\", adapter.getEncoder())\n```\n\n以上，就是Dubbo中关于编解码器对于适配器模式的应用。\n\n\n## 六、责任链模式\n\n责任链模式为请求创建了一个接收者对象的链。允许你将请求沿着处理者链进行发送。收到请求后，每个处理者均可对请求进行处理， 或将其传递给链上的下个处理者。\n\n我们来看一个Netty中的例子。我们知道，在Netty中服务端处理消息，就要添加一个或多个ChannelHandler。那么，承载这些ChannelHandler的就是ChannelPipeline，它的实现过程就体现了责任链模式的应用。\n\n```\nServerBootstrap serverBootstrap = new ServerBootstrap();\nserverBootstrap.childHandler(new ChannelInitializer<NioSocketChannel>() {\n    protected void initChannel(NioSocketChannel channel) {\n        channel.pipeline()\n            .addLast(new ChannelHandler1())\n            .addLast(new ChannelHandler2())\n            .addLast(new ChannelHandler3());\n    }\n});\n```\n需要知道的是，在 Netty 整个框架里面，一条连接对应着一个 Channel，每一个新创建的 Channel 都将会被分配一个新的 ChannelPipeline。\n\nChannelPipeline里面保存的是ChannelHandlerContext对象，它是Channel相关的上下文对象，里面包着我们定义的处理器ChannelHandler。\n\n根据事件的起源，IO事件将会被 ChannelInboundHandler或者ChannelOutboundHandler处理。随后，通过调用ChannelHandlerContext 实现，它将被转发给同一超类型的下一个ChannelHandler。\n\n#### 1、ChannelHandler\n\n首先，我们来看责任处理器接口，Netty中的ChannelHandler，它充当了所有处理入站和出站数据的应用程序逻辑的容器。\n```\npublic interface ChannelHandler {\n    //当把 ChannelHandler 添加到 ChannelPipeline 中时被调用\n    void handlerAdded(ChannelHandlerContext ctx) throws Exception;\n    //当从 ChannelPipeline 中移除 ChannelHandler 时被调用\n    void handlerRemoved(ChannelHandlerContext ctx) throws Exception;\n    //当处理过程中在 ChannelPipeline 中有错误产生时被调用\n    void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) throws Exception;\n}\n```\n\n然后 Netty 定义了下面两个重要的 ChannelHandler 子接口：\n\n- ChannelInboundHandler，处理入站数据以及各种状态变化；\n\n```\npublic interface ChannelInboundHandler extends ChannelHandler {\n    //当 Channel 已经注册到它的 EventLoop 并且能够处理 I/O 时被调用\n    void channelRegistered(ChannelHandlerContext ctx) throws Exception;\n    //当 Channel 从它的 EventLoop 注销并且无法处理任何 I/O 时被调用\n    void channelUnregistered(ChannelHandlerContext ctx) throws Exception; \n    //当 Channel 处于活动状态时被调用；Channel 已经连接/绑定并且已经就绪\n    void channelActive(ChannelHandlerContext ctx) throws Exception;   \n    //当 Channel 离开活动状态并且不再连接它的远程节点时被调用\n    void channelInactive(ChannelHandlerContext ctx) throws Exception;  \n    当从 Channel 读取数据时被调用\n    void channelRead(ChannelHandlerContext ctx, Object msg) throws Exception;   \n    //当 Channel上的一个读操作完成时被调用\n    void channelReadComplete(ChannelHandlerContext ctx) throws Exception;\n    void userEventTriggered(ChannelHandlerContext ctx, Object evt) throws Exception; \n    void channelWritabilityChanged(ChannelHandlerContext ctx) throws Exception;\n    void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) throws Exception;\n}\n```\n\n- ChannelOutboundHandler，处理出站数据并且允许拦截所有的操作；\n\n```\npublic interface ChannelOutboundHandler extends ChannelHandler {\n    \n    //当请求将 Channel 绑定到本地地址时被调用\n    void bind(ChannelHandlerContext ctx, SocketAddress localAddress, ChannelPromise promise) throws Exception;\n    //当请求将 Channel 连接到远程节点时被调用\n    void connect(ChannelHandlerContext ctx, SocketAddress remoteAddress,SocketAddress localAddress, \n        ChannelPromise promise) throws Exception;\n    //当请求将 Channel 从远程节点断开时被调用\n    void disconnect(ChannelHandlerContext ctx, ChannelPromise promise) throws Exception;\n    //当请求关闭 Channel 时被调用\n    void close(ChannelHandlerContext ctx, ChannelPromise promise) throws Exception;\n    //当请求将 Channel 从它的 EventLoop 注销时被调用\n    void deregister(ChannelHandlerContext ctx, ChannelPromise promise) throws Exception;\n    //当请求从 Channel 读取更多的数据时被调用\n    void read(ChannelHandlerContext ctx) throws Exception;\n    //当请求通过 Channel 将数据写到远程节点时被调用\n    void write(ChannelHandlerContext ctx, Object msg, ChannelPromise promise) throws Exception;\n    //当请求通过 Channel 将入队数据冲刷到远程节点时被调用\n    void flush(ChannelHandlerContext ctx) throws Exception;\n}\n```\n\n#### 2、ChannelPipeline\n\n既然叫做责任链模式，那就需要有一个“链”，在Netty中就是ChannelPipeline。\n\nChannelPipeline 提供了 ChannelHandler 链的容器，并定义了用于在该链上传播入站和出站事件流的方法，另外它还具有添加删除责任处理器接口的功能。\n```\npublic interface ChannelPipeline{\n    ChannelPipeline addFirst(String name, ChannelHandler handler);\n    ChannelPipeline addLast(String name, ChannelHandler handler);\n    ChannelPipeline addBefore(String baseName, String name, ChannelHandler handler);\n    ChannelPipeline addAfter(String baseName, String name, ChannelHandler handler);\n    ChannelPipeline remove(ChannelHandler handler);\n    ChannelHandler replace(String oldName, String newName, ChannelHandler newHandler);\n    @Override\n    ChannelPipeline fireChannelRegistered();\n    @Override\n    ChannelPipeline fireChannelActive();\n    @Override\n    ChannelPipeline fireExceptionCaught(Throwable cause);\n    @Override\n    ChannelPipeline fireUserEventTriggered(Object event);\n    @Override\n    ChannelPipeline fireChannelRead(Object msg);\n    @Override\n    ChannelPipeline flush();\n    //省略部分方法.....\n}\n```\n\n然后我们看它的实现，默认有两个节点，头结点和尾结点。并在构造函数中，使它们首尾相连。这就是标准的链式结构。\n```\npublic class DefaultChannelPipeline implements ChannelPipeline {\n\n    final AbstractChannelHandlerContext head;\n    final AbstractChannelHandlerContext tail;\n    private final Channel channel;\n    \n    protected DefaultChannelPipeline(Channel channel) {\n        this.channel = ObjectUtil.checkNotNull(channel, \"channel\");\n        tail = new TailContext(this);\n        head = new HeadContext(this);\n        head.next = tail;\n        tail.prev = head;\n    }\n}\n```\n\n当有新的ChannelHandler被添加时，则将其封装为ChannelHandlerContext对象，然后插入到链表中。\n```\nprivate void addLast0(AbstractChannelHandlerContext newCtx) {\n    AbstractChannelHandlerContext prev = tail.prev;\n    newCtx.prev = prev;\n    newCtx.next = tail;\n    prev.next = newCtx;\n    tail.prev = newCtx;\n}\n```\n\n\n#### 3、ChannelHandlerContext\n\nChannelHandlerContext 代表了 ChannelHandler 和 ChannelPipeline 之间的关联，每当有 ChannelHandler 添加到 ChannelPipeline 中时，都会创建 ChannelHandlerContext。\n\nChannelHandlerContext 的主要功能是管理它所关联的 ChannelHandler 和在同一个 ChannelPipeline 中的其他 ChannelHandler 之间的交互。\n\n```\npublic interface ChannelHandlerContext{\n    Channel channel();\n    EventExecutor executor();\n    ChannelHandler handler();\n    ChannelPipeline pipeline();\n    @Override\n    ChannelHandlerContext fireChannelRegistered();\n    @Override\n    ChannelHandlerContext fireChannelUnregistered();\n    @Override\n    ChannelHandlerContext fireChannelActive();\n    @Override\n    ChannelHandlerContext fireChannelRead(Object msg);\n    @Override\n    ChannelHandlerContext read();\n    @Override\n    ChannelHandlerContext flush();\n    //省略部分方法...\n}\n```\n\nChannelHandlerContext负责在链上传播责任处理器接口的事件。\n\n它有两个重要的方法，查找Inbound类型和Outbound类型的处理器。\n\n值得注意的是，如果一个入站事件被触发，它将被从ChannelPipeline的头部开始一直被传播到ChannelPipeline的尾端；一个出站事件将从ChannelPipeline的最右边开始，然后向左传播。\n```\nabstract class AbstractChannelHandlerContext implements ChannelHandlerContext, ResourceLeakHint {\n\t\n    volatile AbstractChannelHandlerContext next;\n    volatile AbstractChannelHandlerContext prev;\n    \n    //查找下一个Inbound类型的处理器，左 > 右\n    private AbstractChannelHandlerContext findContextInbound(int mask) {\n        AbstractChannelHandlerContext ctx = this;\n        EventExecutor currentExecutor = executor();\n        do {\n            ctx = ctx.next;\n        } while (skipContext(ctx, currentExecutor, mask, MASK_ONLY_INBOUND));\n        return ctx;\n    }\n    //查找下一个Outbound类型的处理器，右 > 左\n    private AbstractChannelHandlerContext findContextOutbound(int mask) {\n        AbstractChannelHandlerContext ctx = this;\n        EventExecutor currentExecutor = executor();\n        do {\n            ctx = ctx.prev;\n        } while (skipContext(ctx, currentExecutor, mask, MASK_ONLY_OUTBOUND));\n        return ctx;\n    }\n}\n```\n\n#### 4、处理流程\n\n当我们向服务端发送消息的时候，将会触发read方法。\n```\npublic abstract class AbstractNioByteChannel extends AbstractNioChannel {\n    public final void read() {\t\n        //从Channel中获取对应的ChannelPipeline\n        final ChannelPipeline pipeline = pipeline();\n        //数据载体\n        ByteBuf byteBuf = allocHandle.allocate(allocator);\n        //传递数据\n        pipeline.fireChannelRead(byteBuf);\n    }\n}\n```\n\n上面的代码中，就会调用到ChannelPipeline，它会从Head节点开始，根据上下文对象依次调用处理器。\n```\npublic class DefaultChannelPipeline implements ChannelPipeline {\n    public final ChannelPipeline fireChannelRead(Object msg) {\n        AbstractChannelHandlerContext.invokeChannelRead(head, msg);\n        return this;\n    }\n}\n```\n\n因为第一个节点是默认的头结点HeadContext，所以它是从ChannelHandlerContext开始的。\n\n```\nabstract class AbstractChannelHandlerContext implements ChannelHandlerContext, ResourceLeakHint {\n    //找到下一个ChannelHandler并执行\n    public ChannelHandlerContext fireChannelRead(final Object msg) {\n        invokeChannelRead(findContextInbound(MASK_CHANNEL_READ), msg);\n        return this;\n    }\n    \n}\n```\n\n然后在我们自定义的ChannelHandler中，就会被调用到。\n```\npublic class ChannelHandler1 extends ChannelInboundHandlerAdapter {\n    public void channelRead(ChannelHandlerContext ctx, Object msg){\n        System.out.println(\"ChannelHandler1:\"+msg);\n        ctx.fireChannelRead(msg);\n    }\n}\n```\n\n如果消息有多个ChannelHandler，你可以自由选择是否继续往下传递请求。\n\n比如，如果你认为消息已经被处理且不应该继续往下调用，把上面的ctx.fireChannelRead(msg);注释掉就终止了整个责任链。\n\n## 七、策略模式\n\n该模式定义了一系列算法，并将每个算法封装起来，使它们可以相互替换，且算法的变化不会影响使用算法的客户。\n\n策略模式是一个很常见，而且也很好用的设计模式，如果你的业务代码中有大量的if...else，那么就可以考虑是否可以使用策略模式改造一下。\n\nRocketMQ我们大家都熟悉，是一款优秀的分布式消息中间件。消息中间件，简单来说，就是客户端发送一条消息，服务端存储起来并提供给消费者去消费。\n\n请求消息的类型多种多样，处理过程肯定也不一样，每次都判断一下再处理就落了下乘。在RocketMQ里，它会把所有处理器注册起来，然后根据请求消息的 code ，让对应的处理器处理请求，这就是策略模式的应用。\n\n首先，它们需要实现同一个接口，在这里就是请求处理器接口。\n```\npublic interface NettyRequestProcessor {\n    RemotingCommand processRequest(ChannelHandlerContext ctx, RemotingCommand request)throws Exception;\n    boolean rejectRequest();\n}\n```\n\n这个接口只做一件事，就是处理来自客户端的请求。不同类型的请求封装成不同的RemotingCommand对象。\n\nRocketMQ大概有90多种请求类型，都在RequestCode里以 code 来区分。\n\n然后，定义一系列策略类。我们来看几个。\n```\n//默认的消息处理器\npublic class DefaultRequestProcessor implements NettyRequestProcessor {}\n//发送消息的处理器\npublic class SendMessageProcessor extends AbstractSendMessageProcessor implements NettyRequestProcessor {}\n//拉取消息的处理器\npublic class PullMessageProcessor implements NettyRequestProcessor {}\n//查询消息的处理器\npublic class QueryMessageProcessor implements NettyRequestProcessor {}\n//消费者端管理的处理器\npublic class ConsumerManageProcessor implements NettyRequestProcessor {}\n```\n\n接着，将这些策略类封装起来。在RocketMQ中，在启动Broker服务器的时候，注册这些处理器。\n```\npublic class BrokerController {\n\n    public void registerProcessor() {\n    \n        SendMessageProcessor sendProcessor = new SendMessageProcessor(this);\n        this.remotingServer.registerProcessor(RequestCode.SEND_MESSAGE, sendProcessor, this.sendMessageExecutor);\n        this.remotingServer.registerProcessor(RequestCode.SEND_MESSAGE_V2, sendProcessor, this.sendMessageExecutor);\n        this.remotingServer.registerProcessor(RequestCode.PULL_MESSAGE,this.pullMessageProcessor,this.pullMessageExecutor);\n        \n        this.remotingServer.registerProcessor(RequestCode.SEND_REPLY_MESSAGE, replyMessageProcessor, replyMessageExecutor);\n        this.remotingServer.registerProcessor(RequestCode.SEND_REPLY_MESSAGE_V2, replyMessageProcessor, replyMessageExecutor);\n        \n        NettyRequestProcessor queryProcessor = new QueryMessageProcessor(this);\n        this.remotingServer.registerProcessor(RequestCode.QUERY_MESSAGE, queryProcessor, this.queryMessageExecutor);\n        this.remotingServer.registerProcessor(RequestCode.VIEW_MESSAGE_BY_ID, queryProcessor, this.queryMessageExecutor);\n        \n        ClientManageProcessor clientProcessor = new ClientManageProcessor(this);\n        this.remotingServer.registerProcessor(RequestCode.HEART_BEAT, clientProcessor, this.heartbeatExecutor);\n        this.remotingServer.registerProcessor(RequestCode.UNREGISTER_CLIENT, clientProcessor, this.clientManageExecutor);\n        //省略部分注册过程.....\n    }\n}\n```\n\n最后，在Netty接收到客户端的请求之后，就会根据消息的类型，找到对应的策略类，去处理消息。\n```\npublic abstract class NettyRemotingAbstract {\n\n    public void processRequestCommand(final ChannelHandlerContext ctx, final RemotingCommand cmd) {\n        //根据请求类型找到对应的策略类\n        final Pair<NettyRequestProcessor, ExecutorService> matched = this.processorTable.get(cmd.getCode());\n        //如果没有找到就使用默认的\n        final Pair<NettyRequestProcessor, ExecutorService> pair = \n                    null == matched ? this.defaultRequestProcessor : matched;\n        //执行策略\n        final RemotingCommand response = pair.getObject1().processRequest(ctx, cmd);\n        //省略大部分代码......\n    }\n}\n```\n\n如果有了新的请求消息类型，RocketMQ也无需修改业务代码，新增策略类并将其注册进来就好了。\n\n## 八、代理模式\n\n代理模式，为其他对象提供一种代理以控制对这个对象的访问。\n\n在一些开源框架或中间件产品中，代理模式会非常常见。我们使用的时候越简便，框架在背后帮我们做的事就可能越复杂。这里面往往都体现着代理模式的应用，颇有移花接木的味道。\n\n#### 1、Dubbo\n\nDubbo作为一个RPC框架，其中有一个很重要的功能就是：\n\n> 提供高性能的基于代理的远程调用能力，服务以接口为粒度，为开发者屏蔽远程调用底层细节。\n\n这里我们关注两个重点：\n\n- 面向接口代理；\n- 屏蔽调用底层细节。\n\n比如我们有一个库存服务，它提供一个扣减库存的接口。\n```\npublic interface StorageDubboService {\n    int decreaseStorage(StorageDTO storage);\n}\n```\n\n在别的服务里，需要扣减库存的时候，就会通过Dubbo引用这个接口，也比较简单。\n```\n@Reference\nStorageDubboService storageDubboService;\n```\n\n我们使用起来很简单，可 StorageDubboService 只是一个普通的服务类，并不具备远程调用的能力。\n\nDubbo就是给这些服务类，创建了代理类。通过ReferenceBean来创建并返回一个代理对象。\n\n```\npublic class ReferenceBean<T>{\n    @Override\n    public Object getObject() {\n        return get();\n    }\n    public synchronized T get() {\n        if (ref == null) {\n            init();\n        }\n        return ref;\n    }\n}\n```\n在我们使用的时候，实则调用的是代理对象，代理对象完成复杂的远程调用。比如连接注册中心、负载均衡、集群容错、连接服务器发送消息等功能。\n\n#### 2、Mybatis \n\n还有一个典型的应用，就是我们经常在用的Mybatis。我们在使用的时候，一般只操作Mapper接口，然后Mybatis会找到对应的SQL语句来执行。\n```\npublic interface UserMapper {\t\n    List<User> getUserList();\n}\n```\n\n如上代码，UserMapper也只是一个普通的接口，它是怎样最终执行到我们的SQL语句的呢？\n\n答案也是代理。当Mybatis扫描到我们定义的Mapper接口时，会将其设置为MapperFactoryBean，并创建返回一个代理对象。\n```\nprotected T newInstance(SqlSession sqlSession) {\n    final MapperProxy<T> mapperProxy = new MapperProxy<>(sqlSession, mapperInterface, methodCache);\n    return (T) Proxy.newProxyInstance(mapperInterface.getClassLoader(), new Class[] { mapperInterface }, mapperProxy);\n}\n```\n\n代理对象去通过请求的方法名找到MappedStatement对象，调用执行器，解析SqlSource对象来生成SQL，执行并解析返回结果等。\n\n以上案例具体的实现过程，在这里就不再深入细聊。有兴趣可能翻阅笔者其他文章~\n\n\n## 九、装饰器模式\n\n装饰器模式，在不改变现有对象结构的情况下，动态地给该对象增加一些职责（即增加其额外功能）的模式，它属于对象结构型模式。\n\nMybatis里的缓存设计，就是装饰器模式的典型应用。\n\n首先，我们知道，MyBatis 执行器是 MyBatis 调度的核心，它负责SQL语句的生成和执行。\n\n在创建SqlSession的时候，会创建这个执行器，默认的执行器是SimpleExecutor。\n\n但是为了给执行器增加缓存的职责，就变成了在SimpleExecutor上一层添加了CachingExecutor。\n\n在CachingExecutor中的实际操作还是委托给SimpleExecutor去执行，只是在执行前后增加了缓存的操作。\n\n首先，我们来看看它的装饰过程。\n```\npublic Executor newExecutor(Transaction transaction, ExecutorType executorType) {\n    //默认的执行器\n    executorType = executorType == null ? defaultExecutorType : executorType;\n    executorType = executorType == null ? ExecutorType.SIMPLE : executorType;\n    Executor executor;\n    if (ExecutorType.BATCH == executorType) {\n        executor = new BatchExecutor(this, transaction);\n    } else if (ExecutorType.REUSE == executorType) {\n        executor = new ReuseExecutor(this, transaction);\n    } else {\n        executor = new SimpleExecutor(this, transaction);\n    }\n    //使用缓存执行器来装饰\n    if (cacheEnabled) {\n        executor = new CachingExecutor(executor);\n    }\n    executor = (Executor) interceptorChain.pluginAll(executor);\n    return executor;\n}\n```\n\n当SqlSession执行方法的时候，则会先调用到CachingExecutor，我们来看查询方法。\n```\npublic class CachingExecutor implements Executor {\n    @Override\n    public <E> List<E> query()throws SQLException {\n        Cache cache = ms.getCache();\n        if (cache != null) {\n            flushCacheIfRequired(ms);\n            if (ms.isUseCache() && resultHandler == null) {\n                List<E> list = (List<E>) tcm.getObject(cache, key);\n                if (list == null) {\n                    list = delegate.query(ms, parameterObject, rowBounds, resultHandler, key, boundSql);\n                    tcm.putObject(cache, key, list); // issue #578 and #116\n                }\n                return list;\n            }\n        }\n        return delegate.query(ms, parameterObject, rowBounds, resultHandler, key, boundSql);\n    }\n}\n```\n这里的代码，如果开启了缓存，则先从缓存中获取结果。如果没有开启缓存或者缓存中没有结果，则再调用SimpleExecutor执行器去数据库中查询。\n\n\n## 十、观察者模式\n\n观察者模式，定义对象间的一种一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都得到通知并被自动更新。\n\n在Spring或者SpringBoot项目中，有时候我们需要在Spring容器启动并加载完之后，做一些系统初始化的事情。这时候，我们可以配置一个观察者ApplicationListener，来达到这一目的。这就是观察者模式的实践。\n```\n@Component\npublic class ApplicationStartup implements ApplicationListener<ContextRefreshedEvent> {\n    @Override\n    public void onApplicationEvent(ContextRefreshedEvent event) {\n        System.out.println(\"干一些系统初始化的事情....\");\n        ApplicationContext context = event.getApplicationContext();\n        String[] names = context.getBeanDefinitionNames();\n        for (String beanName:names){\n            System.out.println(\"----------\"+beanName+\"---------\");\n        }\n    }\n}\n```\n\n首先，我们知道，ApplicationContext是 Spring 中的核心容器。\n```\npublic abstract class AbstractApplicationContext extends DefaultResourceLoader implements ConfigurableApplicationContext {\n\t\n    //观察者容器\n    private final Set<ApplicationListener<?>> applicationListeners = new LinkedHashSet<>();\n    //被观察者\n    private ApplicationEventMulticaster applicationEventMulticaster;\n}\n```\n\n在ApplicationContext容器刷新的时候，会初始化一个被观察者，并注册到Spring容器中。\n\n然后，注册各种观察者到被观察者中，形成一对多的依赖。\n```\npublic abstract class AbstractApplicationContext{\n\t\n    protected void registerListeners() {\n        for (ApplicationListener<?> listener : getApplicationListeners()) {\n            getApplicationEventMulticaster().addApplicationListener(listener);\n        }\n        String[] listenerBeanNames = getBeanNamesForType(ApplicationListener.class, true, false);\n        for (String listenerBeanName : listenerBeanNames) {\n            getApplicationEventMulticaster().addApplicationListenerBean(listenerBeanName);\n        }\n        Set<ApplicationEvent> earlyEventsToProcess = this.earlyApplicationEvents;\n        this.earlyApplicationEvents = null;\n        if (earlyEventsToProcess != null) {\n            for (ApplicationEvent earlyEvent : earlyEventsToProcess) {\n                getApplicationEventMulticaster().multicastEvent(earlyEvent);\n            }\n        }\n    }\n}\n```\n这时候，我们自定义的观察者对象也被注册到了applicationEventMulticaster里面。\n\n最后，当ApplicationContext完成刷新后，则发布ContextRefreshedEvent事件。\n```\nprotected void finishRefresh() {\n    publishEvent(new ContextRefreshedEvent(this));\n}\n```\n\n通知观察者，调用ApplicationListener.onApplicationEvent()。\n```\nprivate void doInvokeListener(ApplicationListener listener, ApplicationEvent event) {\n    listener.onApplicationEvent(event);\n}\n```\n\n接下来我们再看看在Dubbo是如何应用这一机制的。\n\nDubbo服务导出过程始于 Spring 容器发布刷新事件，Dubbo 在接收到事件后，会立即执行服务导出逻辑。\n```\npublic class ServiceBean<T> extends ServiceConfig<T> implements InitializingBean, DisposableBean,\n        ApplicationContextAware, ApplicationListener<ContextRefreshedEvent>, BeanNameAware,\n        ApplicationEventPublisherAware {\n\n    @Override\n    public void onApplicationEvent(ContextRefreshedEvent event) {\n        if (!isExported() && !isUnexported()) {\n            if (logger.isInfoEnabled()) {\n                logger.info(\"The service ready on spring started. service: \" + getInterface());\n            }\n            export();\n        }\n    }\n}\n```\n\n我们看到，Dubbo中的ServiceBean也实现了 ApplicationListener 接口，在 Spring 容器发布刷新事件之后就会执行导出方法。我们重点关注，在Dubbo执行完导出之后，它也发布了一个事件。\n```\npublic class ServiceBean<T>{\n\t\n    public void export() {\n        super.export();\n        publishExportEvent();\n    }\n    private void publishExportEvent() {\n        ServiceBeanExportedEvent exportEvent = new ServiceBeanExportedEvent(this);\n        applicationEventPublisher.publishEvent(exportEvent);\n    }\n}\n```\n\nServiceBeanExportedEvent，服务导出事件，需要继承Spring中的事件对象ApplicationEvent。\n```\npublic class ServiceBeanExportedEvent extends ApplicationEvent {\n    public ServiceBeanExportedEvent(ServiceBean serviceBean) {\n        super(serviceBean);\n    }\n    public ServiceBean getServiceBean() {\n        return (ServiceBean) super.getSource();\n    }\n}\n```\n\n然后我们自定义一个ApplicationListener，也就是观察者，就可以监听到Dubbo服务接口导出事件了。\n```\n@Component\npublic class ServiceBeanListener implements ApplicationListener<ServiceBeanExportedEvent> {\n    @Override\n    public void onApplicationEvent(ServiceBeanExportedEvent event) {\n        ServiceBean serviceBean = event.getServiceBean();\n        String beanName = serviceBean.getBeanName();\n        Service service = serviceBean.getService();\n        System.out.println(beanName+\":\"+service);\n    }\n}\n```\n\n\n\n## 十一、命令模式\n\n命令模式是一种行为设计模式，它可将请求转换为一个包含与请求相关的所有信息的独立对象。该转换让你能根据不同的请求将方法参数化、延迟请求执行或将其放入队列中，且能实现可撤销操作。\n\nHystrix是Netflix开源的一款容错框架，具有自我保护能力。可以阻止故障的连锁反应，快速失败和优雅降级。\n\n它用一个HystrixCommand或者HystrixObservableCommand包装所有对外部系统/依赖的调用，每个命令在单独线程中/信号授权下执行。这正是命令模式的典型应用。\n\n我们来看一个Hystrix应用的例子。\n\n首先，我们需要创建一个具体的命令类，通过构造函数传递接收者对象。\n```\npublic class OrderServiceHystrixCommand extends HystrixCommand<Object> {\n\t\n\t//接收者，处理业务逻辑\n    private OrderService orderService;\n\n    public OrderServiceHystrixCommand(OrderService orderService) {\n        super(setter());\n        this.orderService = orderService;\n    }\n\t//设置Hystrix相关参数\n    public static Setter setter() {\n        HystrixCommandGroupKey groupKey = HystrixCommandGroupKey.Factory.asKey(\"orderGroup\");\n        HystrixCommandKey commandKey = HystrixCommandKey.Factory.asKey(\"orderService\");\n        HystrixThreadPoolProperties.Setter threadPoolProperties = HystrixThreadPoolProperties.Setter().withCoreSize(1)\n                .withQueueSizeRejectionThreshold(1);\n        HystrixCommandProperties.Setter commandProperties = HystrixCommandProperties.Setter();\n        return Setter.withGroupKey(groupKey)\n                .andCommandKey(commandKey)\n                .andThreadPoolPropertiesDefaults(threadPoolProperties)\n                .andCommandPropertiesDefaults(commandProperties);\n\n    }\n    @Override\n    protected Object run() throws InterruptedException {\n        Thread.sleep(500);\n        return orderService.orders();\n    }\n    @Override\n    protected Object getFallback() {\n        System.out.println(\"-------------------------------\");\n        return new ArrayList();\n    }\n}\n```\n\n然后，在客户端调用的时候，创建这个命令类并执行即可。\n```\n@RestController\npublic class OrderController {\n\n    @Autowired\n    OrderService orderService;\n\n    @RequestMapping(\"/orders\")\n\tpublic Object orders(){\n\t\tOrderServiceHystrixCommand command = new OrderServiceHystrixCommand(orderService);\n\t\treturn command.execute();\n\t}\n}\n```\n看上去，命令模式和策略模式有些相像，它们都可以通过某些行为来参数化对象。但它们的思想有很大区别。\n\n比如说我们可以使用命令来将任何操作转换为对象，操作的参数将成为对象的成员变量。同样的，我们也可以对请求做任何操作，比如延迟执行，记录日志，保存历史命令等。\n\n而策略模式侧重点在于描述完成某件事的不同方式， 让你能够在同一个上下文类中切换算法。\n\n\n## 总结\n\n本文重点介绍了设计模式在不同框架中的实现，以期让大家更好地理解模式背后的思想和应用场景。欢迎有不同想法的朋友，留言探讨~\n\n\n**原创不易，客官们点个赞再走嘛，这将是笔者持续写作的动力~**\n\n\n\n", "user_name": "清幽之地", "description": "公众号：清幽之地的博客", "got_view_count": 101075, "category_name": "后端", "ctime": 1457483880}
{"tag_name": "HTTP", "concern_user_count": 151675, "user_id": "4265760848101096", "title": "为什么cookie会有sameSite属性?-真实案例解释CSRF的三种攻击方式", "mark_content": "<section id=\"nice\" data-tool=\"mdnice编辑器\" data-website=\"https://www.mdnice.com\" style=\"color: black; line-height: 1.6; word-spacing: 0px; letter-spacing: 0px; word-break: break-word; word-wrap: break-word; text-align: left; font-family: Optima-Regular, Optima, PingFangSC-light, PingFangTC-light, 'PingFang SC', Cambria, Cochin, Georgia, Times, 'Times New Roman', serif; font-size: 14px; padding: 10px;\"><p data-tool=\"mdnice编辑器\" style=\"padding-top: 8px; padding-bottom: 8px; margin: 0; line-height: 26px; color: black; font-size: 14px;\">作为姊妹篇，建议先食用<a href=\"https://juejin.im/post/6857698580817182728\" style=\"text-decoration: none; color: #1e6bb8; word-wrap: break-word; font-weight: bold; border-bottom: 1px solid #1e6bb8;\">一个真实例子了解XSS攻击</a>。</p>\n<p data-tool=\"mdnice编辑器\" style=\"padding-top: 8px; padding-bottom: 8px; margin: 0; line-height: 26px; color: black; font-size: 14px;\">后面会这总结两种攻击和Cookie的samesite、httponly属性的关系。</p>\n<h2 data-tool=\"mdnice编辑器\" style=\"margin-top: 30px; margin-bottom: 15px; padding: 0px; font-size: 22px; text-align: center; position: relative; font-weight: bold; color: black; line-height: 1.1em; padding-top: 12px; padding-bottom: 12px; margin: 70px 30px 30px; border: 1px solid #000;\"><span style=\"float: left; display: block; width: 90%; border-top: 1px solid #000; height: 1px; line-height: 1px; margin-left: -5px; margin-top: -17px;\"> </span><span class=\"prefix\" style=\"display: block; width: 3px; margin: 0 0 0 5%; height: 3px; line-height: 3px; overflow: hidden; background-color: #000; box-shadow: 3px 0 #000,\n    0 3px #000,\n    -3px 0 #000,\n    0 -3px #000;\"></span><span class=\"content\" style=\"display: block; -webkit-box-reflect: below 0em -webkit-gradient(linear,left top,left bottom, from(rgba(0,0,0,0)),to(rgba(255,255,255,0.1)));\">什么是CSRF攻击？</span><span class=\"suffix\" style=\"display: block; width: 3px; margin: 0 0 0 95%; height: 3px; line-height: 3px; overflow: hidden; background-color: #000; box-shadow: 3px 0 #000,\n    0 3px #000,\n    -3px 0 #000,\n    0 -3px #000;\"></span><span style=\"float: right; display: block; width: 90%; border-bottom: 1px solid #000; height: 1px; line-height: 1px; margin-right: -5px; margin-top: 16px;\"> </span></h2>\n<p data-tool=\"mdnice编辑器\" style=\"padding-top: 8px; padding-bottom: 8px; margin: 0; line-height: 26px; color: black; font-size: 14px;\">网上冲浪这些年，经常能听到的一句话：“别点那个链接，小心有病毒！”。那么问题来了，我就点击一个链接怎么就能染上病毒了呢？这个‘病毒’是怎样盗走我的账号的？</p>\n<p data-tool=\"mdnice编辑器\" style=\"padding-top: 8px; padding-bottom: 8px; margin: 0; line-height: 26px; color: black; font-size: 14px;\">CSRF 英文全称是 Cross-site request forgery，所以又称为“跨站请求伪造”，是指黑客引诱用户打开黑客的网站，在黑客的网站中，利用用户的登录状态发起的跨站请求。简单来讲，CSRF 攻击就是黑客利用了用户的登录状态，并通过第三方的站点来做一些坏事。</p>\n<p data-tool=\"mdnice编辑器\" style=\"padding-top: 8px; padding-bottom: 8px; margin: 0; line-height: 26px; color: black; font-size: 14px;\">一个远古例子：</p>\n<p data-tool=\"mdnice编辑器\" style=\"padding-top: 8px; padding-bottom: 8px; margin: 0; line-height: 26px; color: black; font-size: 14px;\">遥远的2007年，David 使用浏览器无打开了 Gmail 中的一份邮件，并点击了该邮件中的一个链接。过了几天，David 就发现他的域名被盗了。虽然 David 最后通过走关系（网上冲浪认识的关系），拿回了域名。被盗走域名，就是因为无意间点击的那个链接。</p>\n<p data-tool=\"mdnice编辑器\" style=\"padding-top: 8px; padding-bottom: 8px; margin: 0; line-height: 26px; color: black; font-size: 14px;\">那么黑客是怎么盗走 David的域名的呢？</p>\n<figure data-tool=\"mdnice编辑器\" style=\"margin: 0; margin-top: 10px; margin-bottom: 10px; display: flex; flex-direction: column; justify-content: center; align-items: center;\"><img src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6c906bd5affa469fab9b6443cafca2b2~tplv-k3u1fbpfcp-zoom-1.image\" alt=\"盗取域名的流程图\" style=\"display: block; margin: 0 auto; max-width: 100%; box-shadow: rgba(170, 170, 170, 0.48) 0px 0px 6px 0px; border-radius: 4px; margin-top: 10px;\"><figcaption style=\"margin-top: 5px; text-align: center; color: #888; font-size: 12px;\">盗取域名的流程图</figcaption></figure>\n<ol data-tool=\"mdnice编辑器\" style=\"margin-top: 8px; margin-bottom: 8px; padding-left: 25px; color: black; list-style-type: decimal;\">\n<li><section style=\"margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;\">首先 David 使用浏览器发起登录 Gmail，然后 Gmail 服务器返回一些登录状态Cookie、Session 等给浏览器。</section></li><li><section style=\"margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;\">接着黑客引诱 David 去打开他的链接，然后在 xxx.com 页面中，黑客编写好了一个邮件过滤器的请求去访问Gmail的接口，设置好了新的邮件过滤功能，因为在相同浏览器中，请求可以拿到服务器返回Gmail的一些登录状态Cookie等鉴权信息，并顺利设置好所有的邮件都转发到黑客的邮箱中。</section></li><li><section style=\"margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;\">黑客通过邮箱找回域名账户的密码，然后将域名转出到黑客的账户了。</section></li></ol>\n<p data-tool=\"mdnice编辑器\" style=\"padding-top: 8px; padding-bottom: 8px; margin: 0; line-height: 26px; color: black; font-size: 14px;\">以上就是 David 的域名被盗事件之谜的真相，其中前两步过程就是 CSRF 攻击。</p>\n<p data-tool=\"mdnice编辑器\" style=\"padding-top: 8px; padding-bottom: 8px; margin: 0; line-height: 26px; color: black; font-size: 14px;\">David 在要回了他的域名之后，也将整个攻击过程分享到他的站点上了，如果你感兴趣的话，可以参考<a href=\"https://www.davidairey.com/google-gmail-security-hijack\" style=\"text-decoration: none; color: #1e6bb8; word-wrap: break-word; font-weight: bold; border-bottom: 1px solid #1e6bb8;\">该链接</a>（放心这个链接不会对你进行CSRF攻击 狗头保命）。</p>\n<h2 data-tool=\"mdnice编辑器\" style=\"margin-top: 30px; margin-bottom: 15px; padding: 0px; font-size: 22px; text-align: center; position: relative; font-weight: bold; color: black; line-height: 1.1em; padding-top: 12px; padding-bottom: 12px; margin: 70px 30px 30px; border: 1px solid #000;\"><span style=\"float: left; display: block; width: 90%; border-top: 1px solid #000; height: 1px; line-height: 1px; margin-left: -5px; margin-top: -17px;\"> </span><span class=\"prefix\" style=\"display: block; width: 3px; margin: 0 0 0 5%; height: 3px; line-height: 3px; overflow: hidden; background-color: #000; box-shadow: 3px 0 #000,\n    0 3px #000,\n    -3px 0 #000,\n    0 -3px #000;\"></span><span class=\"content\" style=\"display: block; -webkit-box-reflect: below 0em -webkit-gradient(linear,left top,left bottom, from(rgba(0,0,0,0)),to(rgba(255,255,255,0.1)));\">如何进行CSRF攻击？</span><span class=\"suffix\" style=\"display: block; width: 3px; margin: 0 0 0 95%; height: 3px; line-height: 3px; overflow: hidden; background-color: #000; box-shadow: 3px 0 #000,\n    0 3px #000,\n    -3px 0 #000,\n    0 -3px #000;\"></span><span style=\"float: right; display: block; width: 90%; border-bottom: 1px solid #000; height: 1px; line-height: 1px; margin-right: -5px; margin-top: 16px;\"> </span></h2>\n<p data-tool=\"mdnice编辑器\" style=\"padding-top: 8px; padding-bottom: 8px; margin: 0; line-height: 26px; color: black; font-size: 14px;\">有三种方式可以进行CSRF攻击。</p>\n<p data-tool=\"mdnice编辑器\" style=\"padding-top: 8px; padding-bottom: 8px; margin: 0; line-height: 26px; color: black; font-size: 14px;\">假设\n现在有一个银行转账接口</p>\n<pre class=\"custom\" data-tool=\"mdnice编辑器\" style=\"margin-top: 10px; margin-bottom: 10px; box-shadow: rgba(170, 170, 170, 0.48) 0px 0px 6px 0px; max-width: 100%; border-radius: 4px; margin: 10px auto 0 auto;\"><span style=\"display: block; background: url(https://my-wechat.mdnice.com/point.png); height: 30px; width: 100%; background-size: 40px; background-repeat: no-repeat; background-color: #fafafa; margin-bottom: -7px; border-radius: 5px; background-position: 10px 10px;\"></span><code class=\"hljs\" style=\"overflow-x: auto; padding: 16px; color: #383a42; display: -webkit-box; font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; font-size: 12px; -webkit-overflow-scrolling: touch; padding-top: 15px; background: #fafafa; border-radius: 5px;\"><span class=\"hljs-comment\" style=\"color: #a0a1a7; font-style: italic; line-height: 26px;\">#同时支持POST和Get</span><br><span class=\"hljs-comment\" style=\"color: #a0a1a7; font-style: italic; line-height: 26px;\">#接口&nbsp;</span><br>https://www.bank.com/sendmoney<br><span class=\"hljs-comment\" style=\"color: #a0a1a7; font-style: italic; line-height: 26px;\">#参数</span><br><span class=\"hljs-comment\" style=\"color: #a0a1a7; font-style: italic; line-height: 26px;\">##目标用户</span><br>user<br><span class=\"hljs-comment\" style=\"color: #a0a1a7; font-style: italic; line-height: 26px;\">##目标金额</span><br>number<br></code></pre>\n<h3 data-tool=\"mdnice编辑器\" style=\"margin-top: 30px; margin-bottom: 15px; font-weight: bold; background-color: #000; color: #fff; padding: 2px 10px; width: fit-content; font-size: 17px; margin: 60px auto 10px;\"><span class=\"prefix\" style=\"display: none;\"></span><span class=\"content\">1.自动发起GET请求</span><span class=\"suffix\" style=\"display: none;\"></span></h3>\n<p data-tool=\"mdnice编辑器\" style=\"padding-top: 8px; padding-bottom: 8px; margin: 0; line-height: 26px; color: black; font-size: 14px;\">黑客最容易的就是在用户无察觉的情况下发送GET请求。</p>\n<pre class=\"custom\" data-tool=\"mdnice编辑器\" style=\"margin-top: 10px; margin-bottom: 10px; box-shadow: rgba(170, 170, 170, 0.48) 0px 0px 6px 0px; max-width: 100%; border-radius: 4px; margin: 10px auto 0 auto;\"><span style=\"display: block; background: url(https://my-wechat.mdnice.com/point.png); height: 30px; width: 100%; background-size: 40px; background-repeat: no-repeat; background-color: #fafafa; margin-bottom: -7px; border-radius: 5px; background-position: 10px 10px;\"></span><code class=\"hljs\" style=\"overflow-x: auto; padding: 16px; color: #383a42; display: -webkit-box; font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; font-size: 12px; -webkit-overflow-scrolling: touch; padding-top: 15px; background: #fafafa; border-radius: 5px;\"><span class=\"hljs-meta\" style=\"color: #4078f2; line-height: 26px;\">&lt;!DOCTYPE&nbsp;html&gt;</span><br><span class=\"hljs-tag\" style=\"line-height: 26px;\">&lt;<span class=\"hljs-name\" style=\"color: #e45649; line-height: 26px;\">html</span>&gt;</span><br>&nbsp;&nbsp;<span class=\"hljs-tag\" style=\"line-height: 26px;\">&lt;<span class=\"hljs-name\" style=\"color: #e45649; line-height: 26px;\">body</span>&gt;</span><br>&nbsp;&nbsp;&nbsp;&nbsp;<span class=\"hljs-tag\" style=\"line-height: 26px;\">&lt;<span class=\"hljs-name\" style=\"color: #e45649; line-height: 26px;\">h1</span>&gt;</span>黑客的站点：CSRF攻击演示<span class=\"hljs-tag\" style=\"line-height: 26px;\">&lt;/<span class=\"hljs-name\" style=\"color: #e45649; line-height: 26px;\">h1</span>&gt;</span><br>&nbsp;&nbsp;&nbsp;&nbsp;<span class=\"hljs-tag\" style=\"line-height: 26px;\">&lt;<span class=\"hljs-name\" style=\"color: #e45649; line-height: 26px;\">img</span>&nbsp;<span class=\"hljs-attr\" style=\"color: #986801; line-height: 26px;\">src</span>=<span class=\"hljs-string\" style=\"color: #50a14f; line-height: 26px;\">\"https://www.bank.com/sendmoney?user=hacker&amp;number=100\"</span>&gt;</span><br>&nbsp;&nbsp;<span class=\"hljs-tag\" style=\"line-height: 26px;\">&lt;/<span class=\"hljs-name\" style=\"color: #e45649; line-height: 26px;\">body</span>&gt;</span><br><span class=\"hljs-tag\" style=\"line-height: 26px;\">&lt;/<span class=\"hljs-name\" style=\"color: #e45649; line-height: 26px;\">html</span>&gt;</span><br></code></pre>\n<p data-tool=\"mdnice编辑器\" style=\"padding-top: 8px; padding-bottom: 8px; margin: 0; line-height: 26px; color: black; font-size: 14px;\">当用户访问链接时，转账的请求接口隐藏在 img 标签内，浏览器以为这是一张图片资源。发送请求，服务器就会认为该请求是一个转账请求，于是用户账户上的 100 块就被转移到黑客的账户上去了。</p>\n<h3 data-tool=\"mdnice编辑器\" style=\"margin-top: 30px; margin-bottom: 15px; font-weight: bold; background-color: #000; color: #fff; padding: 2px 10px; width: fit-content; font-size: 17px; margin: 60px auto 10px;\"><span class=\"prefix\" style=\"display: none;\"></span><span class=\"content\">2.自动发起 POST 请求</span><span class=\"suffix\" style=\"display: none;\"></span></h3>\n<p data-tool=\"mdnice编辑器\" style=\"padding-top: 8px; padding-bottom: 8px; margin: 0; line-height: 26px; color: black; font-size: 14px;\">对于接口类型使用post的接口，在站点上伪造 POST 请求，当用户点开链接后，会自动提交 POST 请求。</p>\n<pre class=\"custom\" data-tool=\"mdnice编辑器\" style=\"margin-top: 10px; margin-bottom: 10px; box-shadow: rgba(170, 170, 170, 0.48) 0px 0px 6px 0px; max-width: 100%; border-radius: 4px; margin: 10px auto 0 auto;\"><span style=\"display: block; background: url(https://my-wechat.mdnice.com/point.png); height: 30px; width: 100%; background-size: 40px; background-repeat: no-repeat; background-color: #fafafa; margin-bottom: -7px; border-radius: 5px; background-position: 10px 10px;\"></span><code class=\"hljs\" style=\"overflow-x: auto; padding: 16px; color: #383a42; display: -webkit-box; font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; font-size: 12px; -webkit-overflow-scrolling: touch; padding-top: 15px; background: #fafafa; border-radius: 5px;\"><span class=\"hljs-meta\" style=\"color: #4078f2; line-height: 26px;\">&lt;!DOCTYPE&nbsp;html&gt;</span><br><span class=\"hljs-tag\" style=\"line-height: 26px;\">&lt;<span class=\"hljs-name\" style=\"color: #e45649; line-height: 26px;\">html</span>&gt;</span><br><span class=\"hljs-tag\" style=\"line-height: 26px;\">&lt;<span class=\"hljs-name\" style=\"color: #e45649; line-height: 26px;\">body</span>&gt;</span><br>&nbsp;&nbsp;<span class=\"hljs-tag\" style=\"line-height: 26px;\">&lt;<span class=\"hljs-name\" style=\"color: #e45649; line-height: 26px;\">h1</span>&gt;</span>黑客的站点：CSRF攻击演示<span class=\"hljs-tag\" style=\"line-height: 26px;\">&lt;/<span class=\"hljs-name\" style=\"color: #e45649; line-height: 26px;\">h1</span>&gt;</span><br>&nbsp;&nbsp;<span class=\"hljs-tag\" style=\"line-height: 26px;\">&lt;<span class=\"hljs-name\" style=\"color: #e45649; line-height: 26px;\">form</span>&nbsp;<span class=\"hljs-attr\" style=\"color: #986801; line-height: 26px;\">id</span>=<span class=\"hljs-string\" style=\"color: #50a14f; line-height: 26px;\">'hacker-form'</span>&nbsp;<span class=\"hljs-attr\" style=\"color: #986801; line-height: 26px;\">action</span>=<span class=\"hljs-string\" style=\"color: #50a14f; line-height: 26px;\">\"https://time.geekbang.org/sendcoin\"</span>&nbsp;<span class=\"hljs-attr\" style=\"color: #986801; line-height: 26px;\">method</span>=<span class=\"hljs-string\" style=\"color: #50a14f; line-height: 26px;\">POST</span>&gt;</span><br>&nbsp;&nbsp;&nbsp;&nbsp;<span class=\"hljs-tag\" style=\"line-height: 26px;\">&lt;<span class=\"hljs-name\" style=\"color: #e45649; line-height: 26px;\">input</span>&nbsp;<span class=\"hljs-attr\" style=\"color: #986801; line-height: 26px;\">type</span>=<span class=\"hljs-string\" style=\"color: #50a14f; line-height: 26px;\">\"hidden\"</span>&nbsp;<span class=\"hljs-attr\" style=\"color: #986801; line-height: 26px;\">name</span>=<span class=\"hljs-string\" style=\"color: #50a14f; line-height: 26px;\">\"user\"</span>&nbsp;<span class=\"hljs-attr\" style=\"color: #986801; line-height: 26px;\">value</span>=<span class=\"hljs-string\" style=\"color: #50a14f; line-height: 26px;\">\"hacker\"</span>&nbsp;/&gt;</span><br>&nbsp;&nbsp;&nbsp;&nbsp;<span class=\"hljs-tag\" style=\"line-height: 26px;\">&lt;<span class=\"hljs-name\" style=\"color: #e45649; line-height: 26px;\">input</span>&nbsp;<span class=\"hljs-attr\" style=\"color: #986801; line-height: 26px;\">type</span>=<span class=\"hljs-string\" style=\"color: #50a14f; line-height: 26px;\">\"hidden\"</span>&nbsp;<span class=\"hljs-attr\" style=\"color: #986801; line-height: 26px;\">name</span>=<span class=\"hljs-string\" style=\"color: #50a14f; line-height: 26px;\">\"number\"</span>&nbsp;<span class=\"hljs-attr\" style=\"color: #986801; line-height: 26px;\">value</span>=<span class=\"hljs-string\" style=\"color: #50a14f; line-height: 26px;\">\"100\"</span>&nbsp;/&gt;</span><br>&nbsp;&nbsp;<span class=\"hljs-tag\" style=\"line-height: 26px;\">&lt;/<span class=\"hljs-name\" style=\"color: #e45649; line-height: 26px;\">form</span>&gt;</span><br>&nbsp;&nbsp;<span class=\"hljs-tag\" style=\"line-height: 26px;\">&lt;<span class=\"hljs-name\" style=\"color: #e45649; line-height: 26px;\">script</span>&gt;</span><span class=\"javascript\" style=\"line-height: 26px;\">&nbsp;<span class=\"hljs-built_in\" style=\"color: #c18401; line-height: 26px;\">document</span>.getElementById(<span class=\"hljs-string\" style=\"color: #50a14f; line-height: 26px;\">'hacker-form'</span>).submit();&nbsp;</span><span class=\"hljs-tag\" style=\"line-height: 26px;\">&lt;/<span class=\"hljs-name\" style=\"color: #e45649; line-height: 26px;\">script</span>&gt;</span><br><span class=\"hljs-tag\" style=\"line-height: 26px;\">&lt;/<span class=\"hljs-name\" style=\"color: #e45649; line-height: 26px;\">body</span>&gt;</span><br><span class=\"hljs-tag\" style=\"line-height: 26px;\">&lt;/<span class=\"hljs-name\" style=\"color: #e45649; line-height: 26px;\">html</span>&gt;</span><br></code></pre>\n<h3 data-tool=\"mdnice编辑器\" style=\"margin-top: 30px; margin-bottom: 15px; font-weight: bold; background-color: #000; color: #fff; padding: 2px 10px; width: fit-content; font-size: 17px; margin: 60px auto 10px;\"><span class=\"prefix\" style=\"display: none;\"></span><span class=\"content\">3.诱骗链接</span><span class=\"suffix\" style=\"display: none;\"></span></h3>\n<p data-tool=\"mdnice编辑器\" style=\"padding-top: 8px; padding-bottom: 8px; margin: 0; line-height: 26px; color: black; font-size: 14px;\">这种常用于邮箱的邮件或者论坛上，会故意引诱用户去点击链接。</p>\n<pre class=\"custom\" data-tool=\"mdnice编辑器\" style=\"margin-top: 10px; margin-bottom: 10px; box-shadow: rgba(170, 170, 170, 0.48) 0px 0px 6px 0px; max-width: 100%; border-radius: 4px; margin: 10px auto 0 auto;\"><span style=\"display: block; background: url(https://my-wechat.mdnice.com/point.png); height: 30px; width: 100%; background-size: 40px; background-repeat: no-repeat; background-color: #fafafa; margin-bottom: -7px; border-radius: 5px; background-position: 10px 10px;\"></span><code class=\"hljs\" style=\"overflow-x: auto; padding: 16px; color: #383a42; display: -webkit-box; font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; font-size: 12px; -webkit-overflow-scrolling: touch; padding-top: 15px; background: #fafafa; border-radius: 5px;\"><span class=\"hljs-tag\" style=\"line-height: 26px;\">&lt;<span class=\"hljs-name\" style=\"color: #e45649; line-height: 26px;\">div</span>&gt;</span><br>&nbsp;&nbsp;<span class=\"hljs-tag\" style=\"line-height: 26px;\">&lt;<span class=\"hljs-name\" style=\"color: #e45649; line-height: 26px;\">img</span>&nbsp;<span class=\"hljs-attr\" style=\"color: #986801; line-height: 26px;\">width</span>=<span class=\"hljs-string\" style=\"color: #50a14f; line-height: 26px;\">150</span>&nbsp;<span class=\"hljs-attr\" style=\"color: #986801; line-height: 26px;\">src</span>=<span class=\"hljs-string\" style=\"color: #50a14f; line-height: 26px;\">http://images.xuejuzi.cn/1612/1_161230185104_1.jpg</span>&gt;</span>&nbsp;<span class=\"hljs-tag\" style=\"line-height: 26px;\">&lt;/<span class=\"hljs-name\" style=\"color: #e45649; line-height: 26px;\">img</span>&gt;</span>&nbsp;<span class=\"hljs-tag\" style=\"line-height: 26px;\">&lt;/<span class=\"hljs-name\" style=\"color: #e45649; line-height: 26px;\">div</span>&gt;</span>&nbsp;<span class=\"hljs-tag\" style=\"line-height: 26px;\">&lt;<span class=\"hljs-name\" style=\"color: #e45649; line-height: 26px;\">div</span>&gt;</span><br>&nbsp;&nbsp;<span class=\"hljs-tag\" style=\"line-height: 26px;\">&lt;<span class=\"hljs-name\" style=\"color: #e45649; line-height: 26px;\">a</span>&nbsp;<span class=\"hljs-attr\" style=\"color: #986801; line-height: 26px;\">href</span>=<span class=\"hljs-string\" style=\"color: #50a14f; line-height: 26px;\">\"https://www.bank.com/sendmoney?user=hacker&amp;number=100\"</span>&nbsp;<span class=\"hljs-attr\" style=\"color: #986801; line-height: 26px;\">taget</span>=<span class=\"hljs-string\" style=\"color: #50a14f; line-height: 26px;\">\"_blank\"</span>&gt;</span><br>&nbsp;&nbsp;&nbsp;&nbsp;点击下载美女照片<br>&nbsp;&nbsp;<span class=\"hljs-tag\" style=\"line-height: 26px;\">&lt;/<span class=\"hljs-name\" style=\"color: #e45649; line-height: 26px;\">a</span>&gt;</span><br><span class=\"hljs-tag\" style=\"line-height: 26px;\">&lt;/<span class=\"hljs-name\" style=\"color: #e45649; line-height: 26px;\">div</span>&gt;</span><br></code></pre>\n<p data-tool=\"mdnice编辑器\" style=\"padding-top: 8px; padding-bottom: 8px; margin: 0; line-height: 26px; color: black; font-size: 14px;\"><img src=\"https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/44c55b4681b8420f88768072cd0d7e30~tplv-k3u1fbpfcp-zoom-1.image\" alt style=\"display: block; margin: 0 auto; max-width: 100%; box-shadow: rgba(170, 170, 170, 0.48) 0px 0px 6px 0px; border-radius: 4px; margin-top: 10px;\">\n<a href=\"https://juejin.im/\" style=\"display: block;text-decoration: none; color: #1e6bb8; word-wrap: break-word; font-weight: bold; text-align: center;margin-top:30px\">点击进行深度♀学习♂交流</a></p>\n<p data-tool=\"mdnice编辑器\" style=\"padding-top: 8px; padding-bottom: 8px; margin: 0; line-height: 26px; color: black; font-size: 14px;\">就问你心不心动？（狗头）</p>\n<p data-tool=\"mdnice编辑器\" style=\"padding-top: 8px; padding-bottom: 8px; margin: 0; line-height: 26px; color: black; font-size: 14px;\">黑客页面上放了一张美女图片，下面放了图片下载地址，而这个下载地址实际上是黑客用来转账的接口，一旦用户点击了这个链接，那么他的钱就被转到黑客账户上了。</p>\n<p data-tool=\"mdnice编辑器\" style=\"padding-top: 8px; padding-bottom: 8px; margin: 0; line-height: 26px; color: black; font-size: 14px;\">以上三种就是黑客经常采用的CSRF攻击方式。</p>\n<p data-tool=\"mdnice编辑器\" style=\"padding-top: 8px; padding-bottom: 8px; margin: 0; line-height: 26px; color: black; font-size: 14px;\">当然前提是用户登录了银行，以上三种 CSRF 攻击方式中的任何一种发生时，那么服务器都会将一定金额的钱发送到黑客账户。</p>\n<p data-tool=\"mdnice编辑器\" style=\"padding-top: 8px; padding-bottom: 8px; margin: 0; line-height: 26px; color: black; font-size: 14px;\">到这里，相信你已经知道什么是 CSRF 攻击了。和 XSS 不同的是，CSRF 攻击不需要将恶意代码注入用户的页面，仅仅是利用服务器的漏洞和用户的登录状态来实施攻击。</p>\n<h2 data-tool=\"mdnice编辑器\" style=\"margin-top: 30px; margin-bottom: 15px; padding: 0px; font-size: 22px; text-align: center; position: relative; font-weight: bold; color: black; line-height: 1.1em; padding-top: 12px; padding-bottom: 12px; margin: 70px 30px 30px; border: 1px solid #000;\"><span style=\"float: left; display: block; width: 90%; border-top: 1px solid #000; height: 1px; line-height: 1px; margin-left: -5px; margin-top: -17px;\"> </span><span class=\"prefix\" style=\"display: block; width: 3px; margin: 0 0 0 5%; height: 3px; line-height: 3px; overflow: hidden; background-color: #000; box-shadow: 3px 0 #000,\n    0 3px #000,\n    -3px 0 #000,\n    0 -3px #000;\"></span><span class=\"content\" style=\"display: block; -webkit-box-reflect: below 0em -webkit-gradient(linear,left top,left bottom, from(rgba(0,0,0,0)),to(rgba(255,255,255,0.1)));\">如何阻止CSRF攻击？</span><span class=\"suffix\" style=\"display: block; width: 3px; margin: 0 0 0 95%; height: 3px; line-height: 3px; overflow: hidden; background-color: #000; box-shadow: 3px 0 #000,\n    0 3px #000,\n    -3px 0 #000,\n    0 -3px #000;\"></span><span style=\"float: right; display: block; width: 90%; border-bottom: 1px solid #000; height: 1px; line-height: 1px; margin-right: -5px; margin-top: 16px;\"> </span></h2>\n<p data-tool=\"mdnice编辑器\" style=\"padding-top: 8px; padding-bottom: 8px; margin: 0; line-height: 26px; color: black; font-size: 14px;\">首先，让我们总结一下能施展CSRF攻击的几个前提</p>\n<ol data-tool=\"mdnice编辑器\" style=\"margin-top: 8px; margin-bottom: 8px; padding-left: 25px; color: black; list-style-type: decimal;\">\n<li><section style=\"margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;\">目标站点一定要有 CSRF 漏洞；即没有完善的鉴权或二次确认。</section></li><li><section style=\"margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;\">用户要登录过目标站点，并且在浏览器上保持有该站点的登录状态。</section></li><li><section style=\"margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;\">需要用户打开一个第三方站点。</section></li></ol>\n<p data-tool=\"mdnice编辑器\" style=\"padding-top: 8px; padding-bottom: 8px; margin: 0; line-height: 26px; color: black; font-size: 14px;\">可以注意到，与 XSS 攻击不同，CSRF 攻击不会往页面注入恶意脚本，因此黑客是无法通过 CSRF 攻击来获取用户页面数据的；</p>\n<p data-tool=\"mdnice编辑器\" style=\"padding-top: 8px; padding-bottom: 8px; margin: 0; line-height: 26px; color: black; font-size: 14px;\">其最关键的一点是要能找到服务器请求漏洞，所以说对于 CSRF 攻击我们主要的防护手段是提升服务器的安全性。</p>\n<p data-tool=\"mdnice编辑器\" style=\"padding-top: 8px; padding-bottom: 8px; margin: 0; line-height: 26px; color: black; font-size: 14px;\">提升服务器安全性的几个方法：</p>\n<h3 data-tool=\"mdnice编辑器\" style=\"margin-top: 30px; margin-bottom: 15px; font-weight: bold; background-color: #000; color: #fff; padding: 2px 10px; width: fit-content; font-size: 17px; margin: 60px auto 10px;\"><span class=\"prefix\" style=\"display: none;\"></span><span class=\"content\">1. 使用Cookie的SameSite属性</span><span class=\"suffix\" style=\"display: none;\"></span></h3>\n<p data-tool=\"mdnice编辑器\" style=\"padding-top: 8px; padding-bottom: 8px; margin: 0; line-height: 26px; color: black; font-size: 14px;\">在 HTTP 响应头中，设置 Cookie 时，带上 SameSite 选项，可以防止第三方站点使用Cookie。</p>\n<p data-tool=\"mdnice编辑器\" style=\"padding-top: 8px; padding-bottom: 8px; margin: 0; line-height: 26px; color: black; font-size: 14px;\">SameSite 选项通常有 Strict、Lax 和 None 三个值。</p>\n<ul data-tool=\"mdnice编辑器\" style=\"margin-top: 8px; margin-bottom: 8px; padding-left: 25px; color: black; list-style-type: square;\">\n<li><section style=\"margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;\">Strict 最为严格。如果 SameSite 的值是 Strict，那么浏览器会完全禁止第三方 Cookie。简言之，如果你从极客时间的页面中访问 InfoQ 的资源，而 InfoQ 的某些 Cookie 设置了 SameSite = Strict 的话，那么这些 Cookie 是不会被发送到 InfoQ 的服务器上的。只有你从 InfoQ 的站点去请求 InfoQ 的资源时，才会带上这些 Cookie。</section></li><li><section style=\"margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;\">Lax 相对宽松一点。在跨站点的情况下，从第三方站点的链接打开和从第三方站点提交 Get 方式的表单这两种方式都会携带 Cookie。但如果在第三方站点中使用 Post 方法，或者通过 img、iframe 等标签加载的 URL，这些场景都不会携带 Cookie。</section></li><li><section style=\"margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;\">而如果使用 None 的话，在任何情况下都会发送 Cookie 数据。</section></li></ul>\n<p data-tool=\"mdnice编辑器\" style=\"padding-top: 8px; padding-bottom: 8px; margin: 0; line-height: 26px; color: black; font-size: 14px;\">严格程度分别是<strong style=\"font-weight: bold; color: black;\">全部不允许</strong>第三方&gt;仅允许<strong style=\"font-weight: bold; color: black;\">GET</strong>请求&gt;<strong style=\"font-weight: bold; color: black;\">全部允许</strong></p>\n<p data-tool=\"mdnice编辑器\" style=\"padding-top: 8px; padding-bottom: 8px; margin: 0; line-height: 26px; color: black; font-size: 14px;\">SameSite具体使用方式，参考<a href=\"https://web.dev/samesite-cookies-explained\" style=\"text-decoration: none; color: #1e6bb8; word-wrap: break-word; font-weight: bold; border-bottom: 1px solid #1e6bb8;\">链接</a>(放心这个也没有CSRF攻击，仿佛CSRF PTSD)</p>\n<h3 data-tool=\"mdnice编辑器\" style=\"margin-top: 30px; margin-bottom: 15px; font-weight: bold; background-color: #000; color: #fff; padding: 2px 10px; width: fit-content; font-size: 17px; margin: 60px auto 10px;\"><span class=\"prefix\" style=\"display: none;\"></span><span class=\"content\">2. 验证请求的来源站点</span><span class=\"suffix\" style=\"display: none;\"></span></h3>\n<p data-tool=\"mdnice编辑器\" style=\"padding-top: 8px; padding-bottom: 8px; margin: 0; line-height: 26px; color: black; font-size: 14px;\">当使用post请求时，HTTP头会自带<strong style=\"font-weight: bold; color: black;\">origin</strong>字段，服务器可以通过orig知晓从那个第三方站点请求，可以做白名单加以过滤。</p>\n<h3 data-tool=\"mdnice编辑器\" style=\"margin-top: 30px; margin-bottom: 15px; font-weight: bold; background-color: #000; color: #fff; padding: 2px 10px; width: fit-content; font-size: 17px; margin: 60px auto 10px;\"><span class=\"prefix\" style=\"display: none;\"></span><span class=\"content\">3. CSRF Token</span><span class=\"suffix\" style=\"display: none;\"></span></h3>\n<p data-tool=\"mdnice编辑器\" style=\"padding-top: 8px; padding-bottom: 8px; margin: 0; line-height: 26px; color: black; font-size: 14px;\">简单来说就是Cookie不安全，可以手动设置一个状态字段，浏览器请求页面数据的时候带过去，请求关键数据的时候通过请求字段携带状态字段。因为CSRF不能访问用户页面数据，就可以保证请求是合法的。就算黑客通过CSRF发出了请求，服务器也会因为 CSRF Token 不正确而拒绝请求。</p>\n<h2 data-tool=\"mdnice编辑器\" style=\"margin-top: 30px; margin-bottom: 15px; padding: 0px; font-size: 22px; text-align: center; position: relative; font-weight: bold; color: black; line-height: 1.1em; padding-top: 12px; padding-bottom: 12px; margin: 70px 30px 30px; border: 1px solid #000;\"><span style=\"float: left; display: block; width: 90%; border-top: 1px solid #000; height: 1px; line-height: 1px; margin-left: -5px; margin-top: -17px;\"> </span><span class=\"prefix\" style=\"display: block; width: 3px; margin: 0 0 0 5%; height: 3px; line-height: 3px; overflow: hidden; background-color: #000; box-shadow: 3px 0 #000,\n    0 3px #000,\n    -3px 0 #000,\n    0 -3px #000;\"></span><span class=\"content\" style=\"display: block; -webkit-box-reflect: below 0em -webkit-gradient(linear,left top,left bottom, from(rgba(0,0,0,0)),to(rgba(255,255,255,0.1)));\">总结</span><span class=\"suffix\" style=\"display: block; width: 3px; margin: 0 0 0 95%; height: 3px; line-height: 3px; overflow: hidden; background-color: #000; box-shadow: 3px 0 #000,\n    0 3px #000,\n    -3px 0 #000,\n    0 -3px #000;\"></span><span style=\"float: right; display: block; width: 90%; border-bottom: 1px solid #000; height: 1px; line-height: 1px; margin-right: -5px; margin-top: 16px;\"> </span></h2>\n<ul data-tool=\"mdnice编辑器\" style=\"margin-top: 8px; margin-bottom: 8px; padding-left: 25px; color: black; list-style-type: square;\">\n<li><section style=\"margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;\">满足CSRF攻击的条件：\n<ol style=\"margin-top: 8px; margin-bottom: 8px; padding-left: 25px; color: black; list-style-type: decimal;\">\n<li><section style=\"margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;\">目标站点存在漏洞</section></li><li><section style=\"margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;\">用户要登录过目标站点</section></li><li><section style=\"margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;\">黑客需要通过第三方站点发起攻击。</section></li></ol>\n</section></li><li><section style=\"margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;\">防御CSRF的方法\n<ol style=\"margin-top: 8px; margin-bottom: 8px; padding-left: 25px; color: black; list-style-type: decimal;\">\n<li><section style=\"margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;\">利用好 Cookie 的 SameSite 属性</section></li><li><section style=\"margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;\">验证请求的来源站点</section></li><li><section style=\"margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;\">使用 CSRF Token</section></li></ol>\n</section></li><li><section style=\"margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;\">出现XSS和CSRF漏洞的原因就是因为浏览器的同源策略开了两个口子：在页面中可以任意引用第三方资源和通过 CORS 策略让 XMLHttpRequest 和 Fetch 去跨域请求资源。这就导致来XSS和CSRF，作为debug，引入了 HttpOnly 机制来禁止第三方资源发送一些关键 Cookie，引入了 SameSite 和 Origin 来防止CSRF跨域请求的攻击。</section></li></ul>\n<span style=\"font-size: 15px; display: block; text-align: center; margin-top: 50px; color: #999; border-bottom: 1px solid #eee;\">- END -</span></section>", "user_name": "宫本", "description": "", "got_view_count": 943, "category_name": "阅读", "ctime": 1457483895}
{"tag_name": "Dubbo", "concern_user_count": 9623, "user_id": "2313028193225319", "title": "聊聊dubbo-go的ConsistentHashLoadBalance", "mark_content": "## 序\n本文主要研究一下dubbo-go的ConsistentHashLoadBalance\n\n## ConsistentHashLoadBalance\ndubbo-go-v1.4.2/cluster/loadbalance/consistent_hash.go\n```\nconst (\n\t// ConsistentHash ...\n\tConsistentHash = \"consistenthash\"\n\t// HashNodes ...\n\tHashNodes = \"hash.nodes\"\n\t// HashArguments ...\n\tHashArguments = \"hash.arguments\"\n)\n\nvar (\n\tselectors = make(map[string]*ConsistentHashSelector)\n\tre        = regexp.MustCompile(constant.COMMA_SPLIT_PATTERN)\n)\n\nfunc init() {\n\textension.SetLoadbalance(ConsistentHash, NewConsistentHashLoadBalance)\n}\n\n// ConsistentHashLoadBalance ...\ntype ConsistentHashLoadBalance struct {\n}\n\n// NewConsistentHashLoadBalance ...\nfunc NewConsistentHashLoadBalance() cluster.LoadBalance {\n\treturn &ConsistentHashLoadBalance{}\n}\n```\n- ConsistentHashLoadBalance的init方法设置了名为consistenthash的ConsistentHashLoadBalance到extension中\n\n## Select\ndubbo-go-v1.4.2/cluster/loadbalance/consistent_hash.go\n```\n// Select ...\nfunc (lb *ConsistentHashLoadBalance) Select(invokers []protocol.Invoker, invocation protocol.Invocation) protocol.Invoker {\n\tmethodName := invocation.MethodName()\n\tkey := invokers[0].GetUrl().ServiceKey() + \".\" + methodName\n\n\t// hash the invokers\n\tbs := make([]byte, 0)\n\tfor _, invoker := range invokers {\n\t\tb, err := json.Marshal(invoker)\n\t\tif err != nil {\n\t\t\treturn nil\n\t\t}\n\t\tbs = append(bs, b...)\n\t}\n\thashCode := crc32.ChecksumIEEE(bs)\n\tselector, ok := selectors[key]\n\tif !ok || selector.hashCode != hashCode {\n\t\tselectors[key] = newConsistentHashSelector(invokers, methodName, hashCode)\n\t\tselector = selectors[key]\n\t}\n\treturn selector.Select(invocation)\n}\n```\n- Select方法遍历invokers挨个执行json.Marshal(invoker)，将bytes[]添加到bs中，之后通过crc32.ChecksumIEEE(bs)计算hashCode，然后对比selectors[key]的hashCode与计算出来的hashCode是否一致，不一致则通过newConsistentHashSelector重新设置一个，最后执行selector.Select(invocation)\n\n## ConsistentHashSelector\ndubbo-go-v1.4.2/cluster/loadbalance/consistent_hash.go\n```\n// ConsistentHashSelector ...\ntype ConsistentHashSelector struct {\n\thashCode        uint32\n\treplicaNum      int\n\tvirtualInvokers map[uint32]protocol.Invoker\n\tkeys            Uint32Slice\n\targumentIndex   []int\n}\n```\n- ConsistentHashSelector定义了hashCode、replicaNum、virtualInvokers、keys、argumentIndex属性\n\n## newConsistentHashSelector\ndubbo-go-v1.4.2/cluster/loadbalance/consistent_hash.go\n```\nfunc newConsistentHashSelector(invokers []protocol.Invoker, methodName string,\n\thashCode uint32) *ConsistentHashSelector {\n\n\tselector := &ConsistentHashSelector{}\n\tselector.virtualInvokers = make(map[uint32]protocol.Invoker)\n\tselector.hashCode = hashCode\n\turl := invokers[0].GetUrl()\n\tselector.replicaNum = int(url.GetMethodParamInt(methodName, HashNodes, 160))\n\tindices := re.Split(url.GetMethodParam(methodName, HashArguments, \"0\"), -1)\n\tfor _, index := range indices {\n\t\ti, err := strconv.Atoi(index)\n\t\tif err != nil {\n\t\t\treturn nil\n\t\t}\n\t\tselector.argumentIndex = append(selector.argumentIndex, i)\n\t}\n\tfor _, invoker := range invokers {\n\t\tu := invoker.GetUrl()\n\t\taddress := u.Ip + \":\" + u.Port\n\t\tfor i := 0; i < selector.replicaNum/4; i++ {\n\t\t\tdigest := md5.Sum([]byte(address + strconv.Itoa(i)))\n\t\t\tfor j := 0; j < 4; j++ {\n\t\t\t\tkey := selector.hash(digest, j)\n\t\t\t\tselector.keys = append(selector.keys, key)\n\t\t\t\tselector.virtualInvokers[key] = invoker\n\t\t\t}\n\t\t}\n\t}\n\tsort.Sort(selector.keys)\n\treturn selector\n}\n```\n- newConsistentHashSelector方法实例化ConsistentHashSelector，并初始化virtualInvokers、hashCode、argumentIndex、keys、virtualInvokers属性\n\n## Select\ndubbo-go-v1.4.2/cluster/loadbalance/consistent_hash.go\n```\n// Select ...\nfunc (c *ConsistentHashSelector) Select(invocation protocol.Invocation) protocol.Invoker {\n\tkey := c.toKey(invocation.Arguments())\n\tdigest := md5.Sum([]byte(key))\n\treturn c.selectForKey(c.hash(digest, 0))\n}\n\nfunc (c *ConsistentHashSelector) toKey(args []interface{}) string {\n\tvar sb strings.Builder\n\tfor i := range c.argumentIndex {\n\t\tif i >= 0 && i < len(args) {\n\t\t\tfmt.Fprint(&sb, args[i].(string))\n\t\t}\n\t}\n\treturn sb.String()\n}\n\nfunc (c *ConsistentHashSelector) selectForKey(hash uint32) protocol.Invoker {\n\tidx := sort.Search(len(c.keys), func(i int) bool {\n\t\treturn c.keys[i] >= hash\n\t})\n\tif idx == len(c.keys) {\n\t\tidx = 0\n\t}\n\treturn c.virtualInvokers[c.keys[idx]]\n}\n\nfunc (c *ConsistentHashSelector) hash(digest [16]byte, i int) uint32 {\n\treturn uint32((digest[3+i*4]&0xFF)<<24) | uint32((digest[2+i*4]&0xFF)<<16) |\n\t\tuint32((digest[1+i*4]&0xFF)<<8) | uint32(digest[i*4]&0xFF)&0xFFFFFFF\n}\n```\n- Select方法通过c.toKey(invocation.Arguments())获取key，再通过md5.Sum([]byte(key))计算digest，最后通过c.selectForKey(c.hash(digest, 0))选取Invoker\n\n## 小结\nConsistentHashLoadBalance的Select方法遍历invokers挨个执行json.Marshal(invoker)，将bytes[]添加到bs中，之后通过crc32.ChecksumIEEE(bs)计算hashCode，然后对比selectors[key]的hashCode与计算出来的hashCode是否一致，不一致则通过newConsistentHashSelector重新设置一个，最后执行selector.Select(invocation)\n\n## doc\n- [consistent_hash](dubbo-go-v1.4.2/cluster/loadbalance/consistent_hash.go)", "user_name": "go4it", "description": "", "got_view_count": 245525, "category_name": "后端", "ctime": 1457483880}
{"tag_name": "HTTP", "concern_user_count": 151675, "user_id": "2348212569517645", "title": "「查缺补漏」巩固你的HTTP知识体系", "mark_content": "<section id=\"nice\" data-tool=\"mdnice编辑器\" data-website=\"https://www.mdnice.com\" style=\"font-size: 16px; color: black; padding: 0 10px; word-spacing: 0px; word-break: break-word; word-wrap: break-word; text-align: left; line-height: 1.25; font-family: Optima-Regular, Optima, PingFangTC-Light, PingFangSC-light, PingFangTC-light; letter-spacing: 2px; background-image: linear-gradient(90deg, rgba(50, 0, 0, 0.05) 3%, rgba(0, 0, 0, 0) 3%), linear-gradient(360deg, rgba(50, 0, 0, 0.05) 3%, rgba(0, 0, 0, 0) 3%); background-size: 20px 20px; background-position: center center;\"><h2 data-tool=\"mdnice编辑器\" style=\"margin-top: 30px; margin-bottom: 15px; padding: 0px; font-weight: bold; color: black; font-size: 22px; text-align: left; margin: 20px 10px 0px 0px;\"><span class=\"prefix\" style=\"display: none;\"></span><span class=\"content\" style=\"font-size: 18px; font-weight: bold; display: inline-block; padding-left: 10px; border-left: 5px solid #916dd5;\">前言</span><span class=\"suffix\"></span></h2>\n<p data-tool=\"mdnice编辑器\" style=\"padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: black; margin: 10px 0px; letter-spacing: 2px; font-size: 14px; word-spacing: 2px;\">这次梳理的篇幅主要是涉及网络部分，包括HTTP等，对巩固自己的网络知识体系也是很有帮助的，进一步的对性能优化而言也是帮助很大的。</p>\n<p data-tool=\"mdnice编辑器\" style=\"padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: black; margin: 10px 0px; letter-spacing: 2px; font-size: 14px; word-spacing: 2px;\">但更多的是抛砖引玉，希望对你们有所帮助。</p>\n<blockquote data-tool=\"mdnice编辑器\" style=\"display: block; font-size: 0.9em; overflow: auto; overflow-scrolling: touch; border-left: 3px solid rgba(0, 0, 0, 0.4); color: #6a737d; padding-top: 10px; padding-bottom: 10px; padding-left: 20px; padding-right: 10px; margin-bottom: 20px; margin-top: 20px; border-left-color: #d89cf6; background: #f4eeff;\">\n<p style=\"padding-top: 8px; padding-bottom: 8px; letter-spacing: 2px; font-size: 14px; word-spacing: 2px; margin: 0px; color: black; line-height: 26px;\">感谢掘友的鼓励与支持🌹🌹🌹，往期文章都在最后梳理出来了(●'◡'●)</p>\n</blockquote>\n<p data-tool=\"mdnice编辑器\" style=\"padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: black; margin: 10px 0px; letter-spacing: 2px; font-size: 14px; word-spacing: 2px;\">接下来就以问题的形式展开梳理👇</p>\n<h2 data-tool=\"mdnice编辑器\" style=\"margin-top: 30px; margin-bottom: 15px; padding: 0px; font-weight: bold; color: black; font-size: 22px; text-align: left; margin: 20px 10px 0px 0px;\"><span class=\"prefix\" style=\"display: none;\"></span><span class=\"content\" style=\"font-size: 18px; font-weight: bold; display: inline-block; padding-left: 10px; border-left: 5px solid #916dd5;\">谈一谈HTTP协议优缺点</span><span class=\"suffix\"></span></h2>\n<p data-tool=\"mdnice编辑器\" style=\"padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: black; margin: 10px 0px; letter-spacing: 2px; font-size: 14px; word-spacing: 2px;\">超文本传输协议，<strong style=\"color: #916dd5; font-weight: bold;\"><span>「</span>HTTP 是一个在计算机世界里专门在两点之间传输文字、图片、音频、视频等超文本数据的约定和规范<span>」</span></strong>。</p>\n<h3 data-tool=\"mdnice编辑器\" style=\"margin-top: 30px; margin-bottom: 15px; padding: 0px; color: black; font-size: 16px; font-weight: bold; text-align: center;\"><span class=\"prefix\" style=\"display: none;\"></span><span class=\"content\" style=\"border-bottom: 2px solid #d89cf6;\">HTTP 特点</span><span class=\"suffix\" style=\"display: none;\"></span></h3>\n<ol data-tool=\"mdnice编辑器\" style=\"margin-top: 8px; margin-bottom: 8px; padding-left: 25px; color: black; list-style-type: decimal; font-size: 15px;\">\n<li><section style=\"margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-size: 14px; font-weight: normal;\"><strong style=\"color: #916dd5; font-weight: bold;\"><span>「</span>灵活可扩展<span>」</span></strong>。一个是语法上只规定了基本格式，空格分隔单词，换行分隔字段等。另外一个就是传输形式上不仅可以传输文本，还可以传输图片，视频等任意数据。</section></li><li><section style=\"margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-size: 14px; font-weight: normal;\"><strong style=\"color: #916dd5; font-weight: bold;\"><span>「</span>请求-应答模式<span>」</span></strong>，通常而言，就是一方发送消息，另外一方要接受消息，或者是做出相应等。</section></li><li><section style=\"margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-size: 14px; font-weight: normal;\"><strong style=\"color: #916dd5; font-weight: bold;\"><span>「</span>可靠传输<span>」</span></strong>，HTTP是基于TCP/IP，因此把这一特性继承了下来。</section></li><li><section style=\"margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-size: 14px; font-weight: normal;\"><strong style=\"color: #916dd5; font-weight: bold;\"><span>「</span>无状态<span>」</span></strong>，这个分场景回答即可。</section></li></ol>\n<h3 data-tool=\"mdnice编辑器\" style=\"margin-top: 30px; margin-bottom: 15px; padding: 0px; color: black; font-size: 16px; font-weight: bold; text-align: center;\"><span class=\"prefix\" style=\"display: none;\"></span><span class=\"content\" style=\"border-bottom: 2px solid #d89cf6;\">HTTP 缺点</span><span class=\"suffix\" style=\"display: none;\"></span></h3>\n<ol data-tool=\"mdnice编辑器\" style=\"margin-top: 8px; margin-bottom: 8px; padding-left: 25px; color: black; list-style-type: decimal; font-size: 15px;\">\n<li><section style=\"margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-size: 14px; font-weight: normal;\"><strong style=\"color: #916dd5; font-weight: bold;\"><span>「</span>无状态<span>」</span></strong>，有时候，需要保存信息，比如像购物系统，需要保留下顾客信息等等，另外一方面，有时候，无状态也会减少网络开销，比如类似直播行业这样子等，这个还是分场景来说。</section></li><li><section style=\"margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-size: 14px; font-weight: normal;\"><strong style=\"color: #916dd5; font-weight: bold;\"><span>「</span>明文传输<span>」</span></strong>，即协议里的报文(主要指的是头部)不使用二进制数据，而是文本形式。这让HTTP的报文信息暴露给了外界，给攻击者带来了便利。</section></li><li><section style=\"margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-size: 14px; font-weight: normal;\"><strong style=\"color: #916dd5; font-weight: bold;\"><span>「</span>队头阻塞<span>」</span></strong>，当http开启长连接时，共用一个TCP连接，当某个请求时间过长时，其他的请求只能处于阻塞状态，这就是队头阻塞问题。</section></li></ol>\n<hr data-tool=\"mdnice编辑器\" style=\"margin: 0; margin-top: 10px; margin-bottom: 10px; height: 1px; padding: 0; border: none; border-top: 2px solid #d9b8fa;\">\n<h2 data-tool=\"mdnice编辑器\" style=\"margin-top: 30px; margin-bottom: 15px; padding: 0px; font-weight: bold; color: black; font-size: 22px; text-align: left; margin: 20px 10px 0px 0px;\"><span class=\"prefix\" style=\"display: none;\"></span><span class=\"content\" style=\"font-size: 18px; font-weight: bold; display: inline-block; padding-left: 10px; border-left: 5px solid #916dd5;\">HTTP/1.0 HTTP1.1 HTTP2.0版本之间的差异</span><span class=\"suffix\"></span></h2>\n<h3 data-tool=\"mdnice编辑器\" style=\"margin-top: 30px; margin-bottom: 15px; padding: 0px; color: black; font-size: 16px; font-weight: bold; text-align: center;\"><span class=\"prefix\" style=\"display: none;\"></span><span class=\"content\" style=\"border-bottom: 2px solid #d89cf6;\">HTTP 0.9</span><span class=\"suffix\" style=\"display: none;\"></span></h3>\n<ul data-tool=\"mdnice编辑器\" style=\"margin-top: 8px; margin-bottom: 8px; padding-left: 25px; color: black; font-size: 15px; list-style-type: circle;\">\n<li><section style=\"margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-size: 14px; font-weight: normal;\">1991年,原型版本，功能简陋，只有一个命令GET,只支持纯文本内容，该版本已过时。</section></li></ul>\n<h3 data-tool=\"mdnice编辑器\" style=\"margin-top: 30px; margin-bottom: 15px; padding: 0px; color: black; font-size: 16px; font-weight: bold; text-align: center;\"><span class=\"prefix\" style=\"display: none;\"></span><span class=\"content\" style=\"border-bottom: 2px solid #d89cf6;\">HTTP 1.0</span><span class=\"suffix\" style=\"display: none;\"></span></h3>\n<ul data-tool=\"mdnice编辑器\" style=\"margin-top: 8px; margin-bottom: 8px; padding-left: 25px; color: black; font-size: 15px; list-style-type: circle;\">\n<li><section style=\"margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-size: 14px; font-weight: normal;\">任何格式的内容都可以发送，这使得互联网不仅可以传输文字，还能传输图像、视频、二进制等文件。</section></li><li><section style=\"margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-size: 14px; font-weight: normal;\">除了GET命令，还引入了POST命令和HEAD命令。</section></li><li><section style=\"margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-size: 14px; font-weight: normal;\">http请求和回应的格式改变，除了数据部分，每次通信都必须包括头信息（HTTP header），用来描述一些元数据。</section></li><li><section style=\"margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-size: 14px; font-weight: normal;\">只使用 header 中的 If-Modified-Since 和 Expires 作为缓存失效的标准。</section></li><li><section style=\"margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-size: 14px; font-weight: normal;\">不支持断点续传，也就是说，每次都会传送全部的页面和数据。</section></li><li><section style=\"margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-size: 14px; font-weight: normal;\">通常每台计算机只能绑定一个 IP，所以请求消息中的 URL 并没有传递主机名（hostname）</section></li></ul>\n<h3 data-tool=\"mdnice编辑器\" style=\"margin-top: 30px; margin-bottom: 15px; padding: 0px; color: black; font-size: 16px; font-weight: bold; text-align: center;\"><span class=\"prefix\" style=\"display: none;\"></span><span class=\"content\" style=\"border-bottom: 2px solid #d89cf6;\">HTTP 1.1</span><span class=\"suffix\" style=\"display: none;\"></span></h3>\n<p data-tool=\"mdnice编辑器\" style=\"padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: black; margin: 10px 0px; letter-spacing: 2px; font-size: 14px; word-spacing: 2px;\">http1.1是目前最为主流的http协议版本，从1999年发布至今，仍是主流的http协议版本。</p>\n<ul data-tool=\"mdnice编辑器\" style=\"margin-top: 8px; margin-bottom: 8px; padding-left: 25px; color: black; font-size: 15px; list-style-type: circle;\">\n<li><section style=\"margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-size: 14px; font-weight: normal;\">引入了持久连接（ persistent connection），即TCP连接默认不关闭，可以被多个请求复用，不用声明Connection: keep-alive。长连接的连接时长可以通过请求头中的 <code style=\"font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #916dd5; font-weight: bolder; background: none;\">keep-alive</code> 来设置</section></li><li><section style=\"margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-size: 14px; font-weight: normal;\">引入了管道机制（ pipelining），即在同一个TCP连接里，客户端可以同时发送多个\n请求，进一步改进了HTTP协议的效率。</section></li><li><section style=\"margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-size: 14px; font-weight: normal;\">HTTP 1.1 中新增加了 E-tag，If-Unmodified-Since, If-Match, If-None-Match 等缓存控制标头来控制缓存失效。</section></li><li><section style=\"margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-size: 14px; font-weight: normal;\">支持断点续传，通过使用请求头中的 <code style=\"font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #916dd5; font-weight: bolder; background: none;\">Range</code> 来实现。</section></li><li><section style=\"margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-size: 14px; font-weight: normal;\">使用了虚拟网络，在一台物理服务器上可以存在多个虚拟主机（Multi-homed Web Servers），并且它们共享一个IP地址。</section></li><li><section style=\"margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-size: 14px; font-weight: normal;\">新增方法：PUT、 PATCH、 OPTIONS、 DELETE。</section></li></ul>\n<h3 data-tool=\"mdnice编辑器\" style=\"margin-top: 30px; margin-bottom: 15px; padding: 0px; color: black; font-size: 16px; font-weight: bold; text-align: center;\"><span class=\"prefix\" style=\"display: none;\"></span><span class=\"content\" style=\"border-bottom: 2px solid #d89cf6;\">http1.x版本问题</span><span class=\"suffix\" style=\"display: none;\"></span></h3>\n<ul data-tool=\"mdnice编辑器\" style=\"margin-top: 8px; margin-bottom: 8px; padding-left: 25px; color: black; font-size: 15px; list-style-type: circle;\">\n<li><section style=\"margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-size: 14px; font-weight: normal;\">在传输数据过程中，所有内容都是明文，客户端和服务器端都无法验证对方的身份，无法保证数据的安全性。</section></li><li><section style=\"margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-size: 14px; font-weight: normal;\">HTTP/1.1 版本默认允许复用TCP连接，但是在同一个TCP连接里，所有数据通信是按次序进行的，服务器通常在处理完一个回应后，才会继续去处理下一个，这样子就会造成队头阻塞。</section></li><li><section style=\"margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-size: 14px; font-weight: normal;\">http/1.x 版本支持Keep-alive，用此方案来弥补创建多次连接产生的延迟，但是同样会给服务器带来压力，并且的话，对于单文件被不断请求的服务，Keep-alive会极大影响性能，因为它在文件被请求之后还保持了不必要的连接很长时间。</section></li></ul>\n<h3 data-tool=\"mdnice编辑器\" style=\"margin-top: 30px; margin-bottom: 15px; padding: 0px; color: black; font-size: 16px; font-weight: bold; text-align: center;\"><span class=\"prefix\" style=\"display: none;\"></span><span class=\"content\" style=\"border-bottom: 2px solid #d89cf6;\">HTTP 2.0</span><span class=\"suffix\" style=\"display: none;\"></span></h3>\n<ul data-tool=\"mdnice编辑器\" style=\"margin-top: 8px; margin-bottom: 8px; padding-left: 25px; color: black; font-size: 15px; list-style-type: circle;\">\n<li><section style=\"margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-size: 14px; font-weight: normal;\"><code style=\"font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #916dd5; font-weight: bolder; background: none;\">二进制分帧</code>  这是一次彻底的二进制协议，头信息和数据体都是二进制，并且统称为\"帧\"：头信息帧和数据帧。</section></li><li><section style=\"margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-size: 14px; font-weight: normal;\"><code style=\"font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #916dd5; font-weight: bolder; background: none;\">头部压缩</code>  HTTP 1.1版本会出现 <strong style=\"color: #916dd5; font-weight: bold;\"><span>「</span>User-Agent、Cookie、Accept、Server、Range<span>」</span></strong> 等字段可能会占用几百甚至几千字节，而 Body 却经常只有几十字节，所以导致头部偏重。HTTP 2.0 使用 <code style=\"font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #916dd5; font-weight: bolder; background: none;\">HPACK</code> 算法进行压缩。</section></li><li><section style=\"margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-size: 14px; font-weight: normal;\"><code style=\"font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #916dd5; font-weight: bolder; background: none;\">多路复用</code> 复用TCP连接，在一个连接里，客户端和浏览器都可以同时发送多个请求或回应，且不用按顺序一一对应，这样子解决了队头阻塞的问题。</section></li><li><section style=\"margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-size: 14px; font-weight: normal;\"><code style=\"font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #916dd5; font-weight: bolder; background: none;\">服务器推送</code> 允许服务器未经请求，主动向客户端发送资源，即服务器推送。</section></li><li><section style=\"margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-size: 14px; font-weight: normal;\"><code style=\"font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #916dd5; font-weight: bolder; background: none;\">请求优先级</code> 可以设置数据帧的优先级，让服务端先处理重要资源，优化用户体验。</section></li></ul>\n<hr data-tool=\"mdnice编辑器\" style=\"margin: 0; margin-top: 10px; margin-bottom: 10px; height: 1px; padding: 0; border: none; border-top: 2px solid #d9b8fa;\">\n<h2 data-tool=\"mdnice编辑器\" style=\"margin-top: 30px; margin-bottom: 15px; padding: 0px; font-weight: bold; color: black; font-size: 22px; text-align: left; margin: 20px 10px 0px 0px;\"><span class=\"prefix\" style=\"display: none;\"></span><span class=\"content\" style=\"font-size: 18px; font-weight: bold; display: inline-block; padding-left: 10px; border-left: 5px solid #916dd5;\">谈一谈你对HTTP/2理解</span><span class=\"suffix\"></span></h2>\n<h3 data-tool=\"mdnice编辑器\" style=\"margin-top: 30px; margin-bottom: 15px; padding: 0px; color: black; font-size: 16px; font-weight: bold; text-align: center;\"><span class=\"prefix\" style=\"display: none;\"></span><span class=\"content\" style=\"border-bottom: 2px solid #d89cf6;\">头部压缩</span><span class=\"suffix\" style=\"display: none;\"></span></h3>\n<p data-tool=\"mdnice编辑器\" style=\"padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: black; margin: 10px 0px; letter-spacing: 2px; font-size: 14px; word-spacing: 2px;\">HTTP 1.1版本会出现 <strong style=\"color: #916dd5; font-weight: bold;\"><span>「</span>User-Agent、Cookie、Accept、Server、Range<span>」</span></strong> 等字段可能会占用几百甚至几千字节，而 Body 却经常只有几十字节，所以导致头部偏重。</p>\n<p data-tool=\"mdnice编辑器\" style=\"padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: black; margin: 10px 0px; letter-spacing: 2px; font-size: 14px; word-spacing: 2px;\">HTTP 2.0 使用 <code style=\"font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #916dd5; font-weight: bolder; background: none;\">HPACK</code> 算法进行压缩。</p>\n<p data-tool=\"mdnice编辑器\" style=\"padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: black; margin: 10px 0px; letter-spacing: 2px; font-size: 14px; word-spacing: 2px;\">那我们看看<code style=\"font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #916dd5; font-weight: bolder; background: none;\">HPACK</code>算法吧👇</p>\n<figure data-tool=\"mdnice编辑器\" style=\"margin: 0; margin-top: 10px; margin-bottom: 10px; display: flex; flex-direction: column; justify-content: center; align-items: center;\"><img src=\"https://user-images.githubusercontent.com/34484322/89356545-a3fd4100-d6f0-11ea-8e0a-8870d832e96e.png\" alt style=\"max-width: 100%; border-radius: 6px; display: block; margin: 20px auto; object-fit: contain; box-shadow: 2px 4px 7px #999;\"></figure>\n<blockquote data-tool=\"mdnice编辑器\" style=\"display: block; font-size: 0.9em; overflow: auto; overflow-scrolling: touch; border-left: 3px solid rgba(0, 0, 0, 0.4); color: #6a737d; padding-top: 10px; padding-bottom: 10px; padding-left: 20px; padding-right: 10px; margin-bottom: 20px; margin-top: 20px; border-left-color: #d89cf6; background: #f4eeff;\">\n<p style=\"padding-top: 8px; padding-bottom: 8px; letter-spacing: 2px; font-size: 14px; word-spacing: 2px; margin: 0px; color: black; line-height: 26px;\">从上面看，我们可以看到类似于索引表，每个索引表对应一个值，比如索引为2对应头部中的method头部信息，这样子的话，在传输的时候，不在是传输对应的头部信息了，而是传递索引，对于之前出现过的头部信息，只需要把<strong style=\"color: #916dd5; font-weight: bold;\"><span>「</span>索引<span>」</span></strong>(比如1，2，...)传给对方即可，对方拿到索引查表就行了。</p>\n</blockquote>\n<p data-tool=\"mdnice编辑器\" style=\"padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: black; margin: 10px 0px; letter-spacing: 2px; font-size: 14px; word-spacing: 2px;\">这种<strong style=\"color: #916dd5; font-weight: bold;\"><span>「</span>传索引<span>」</span></strong>的方式，可以说让请求头字段得到极大程度的精简和复用。</p>\n<p data-tool=\"mdnice编辑器\" style=\"padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: black; margin: 10px 0px; letter-spacing: 2px; font-size: 14px; word-spacing: 2px;\">其次是对于整数和字符串进行<strong style=\"color: #916dd5; font-weight: bold;\"><span>「</span>哈夫曼编码<span>」</span></strong>，哈夫曼编码的原理就是先将所有出现的字符建立一张索引表，然后让出现次数多的字符对应的索引尽可能短，传输的时候也是传输这样的<strong style=\"color: #916dd5; font-weight: bold;\"><span>「</span>索引序列<span>」</span></strong>，可以达到非常高的压缩率。</p>\n<h3 data-tool=\"mdnice编辑器\" style=\"margin-top: 30px; margin-bottom: 15px; padding: 0px; color: black; font-size: 16px; font-weight: bold; text-align: center;\"><span class=\"prefix\" style=\"display: none;\"></span><span class=\"content\" style=\"border-bottom: 2px solid #d89cf6;\">多路复用</span><span class=\"suffix\" style=\"display: none;\"></span></h3>\n<p data-tool=\"mdnice编辑器\" style=\"padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: black; margin: 10px 0px; letter-spacing: 2px; font-size: 14px; word-spacing: 2px;\">HTTP 1.x 中，如果想并发多个请求，必须使用多个 TCP 链接，且浏览器为了控制资源，还会对单个域名有 6-8个的TCP链接请求限制。</p>\n<p data-tool=\"mdnice编辑器\" style=\"padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: black; margin: 10px 0px; letter-spacing: 2px; font-size: 14px; word-spacing: 2px;\">HTTP2中：</p>\n<ul data-tool=\"mdnice编辑器\" style=\"margin-top: 8px; margin-bottom: 8px; padding-left: 25px; color: black; font-size: 15px; list-style-type: circle;\">\n<li><section style=\"margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-size: 14px; font-weight: normal;\">同域名下所有通信都在单个连接上完成。</section></li><li><section style=\"margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-size: 14px; font-weight: normal;\">单个连接可以承载任意数量的双向数据流。</section></li><li><section style=\"margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-size: 14px; font-weight: normal;\">数据流以消息的形式发送，而消息又由一个或多个帧组成，多个帧之间可以乱序发送，因为根据帧首部的流标识可以重新组装，也就是<code style=\"font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #916dd5; font-weight: bolder; background: none;\">Stream ID</code>，流标识符，有了它，接收方就能从乱序的二进制帧中选择ID相同的帧，按照顺序组装成请求/响应报文。</section></li></ul>\n<h3 data-tool=\"mdnice编辑器\" style=\"margin-top: 30px; margin-bottom: 15px; padding: 0px; color: black; font-size: 16px; font-weight: bold; text-align: center;\"><span class=\"prefix\" style=\"display: none;\"></span><span class=\"content\" style=\"border-bottom: 2px solid #d89cf6;\">服务器推送</span><span class=\"suffix\" style=\"display: none;\"></span></h3>\n<p data-tool=\"mdnice编辑器\" style=\"padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: black; margin: 10px 0px; letter-spacing: 2px; font-size: 14px; word-spacing: 2px;\">浏览器发送一个请求，服务器主动向浏览器推送与这个请求相关的资源，这样浏览器就不用发起后续请求。</p>\n<p data-tool=\"mdnice编辑器\" style=\"padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: black; margin: 10px 0px; letter-spacing: 2px; font-size: 14px; word-spacing: 2px;\">相比较http/1.1的优势👇</p>\n<ul data-tool=\"mdnice编辑器\" style=\"margin-top: 8px; margin-bottom: 8px; padding-left: 25px; color: black; font-size: 15px; list-style-type: circle;\">\n<li><section style=\"margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-size: 14px; font-weight: normal;\">推送资源可以由不同页面共享</section></li><li><section style=\"margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-size: 14px; font-weight: normal;\">服务器可以按照优先级推送资源</section></li><li><section style=\"margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-size: 14px; font-weight: normal;\">客户端可以缓存推送的资源</section></li><li><section style=\"margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-size: 14px; font-weight: normal;\">客户端可以拒收推送过来的资源</section></li></ul>\n<h3 data-tool=\"mdnice编辑器\" style=\"margin-top: 30px; margin-bottom: 15px; padding: 0px; color: black; font-size: 16px; font-weight: bold; text-align: center;\"><span class=\"prefix\" style=\"display: none;\"></span><span class=\"content\" style=\"border-bottom: 2px solid #d89cf6;\">二进制分帧</span><span class=\"suffix\" style=\"display: none;\"></span></h3>\n<p data-tool=\"mdnice编辑器\" style=\"padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: black; margin: 10px 0px; letter-spacing: 2px; font-size: 14px; word-spacing: 2px;\">之前是明文传输，不方便计算机解析，对于回车换行符来说到底是内容还是分隔符，都需要内部状态机去识别，这样子效率低，HTTP/2采用二进制格式，全部传输01串，便于机器解码。</p>\n<p data-tool=\"mdnice编辑器\" style=\"padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: black; margin: 10px 0px; letter-spacing: 2px; font-size: 14px; word-spacing: 2px;\">这样子一个报文格式就被拆分为一个个二进制帧，用<strong style=\"color: #916dd5; font-weight: bold;\"><span>「</span>Headers帧<span>」</span></strong>存放头部字段，<strong style=\"color: #916dd5; font-weight: bold;\"><span>「</span>Data帧<span>」</span></strong>存放请求体数据。这样子的话，就是一堆乱序的二进制帧，它们不存在先后关系，因此不需要排队等待，解决了HTTP队头阻塞问题。</p>\n<p data-tool=\"mdnice编辑器\" style=\"padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: black; margin: 10px 0px; letter-spacing: 2px; font-size: 14px; word-spacing: 2px;\">在客户端与服务器之间，双方都可以互相发送二进制帧，这样子<strong style=\"color: #916dd5; font-weight: bold;\"><span>「</span>双向传输的序列<span>」</span></strong>，称为<code style=\"font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #916dd5; font-weight: bolder; background: none;\">流</code>，所以HTTP/2中以流来表示一个TCP连接上进行多个数据帧的通信，这就是多路复用概念。</p>\n<p data-tool=\"mdnice编辑器\" style=\"padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: black; margin: 10px 0px; letter-spacing: 2px; font-size: 14px; word-spacing: 2px;\">那乱序的二进制帧，是如何组装成对于的报文呢？</p>\n<ul data-tool=\"mdnice编辑器\" style=\"margin-top: 8px; margin-bottom: 8px; padding-left: 25px; color: black; font-size: 15px; list-style-type: circle;\">\n<li><section style=\"margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-size: 14px; font-weight: normal;\">所谓的乱序，值的是不同ID的Stream是乱序的，对于同一个Stream ID的帧是按顺序传输的。</section></li><li><section style=\"margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-size: 14px; font-weight: normal;\">接收方收到二进制帧后，将相同的Stream ID组装成完整的请求报文和响应报文。</section></li><li><section style=\"margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-size: 14px; font-weight: normal;\">二进制帧中有一些字段，控制着<code style=\"font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #916dd5; font-weight: bolder; background: none;\">优先级</code>和<code style=\"font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #916dd5; font-weight: bolder; background: none;\">流量控制</code>等功能，这样子的话，就可以设置数据帧的优先级，让服务器处理重要资源，优化用户体验。</section></li></ul>\n<hr data-tool=\"mdnice编辑器\" style=\"margin: 0; margin-top: 10px; margin-bottom: 10px; height: 1px; padding: 0; border: none; border-top: 2px solid #d9b8fa;\">\n<h2 data-tool=\"mdnice编辑器\" style=\"margin-top: 30px; margin-bottom: 15px; padding: 0px; font-weight: bold; color: black; font-size: 22px; text-align: left; margin: 20px 10px 0px 0px;\"><span class=\"prefix\" style=\"display: none;\"></span><span class=\"content\" style=\"font-size: 18px; font-weight: bold; display: inline-block; padding-left: 10px; border-left: 5px solid #916dd5;\">介绍一下HTTP 常见状态码</span><span class=\"suffix\"></span></h2>\n<p data-tool=\"mdnice编辑器\" style=\"padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: black; margin: 10px 0px; letter-spacing: 2px; font-size: 14px; word-spacing: 2px;\">RFC 规定 HTTP 的状态码为<strong style=\"color: #916dd5; font-weight: bold;\"><span>「</span>三位数<span>」</span></strong>，第一个数字定义了响应的类别，被分为五类:</p>\n<ul data-tool=\"mdnice编辑器\" style=\"margin-top: 8px; margin-bottom: 8px; padding-left: 25px; color: black; font-size: 15px; list-style-type: circle;\">\n<li><section style=\"margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-size: 14px; font-weight: normal;\"><strong style=\"color: #916dd5; font-weight: bold;\"><span>「</span>1xx<span>」</span></strong>: 代表请求已被接受，需要继续处理。</section></li><li><section style=\"margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-size: 14px; font-weight: normal;\"><strong style=\"color: #916dd5; font-weight: bold;\"><span>「</span>2xx<span>」</span></strong>: 表示成功状态。</section></li><li><section style=\"margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-size: 14px; font-weight: normal;\"><strong style=\"color: #916dd5; font-weight: bold;\"><span>「</span>3xx<span>」</span></strong>: 重定向状态。</section></li><li><section style=\"margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-size: 14px; font-weight: normal;\"><strong style=\"color: #916dd5; font-weight: bold;\"><span>「</span>4xx<span>」</span></strong>: 客户端错误。</section></li><li><section style=\"margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-size: 14px; font-weight: normal;\"><strong style=\"color: #916dd5; font-weight: bold;\"><span>「</span>5xx<span>」</span></strong>: 服务器端错误。</section></li></ul>\n<h3 data-tool=\"mdnice编辑器\" style=\"margin-top: 30px; margin-bottom: 15px; padding: 0px; color: black; font-size: 16px; font-weight: bold; text-align: center;\"><span class=\"prefix\" style=\"display: none;\"></span><span class=\"content\" style=\"border-bottom: 2px solid #d89cf6;\">1xx 信息类</span><span class=\"suffix\" style=\"display: none;\"></span></h3>\n<p data-tool=\"mdnice编辑器\" style=\"padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: black; margin: 10px 0px; letter-spacing: 2px; font-size: 14px; word-spacing: 2px;\">接受的请求正在处理，信息类状态码。</p>\n<h3 data-tool=\"mdnice编辑器\" style=\"margin-top: 30px; margin-bottom: 15px; padding: 0px; color: black; font-size: 16px; font-weight: bold; text-align: center;\"><span class=\"prefix\" style=\"display: none;\"></span><span class=\"content\" style=\"border-bottom: 2px solid #d89cf6;\">2xx 成功</span><span class=\"suffix\" style=\"display: none;\"></span></h3>\n<ul data-tool=\"mdnice编辑器\" style=\"margin-top: 8px; margin-bottom: 8px; padding-left: 25px; color: black; font-size: 15px; list-style-type: circle;\">\n<li><section style=\"margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-size: 14px; font-weight: normal;\">200 OK 表示从客户端发来的请求在服务器端被正确请求。</section></li><li><section style=\"margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-size: 14px; font-weight: normal;\">204 No content，表示请求成功，但没有资源可返回。</section></li><li><section style=\"margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-size: 14px; font-weight: normal;\">206 Partial Content，该状态码表示客户端进行了范围请求，而服务器成功执行了这部分的 GET 请求\n响应报文中包含由 <strong style=\"color: #916dd5; font-weight: bold;\"><span>「</span>Content-Range<span>」</span></strong> 指定范围的实体内容。</section></li></ul>\n<h3 data-tool=\"mdnice编辑器\" style=\"margin-top: 30px; margin-bottom: 15px; padding: 0px; color: black; font-size: 16px; font-weight: bold; text-align: center;\"><span class=\"prefix\" style=\"display: none;\"></span><span class=\"content\" style=\"border-bottom: 2px solid #d89cf6;\">3xx 重定向</span><span class=\"suffix\" style=\"display: none;\"></span></h3>\n<ul data-tool=\"mdnice编辑器\" style=\"margin-top: 8px; margin-bottom: 8px; padding-left: 25px; color: black; font-size: 15px; list-style-type: circle;\">\n<li><section style=\"margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-size: 14px; font-weight: normal;\">301 moved permanently，永久性重定向，表示资源已被分配了新的 URL，这时应该按 Location 首部字段提示的 URI 重新保存。</section></li><li><section style=\"margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-size: 14px; font-weight: normal;\">302 found，临时性重定向，表示资源临时被分配了新的 URL。</section></li><li><section style=\"margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-size: 14px; font-weight: normal;\">303 see other，表示资源存在着另一个 URL，应使用 GET 方法获取资源。</section></li><li><section style=\"margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-size: 14px; font-weight: normal;\">304 not modified，当协商缓存命中时会返回这个状态码。</section></li><li><section style=\"margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-size: 14px; font-weight: normal;\">307 temporary redirect，临时重定向，和302含义相同,不会改变method</section></li></ul>\n<blockquote data-tool=\"mdnice编辑器\" style=\"display: block; font-size: 0.9em; overflow: auto; overflow-scrolling: touch; border-left: 3px solid rgba(0, 0, 0, 0.4); color: #6a737d; padding-top: 10px; padding-bottom: 10px; padding-left: 20px; padding-right: 10px; margin-bottom: 20px; margin-top: 20px; border-left-color: #d89cf6; background: #f4eeff;\">\n<p style=\"padding-top: 8px; padding-bottom: 8px; letter-spacing: 2px; font-size: 14px; word-spacing: 2px; margin: 0px; color: black; line-height: 26px;\">当 301、302、303 响应状态码返回时，几乎所有的浏览器都会把 POST 改成 GET，并删除请求报文内的主体，之后请求会自动再次发送\n301、302 标准是禁止将 POST 方法改变成 GET 方法的，但实际使用时大家都会这么做</p>\n</blockquote>\n<h3 data-tool=\"mdnice编辑器\" style=\"margin-top: 30px; margin-bottom: 15px; padding: 0px; color: black; font-size: 16px; font-weight: bold; text-align: center;\"><span class=\"prefix\" style=\"display: none;\"></span><span class=\"content\" style=\"border-bottom: 2px solid #d89cf6;\">4XX 客户端错误</span><span class=\"suffix\" style=\"display: none;\"></span></h3>\n<ul data-tool=\"mdnice编辑器\" style=\"margin-top: 8px; margin-bottom: 8px; padding-left: 25px; color: black; font-size: 15px; list-style-type: circle;\">\n<li><section style=\"margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-size: 14px; font-weight: normal;\">400 bad request，请求报文存在语法错误。</section></li><li><section style=\"margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-size: 14px; font-weight: normal;\">401 unauthorized，表示发送的请求需要有通过 HTTP 认证的认证信息。</section></li><li><section style=\"margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-size: 14px; font-weight: normal;\">403 forbidden，表示对请求资源的访问被服务器拒绝。</section></li><li><section style=\"margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-size: 14px; font-weight: normal;\">404 not found，表示在服务器上没有找到请求的资源。</section></li><li><section style=\"margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-size: 14px; font-weight: normal;\">405 Method Not Allowed，服务器禁止使用该方法，客户端可以通过options方法来查看服务器允许的访问方法，如下 👇</section></li></ul>\n<pre class=\"custom\" data-tool=\"mdnice编辑器\" style=\"margin-top: 10px; margin-bottom: 10px; border-radius: 5px; box-shadow: rgba(0, 0, 0, 0.55) 0px 2px 10px;\"><span style=\"display: block; background: url(https://files.mdnice.com/point.png); height: 30px; width: 100%; background-size: 40px; background-repeat: no-repeat; background-color: #f8f8f8; margin-bottom: -7px; border-radius: 5px; background-position: 10px 10px;\"></span><code class=\"hljs\" style=\"overflow-x: auto; padding: 16px; color: #333; display: -webkit-box; font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; font-size: 12px; -webkit-overflow-scrolling: touch; padding-top: 15px; background: #f8f8f8; border-radius: 5px;\">Access-Control-Allow-Methods&nbsp;→GET,HEAD,PUT,PATCH,POST,DELETE<br></code></pre>\n<h3 data-tool=\"mdnice编辑器\" style=\"margin-top: 30px; margin-bottom: 15px; padding: 0px; color: black; font-size: 16px; font-weight: bold; text-align: center;\"><span class=\"prefix\" style=\"display: none;\"></span><span class=\"content\" style=\"border-bottom: 2px solid #d89cf6;\">5XX 服务器错误</span><span class=\"suffix\" style=\"display: none;\"></span></h3>\n<ul data-tool=\"mdnice编辑器\" style=\"margin-top: 8px; margin-bottom: 8px; padding-left: 25px; color: black; font-size: 15px; list-style-type: circle;\">\n<li><section style=\"margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-size: 14px; font-weight: normal;\">500 internal sever error，表示服务器端在执行请求时发生了错误。</section></li><li><section style=\"margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-size: 14px; font-weight: normal;\">502 Bad Gateway，服务器自身是正常的，访问的时候出了问题，具体啥错误我们不知道。</section></li><li><section style=\"margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-size: 14px; font-weight: normal;\">503 service unavailable，表明服务器暂时处于超负载或正在停机维护，无法处理请求。</section></li></ul>\n<hr data-tool=\"mdnice编辑器\" style=\"margin: 0; margin-top: 10px; margin-bottom: 10px; height: 1px; padding: 0; border: none; border-top: 2px solid #d9b8fa;\">\n<h2 data-tool=\"mdnice编辑器\" style=\"margin-top: 30px; margin-bottom: 15px; padding: 0px; font-weight: bold; color: black; font-size: 22px; text-align: left; margin: 20px 10px 0px 0px;\"><span class=\"prefix\" style=\"display: none;\"></span><span class=\"content\" style=\"font-size: 18px; font-weight: bold; display: inline-block; padding-left: 10px; border-left: 5px solid #916dd5;\">DNS如何工作的</span><span class=\"suffix\"></span></h2>\n<p data-tool=\"mdnice编辑器\" style=\"padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: black; margin: 10px 0px; letter-spacing: 2px; font-size: 14px; word-spacing: 2px;\">DNS 协议提供的是一种主机名到 IP 地址的转换服务，就是我们常说的域名系统。是应用层协议，通常该协议运行在UDP协议之上，使用的是53端口号。</p>\n<p data-tool=\"mdnice编辑器\" style=\"padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: black; margin: 10px 0px; letter-spacing: 2px; font-size: 14px; word-spacing: 2px;\"><strong style=\"color: #916dd5; font-weight: bold;\"><span>「</span>我们通过一张图来看看它的查询过程吧<span>」</span></strong>👇</p>\n<figure data-tool=\"mdnice编辑器\" style=\"margin: 0; margin-top: 10px; margin-bottom: 10px; display: flex; flex-direction: column; justify-content: center; align-items: center;\"><img src=\"https://user-images.githubusercontent.com/34484322/89356512-95168e80-d6f0-11ea-93aa-c4f59fd36942.png\" alt style=\"max-width: 100%; border-radius: 6px; display: block; margin: 20px auto; object-fit: contain; box-shadow: 2px 4px 7px #999;\"></figure>\n<p data-tool=\"mdnice编辑器\" style=\"padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: black; margin: 10px 0px; letter-spacing: 2px; font-size: 14px; word-spacing: 2px;\">这张图很生动的展示了DNS在本地DNS服务器是如何查询的，<strong style=\"color: #916dd5; font-weight: bold;\"><span>「</span>一般向本地DNS服务器发送请求是递归查询的<span>」</span></strong></p>\n<p data-tool=\"mdnice编辑器\" style=\"padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: black; margin: 10px 0px; letter-spacing: 2px; font-size: 14px; word-spacing: 2px;\">本地 DNS 服务器向其他域名服务器请求的过程是迭代查询的过程👇</p>\n<figure data-tool=\"mdnice编辑器\" style=\"margin: 0; margin-top: 10px; margin-bottom: 10px; display: flex; flex-direction: column; justify-content: center; align-items: center;\"><img src=\"https://user-images.githubusercontent.com/34484322/89356522-99db4280-d6f0-11ea-9bf9-851b25bd16c3.png\" alt=\"DNS查询\" style=\"max-width: 100%; border-radius: 6px; display: block; margin: 20px auto; object-fit: contain; box-shadow: 2px 4px 7px #999;\"><figcaption style=\"margin-top: 5px; text-align: center; color: #888; display: block; font-size: 13px;\">DNS查询</figcaption></figure>\n<h3 data-tool=\"mdnice编辑器\" style=\"margin-top: 30px; margin-bottom: 15px; padding: 0px; color: black; font-size: 16px; font-weight: bold; text-align: center;\"><span class=\"prefix\" style=\"display: none;\"></span><span class=\"content\" style=\"border-bottom: 2px solid #d89cf6;\">递归查询和迭代查询</span><span class=\"suffix\" style=\"display: none;\"></span></h3>\n<ul data-tool=\"mdnice编辑器\" style=\"margin-top: 8px; margin-bottom: 8px; padding-left: 25px; color: black; font-size: 15px; list-style-type: circle;\">\n<li><section style=\"margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-size: 14px; font-weight: normal;\"><p style=\"padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: black; margin: 10px 0px; letter-spacing: 2px; font-size: 14px; word-spacing: 2px;\">递归查询指的是查询请求发出后，域名服务器代为向下一级域名服务器发出请求，最后向用户返回查询的最终结果。使用递归 查询，用户只需要发出一次查询请求。</p>\n</section></li><li><section style=\"margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-size: 14px; font-weight: normal;\"><p style=\"padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: black; margin: 10px 0px; letter-spacing: 2px; font-size: 14px; word-spacing: 2px;\">迭代查询指的是查询请求后，域名服务器返回单次查询的结果。下一级的查询由用户自己请求。使用迭代查询，用户需要发出 多次的查询请求。</p>\n</section></li></ul>\n<p data-tool=\"mdnice编辑器\" style=\"padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: black; margin: 10px 0px; letter-spacing: 2px; font-size: 14px; word-spacing: 2px;\">所以一般而言，<strong style=\"color: #916dd5; font-weight: bold;\"><span>「</span>本地服务器查询是递归查询<span>」</span></strong>，而<strong style=\"color: #916dd5; font-weight: bold;\"><span>「</span>本地 DNS 服务器向其他域名服务器请求的过程是迭代查询的过程<span>」</span></strong>。</p>\n<h3 data-tool=\"mdnice编辑器\" style=\"margin-top: 30px; margin-bottom: 15px; padding: 0px; color: black; font-size: 16px; font-weight: bold; text-align: center;\"><span class=\"prefix\" style=\"display: none;\"></span><span class=\"content\" style=\"border-bottom: 2px solid #d89cf6;\">DNS缓存</span><span class=\"suffix\" style=\"display: none;\"></span></h3>\n<p data-tool=\"mdnice编辑器\" style=\"padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: black; margin: 10px 0px; letter-spacing: 2px; font-size: 14px; word-spacing: 2px;\">缓存也很好理解，在一个请求中，当某个DNS服务器收到一个DNS回答后，它能够回答中的信息缓存在本地存储器中。<strong style=\"color: #916dd5; font-weight: bold;\"><span>「</span>返回的资源记录中的 TTL 代表了该条记录的缓存的时间。<span>」</span></strong></p>\n<h3 data-tool=\"mdnice编辑器\" style=\"margin-top: 30px; margin-bottom: 15px; padding: 0px; color: black; font-size: 16px; font-weight: bold; text-align: center;\"><span class=\"prefix\" style=\"display: none;\"></span><span class=\"content\" style=\"border-bottom: 2px solid #d89cf6;\">DNS实现负载平衡</span><span class=\"suffix\" style=\"display: none;\"></span></h3>\n<p data-tool=\"mdnice编辑器\" style=\"padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: black; margin: 10px 0px; letter-spacing: 2px; font-size: 14px; word-spacing: 2px;\">它是如何实现负载均衡的呢？首先我们得清楚DNS 是可以用于在冗余的服务器上实现负载平衡。</p>\n<p data-tool=\"mdnice编辑器\" style=\"padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: black; margin: 10px 0px; letter-spacing: 2px; font-size: 14px; word-spacing: 2px;\">**原因：**这是因为一般的大型网站使用多台服务器提供服务，因此一个域名可能会对应 多个服务器地址。</p>\n<p data-tool=\"mdnice编辑器\" style=\"padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: black; margin: 10px 0px; letter-spacing: 2px; font-size: 14px; word-spacing: 2px;\">举个例子来说👇</p>\n<ul data-tool=\"mdnice编辑器\" style=\"margin-top: 8px; margin-bottom: 8px; padding-left: 25px; color: black; font-size: 15px; list-style-type: circle;\">\n<li><section style=\"margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-size: 14px; font-weight: normal;\">当用户发起网站域名的 DNS 请求的时候，DNS 服务器返回这个域名所对应的服务器 IP 地址的集合</section></li><li><section style=\"margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-size: 14px; font-weight: normal;\">在每个回答中，会循环这些 IP 地址的顺序，用户一般会选择排在前面的地址发送请求。</section></li><li><section style=\"margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-size: 14px; font-weight: normal;\">以此将用户的请求均衡的分配到各个不同的服务器上，这样来实现负载均衡。</section></li></ul>\n<h3 data-tool=\"mdnice编辑器\" style=\"margin-top: 30px; margin-bottom: 15px; padding: 0px; color: black; font-size: 16px; font-weight: bold; text-align: center;\"><span class=\"prefix\" style=\"display: none;\"></span><span class=\"content\" style=\"border-bottom: 2px solid #d89cf6;\">总结</span><span class=\"suffix\" style=\"display: none;\"></span></h3>\n<ul data-tool=\"mdnice编辑器\" style=\"margin-top: 8px; margin-bottom: 8px; padding-left: 25px; color: black; font-size: 15px; list-style-type: circle;\">\n<li><section style=\"margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-size: 14px; font-weight: normal;\">DNS域名系统，是应用层协议，运行UDP协议之上，使用端口43。</section></li><li><section style=\"margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-size: 14px; font-weight: normal;\">查询过程，本地查询是递归查询，依次通过浏览器缓存 <code style=\"font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #916dd5; font-weight: bolder; background: none;\">—&gt;&gt;</code> 本地hosts文件 <code style=\"font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #916dd5; font-weight: bolder; background: none;\">—&gt;&gt;</code> 本地DNS解析器 <code style=\"font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #916dd5; font-weight: bolder; background: none;\">—&gt;&gt;</code>本地DNS服务器 <code style=\"font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #916dd5; font-weight: bolder; background: none;\">—&gt;&gt;</code> 其他域名服务器请求。 接下来的过程就是迭代过程。</section></li><li><section style=\"margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-size: 14px; font-weight: normal;\">递归查询一般而言，发送一次请求就够，迭代过程需要用户发送多次请求。</section></li></ul>\n<h2 data-tool=\"mdnice编辑器\" style=\"margin-top: 30px; margin-bottom: 15px; padding: 0px; font-weight: bold; color: black; font-size: 22px; text-align: left; margin: 20px 10px 0px 0px;\"><span class=\"prefix\" style=\"display: none;\"></span><span class=\"content\" style=\"font-size: 18px; font-weight: bold; display: inline-block; padding-left: 10px; border-left: 5px solid #916dd5;\">DNS 为什么使用 UDP 协议作为传输层协议？</span><span class=\"suffix\"></span></h2>\n<p data-tool=\"mdnice编辑器\" style=\"padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: black; margin: 10px 0px; letter-spacing: 2px; font-size: 14px; word-spacing: 2px;\"><strong style=\"color: #916dd5; font-weight: bold;\"><span>「</span>DNS 使用 UDP 协议作为传输层协议的主要原因是为了避免使用 TCP 协议时造成的连接时延。<span>」</span></strong></p>\n<ul data-tool=\"mdnice编辑器\" style=\"margin-top: 8px; margin-bottom: 8px; padding-left: 25px; color: black; font-size: 15px; list-style-type: circle;\">\n<li><section style=\"margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-size: 14px; font-weight: normal;\">为了得到一个域名的 IP 地址，往往会向多个域名服务器查询，如果使用 TCP 协议，那么每次请求都会存在连接时延，这样使 DNS 服务变得很慢。</section></li><li><section style=\"margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-size: 14px; font-weight: normal;\">大多数的地址查询请求，都是浏览器请求页面时发出的，这样会造成网页的等待时间过长。</section></li></ul>\n<hr data-tool=\"mdnice编辑器\" style=\"margin: 0; margin-top: 10px; margin-bottom: 10px; height: 1px; padding: 0; border: none; border-top: 2px solid #d9b8fa;\">\n<h2 data-tool=\"mdnice编辑器\" style=\"margin-top: 30px; margin-bottom: 15px; padding: 0px; font-weight: bold; color: black; font-size: 22px; text-align: left; margin: 20px 10px 0px 0px;\"><span class=\"prefix\" style=\"display: none;\"></span><span class=\"content\" style=\"font-size: 18px; font-weight: bold; display: inline-block; padding-left: 10px; border-left: 5px solid #916dd5;\">介绍一下Connection:keep-alive</span><span class=\"suffix\"></span></h2>\n<h3 data-tool=\"mdnice编辑器\" style=\"margin-top: 30px; margin-bottom: 15px; padding: 0px; color: black; font-size: 16px; font-weight: bold; text-align: center;\"><span class=\"prefix\" style=\"display: none;\"></span><span class=\"content\" style=\"border-bottom: 2px solid #d89cf6;\">什么是keep-alive</span><span class=\"suffix\" style=\"display: none;\"></span></h3>\n<p data-tool=\"mdnice编辑器\" style=\"padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: black; margin: 10px 0px; letter-spacing: 2px; font-size: 14px; word-spacing: 2px;\">我们知道HTTP协议采用“请求-应答”模式，当使用普通模式，即非KeepAlive模式时，每个请求/应答客户和服务器都要新建一个连接，完成 之后立即断开连接（HTTP协议为无连接的协议）；</p>\n<p data-tool=\"mdnice编辑器\" style=\"padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: black; margin: 10px 0px; letter-spacing: 2px; font-size: 14px; word-spacing: 2px;\">当使用Keep-Alive模式（又称持久连接、连接重用）时，Keep-Alive功能使客户端到服 务器端的连接持续有效，当出现对服务器的后继请求时，Keep-Alive功能避免了建立或者重新建立连接。</p>\n<h3 data-tool=\"mdnice编辑器\" style=\"margin-top: 30px; margin-bottom: 15px; padding: 0px; color: black; font-size: 16px; font-weight: bold; text-align: center;\"><span class=\"prefix\" style=\"display: none;\"></span><span class=\"content\" style=\"border-bottom: 2px solid #d89cf6;\">为什么要使用keep-alive</span><span class=\"suffix\" style=\"display: none;\"></span></h3>\n<p data-tool=\"mdnice编辑器\" style=\"padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: black; margin: 10px 0px; letter-spacing: 2px; font-size: 14px; word-spacing: 2px;\">keep-alive技术的创建目的，能在多次HTTP之前重用同一个TCP连接，从而减少创建/关闭多个 TCP 连接的开销（包括响应时间、CPU 资源、减少拥堵等），参考如下示意图（来源：维基百科）：</p>\n<figure data-tool=\"mdnice编辑器\" style=\"margin: 0; margin-top: 10px; margin-bottom: 10px; display: flex; flex-direction: column; justify-content: center; align-items: center;\"><img src=\"https://user-images.githubusercontent.com/34484322/89356849-64832480-d6f1-11ea-8f53-5372f8c30f39.png\" alt style=\"max-width: 100%; border-radius: 6px; display: block; margin: 20px auto; object-fit: contain; box-shadow: 2px 4px 7px #999;\"></figure>\n<h3 data-tool=\"mdnice编辑器\" style=\"margin-top: 30px; margin-bottom: 15px; padding: 0px; color: black; font-size: 16px; font-weight: bold; text-align: center;\"><span class=\"prefix\" style=\"display: none;\"></span><span class=\"content\" style=\"border-bottom: 2px solid #d89cf6;\">客户端如何开启</span><span class=\"suffix\" style=\"display: none;\"></span></h3>\n<p data-tool=\"mdnice编辑器\" style=\"padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: black; margin: 10px 0px; letter-spacing: 2px; font-size: 14px; word-spacing: 2px;\">在HTTP/1.0协议中，默认是关闭的，需要在http头加入\"Connection: Keep-Alive”，才能启用Keep-Alive；</p>\n<pre class=\"custom\" data-tool=\"mdnice编辑器\" style=\"margin-top: 10px; margin-bottom: 10px; border-radius: 5px; box-shadow: rgba(0, 0, 0, 0.55) 0px 2px 10px;\"><span style=\"display: block; background: url(https://files.mdnice.com/point.png); height: 30px; width: 100%; background-size: 40px; background-repeat: no-repeat; background-color: #f8f8f8; margin-bottom: -7px; border-radius: 5px; background-position: 10px 10px;\"></span><code class=\"hljs\" style=\"overflow-x: auto; padding: 16px; color: #333; display: -webkit-box; font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; font-size: 12px; -webkit-overflow-scrolling: touch; padding-top: 15px; background: #f8f8f8; border-radius: 5px;\">Connection:&nbsp;keep-alive<br></code></pre>\n<p data-tool=\"mdnice编辑器\" style=\"padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: black; margin: 10px 0px; letter-spacing: 2px; font-size: 14px; word-spacing: 2px;\">http 1.1中默认启用Keep-Alive，如果加入\"Connection: close “，才关闭。</p>\n<pre class=\"custom\" data-tool=\"mdnice编辑器\" style=\"margin-top: 10px; margin-bottom: 10px; border-radius: 5px; box-shadow: rgba(0, 0, 0, 0.55) 0px 2px 10px;\"><span style=\"display: block; background: url(https://files.mdnice.com/point.png); height: 30px; width: 100%; background-size: 40px; background-repeat: no-repeat; background-color: #f8f8f8; margin-bottom: -7px; border-radius: 5px; background-position: 10px 10px;\"></span><code class=\"hljs\" style=\"overflow-x: auto; padding: 16px; color: #333; display: -webkit-box; font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; font-size: 12px; -webkit-overflow-scrolling: touch; padding-top: 15px; background: #f8f8f8; border-radius: 5px;\">Connection:&nbsp;close<br></code></pre>\n<p data-tool=\"mdnice编辑器\" style=\"padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: black; margin: 10px 0px; letter-spacing: 2px; font-size: 14px; word-spacing: 2px;\">目前大部分浏览器都是用http1.1协议，也就是说默认都会发起Keep-Alive的连接请求了，所以是否能完成一个完整的Keep- Alive连接就看服务器设置情况。</p>\n<hr data-tool=\"mdnice编辑器\" style=\"margin: 0; margin-top: 10px; margin-bottom: 10px; height: 1px; padding: 0; border: none; border-top: 2px solid #d9b8fa;\">\n<h2 data-tool=\"mdnice编辑器\" style=\"margin-top: 30px; margin-bottom: 15px; padding: 0px; font-weight: bold; color: black; font-size: 22px; text-align: left; margin: 20px 10px 0px 0px;\"><span class=\"prefix\" style=\"display: none;\"></span><span class=\"content\" style=\"font-size: 18px; font-weight: bold; display: inline-block; padding-left: 10px; border-left: 5px solid #916dd5;\">介绍HTTP 缓存策略</span><span class=\"suffix\"></span></h2>\n<p data-tool=\"mdnice编辑器\" style=\"padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: black; margin: 10px 0px; letter-spacing: 2px; font-size: 14px; word-spacing: 2px;\">这个跟之前的浏览器缓存原理一样，我直接拿我之前梳理过的吧。</p>\n<p data-tool=\"mdnice编辑器\" style=\"padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: black; margin: 10px 0px; letter-spacing: 2px; font-size: 14px; word-spacing: 2px;\">我在我之前的那一篇中已经详细的说过了，<a href=\"https://juejin.im/post/5f184aade51d4534aa4ad7c0#heading-40\" style=\"text-decoration: none; word-wrap: break-word; color: #916dd5; font-weight: bolder; border-bottom: 1px solid #916dd5;\">点这里传送门聊一聊浏览器缓存</a></p>\n<p data-tool=\"mdnice编辑器\" style=\"padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: black; margin: 10px 0px; letter-spacing: 2px; font-size: 14px; word-spacing: 2px;\">我们来梳理一下吧👇</p>\n<h3 data-tool=\"mdnice编辑器\" style=\"margin-top: 30px; margin-bottom: 15px; padding: 0px; color: black; font-size: 16px; font-weight: bold; text-align: center;\"><span class=\"prefix\" style=\"display: none;\"></span><span class=\"content\" style=\"border-bottom: 2px solid #d89cf6;\">强缓存</span><span class=\"suffix\" style=\"display: none;\"></span></h3>\n<p data-tool=\"mdnice编辑器\" style=\"padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: black; margin: 10px 0px; letter-spacing: 2px; font-size: 14px; word-spacing: 2px;\">强缓存两个相关字段，<strong style=\"color: #916dd5; font-weight: bold;\"><span>「</span>Expires<span>」</span></strong>，<strong style=\"color: #916dd5; font-weight: bold;\"><span>「</span>Cache-Control<span>」</span></strong>。</p>\n<p data-tool=\"mdnice编辑器\" style=\"padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: black; margin: 10px 0px; letter-spacing: 2px; font-size: 14px; word-spacing: 2px;\"><strong style=\"color: #916dd5; font-weight: bold;\"><span>「</span>强缓存分为两种情况，一种是发送HTTP请求，一种不需要发送。<span>」</span></strong></p>\n<p data-tool=\"mdnice编辑器\" style=\"padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: black; margin: 10px 0px; letter-spacing: 2px; font-size: 14px; word-spacing: 2px;\">首先检查强缓存，这个阶段**不需要发送HTTP请求。**通过查找不同的字段来进行，不同的HTTP版本所以不同。</p>\n<ul data-tool=\"mdnice编辑器\" style=\"margin-top: 8px; margin-bottom: 8px; padding-left: 25px; color: black; font-size: 15px; list-style-type: circle;\">\n<li><section style=\"margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-size: 14px; font-weight: normal;\">HTTP1.0版本，使用的是Expires，HTTP1.1使用的是Cache-Control</section></li></ul>\n<h4 data-tool=\"mdnice编辑器\" style=\"margin-top: 30px; margin-bottom: 15px; padding: 0px; font-weight: bold; color: black; font-size: 18px;\"><span class=\"prefix\" style=\"display: none;\"></span><span class=\"content\">Expires</span><span class=\"suffix\" style=\"display: none;\"></span></h4>\n<p data-tool=\"mdnice编辑器\" style=\"padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: black; margin: 10px 0px; letter-spacing: 2px; font-size: 14px; word-spacing: 2px;\"><code style=\"font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #916dd5; font-weight: bolder; background: none;\">Expires</code>即过期时间，时间是相对于服务器的时间而言的，存在于服务端返回的响应头中，在这个过期时间之前可以直接从缓存里面获取数据，无需再次请求。比如下面这样:</p>\n<pre class=\"custom\" data-tool=\"mdnice编辑器\" style=\"margin-top: 10px; margin-bottom: 10px; border-radius: 5px; box-shadow: rgba(0, 0, 0, 0.55) 0px 2px 10px;\"><span style=\"display: block; background: url(https://files.mdnice.com/point.png); height: 30px; width: 100%; background-size: 40px; background-repeat: no-repeat; background-color: #f8f8f8; margin-bottom: -7px; border-radius: 5px; background-position: 10px 10px;\"></span><code class=\"hljs\" style=\"overflow-x: auto; padding: 16px; color: #333; display: -webkit-box; font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; font-size: 12px; -webkit-overflow-scrolling: touch; padding-top: 15px; background: #f8f8f8; border-radius: 5px;\">Expires:Mon,&nbsp;29&nbsp;Jun&nbsp;2020&nbsp;11:10:23&nbsp;GMT<br></code></pre>\n<p data-tool=\"mdnice编辑器\" style=\"padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: black; margin: 10px 0px; letter-spacing: 2px; font-size: 14px; word-spacing: 2px;\">表示该资源在2020年<code style=\"font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #916dd5; font-weight: bolder; background: none;\">7月29日11:10:23</code>过期，过期时就会重新向服务器发起请求。</p>\n<p data-tool=\"mdnice编辑器\" style=\"padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: black; margin: 10px 0px; letter-spacing: 2px; font-size: 14px; word-spacing: 2px;\">这个方式有一个问题：<strong style=\"color: #916dd5; font-weight: bold;\"><span>「</span>服务器的时间和浏览器的时间可能并不一致<span>」</span></strong>，所以HTTP1.1提出新的字段代替它。</p>\n<h4 data-tool=\"mdnice编辑器\" style=\"margin-top: 30px; margin-bottom: 15px; padding: 0px; font-weight: bold; color: black; font-size: 18px;\"><span class=\"prefix\" style=\"display: none;\"></span><span class=\"content\">Cache-Control</span><span class=\"suffix\" style=\"display: none;\"></span></h4>\n<p data-tool=\"mdnice编辑器\" style=\"padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: black; margin: 10px 0px; letter-spacing: 2px; font-size: 14px; word-spacing: 2px;\">HTTP1.1版本中，使用的就是该字段，这个字段采用的时间是过期时长，对应的是max-age。</p>\n<pre class=\"custom\" data-tool=\"mdnice编辑器\" style=\"margin-top: 10px; margin-bottom: 10px; border-radius: 5px; box-shadow: rgba(0, 0, 0, 0.55) 0px 2px 10px;\"><span style=\"display: block; background: url(https://files.mdnice.com/point.png); height: 30px; width: 100%; background-size: 40px; background-repeat: no-repeat; background-color: #f8f8f8; margin-bottom: -7px; border-radius: 5px; background-position: 10px 10px;\"></span><code class=\"hljs\" style=\"overflow-x: auto; padding: 16px; color: #333; display: -webkit-box; font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; font-size: 12px; -webkit-overflow-scrolling: touch; padding-top: 15px; background: #f8f8f8; border-radius: 5px;\">Cache-Control:max-age=6000<br></code></pre>\n<p data-tool=\"mdnice编辑器\" style=\"padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: black; margin: 10px 0px; letter-spacing: 2px; font-size: 14px; word-spacing: 2px;\">上面代表该资源返回后6000秒，可以直接使用缓存。</p>\n<p data-tool=\"mdnice编辑器\" style=\"padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: black; margin: 10px 0px; letter-spacing: 2px; font-size: 14px; word-spacing: 2px;\">当然了，它还有其他很多关键的指令，梳理了几个重要的👇</p>\n<p data-tool=\"mdnice编辑器\" style=\"padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: black; margin: 10px 0px; letter-spacing: 2px; font-size: 14px; word-spacing: 2px;\">注意点：</p>\n<ul data-tool=\"mdnice编辑器\" style=\"margin-top: 8px; margin-bottom: 8px; padding-left: 25px; color: black; font-size: 15px; list-style-type: circle;\">\n<li><section style=\"margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-size: 14px; font-weight: normal;\">当Expires和Cache-Control同时存在时，优先考虑Cache-Control。</section></li><li><section style=\"margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-size: 14px; font-weight: normal;\">当然了，当缓存资源失效了，也就是没有命中强缓存，接下来就进入协商缓存👇</section></li></ul>\n<h3 data-tool=\"mdnice编辑器\" style=\"margin-top: 30px; margin-bottom: 15px; padding: 0px; color: black; font-size: 16px; font-weight: bold; text-align: center;\"><span class=\"prefix\" style=\"display: none;\"></span><span class=\"content\" style=\"border-bottom: 2px solid #d89cf6;\">协商缓存</span><span class=\"suffix\" style=\"display: none;\"></span></h3>\n<p data-tool=\"mdnice编辑器\" style=\"padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: black; margin: 10px 0px; letter-spacing: 2px; font-size: 14px; word-spacing: 2px;\">强缓存失效后，浏览器在请求头中携带响应的<code style=\"font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #916dd5; font-weight: bolder; background: none;\">缓存Tag</code>来向服务器发送请求，服务器根据对应的tag，来决定是否使用缓存。</p>\n<p data-tool=\"mdnice编辑器\" style=\"padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: black; margin: 10px 0px; letter-spacing: 2px; font-size: 14px; word-spacing: 2px;\">缓存分为两种，<strong style=\"color: #916dd5; font-weight: bold;\"><span>「</span>Last-Modified<span>」</span></strong> 和 <strong style=\"color: #916dd5; font-weight: bold;\"><span>「</span>ETag<span>」</span></strong>。两者各有优势，并不存在谁对谁有<code style=\"font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #916dd5; font-weight: bolder; background: none;\">绝对的优势</code>，与上面所讲的强缓存两个Tag所不同。</p>\n<h4 data-tool=\"mdnice编辑器\" style=\"margin-top: 30px; margin-bottom: 15px; padding: 0px; font-weight: bold; color: black; font-size: 18px;\"><span class=\"prefix\" style=\"display: none;\"></span><span class=\"content\">Last-Modified</span><span class=\"suffix\" style=\"display: none;\"></span></h4>\n<p data-tool=\"mdnice编辑器\" style=\"padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: black; margin: 10px 0px; letter-spacing: 2px; font-size: 14px; word-spacing: 2px;\">这个字段表示的是<strong style=\"color: #916dd5; font-weight: bold;\"><span>「</span>最后修改时间<span>」</span></strong>。在浏览器第一次给服务器发送请求后，服务器会在响应头中加上这个字段。</p>\n<p data-tool=\"mdnice编辑器\" style=\"padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: black; margin: 10px 0px; letter-spacing: 2px; font-size: 14px; word-spacing: 2px;\">浏览器接收到后，<strong style=\"color: #916dd5; font-weight: bold;\"><span>「</span>如果再次请求<span>」</span></strong>，会在请求头中携带<code style=\"font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #916dd5; font-weight: bolder; background: none;\">If-Modified-Since</code>字段，这个字段的值也就是服务器传来的最后修改时间。</p>\n<p data-tool=\"mdnice编辑器\" style=\"padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: black; margin: 10px 0px; letter-spacing: 2px; font-size: 14px; word-spacing: 2px;\">服务器拿到请求头中的<code style=\"font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #916dd5; font-weight: bolder; background: none;\">If-Modified-Since</code>的字段后，其实会和这个服务器中<code style=\"font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #916dd5; font-weight: bolder; background: none;\">该资源的最后修改时间</code>对比:</p>\n<ul data-tool=\"mdnice编辑器\" style=\"margin-top: 8px; margin-bottom: 8px; padding-left: 25px; color: black; font-size: 15px; list-style-type: circle;\">\n<li><section style=\"margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-size: 14px; font-weight: normal;\">如果请求头中的这个值小于最后修改时间，说明是时候更新了。返回新的资源，跟常规的HTTP请求响应的流程一样。</section></li><li><section style=\"margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-size: 14px; font-weight: normal;\">否则返回304，告诉浏览器直接使用缓存。</section></li></ul>\n<h4 data-tool=\"mdnice编辑器\" style=\"margin-top: 30px; margin-bottom: 15px; padding: 0px; font-weight: bold; color: black; font-size: 18px;\"><span class=\"prefix\" style=\"display: none;\"></span><span class=\"content\">ETag</span><span class=\"suffix\" style=\"display: none;\"></span></h4>\n<p data-tool=\"mdnice编辑器\" style=\"padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: black; margin: 10px 0px; letter-spacing: 2px; font-size: 14px; word-spacing: 2px;\">ETag是服务器根据当前文件的内容，对文件生成唯一的标识，比如MD5算法，只要里面的内容有改动，这个值就会修改，服务器通过把响应头把该字段给浏览器。</p>\n<p data-tool=\"mdnice编辑器\" style=\"padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: black; margin: 10px 0px; letter-spacing: 2px; font-size: 14px; word-spacing: 2px;\">浏览器接受到ETag值，会在下次请求的时候，将这个值作为<strong style=\"color: #916dd5; font-weight: bold;\"><span>「</span>If-None-Match<span>」</span></strong>这个字段的内容，发给服务器。</p>\n<p data-tool=\"mdnice编辑器\" style=\"padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: black; margin: 10px 0px; letter-spacing: 2px; font-size: 14px; word-spacing: 2px;\">服务器接收到<strong style=\"color: #916dd5; font-weight: bold;\"><span>「</span>If-None-Match<span>」</span></strong>后，会跟服务器上该资源的<strong style=\"color: #916dd5; font-weight: bold;\"><span>「</span>ETag<span>」</span></strong>进行比对👇</p>\n<ul data-tool=\"mdnice编辑器\" style=\"margin-top: 8px; margin-bottom: 8px; padding-left: 25px; color: black; font-size: 15px; list-style-type: circle;\">\n<li><section style=\"margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-size: 14px; font-weight: normal;\">如果两者一样的话，直接返回304，告诉浏览器直接使用缓存</section></li><li><section style=\"margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-size: 14px; font-weight: normal;\">如果不一样的话，说明内容更新了，返回新的资源，跟常规的HTTP请求响应的流程一样</section></li></ul>\n<h4 data-tool=\"mdnice编辑器\" style=\"margin-top: 30px; margin-bottom: 15px; padding: 0px; font-weight: bold; color: black; font-size: 18px;\"><span class=\"prefix\" style=\"display: none;\"></span><span class=\"content\">两者对比</span><span class=\"suffix\" style=\"display: none;\"></span></h4>\n<ul data-tool=\"mdnice编辑器\" style=\"margin-top: 8px; margin-bottom: 8px; padding-left: 25px; color: black; font-size: 15px; list-style-type: circle;\">\n<li><section style=\"margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-size: 14px; font-weight: normal;\">性能上，<code style=\"font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #916dd5; font-weight: bolder; background: none;\">Last-Modified</code>优于<code style=\"font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #916dd5; font-weight: bolder; background: none;\">ETag</code>，<code style=\"font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #916dd5; font-weight: bolder; background: none;\">Last-Modified</code>记录的是时间点，而<code style=\"font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #916dd5; font-weight: bolder; background: none;\">Etag</code>需要根据文件的MD5算法生成对应的hash值。</section></li><li><section style=\"margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-size: 14px; font-weight: normal;\">精度上，<code style=\"font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #916dd5; font-weight: bolder; background: none;\">ETag</code>优于<code style=\"font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #916dd5; font-weight: bolder; background: none;\">Last-Modified</code>。<code style=\"font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #916dd5; font-weight: bolder; background: none;\">ETag</code>按照内容给资源带上标识，能准确感知资源变化，<code style=\"font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #916dd5; font-weight: bolder; background: none;\">Last-Modified</code>在某些场景并不能准确感知变化，比如👇\n<ul style=\"margin-top: 8px; margin-bottom: 8px; padding-left: 25px; color: black; font-size: 15px; list-style-type: square;\">\n<li><section style=\"margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-size: 14px; font-weight: normal;\">编辑了资源文件，但是文件内容并没有更改，这样也会造成缓存失效。</section></li><li><section style=\"margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-size: 14px; font-weight: normal;\">Last-Modified 能够感知的单位时间是秒，如果文件在 1 秒内改变了多次，那么这时候的 Last-Modified 并没有体现出修改了。</section></li></ul>\n</section></li></ul>\n<p data-tool=\"mdnice编辑器\" style=\"padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: black; margin: 10px 0px; letter-spacing: 2px; font-size: 14px; word-spacing: 2px;\">最后，<strong style=\"color: #916dd5; font-weight: bold;\"><span>「</span>如果两种方式都支持的话，服务器会优先考虑<code style=\"font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #916dd5; font-weight: bolder; background: none;\">ETag</code><span>」</span></strong>。</p>\n<h3 data-tool=\"mdnice编辑器\" style=\"margin-top: 30px; margin-bottom: 15px; padding: 0px; color: black; font-size: 16px; font-weight: bold; text-align: center;\"><span class=\"prefix\" style=\"display: none;\"></span><span class=\"content\" style=\"border-bottom: 2px solid #d89cf6;\">缓存位置</span><span class=\"suffix\" style=\"display: none;\"></span></h3>\n<p data-tool=\"mdnice编辑器\" style=\"padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: black; margin: 10px 0px; letter-spacing: 2px; font-size: 14px; word-spacing: 2px;\">接下来我们考虑使用缓存的话，缓存的位置在哪里呢？</p>\n<p data-tool=\"mdnice编辑器\" style=\"padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: black; margin: 10px 0px; letter-spacing: 2px; font-size: 14px; word-spacing: 2px;\">浏览器缓存的位置的话，可以分为四种,优先级从高到低排列分别👇</p>\n<ul data-tool=\"mdnice编辑器\" style=\"margin-top: 8px; margin-bottom: 8px; padding-left: 25px; color: black; font-size: 15px; list-style-type: circle;\">\n<li><section style=\"margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-size: 14px; font-weight: normal;\">Service Worker</section></li><li><section style=\"margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-size: 14px; font-weight: normal;\">Memory Cache</section></li><li><section style=\"margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-size: 14px; font-weight: normal;\">Disk Cache</section></li><li><section style=\"margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-size: 14px; font-weight: normal;\">Push Cache</section></li></ul>\n<h4 data-tool=\"mdnice编辑器\" style=\"margin-top: 30px; margin-bottom: 15px; padding: 0px; font-weight: bold; color: black; font-size: 18px;\"><span class=\"prefix\" style=\"display: none;\"></span><span class=\"content\">Service Worker</span><span class=\"suffix\" style=\"display: none;\"></span></h4>\n<p data-tool=\"mdnice编辑器\" style=\"padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: black; margin: 10px 0px; letter-spacing: 2px; font-size: 14px; word-spacing: 2px;\">这个应用场景比如PWA，它借鉴了Web Worker思路，由于它脱离了浏览器的窗体，因此无法直接访问DOM。它能完成的功能比如：<code style=\"font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #916dd5; font-weight: bolder; background: none;\">离线缓存</code>、<code style=\"font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #916dd5; font-weight: bolder; background: none;\">消息推送</code>和<code style=\"font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #916dd5; font-weight: bolder; background: none;\">网络代理</code>，其中<code style=\"font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #916dd5; font-weight: bolder; background: none;\">离线缓存</code>就是<strong style=\"color: #916dd5; font-weight: bold;\"><span>「</span>Service Worker Cache<span>」</span></strong>。</p>\n<h4 data-tool=\"mdnice编辑器\" style=\"margin-top: 30px; margin-bottom: 15px; padding: 0px; font-weight: bold; color: black; font-size: 18px;\"><span class=\"prefix\" style=\"display: none;\"></span><span class=\"content\">Memory Cache</span><span class=\"suffix\" style=\"display: none;\"></span></h4>\n<p data-tool=\"mdnice编辑器\" style=\"padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: black; margin: 10px 0px; letter-spacing: 2px; font-size: 14px; word-spacing: 2px;\">指的是内存缓存，从效率上讲它是最快的，从存活时间来讲又是最短的，当渲染进程结束后，内存缓存也就不存在了。</p>\n<h4 data-tool=\"mdnice编辑器\" style=\"margin-top: 30px; margin-bottom: 15px; padding: 0px; font-weight: bold; color: black; font-size: 18px;\"><span class=\"prefix\" style=\"display: none;\"></span><span class=\"content\">Disk Cache</span><span class=\"suffix\" style=\"display: none;\"></span></h4>\n<p data-tool=\"mdnice编辑器\" style=\"padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: black; margin: 10px 0px; letter-spacing: 2px; font-size: 14px; word-spacing: 2px;\">存储在磁盘中的缓存，从存取效率上讲是比内存缓存慢的，优势在于存储容量和存储时长。</p>\n<h4 data-tool=\"mdnice编辑器\" style=\"margin-top: 30px; margin-bottom: 15px; padding: 0px; font-weight: bold; color: black; font-size: 18px;\"><span class=\"prefix\" style=\"display: none;\"></span><span class=\"content\">Disk Cache VS Memory Cache</span><span class=\"suffix\" style=\"display: none;\"></span></h4>\n<p data-tool=\"mdnice编辑器\" style=\"padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: black; margin: 10px 0px; letter-spacing: 2px; font-size: 14px; word-spacing: 2px;\">两者对比，主要的策略👇</p>\n<p data-tool=\"mdnice编辑器\" style=\"padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: black; margin: 10px 0px; letter-spacing: 2px; font-size: 14px; word-spacing: 2px;\">内容使用率高的话，文件优先进入磁盘</p>\n<p data-tool=\"mdnice编辑器\" style=\"padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: black; margin: 10px 0px; letter-spacing: 2px; font-size: 14px; word-spacing: 2px;\">比较大的JS，CSS文件会直接放入磁盘，反之放入内存。</p>\n<h4 data-tool=\"mdnice编辑器\" style=\"margin-top: 30px; margin-bottom: 15px; padding: 0px; font-weight: bold; color: black; font-size: 18px;\"><span class=\"prefix\" style=\"display: none;\"></span><span class=\"content\">Push Cache</span><span class=\"suffix\" style=\"display: none;\"></span></h4>\n<p data-tool=\"mdnice编辑器\" style=\"padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: black; margin: 10px 0px; letter-spacing: 2px; font-size: 14px; word-spacing: 2px;\">推送缓存，这算是浏览器中最后一道防线吧，它是<code style=\"font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #916dd5; font-weight: bolder; background: none;\">HTTP/2</code>的内容。具体我也不是很清楚，有兴趣的可以去了解。</p>\n<h3 data-tool=\"mdnice编辑器\" style=\"margin-top: 30px; margin-bottom: 15px; padding: 0px; color: black; font-size: 16px; font-weight: bold; text-align: center;\"><span class=\"prefix\" style=\"display: none;\"></span><span class=\"content\" style=\"border-bottom: 2px solid #d89cf6;\">总结</span><span class=\"suffix\" style=\"display: none;\"></span></h3>\n<ul data-tool=\"mdnice编辑器\" style=\"margin-top: 8px; margin-bottom: 8px; padding-left: 25px; color: black; font-size: 15px; list-style-type: circle;\">\n<li><section style=\"margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-size: 14px; font-weight: normal;\">首先检查<code style=\"font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #916dd5; font-weight: bolder; background: none;\">Cache-Control</code>， 尝鲜，看强缓存是否可用</section></li><li><section style=\"margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-size: 14px; font-weight: normal;\">如果可用的话，直接使用</section></li><li><section style=\"margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-size: 14px; font-weight: normal;\">否则进入协商缓存，发送HTTP请求，服务器通过请求头中的<code style=\"font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #916dd5; font-weight: bolder; background: none;\">If-Modified-Since</code>或者<code style=\"font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #916dd5; font-weight: bolder; background: none;\">If-None-Match</code>字段检查资源是否更新</section></li><li><section style=\"margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-size: 14px; font-weight: normal;\">资源更新，返回资源和200状态码。</section></li><li><section style=\"margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-size: 14px; font-weight: normal;\">否则，返回304，直接告诉浏览器直接从缓存中去资源。</section></li></ul>\n<hr data-tool=\"mdnice编辑器\" style=\"margin: 0; margin-top: 10px; margin-bottom: 10px; height: 1px; padding: 0; border: none; border-top: 2px solid #d9b8fa;\">\n<h2 data-tool=\"mdnice编辑器\" style=\"margin-top: 30px; margin-bottom: 15px; padding: 0px; font-weight: bold; color: black; font-size: 22px; text-align: left; margin: 20px 10px 0px 0px;\"><span class=\"prefix\" style=\"display: none;\"></span><span class=\"content\" style=\"font-size: 18px; font-weight: bold; display: inline-block; padding-left: 10px; border-left: 5px solid #916dd5;\">说一说HTTP 的请求方法？</span><span class=\"suffix\"></span></h2>\n<ul data-tool=\"mdnice编辑器\" style=\"margin-top: 8px; margin-bottom: 8px; padding-left: 25px; color: black; font-size: 15px; list-style-type: circle;\">\n<li><section style=\"margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-size: 14px; font-weight: normal;\">HTTP1.0定义了三种请求方法： GET, POST 和 HEAD方法</section></li><li><section style=\"margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-size: 14px; font-weight: normal;\">HTTP1.1新增了五种请求方法：OPTIONS, PUT, DELETE, TRACE 和 CONNECT</section></li></ul>\n<p data-tool=\"mdnice编辑器\" style=\"padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: black; margin: 10px 0px; letter-spacing: 2px; font-size: 14px; word-spacing: 2px;\"><code style=\"font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #916dd5; font-weight: bolder; background: none;\">http/1.1</code>规定了以下请求方法(注意，都是大写):</p>\n<ul data-tool=\"mdnice编辑器\" style=\"margin-top: 8px; margin-bottom: 8px; padding-left: 25px; color: black; font-size: 15px; list-style-type: circle;\">\n<li><section style=\"margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-size: 14px; font-weight: normal;\">GET：                请求获取Request-URI所标识的资源</section></li><li><section style=\"margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-size: 14px; font-weight: normal;\">POST：              在Request-URI所标识的资源后附加新的数据</section></li><li><section style=\"margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-size: 14px; font-weight: normal;\">HEAD：             请求获取由Request-URI所标识的资源的响应消息报头</section></li><li><section style=\"margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-size: 14px; font-weight: normal;\">PUT：                请求服务器存储一个资源，并用Request-URI作为其标识（修改数据）</section></li><li><section style=\"margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-size: 14px; font-weight: normal;\">DELETE：          请求服务器删除对应所标识的资源</section></li><li><section style=\"margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-size: 14px; font-weight: normal;\">TRACE：            请求服务器回送收到的请求信息，主要用于测试或诊断</section></li><li><section style=\"margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-size: 14px; font-weight: normal;\">CONNECT：      建立连接隧道，用于代理服务器</section></li><li><section style=\"margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-size: 14px; font-weight: normal;\">OPTIONS：       列出可对资源实行的请求方法，用来跨域请求</section></li></ul>\n<hr data-tool=\"mdnice编辑器\" style=\"margin: 0; margin-top: 10px; margin-bottom: 10px; height: 1px; padding: 0; border: none; border-top: 2px solid #d9b8fa;\">\n<h2 data-tool=\"mdnice编辑器\" style=\"margin-top: 30px; margin-bottom: 15px; padding: 0px; font-weight: bold; color: black; font-size: 22px; text-align: left; margin: 20px 10px 0px 0px;\"><span class=\"prefix\" style=\"display: none;\"></span><span class=\"content\" style=\"font-size: 18px; font-weight: bold; display: inline-block; padding-left: 10px; border-left: 5px solid #916dd5;\">谈一谈GET 和 POST 的区别</span><span class=\"suffix\"></span></h2>\n<p data-tool=\"mdnice编辑器\" style=\"padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: black; margin: 10px 0px; letter-spacing: 2px; font-size: 14px; word-spacing: 2px;\">本质上，只是语义上的区别，GET 用于获取资源，POST 用于提交资源。</p>\n<p data-tool=\"mdnice编辑器\" style=\"padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: black; margin: 10px 0px; letter-spacing: 2px; font-size: 14px; word-spacing: 2px;\">想装逼请参考 https://zhuanlan.zhihu.com/p/22536382</p>\n<p data-tool=\"mdnice编辑器\" style=\"padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: black; margin: 10px 0px; letter-spacing: 2px; font-size: 14px; word-spacing: 2px;\">具体差别👇</p>\n<ul data-tool=\"mdnice编辑器\" style=\"margin-top: 8px; margin-bottom: 8px; padding-left: 25px; color: black; font-size: 15px; list-style-type: circle;\">\n<li><section style=\"margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-size: 14px; font-weight: normal;\">从缓存角度看，GET 请求后浏览器会主动缓存，POST 默认情况下不能。</section></li><li><section style=\"margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-size: 14px; font-weight: normal;\">从参数角度来看，GET请求一般放在URL中，因此不安全，POST请求放在请求体中，相对而言较为安全，但是在抓包的情况下都是一样的。</section></li><li><section style=\"margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-size: 14px; font-weight: normal;\">从编码角度看，GET请求只能经行URL编码，只能接受ASCII码，而POST支持更多的编码类型且不对数据类型限值。</section></li><li><section style=\"margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-size: 14px; font-weight: normal;\">GET请求幂等，POST请求不幂等，幂等指发送 M 和 N 次请求（两者不相同且都大于1），服务器上资源的状态一致。</section></li><li><section style=\"margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-size: 14px; font-weight: normal;\">GET请求会一次性发送请求报文，POST请求通常分为两个TCP数据包，首先发 header 部分，如果服务器响应 100(continue)， 然后发 body 部分。</section></li></ul>\n<p data-tool=\"mdnice编辑器\" style=\"padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: black; margin: 10px 0px; letter-spacing: 2px; font-size: 14px; word-spacing: 2px;\">从应用场景角度来看，Get 多用于无副作用，幂等的场景，例如搜索关键字。Post 多用于副作用，不幂等的场景，例如注册。</p>\n<hr data-tool=\"mdnice编辑器\" style=\"margin: 0; margin-top: 10px; margin-bottom: 10px; height: 1px; padding: 0; border: none; border-top: 2px solid #d9b8fa;\">\n<h2 data-tool=\"mdnice编辑器\" style=\"margin-top: 30px; margin-bottom: 15px; padding: 0px; font-weight: bold; color: black; font-size: 22px; text-align: left; margin: 20px 10px 0px 0px;\"><span class=\"prefix\" style=\"display: none;\"></span><span class=\"content\" style=\"font-size: 18px; font-weight: bold; display: inline-block; padding-left: 10px; border-left: 5px solid #916dd5;\">options 方法有什么用？</span><span class=\"suffix\"></span></h2>\n<ul data-tool=\"mdnice编辑器\" style=\"margin-top: 8px; margin-bottom: 8px; padding-left: 25px; color: black; font-size: 15px; list-style-type: circle;\">\n<li><section style=\"margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-size: 14px; font-weight: normal;\"><p style=\"padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: black; margin: 10px 0px; letter-spacing: 2px; font-size: 14px; word-spacing: 2px;\">OPTIONS 请求与 HEAD 类似，一般也是用于客户端查看服务器的性能。</p>\n</section></li><li><section style=\"margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-size: 14px; font-weight: normal;\"><p style=\"padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: black; margin: 10px 0px; letter-spacing: 2px; font-size: 14px; word-spacing: 2px;\">这个方法会请求服务器返回该资源所支持的所有 HTTP 请求方法，该方法会用'*'来代替资源名称，向服务器发送 OPTIONS 请求，可以测试服务器功能是否正常。</p>\n</section></li><li><section style=\"margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-size: 14px; font-weight: normal;\"><p style=\"padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: black; margin: 10px 0px; letter-spacing: 2px; font-size: 14px; word-spacing: 2px;\">JS 的 XMLHttpRequest对象进行 CORS 跨域资源共享时，对于复杂请求，就是使用 OPTIONS 方法发送嗅探请求，以判断是否有对指定资源的访问权限。</p>\n</section></li></ul>\n<hr data-tool=\"mdnice编辑器\" style=\"margin: 0; margin-top: 10px; margin-bottom: 10px; height: 1px; padding: 0; border: none; border-top: 2px solid #d9b8fa;\">\n<h2 data-tool=\"mdnice编辑器\" style=\"margin-top: 30px; margin-bottom: 15px; padding: 0px; font-weight: bold; color: black; font-size: 22px; text-align: left; margin: 20px 10px 0px 0px;\"><span class=\"prefix\" style=\"display: none;\"></span><span class=\"content\" style=\"font-size: 18px; font-weight: bold; display: inline-block; padding-left: 10px; border-left: 5px solid #916dd5;\">谈一谈你对URL理解</span><span class=\"suffix\"></span></h2>\n<p data-tool=\"mdnice编辑器\" style=\"padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: black; margin: 10px 0px; letter-spacing: 2px; font-size: 14px; word-spacing: 2px;\">统一资源定位符的简称，Uniform Resource Locator，常常被称为网址，是因特网上标准的资源地址。</p>\n<h3 data-tool=\"mdnice编辑器\" style=\"margin-top: 30px; margin-bottom: 15px; padding: 0px; color: black; font-size: 16px; font-weight: bold; text-align: center;\"><span class=\"prefix\" style=\"display: none;\"></span><span class=\"content\" style=\"border-bottom: 2px solid #d89cf6;\">组成</span><span class=\"suffix\" style=\"display: none;\"></span></h3>\n<p data-tool=\"mdnice编辑器\" style=\"padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: black; margin: 10px 0px; letter-spacing: 2px; font-size: 14px; word-spacing: 2px;\">通用的格式：scheme://host[:port]/path/…/?query#anchor</p>\n<section class=\"table-container\" data-tool=\"mdnice编辑器\" style=\"overflow-x: auto;\"><table style=\"display: table; text-align: left;\">\n<thead>\n<tr style=\"border: 0; border-top: 1px solid #ccc; background-color: white;\">\n<th style=\"border: 1px solid #ccc; padding: 5px 10px; text-align: left; font-weight: bold; background-color: #f0f0f0; font-size: 14px; min-width: 85px;\">名称</th>\n<th style=\"border: 1px solid #ccc; padding: 5px 10px; font-weight: bold; background-color: #f0f0f0; font-size: 14px; min-width: 85px; text-align: left;\">功能</th>\n</tr>\n</thead>\n<tbody style=\"border: 0;\">\n<tr style=\"border: 0; border-top: 1px solid #ccc; background-color: white;\">\n<td style=\"border: 1px solid #ccc; padding: 5px 10px; text-align: left; font-size: 14px; min-width: 85px;\">scheme</td>\n<td style=\"border: 1px solid #ccc; padding: 5px 10px; font-size: 14px; min-width: 85px; text-align: left;\">访问服务器以获取资源时要使用哪种协议，比如：http，https 和 FTP 等</td>\n</tr>\n<tr style=\"border: 0; border-top: 1px solid #ccc; background-color: #F8F8F8;\">\n<td style=\"border: 1px solid #ccc; padding: 5px 10px; text-align: left; font-size: 14px; min-width: 85px;\">host</td>\n<td style=\"border: 1px solid #ccc; padding: 5px 10px; font-size: 14px; min-width: 85px; text-align: left;\">HTTP 服务器的 IP 地址或者域名</td>\n</tr>\n<tr style=\"border: 0; border-top: 1px solid #ccc; background-color: white;\">\n<td style=\"border: 1px solid #ccc; padding: 5px 10px; text-align: left; font-size: 14px; min-width: 85px;\">port</td>\n<td style=\"border: 1px solid #ccc; padding: 5px 10px; font-size: 14px; min-width: 85px; text-align: left;\">HTTP 服务器的默认端口是 80，HTTPS默认端口是443，这种情况下端口号可以省略，如果使用了别的端口，必须指明。不同的端口，你可以认为是不同的应用程序。</td>\n</tr>\n<tr style=\"border: 0; border-top: 1px solid #ccc; background-color: #F8F8F8;\">\n<td style=\"border: 1px solid #ccc; padding: 5px 10px; text-align: left; font-size: 14px; min-width: 85px;\">path</td>\n<td style=\"border: 1px solid #ccc; padding: 5px 10px; font-size: 14px; min-width: 85px; text-align: left;\">访问资源的路径</td>\n</tr>\n<tr style=\"border: 0; border-top: 1px solid #ccc; background-color: white;\">\n<td style=\"border: 1px solid #ccc; padding: 5px 10px; text-align: left; font-size: 14px; min-width: 85px;\">query-string</td>\n<td style=\"border: 1px solid #ccc; padding: 5px 10px; font-size: 14px; min-width: 85px; text-align: left;\">发给 http 服务器的数据</td>\n</tr>\n<tr style=\"border: 0; border-top: 1px solid #ccc; background-color: #F8F8F8;\">\n<td style=\"border: 1px solid #ccc; padding: 5px 10px; text-align: left; font-size: 14px; min-width: 85px;\">anchor</td>\n<td style=\"border: 1px solid #ccc; padding: 5px 10px; font-size: 14px; min-width: 85px; text-align: left;\">锚点</td>\n</tr>\n</tbody>\n</table>\n</section><p data-tool=\"mdnice编辑器\" style=\"padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: black; margin: 10px 0px; letter-spacing: 2px; font-size: 14px; word-spacing: 2px;\">举个例子👇</p>\n<pre class=\"custom\" data-tool=\"mdnice编辑器\" style=\"margin-top: 10px; margin-bottom: 10px; border-radius: 5px; box-shadow: rgba(0, 0, 0, 0.55) 0px 2px 10px;\"><span style=\"display: block; background: url(https://files.mdnice.com/point.png); height: 30px; width: 100%; background-size: 40px; background-repeat: no-repeat; background-color: #f8f8f8; margin-bottom: -7px; border-radius: 5px; background-position: 10px 10px;\"></span><code class=\"hljs\" style=\"overflow-x: auto; padding: 16px; color: #333; display: -webkit-box; font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; font-size: 12px; -webkit-overflow-scrolling: touch; padding-top: 15px; background: #f8f8f8; border-radius: 5px;\">https://www.baidu.com/s?tn=baidu&amp;bar=&amp;wd=TianTian<br></code></pre>\n<p data-tool=\"mdnice编辑器\" style=\"padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: black; margin: 10px 0px; letter-spacing: 2px; font-size: 14px; word-spacing: 2px;\">这个URL中，https就是协议，www.baidu.com就是域名，默认端口是443，/s就是请求的path，<code style=\"font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #916dd5; font-weight: bolder; background: none;\">tn=baidu&amp;bar=&amp;wd=TianTian</code>这个就是query</p>\n<h3 data-tool=\"mdnice编辑器\" style=\"margin-top: 30px; margin-bottom: 15px; padding: 0px; color: black; font-size: 16px; font-weight: bold; text-align: center;\"><span class=\"prefix\" style=\"display: none;\"></span><span class=\"content\" style=\"border-bottom: 2px solid #d89cf6;\">URL 编码</span><span class=\"suffix\" style=\"display: none;\"></span></h3>\n<ul data-tool=\"mdnice编辑器\" style=\"margin-top: 8px; margin-bottom: 8px; padding-left: 25px; color: black; font-size: 15px; list-style-type: circle;\">\n<li><section style=\"margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-size: 14px; font-weight: normal;\">URL 只能使用 <a href=\"https://www.w3school.com.cn/tags/html_ref_ascii.asp\" style=\"text-decoration: none; word-wrap: break-word; color: #916dd5; font-weight: bolder; border-bottom: 1px solid #916dd5;\">ASCII 字符集</a>来通过因特网进行发送。</section></li><li><section style=\"margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-size: 14px; font-weight: normal;\">由于 URL 常常会包含 ASCII 集合之外的字符，URL 必须转换为有效的 ASCII 格式。</section></li><li><section style=\"margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-size: 14px; font-weight: normal;\">URL 编码使用 \"%\" 其后跟随两位的十六进制数来替换非 ASCII 字符。</section></li><li><section style=\"margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-size: 14px; font-weight: normal;\">URL 不能包含空格。URL 编码通常使用 + 来替换空格。</section></li></ul>\n<p data-tool=\"mdnice编辑器\" style=\"padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: black; margin: 10px 0px; letter-spacing: 2px; font-size: 14px; word-spacing: 2px;\">举个例子👇</p>\n<p data-tool=\"mdnice编辑器\" style=\"padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: black; margin: 10px 0px; letter-spacing: 2px; font-size: 14px; word-spacing: 2px;\"><code style=\"font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #916dd5; font-weight: bolder; background: none;\">天天</code>转换为有效的ASCII格式就是<code style=\"font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #916dd5; font-weight: bolder; background: none;\">%CC%EC%CC%EC</code></p>\n<hr data-tool=\"mdnice编辑器\" style=\"margin: 0; margin-top: 10px; margin-bottom: 10px; height: 1px; padding: 0; border: none; border-top: 2px solid #d9b8fa;\">\n<h2 data-tool=\"mdnice编辑器\" style=\"margin-top: 30px; margin-bottom: 15px; padding: 0px; font-weight: bold; color: black; font-size: 22px; text-align: left; margin: 20px 10px 0px 0px;\"><span class=\"prefix\" style=\"display: none;\"></span><span class=\"content\" style=\"font-size: 18px; font-weight: bold; display: inline-block; padding-left: 10px; border-left: 5px solid #916dd5;\">谈一谈队头阻塞问题</span><span class=\"suffix\"></span></h2>\n<h3 data-tool=\"mdnice编辑器\" style=\"margin-top: 30px; margin-bottom: 15px; padding: 0px; color: black; font-size: 16px; font-weight: bold; text-align: center;\"><span class=\"prefix\" style=\"display: none;\"></span><span class=\"content\" style=\"border-bottom: 2px solid #d89cf6;\">什么是队头阻塞？</span><span class=\"suffix\" style=\"display: none;\"></span></h3>\n<p data-tool=\"mdnice编辑器\" style=\"padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: black; margin: 10px 0px; letter-spacing: 2px; font-size: 14px; word-spacing: 2px;\">对于每一个HTTP请求而言，这些任务是会被放入一个任务队列中串行执行的，一旦队首任务请求太慢时，就会阻塞后面的请求处理，这就是<code style=\"font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #916dd5; font-weight: bolder; background: none;\">HTTP队头阻塞</code>问题。</p>\n<p data-tool=\"mdnice编辑器\" style=\"padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: black; margin: 10px 0px; letter-spacing: 2px; font-size: 14px; word-spacing: 2px;\">有什么解决办法吗👇</p>\n<h3 data-tool=\"mdnice编辑器\" style=\"margin-top: 30px; margin-bottom: 15px; padding: 0px; color: black; font-size: 16px; font-weight: bold; text-align: center;\"><span class=\"prefix\" style=\"display: none;\"></span><span class=\"content\" style=\"border-bottom: 2px solid #d89cf6;\">并发连接</span><span class=\"suffix\" style=\"display: none;\"></span></h3>\n<p data-tool=\"mdnice编辑器\" style=\"padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: black; margin: 10px 0px; letter-spacing: 2px; font-size: 14px; word-spacing: 2px;\">我们知道对于一个域名而言，是允许分配多个长连接的，那么可以理解成增加了任务队列，也就是说不会导致一个任务阻塞了该任务队列的其他任务，在<code style=\"font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #916dd5; font-weight: bolder; background: none;\">RFC规范</code>中规定客户端最多并发2个连接，不过实际情况就是要比这个还要多，举个例子，Chrome中是6个。</p>\n<h3 data-tool=\"mdnice编辑器\" style=\"margin-top: 30px; margin-bottom: 15px; padding: 0px; color: black; font-size: 16px; font-weight: bold; text-align: center;\"><span class=\"prefix\" style=\"display: none;\"></span><span class=\"content\" style=\"border-bottom: 2px solid #d89cf6;\">域名分片</span><span class=\"suffix\" style=\"display: none;\"></span></h3>\n<p data-tool=\"mdnice编辑器\" style=\"padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: black; margin: 10px 0px; letter-spacing: 2px; font-size: 14px; word-spacing: 2px;\">顾名思义，我们可以在一个域名下分出多个二级域名出来，而它们最终指向的还是同一个服务器，这样子的话就可以并发处理的任务队列更多，也更好的解决了队头阻塞的问题。</p>\n<p data-tool=\"mdnice编辑器\" style=\"padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: black; margin: 10px 0px; letter-spacing: 2px; font-size: 14px; word-spacing: 2px;\">举个例子，比如<code style=\"font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #916dd5; font-weight: bolder; background: none;\">TianTian.com</code>，可以分出很多二级域名，比如<code style=\"font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #916dd5; font-weight: bolder; background: none;\">Day1.TianTian.com</code>，<code style=\"font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #916dd5; font-weight: bolder; background: none;\">Day2.TianTian.com</code>,<code style=\"font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #916dd5; font-weight: bolder; background: none;\">Day3.TianTian.com</code>,这样子就可以有效解决队头阻塞问题。</p>\n<hr data-tool=\"mdnice编辑器\" style=\"margin: 0; margin-top: 10px; margin-bottom: 10px; height: 1px; padding: 0; border: none; border-top: 2px solid #d9b8fa;\">\n<h2 data-tool=\"mdnice编辑器\" style=\"margin-top: 30px; margin-bottom: 15px; padding: 0px; font-weight: bold; color: black; font-size: 22px; text-align: left; margin: 20px 10px 0px 0px;\"><span class=\"prefix\" style=\"display: none;\"></span><span class=\"content\" style=\"font-size: 18px; font-weight: bold; display: inline-block; padding-left: 10px; border-left: 5px solid #916dd5;\">谈一谈HTTP数据传输</span><span class=\"suffix\"></span></h2>\n<p data-tool=\"mdnice编辑器\" style=\"padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: black; margin: 10px 0px; letter-spacing: 2px; font-size: 14px; word-spacing: 2px;\">大概遇到的情况就分为<strong style=\"color: #916dd5; font-weight: bold;\"><span>「</span>定长数据<span>」</span></strong> 与 <strong style=\"color: #916dd5; font-weight: bold;\"><span>「</span>不定长数据<span>」</span></strong>的处理吧。</p>\n<h3 data-tool=\"mdnice编辑器\" style=\"margin-top: 30px; margin-bottom: 15px; padding: 0px; color: black; font-size: 16px; font-weight: bold; text-align: center;\"><span class=\"prefix\" style=\"display: none;\"></span><span class=\"content\" style=\"border-bottom: 2px solid #d89cf6;\">定长数据</span><span class=\"suffix\" style=\"display: none;\"></span></h3>\n<p data-tool=\"mdnice编辑器\" style=\"padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: black; margin: 10px 0px; letter-spacing: 2px; font-size: 14px; word-spacing: 2px;\">对于定长的数据包而言，发送端在发送数据的过程中，需要设置<code style=\"font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #916dd5; font-weight: bolder; background: none;\">Content-Length</code>,来指明发送数据的长度。</p>\n<p data-tool=\"mdnice编辑器\" style=\"padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: black; margin: 10px 0px; letter-spacing: 2px; font-size: 14px; word-spacing: 2px;\">当然了如果采用了Gzip压缩的话，Content-Length设置的就是压缩后的传输长度。</p>\n<p data-tool=\"mdnice编辑器\" style=\"padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: black; margin: 10px 0px; letter-spacing: 2px; font-size: 14px; word-spacing: 2px;\">我们还需要知道的是👇</p>\n<ul data-tool=\"mdnice编辑器\" style=\"margin-top: 8px; margin-bottom: 8px; padding-left: 25px; color: black; font-size: 15px; list-style-type: circle;\">\n<li><section style=\"margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-size: 14px; font-weight: normal;\">Content-Length如果存在并且有效的话，则必须和消息内容的传输长度完全一致，也就是说，如果过短就会截断，过长的话，就会导致超时。</section></li><li><section style=\"margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-size: 14px; font-weight: normal;\">如果采用短链接的话，直接可以通过服务器关闭连接来确定消息的传输长度。</section></li><li><section style=\"margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-size: 14px; font-weight: normal;\">那么在HTTP/1.0之前的版本中，Content-Length字段可有可无,因为一旦服务器关闭连接，我们就可以获取到传输数据的长度了。</section></li><li><section style=\"margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-size: 14px; font-weight: normal;\">在HTTP/1.1版本中，如果是Keep-alive的话，chunked优先级高于<code style=\"font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #916dd5; font-weight: bolder; background: none;\">Content-Length</code>,若是非Keep-alive，跟前面情况一样，Content-Length可有可无。</section></li></ul>\n<p data-tool=\"mdnice编辑器\" style=\"padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: black; margin: 10px 0px; letter-spacing: 2px; font-size: 14px; word-spacing: 2px;\">那怎么来设置<code style=\"font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #916dd5; font-weight: bolder; background: none;\">Content-Length</code></p>\n<p data-tool=\"mdnice编辑器\" style=\"padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: black; margin: 10px 0px; letter-spacing: 2px; font-size: 14px; word-spacing: 2px;\">举个例子来看看👇</p>\n<pre class=\"custom\" data-tool=\"mdnice编辑器\" style=\"margin-top: 10px; margin-bottom: 10px; border-radius: 5px; box-shadow: rgba(0, 0, 0, 0.55) 0px 2px 10px;\"><span style=\"display: block; background: url(https://files.mdnice.com/point.png); height: 30px; width: 100%; background-size: 40px; background-repeat: no-repeat; background-color: #f8f8f8; margin-bottom: -7px; border-radius: 5px; background-position: 10px 10px;\"></span><code class=\"hljs\" style=\"overflow-x: auto; padding: 16px; color: #333; display: -webkit-box; font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; font-size: 12px; -webkit-overflow-scrolling: touch; padding-top: 15px; background: #f8f8f8; border-radius: 5px;\">const&nbsp;server&nbsp;=&nbsp;require(<span class=\"hljs-string\" style=\"color: #d14; line-height: 26px;\">'http'</span>).createServer();<br>server.on(<span class=\"hljs-string\" style=\"color: #d14; line-height: 26px;\">'request'</span>,&nbsp;(req,&nbsp;res)&nbsp;=&gt;&nbsp;{<br>&nbsp;&nbsp;<span class=\"hljs-keyword\" style=\"color: #333; font-weight: bold; line-height: 26px;\">if</span>(req.url&nbsp;===&nbsp;<span class=\"hljs-string\" style=\"color: #d14; line-height: 26px;\">'/index'</span>)&nbsp;{<br>&nbsp;&nbsp;&nbsp;//&nbsp;设置数据类型<br>&nbsp;&nbsp;&nbsp;&nbsp;res.setHeader(<span class=\"hljs-string\" style=\"color: #d14; line-height: 26px;\">'Content-Type'</span>,&nbsp;<span class=\"hljs-string\" style=\"color: #d14; line-height: 26px;\">'text/plain'</span>);<br>&nbsp;&nbsp;&nbsp;&nbsp;res.setHeader(<span class=\"hljs-string\" style=\"color: #d14; line-height: 26px;\">'Content-Length'</span>,&nbsp;10);<br>&nbsp;&nbsp;&nbsp;&nbsp;res.write(<span class=\"hljs-string\" style=\"color: #d14; line-height: 26px;\">\"你好，使用的是Content-Length设置传输数据形式\"</span>);<br>&nbsp;&nbsp;}<br>})<br><br>server.listen(3000,&nbsp;()&nbsp;=&gt;&nbsp;{<br>&nbsp;&nbsp;console.log(<span class=\"hljs-string\" style=\"color: #d14; line-height: 26px;\">\"成功启动--TinaTian\"</span>);<br>})<br><br></code></pre>\n<h3 data-tool=\"mdnice编辑器\" style=\"margin-top: 30px; margin-bottom: 15px; padding: 0px; color: black; font-size: 16px; font-weight: bold; text-align: center;\"><span class=\"prefix\" style=\"display: none;\"></span><span class=\"content\" style=\"border-bottom: 2px solid #d89cf6;\">不定长数据</span><span class=\"suffix\" style=\"display: none;\"></span></h3>\n<p data-tool=\"mdnice编辑器\" style=\"padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: black; margin: 10px 0px; letter-spacing: 2px; font-size: 14px; word-spacing: 2px;\">现在采用最多的就是HTTP/1.1版本，来完成传输数据，在保存Keep-alive状态下，当数据是不定长的时候，我们需要设置新的头部字段👇</p>\n<pre class=\"custom\" data-tool=\"mdnice编辑器\" style=\"margin-top: 10px; margin-bottom: 10px; border-radius: 5px; box-shadow: rgba(0, 0, 0, 0.55) 0px 2px 10px;\"><span style=\"display: block; background: url(https://files.mdnice.com/point.png); height: 30px; width: 100%; background-size: 40px; background-repeat: no-repeat; background-color: #f8f8f8; margin-bottom: -7px; border-radius: 5px; background-position: 10px 10px;\"></span><code class=\"hljs\" style=\"overflow-x: auto; padding: 16px; color: #333; display: -webkit-box; font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; font-size: 12px; -webkit-overflow-scrolling: touch; padding-top: 15px; background: #f8f8f8; border-radius: 5px;\">Transfer-Encoding:&nbsp;chunked<br></code></pre>\n<p data-tool=\"mdnice编辑器\" style=\"padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: black; margin: 10px 0px; letter-spacing: 2px; font-size: 14px; word-spacing: 2px;\">通过chunked机制，可以完成对不定长数据的处理，当然了，你需要知道的是</p>\n<ul data-tool=\"mdnice编辑器\" style=\"margin-top: 8px; margin-bottom: 8px; padding-left: 25px; color: black; font-size: 15px; list-style-type: circle;\">\n<li><section style=\"margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-size: 14px; font-weight: normal;\">如果头部信息中有<code style=\"font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #916dd5; font-weight: bolder; background: none;\">Transfer-Encoding</code>,优先采用Transfer-Encoding里面的方法来找到对应的长度。</section></li><li><section style=\"margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-size: 14px; font-weight: normal;\">如果设置了Transfer-Encoding，那么Content-Length将被忽视。</section></li><li><section style=\"margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-size: 14px; font-weight: normal;\">使用长连接的话，会持续的推送动态内容。</section></li></ul>\n<p data-tool=\"mdnice编辑器\" style=\"padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: black; margin: 10px 0px; letter-spacing: 2px; font-size: 14px; word-spacing: 2px;\">那我们来模拟一下吧👇</p>\n<pre class=\"custom\" data-tool=\"mdnice编辑器\" style=\"margin-top: 10px; margin-bottom: 10px; border-radius: 5px; box-shadow: rgba(0, 0, 0, 0.55) 0px 2px 10px;\"><span style=\"display: block; background: url(https://files.mdnice.com/point.png); height: 30px; width: 100%; background-size: 40px; background-repeat: no-repeat; background-color: #f8f8f8; margin-bottom: -7px; border-radius: 5px; background-position: 10px 10px;\"></span><code class=\"hljs\" style=\"overflow-x: auto; padding: 16px; color: #333; display: -webkit-box; font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; font-size: 12px; -webkit-overflow-scrolling: touch; padding-top: 15px; background: #f8f8f8; border-radius: 5px;\">const&nbsp;server&nbsp;=&nbsp;require(<span class=\"hljs-string\" style=\"color: #d14; line-height: 26px;\">'http'</span>).createServer();<br>server.on(<span class=\"hljs-string\" style=\"color: #d14; line-height: 26px;\">'request'</span>,&nbsp;(req,&nbsp;res)&nbsp;=&gt;&nbsp;{<br>&nbsp;&nbsp;<span class=\"hljs-keyword\" style=\"color: #333; font-weight: bold; line-height: 26px;\">if</span>(req.url&nbsp;===&nbsp;<span class=\"hljs-string\" style=\"color: #d14; line-height: 26px;\">'/index'</span>)&nbsp;{<br>&nbsp;&nbsp;&nbsp;//&nbsp;设置数据类型<br>&nbsp;&nbsp;&nbsp;&nbsp;res.setHeader(<span class=\"hljs-string\" style=\"color: #d14; line-height: 26px;\">'Content-Type'</span>,&nbsp;<span class=\"hljs-string\" style=\"color: #d14; line-height: 26px;\">'text/html;&nbsp;charset=utf8'</span>);<br>&nbsp;&nbsp;&nbsp;&nbsp;res.setHeader(<span class=\"hljs-string\" style=\"color: #d14; line-height: 26px;\">'Content-Length'</span>,&nbsp;10);<br>&nbsp;&nbsp;&nbsp;&nbsp;res.setHeader(<span class=\"hljs-string\" style=\"color: #d14; line-height: 26px;\">'Transfer-Encoding'</span>,&nbsp;<span class=\"hljs-string\" style=\"color: #d14; line-height: 26px;\">'chunked'</span>);<br>&nbsp;&nbsp;&nbsp;&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;res.write(<span class=\"hljs-string\" style=\"color: #d14; line-height: 26px;\">\"你好，使用的是Transfer-Encoding设置传输数据形式\"</span>);<br>&nbsp;&nbsp;&nbsp;&nbsp;setTimeout(()&nbsp;=&gt;&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;res.write(<span class=\"hljs-string\" style=\"color: #d14; line-height: 26px;\">\"第一次传输数据给您&lt;br/&gt;\"</span>);<br>&nbsp;&nbsp;&nbsp;&nbsp;},&nbsp;1000);<br>&nbsp;&nbsp;&nbsp;&nbsp;res.write(<span class=\"hljs-string\" style=\"color: #d14; line-height: 26px;\">\"骚等一下\"</span>);<br>&nbsp;&nbsp;&nbsp;&nbsp;setTimeout(()&nbsp;=&gt;&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;res.write(<span class=\"hljs-string\" style=\"color: #d14; line-height: 26px;\">\"第一次传输数据给您\"</span>);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;res.end()<br>&nbsp;&nbsp;&nbsp;&nbsp;},&nbsp;3000);<br>&nbsp;&nbsp;}<br>})<br><br>server.listen(3000,&nbsp;()&nbsp;=&gt;&nbsp;{<br>&nbsp;&nbsp;console.log(<span class=\"hljs-string\" style=\"color: #d14; line-height: 26px;\">\"成功启动--TinaTian\"</span>);<br>})<br><br></code></pre>\n<p data-tool=\"mdnice编辑器\" style=\"padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: black; margin: 10px 0px; letter-spacing: 2px; font-size: 14px; word-spacing: 2px;\">上面使用的是nodejs中http模块，有兴趣的小伙伴可以去试一试，以上就是HTTP对<strong style=\"color: #916dd5; font-weight: bold;\"><span>「</span>定长数据<span>」</span></strong>和<strong style=\"color: #916dd5; font-weight: bold;\"><span>「</span>不定长数据<span>」</span></strong>传输过程中的处理手段。</p>\n<hr data-tool=\"mdnice编辑器\" style=\"margin: 0; margin-top: 10px; margin-bottom: 10px; height: 1px; padding: 0; border: none; border-top: 2px solid #d9b8fa;\">\n<h2 data-tool=\"mdnice编辑器\" style=\"margin-top: 30px; margin-bottom: 15px; padding: 0px; font-weight: bold; color: black; font-size: 22px; text-align: left; margin: 20px 10px 0px 0px;\"><span class=\"prefix\" style=\"display: none;\"></span><span class=\"content\" style=\"font-size: 18px; font-weight: bold; display: inline-block; padding-left: 10px; border-left: 5px solid #916dd5;\">介绍一下HTTPS和HTTP区别</span><span class=\"suffix\"></span></h2>\n<p data-tool=\"mdnice编辑器\" style=\"padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: black; margin: 10px 0px; letter-spacing: 2px; font-size: 14px; word-spacing: 2px;\">HTTPS 要比 HTTPS 多了 secure 安全性这个概念，实际上， HTTPS 并不是一个新的应用层协议，它其实就是 HTTP + TLS/SSL 协议组合而成，而安全性的保证正是 SSL/TLS 所做的工作。</p>\n<p data-tool=\"mdnice编辑器\" style=\"padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: black; margin: 10px 0px; letter-spacing: 2px; font-size: 14px; word-spacing: 2px;\"><strong style=\"color: #916dd5; font-weight: bold;\"><span>「</span>SSL<span>」</span></strong></p>\n<p data-tool=\"mdnice编辑器\" style=\"padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: black; margin: 10px 0px; letter-spacing: 2px; font-size: 14px; word-spacing: 2px;\">安全套接层（Secure Sockets Layer）</p>\n<p data-tool=\"mdnice编辑器\" style=\"padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: black; margin: 10px 0px; letter-spacing: 2px; font-size: 14px; word-spacing: 2px;\"><strong style=\"color: #916dd5; font-weight: bold;\"><span>「</span>TLS<span>」</span></strong></p>\n<p data-tool=\"mdnice编辑器\" style=\"padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: black; margin: 10px 0px; letter-spacing: 2px; font-size: 14px; word-spacing: 2px;\">（传输层安全，Transport Layer Security）</p>\n<p data-tool=\"mdnice编辑器\" style=\"padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: black; margin: 10px 0px; letter-spacing: 2px; font-size: 14px; word-spacing: 2px;\">现在主流的版本是 TLS/1.2, 之前的 TLS1.0、TLS1.1 都被认为是不安全的，在不久的将来会被完全淘汰。</p>\n<p data-tool=\"mdnice编辑器\" style=\"padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: black; margin: 10px 0px; letter-spacing: 2px; font-size: 14px; word-spacing: 2px;\"><strong style=\"color: #916dd5; font-weight: bold;\"><span>「</span>HTTPS 就是身披了一层 SSL 的 HTTP<span>」</span></strong>。</p>\n<figure data-tool=\"mdnice编辑器\" style=\"margin: 0; margin-top: 10px; margin-bottom: 10px; display: flex; flex-direction: column; justify-content: center; align-items: center;\"><img src=\"https://user-images.githubusercontent.com/34484322/89356445-626c9600-d6f0-11ea-9f89-dbc77bd4ac4e.png\" alt=\"HTTP与HTTPS区别\" style=\"max-width: 100%; border-radius: 6px; display: block; margin: 20px auto; object-fit: contain; box-shadow: 2px 4px 7px #999;\"><figcaption style=\"margin-top: 5px; text-align: center; color: #888; display: block; font-size: 13px;\">HTTP与HTTPS区别</figcaption></figure>\n<p data-tool=\"mdnice编辑器\" style=\"padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: black; margin: 10px 0px; letter-spacing: 2px; font-size: 14px; word-spacing: 2px;\">那么区别有哪些呢👇</p>\n<ul data-tool=\"mdnice编辑器\" style=\"margin-top: 8px; margin-bottom: 8px; padding-left: 25px; color: black; font-size: 15px; list-style-type: circle;\">\n<li><section style=\"margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-size: 14px; font-weight: normal;\">HTTP 是明文传输协议，HTTPS 协议是由 SSL+HTTP 协议构建的可进行加密传输、身份认证的网络协议，比 HTTP 协议安全。</section></li><li><section style=\"margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-size: 14px; font-weight: normal;\">HTTPS比HTTP更加安全，对搜索引擎更友好，利于SEO,谷歌、百度优先索引HTTPS网页。</section></li><li><section style=\"margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-size: 14px; font-weight: normal;\">HTTPS标准端口443，HTTP标准端口80。</section></li><li><section style=\"margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-size: 14px; font-weight: normal;\">HTTPS需要用到SSL证书，而HTTP不用。</section></li></ul>\n<p data-tool=\"mdnice编辑器\" style=\"padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: black; margin: 10px 0px; letter-spacing: 2px; font-size: 14px; word-spacing: 2px;\">我觉得记住以下两点HTTPS主要作用就行👇</p>\n<ol data-tool=\"mdnice编辑器\" style=\"margin-top: 8px; margin-bottom: 8px; padding-left: 25px; color: black; list-style-type: decimal; font-size: 15px;\">\n<li><section style=\"margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-size: 14px; font-weight: normal;\">对数据进行加密，并建立一个信息安全通道，来保证传输过程中的数据安全;</section></li><li><section style=\"margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-size: 14px; font-weight: normal;\">对网站服务器进行真实身份认证。</section></li></ol>\n<h2 data-tool=\"mdnice编辑器\" style=\"margin-top: 30px; margin-bottom: 15px; padding: 0px; font-weight: bold; color: black; font-size: 22px; text-align: left; margin: 20px 10px 0px 0px;\"><span class=\"prefix\" style=\"display: none;\"></span><span class=\"content\" style=\"font-size: 18px; font-weight: bold; display: inline-block; padding-left: 10px; border-left: 5px solid #916dd5;\">介绍一个HTTPS工作原理</span><span class=\"suffix\"></span></h2>\n<p data-tool=\"mdnice编辑器\" style=\"padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: black; margin: 10px 0px; letter-spacing: 2px; font-size: 14px; word-spacing: 2px;\">上一节来看，我们可以把HTTPS理解成<strong style=\"color: #916dd5; font-weight: bold;\"><span>「</span>HTTPS = HTTP + SSL/TLS<span>」</span></strong></p>\n<blockquote data-tool=\"mdnice编辑器\" style=\"display: block; font-size: 0.9em; overflow: auto; overflow-scrolling: touch; border-left: 3px solid rgba(0, 0, 0, 0.4); color: #6a737d; padding-top: 10px; padding-bottom: 10px; padding-left: 20px; padding-right: 10px; margin-bottom: 20px; margin-top: 20px; border-left-color: #d89cf6; background: #f4eeff;\">\n<p style=\"padding-top: 8px; padding-bottom: 8px; letter-spacing: 2px; font-size: 14px; word-spacing: 2px; margin: 0px; color: black; line-height: 26px;\">TLS/SSL 的功能实现主要依赖于三类基本算法：<code style=\"font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #916dd5; font-weight: bolder; background: none;\">散列函数</code> 、<code style=\"font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #916dd5; font-weight: bolder; background: none;\">对称加密</code>和<code style=\"font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #916dd5; font-weight: bolder; background: none;\">非对称加密</code>，其利用非对称加密实现身份认证和密钥协商，对称加密算法采用协商的密钥对数据加密，基于散列函数验证信息的完整性。</p>\n</blockquote>\n<h3 data-tool=\"mdnice编辑器\" style=\"margin-top: 30px; margin-bottom: 15px; padding: 0px; color: black; font-size: 16px; font-weight: bold; text-align: center;\"><span class=\"prefix\" style=\"display: none;\"></span><span class=\"content\" style=\"border-bottom: 2px solid #d89cf6;\">对称加密</span><span class=\"suffix\" style=\"display: none;\"></span></h3>\n<p data-tool=\"mdnice编辑器\" style=\"padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: black; margin: 10px 0px; letter-spacing: 2px; font-size: 14px; word-spacing: 2px;\">加密和解密用同一个秘钥的加密方式叫做对称加密。Client客户端和Server端共用一套密钥，这样子的加密过程似乎很让人理解，但是随之会产生一些问题。</p>\n<p data-tool=\"mdnice编辑器\" style=\"padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: black; margin: 10px 0px; letter-spacing: 2px; font-size: 14px; word-spacing: 2px;\"><strong style=\"color: #916dd5; font-weight: bold;\"><span>「</span>问题一:<span>」</span></strong> WWW万维网有许许多多的客户端，不可能都用秘钥A进行信息加密，这样子很不合理，所以解决办法就是使用一个客户端使用一个密钥进行加密。</p>\n<p data-tool=\"mdnice编辑器\" style=\"padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: black; margin: 10px 0px; letter-spacing: 2px; font-size: 14px; word-spacing: 2px;\"><strong style=\"color: #916dd5; font-weight: bold;\"><span>「</span>问题二:<strong style=\"color: #916dd5; font-weight: bold;\"><span>「</span>既然不同的客户端使用不同的密钥，那么<span>」</span></strong>对称加密的密钥如何传输？<span>」</span></strong> 那么解决的办法只能是<strong style=\"color: #916dd5; font-weight: bold;\"><span>「</span>一端生成一个秘钥，然后通过HTTP传输给另一端<span>」</span></strong>，那么这样子又会产生新的问题。</p>\n<p data-tool=\"mdnice编辑器\" style=\"padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: black; margin: 10px 0px; letter-spacing: 2px; font-size: 14px; word-spacing: 2px;\"><strong style=\"color: #916dd5; font-weight: bold;\"><span>「</span>问题三:<span>」</span></strong> 这个传输密钥的过程，又如何保证加密？<strong style=\"color: #916dd5; font-weight: bold;\"><span>「</span>如果被中间人拦截，密钥也会被获取,<span>」</span></strong> 那么你会说对密钥再进行加密，那又怎么保存对密钥加密的过程，是加密的过程？</p>\n<p data-tool=\"mdnice编辑器\" style=\"padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: black; margin: 10px 0px; letter-spacing: 2px; font-size: 14px; word-spacing: 2px;\">到这里，我们似乎想明白了，使用对称加密的方式，行不通，所以我们需要采用非对称加密👇</p>\n<h3 data-tool=\"mdnice编辑器\" style=\"margin-top: 30px; margin-bottom: 15px; padding: 0px; color: black; font-size: 16px; font-weight: bold; text-align: center;\"><span class=\"prefix\" style=\"display: none;\"></span><span class=\"content\" style=\"border-bottom: 2px solid #d89cf6;\">非对称加密</span><span class=\"suffix\" style=\"display: none;\"></span></h3>\n<p data-tool=\"mdnice编辑器\" style=\"padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: black; margin: 10px 0px; letter-spacing: 2px; font-size: 14px; word-spacing: 2px;\">通过上面的分析，对称加密的方式行不通，那么我们来梳理一下非对称加密。采用的算法是RSA，所以在一些文章中也会看见<strong style=\"color: #916dd5; font-weight: bold;\"><span>「</span>传统RSA握手<span>」</span></strong>，基于现在TLS主流版本是1.2，所以接下来梳理的是<strong style=\"color: #916dd5; font-weight: bold;\"><span>「</span>TLS/1.2握手过程<span>」</span></strong>。</p>\n<p data-tool=\"mdnice编辑器\" style=\"padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: black; margin: 10px 0px; letter-spacing: 2px; font-size: 14px; word-spacing: 2px;\">非对称加密中，我们需要明确的点是👇</p>\n<ul data-tool=\"mdnice编辑器\" style=\"margin-top: 8px; margin-bottom: 8px; padding-left: 25px; color: black; font-size: 15px; list-style-type: circle;\">\n<li><section style=\"margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-size: 14px; font-weight: normal;\">有一对秘钥，<strong style=\"color: #916dd5; font-weight: bold;\"><span>「</span>公钥<span>」</span></strong>和<strong style=\"color: #916dd5; font-weight: bold;\"><span>「</span>私钥<span>」</span></strong>。</section></li><li><section style=\"margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-size: 14px; font-weight: normal;\">公钥加密的内容，只有私钥可以解开，私钥加密的内容，所有的公钥都可以解开，这里说的<strong style=\"color: #916dd5; font-weight: bold;\"><span>「</span>公钥都可以解开，指的是一对秘钥<span>」</span></strong>。</section></li><li><section style=\"margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-size: 14px; font-weight: normal;\">公钥可以发送给所有的客户端，私钥只保存在服务器端。</section></li></ul>\n<h3 data-tool=\"mdnice编辑器\" style=\"margin-top: 30px; margin-bottom: 15px; padding: 0px; color: black; font-size: 16px; font-weight: bold; text-align: center;\"><span class=\"prefix\" style=\"display: none;\"></span><span class=\"content\" style=\"border-bottom: 2px solid #d89cf6;\">主要工作流程</span><span class=\"suffix\" style=\"display: none;\"></span></h3>\n<p data-tool=\"mdnice编辑器\" style=\"padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: black; margin: 10px 0px; letter-spacing: 2px; font-size: 14px; word-spacing: 2px;\">梳理起来，可以把<strong style=\"color: #916dd5; font-weight: bold;\"><span>「</span>TLS 1.2 握手过程<span>」</span></strong>分为主要的五步👇</p>\n<figure data-tool=\"mdnice编辑器\" style=\"margin: 0; margin-top: 10px; margin-bottom: 10px; display: flex; flex-direction: column; justify-content: center; align-items: center;\"><img src=\"https://user-images.githubusercontent.com/34484322/89356430-58e32e00-d6f0-11ea-9320-115133c36e3e.png\" alt style=\"max-width: 100%; border-radius: 6px; display: block; margin: 20px auto; object-fit: contain; box-shadow: 2px 4px 7px #999;\"></figure>\n<p data-tool=\"mdnice编辑器\" style=\"padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: black; margin: 10px 0px; letter-spacing: 2px; font-size: 14px; word-spacing: 2px;\">图片内容来自<a href=\"https://juejin.im/user/4283353031252967\" style=\"text-decoration: none; word-wrap: break-word; color: #916dd5; font-weight: bolder; border-bottom: 1px solid #916dd5;\">浪里行舟</a></p>\n<h4 data-tool=\"mdnice编辑器\" style=\"margin-top: 30px; margin-bottom: 15px; padding: 0px; font-weight: bold; color: black; font-size: 18px;\"><span class=\"prefix\" style=\"display: none;\"></span><span class=\"content\">步骤(1)</span><span class=\"suffix\" style=\"display: none;\"></span></h4>\n<p data-tool=\"mdnice编辑器\" style=\"padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: black; margin: 10px 0px; letter-spacing: 2px; font-size: 14px; word-spacing: 2px;\">Client发起一个HTTPS请求，连接443端口。这个过程可以理解成是<strong style=\"color: #916dd5; font-weight: bold;\"><span>「</span>请求公钥的过程<span>」</span></strong>。</p>\n<h4 data-tool=\"mdnice编辑器\" style=\"margin-top: 30px; margin-bottom: 15px; padding: 0px; font-weight: bold; color: black; font-size: 18px;\"><span class=\"prefix\" style=\"display: none;\"></span><span class=\"content\">步骤(2)</span><span class=\"suffix\" style=\"display: none;\"></span></h4>\n<p data-tool=\"mdnice编辑器\" style=\"padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: black; margin: 10px 0px; letter-spacing: 2px; font-size: 14px; word-spacing: 2px;\">Server端收到请求后，通过第三方机构私钥加密，会把数字证书（也可以认为是公钥证书）发送给Client。</p>\n<h4 data-tool=\"mdnice编辑器\" style=\"margin-top: 30px; margin-bottom: 15px; padding: 0px; font-weight: bold; color: black; font-size: 18px;\"><span class=\"prefix\" style=\"display: none;\"></span><span class=\"content\">步骤(3)</span><span class=\"suffix\" style=\"display: none;\"></span></h4>\n<ul data-tool=\"mdnice编辑器\" style=\"margin-top: 8px; margin-bottom: 8px; padding-left: 25px; color: black; font-size: 15px; list-style-type: circle;\">\n<li><section style=\"margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-size: 14px; font-weight: normal;\">浏览器安装后会自动带一些权威第三方机构公钥，使用匹配的公钥对数字签名进行解密。</section></li><li><section style=\"margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-size: 14px; font-weight: normal;\">根据签名生成的规则对网站信息进行本地签名生成，然后两者比对。</section></li><li><section style=\"margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-size: 14px; font-weight: normal;\">通过比对两者签名，匹配则说明认证通过，不匹配则获取证书失败。</section></li></ul>\n<h4 data-tool=\"mdnice编辑器\" style=\"margin-top: 30px; margin-bottom: 15px; padding: 0px; font-weight: bold; color: black; font-size: 18px;\"><span class=\"prefix\" style=\"display: none;\"></span><span class=\"content\">步骤(4)</span><span class=\"suffix\" style=\"display: none;\"></span></h4>\n<p data-tool=\"mdnice编辑器\" style=\"padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: black; margin: 10px 0px; letter-spacing: 2px; font-size: 14px; word-spacing: 2px;\">在安全拿到<strong style=\"color: #916dd5; font-weight: bold;\"><span>「</span>服务器公钥<span>」</span></strong>后，客户端Client随机生成一个<strong style=\"color: #916dd5; font-weight: bold;\"><span>「</span>对称密钥<span>」</span></strong>，使用<strong style=\"color: #916dd5; font-weight: bold;\"><span>「</span>服务器公钥<span>」</span></strong>（证书的公钥）加密这个<strong style=\"color: #916dd5; font-weight: bold;\"><span>「</span>对称密钥<span>」</span></strong>，发送给Server(服务器)。</p>\n<h4 data-tool=\"mdnice编辑器\" style=\"margin-top: 30px; margin-bottom: 15px; padding: 0px; font-weight: bold; color: black; font-size: 18px;\"><span class=\"prefix\" style=\"display: none;\"></span><span class=\"content\">步骤(5)</span><span class=\"suffix\" style=\"display: none;\"></span></h4>\n<p data-tool=\"mdnice编辑器\" style=\"padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: black; margin: 10px 0px; letter-spacing: 2px; font-size: 14px; word-spacing: 2px;\">Server(服务器)通过自己的私钥，对信息解密，至此得到了<strong style=\"color: #916dd5; font-weight: bold;\"><span>「</span>对称密钥<span>」</span></strong>，此时两者都拥有了相同的<strong style=\"color: #916dd5; font-weight: bold;\"><span>「</span>对称密钥<span>」</span></strong>。</p>\n<p data-tool=\"mdnice编辑器\" style=\"padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: black; margin: 10px 0px; letter-spacing: 2px; font-size: 14px; word-spacing: 2px;\">接下来，就可以通过该对称密钥对传输的信息加密/解密啦，从上面图举个例子👇</p>\n<ul data-tool=\"mdnice编辑器\" style=\"margin-top: 8px; margin-bottom: 8px; padding-left: 25px; color: black; font-size: 15px; list-style-type: circle;\">\n<li><section style=\"margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-size: 14px; font-weight: normal;\">Client用户使用该<strong style=\"color: #916dd5; font-weight: bold;\"><span>「</span>对称密钥<span>」</span></strong>加密'明文内容B',发送给Server(服务器)</section></li><li><section style=\"margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-size: 14px; font-weight: normal;\">Server使用该<strong style=\"color: #916dd5; font-weight: bold;\"><span>「</span>对称密钥<span>」</span></strong>进行解密消息，得到明文内容B。</section></li></ul>\n<p data-tool=\"mdnice编辑器\" style=\"padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: black; margin: 10px 0px; letter-spacing: 2px; font-size: 14px; word-spacing: 2px;\">接下来考虑一个问题，<strong style=\"color: #916dd5; font-weight: bold;\"><span>「</span>如果公钥被中间人拿到纂改怎么办呢？<span>」</span></strong></p>\n<p data-tool=\"mdnice编辑器\" style=\"padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: black; margin: 10px 0px; letter-spacing: 2px; font-size: 14px; word-spacing: 2px;\">以下图片来自<a href=\"https://juejin.im/user/694547078451278\" style=\"text-decoration: none; word-wrap: break-word; color: #916dd5; font-weight: bolder; border-bottom: 1px solid #916dd5;\">leocoder</a></p>\n<figure data-tool=\"mdnice编辑器\" style=\"margin: 0; margin-top: 10px; margin-bottom: 10px; display: flex; flex-direction: column; justify-content: center; align-items: center;\"><img src=\"https://user-images.githubusercontent.com/34484322/89356414-4cf76c00-d6f0-11ea-9b1a-5d4e4adee530.png\" alt=\"中间人获取公钥\" style=\"max-width: 100%; border-radius: 6px; display: block; margin: 20px auto; object-fit: contain; box-shadow: 2px 4px 7px #999;\"><figcaption style=\"margin-top: 5px; text-align: center; color: #888; display: block; font-size: 13px;\">中间人获取公钥</figcaption></figure>\n<p data-tool=\"mdnice编辑器\" style=\"padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: black; margin: 10px 0px; letter-spacing: 2px; font-size: 14px; word-spacing: 2px;\"><strong style=\"color: #916dd5; font-weight: bold;\"><span>「</span>客户端可能拿到的公钥是假的，解决办法是什么呢？<span>」</span></strong></p>\n<h3 data-tool=\"mdnice编辑器\" style=\"margin-top: 30px; margin-bottom: 15px; padding: 0px; color: black; font-size: 16px; font-weight: bold; text-align: center;\"><span class=\"prefix\" style=\"display: none;\"></span><span class=\"content\" style=\"border-bottom: 2px solid #d89cf6;\">第三方认证</span><span class=\"suffix\" style=\"display: none;\"></span></h3>\n<p data-tool=\"mdnice编辑器\" style=\"padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: black; margin: 10px 0px; letter-spacing: 2px; font-size: 14px; word-spacing: 2px;\">客户端无法识别传回公钥是中间人的，还是服务器的，这是问题的根本，我们是不是可以通过某种规范可以让客户端和服务器都遵循某种约定呢？那就是通过<strong style=\"color: #916dd5; font-weight: bold;\"><span>「</span>第三方认证的方式<span>」</span></strong></p>\n<p data-tool=\"mdnice编辑器\" style=\"padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: black; margin: 10px 0px; letter-spacing: 2px; font-size: 14px; word-spacing: 2px;\">在HTTPS中，通过 <strong style=\"color: #916dd5; font-weight: bold;\"><span>「</span>证书<span>」</span></strong> + <strong style=\"color: #916dd5; font-weight: bold;\"><span>「</span>数字签名<span>」</span></strong>来解决这个问题。</p>\n<figure data-tool=\"mdnice编辑器\" style=\"margin: 0; margin-top: 10px; margin-bottom: 10px; display: flex; flex-direction: column; justify-content: center; align-items: center;\"><img src=\"https://user-images.githubusercontent.com/34484322/89356382-37824200-d6f0-11ea-8c02-630f6362ef91.png\" alt style=\"max-width: 100%; border-radius: 6px; display: block; margin: 20px auto; object-fit: contain; box-shadow: 2px 4px 7px #999;\"></figure>\n<p data-tool=\"mdnice编辑器\" style=\"padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: black; margin: 10px 0px; letter-spacing: 2px; font-size: 14px; word-spacing: 2px;\">这里唯一不同的是，假设对网站信息加密的算法是MD5，通过MD5加密后，<strong style=\"color: #916dd5; font-weight: bold;\"><span>「</span>然后通过第三方机构的私钥再次对其加密，生成数字签名<span>」</span></strong>。</p>\n<p data-tool=\"mdnice编辑器\" style=\"padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: black; margin: 10px 0px; letter-spacing: 2px; font-size: 14px; word-spacing: 2px;\">这样子的话，数字证书包含有两个特别重要的信息👉<strong style=\"color: #916dd5; font-weight: bold;\"><span>「</span>某网站公钥+数字签名<span>」</span></strong></p>\n<p data-tool=\"mdnice编辑器\" style=\"padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: black; margin: 10px 0px; letter-spacing: 2px; font-size: 14px; word-spacing: 2px;\">我们再次假设中间人截取到服务器的公钥后，去替换成自己的公钥，因为有数字签名的存在，这样子客户端验证发现数字签名不匹配，这样子就防止中间人替换公钥的问题。</p>\n<p data-tool=\"mdnice编辑器\" style=\"padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: black; margin: 10px 0px; letter-spacing: 2px; font-size: 14px; word-spacing: 2px;\">那么客户端是如何去对比两者数字签名的呢？</p>\n<ul data-tool=\"mdnice编辑器\" style=\"margin-top: 8px; margin-bottom: 8px; padding-left: 25px; color: black; font-size: 15px; list-style-type: circle;\">\n<li><section style=\"margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-size: 14px; font-weight: normal;\">浏览器会去安装一些比较权威的第三方认证机构的公钥，比如VeriSign、Symantec以及GlobalSign等等。</section></li><li><section style=\"margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-size: 14px; font-weight: normal;\">验证数字签名的时候，会直接从本地拿到相应的第三方的公钥，对私钥加密后的数字签名进行解密得到真正的签名。</section></li><li><section style=\"margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-size: 14px; font-weight: normal;\">然后客户端利用签名生成规则进行签名生成，看两个签名是否匹配，如果匹配认证通过，不匹配则获取证书失败。</section></li></ul>\n<h3 data-tool=\"mdnice编辑器\" style=\"margin-top: 30px; margin-bottom: 15px; padding: 0px; color: black; font-size: 16px; font-weight: bold; text-align: center;\"><span class=\"prefix\" style=\"display: none;\"></span><span class=\"content\" style=\"border-bottom: 2px solid #d89cf6;\">数字签名作用</span><span class=\"suffix\" style=\"display: none;\"></span></h3>\n<p data-tool=\"mdnice编辑器\" style=\"padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: black; margin: 10px 0px; letter-spacing: 2px; font-size: 14px; word-spacing: 2px;\">数字签名：将网站的信息，通过特定的算法加密，比如MD5,加密之后，再通过服务器的私钥进行加密，形成<strong style=\"color: #916dd5; font-weight: bold;\"><span>「</span>加密后的数字签名<span>」</span></strong>。</p>\n<p data-tool=\"mdnice编辑器\" style=\"padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: black; margin: 10px 0px; letter-spacing: 2px; font-size: 14px; word-spacing: 2px;\">第三方认证机构是一个公开的平台，中间人可以去获取。</p>\n<p data-tool=\"mdnice编辑器\" style=\"padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: black; margin: 10px 0px; letter-spacing: 2px; font-size: 14px; word-spacing: 2px;\">如果没有数字签名的话，这样子可以就会有下面情况👇</p>\n<figure data-tool=\"mdnice编辑器\" style=\"margin: 0; margin-top: 10px; margin-bottom: 10px; display: flex; flex-direction: column; justify-content: center; align-items: center;\"><img src=\"https://user-images.githubusercontent.com/34484322/89356394-40731380-d6f0-11ea-9539-46391eedcf47.png\" alt style=\"max-width: 100%; border-radius: 6px; display: block; margin: 20px auto; object-fit: contain; box-shadow: 2px 4px 7px #999;\"></figure>\n<p data-tool=\"mdnice编辑器\" style=\"padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: black; margin: 10px 0px; letter-spacing: 2px; font-size: 14px; word-spacing: 2px;\">从上面我们知道，如果<strong style=\"color: #916dd5; font-weight: bold;\"><span>「</span>只是对网站信息进行第三方机构私钥加密<span>」</span></strong>的话，还是会受到欺骗。</p>\n<p data-tool=\"mdnice编辑器\" style=\"padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: black; margin: 10px 0px; letter-spacing: 2px; font-size: 14px; word-spacing: 2px;\">因为没有认证，所以中间人也向第三方认证机构进行申请，然后拦截后把所有的信息都替换成自己的，客户端仍然可以解密，并且无法判断这是服务器的还是中间人的，最后造成数据泄露。</p>\n<h3 data-tool=\"mdnice编辑器\" style=\"margin-top: 30px; margin-bottom: 15px; padding: 0px; color: black; font-size: 16px; font-weight: bold; text-align: center;\"><span class=\"prefix\" style=\"display: none;\"></span><span class=\"content\" style=\"border-bottom: 2px solid #d89cf6;\"><strong style=\"color: #916dd5; font-weight: bold;\"><span>「</span>总结<span>」</span></strong></span><span class=\"suffix\" style=\"display: none;\"></span></h3>\n<ul data-tool=\"mdnice编辑器\" style=\"margin-top: 8px; margin-bottom: 8px; padding-left: 25px; color: black; font-size: 15px; list-style-type: circle;\">\n<li><section style=\"margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-size: 14px; font-weight: normal;\">HTTPS就是使用SSL/TLS协议进行加密传输</section></li><li><section style=\"margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-size: 14px; font-weight: normal;\">大致流程：客户端拿到服务器的公钥（是正确的），然后客户端随机生成一个<strong style=\"color: #916dd5; font-weight: bold;\"><span>「</span>对称加密的秘钥<span>」</span></strong>，使用<strong style=\"color: #916dd5; font-weight: bold;\"><span>「</span>该公钥<span>」</span></strong>加密，传输给服务端，服务端再通过解密拿到该<strong style=\"color: #916dd5; font-weight: bold;\"><span>「</span>对称秘钥<span>」</span></strong>，后续的所有信息都通过该<strong style=\"color: #916dd5; font-weight: bold;\"><span>「</span>对称秘钥<span>」</span></strong>进行加密解密，完成整个HTTPS的流程。</section></li><li><section style=\"margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-size: 14px; font-weight: normal;\"><strong style=\"color: #916dd5; font-weight: bold;\"><span>「</span>第三方认证<span>」</span></strong>，最重要的是<strong style=\"color: #916dd5; font-weight: bold;\"><span>「</span>数字签名<span>」</span></strong>，避免了获取的公钥是中间人的。</section></li></ul>\n<hr data-tool=\"mdnice编辑器\" style=\"margin: 0; margin-top: 10px; margin-bottom: 10px; height: 1px; padding: 0; border: none; border-top: 2px solid #d9b8fa;\">\n<h2 data-tool=\"mdnice编辑器\" style=\"margin-top: 30px; margin-bottom: 15px; padding: 0px; font-weight: bold; color: black; font-size: 22px; text-align: left; margin: 20px 10px 0px 0px;\"><span class=\"prefix\" style=\"display: none;\"></span><span class=\"content\" style=\"font-size: 18px; font-weight: bold; display: inline-block; padding-left: 10px; border-left: 5px solid #916dd5;\">SSL 连接断开后如何恢复？</span><span class=\"suffix\"></span></h2>\n<p data-tool=\"mdnice编辑器\" style=\"padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: black; margin: 10px 0px; letter-spacing: 2px; font-size: 14px; word-spacing: 2px;\">一共有两种方法来恢复断开的 SSL 连接，一种是使用 session ID，一种是 session ticket。</p>\n<h3 data-tool=\"mdnice编辑器\" style=\"margin-top: 30px; margin-bottom: 15px; padding: 0px; color: black; font-size: 16px; font-weight: bold; text-align: center;\"><span class=\"prefix\" style=\"display: none;\"></span><span class=\"content\" style=\"border-bottom: 2px solid #d89cf6;\">通过session ID</span><span class=\"suffix\" style=\"display: none;\"></span></h3>\n<p data-tool=\"mdnice编辑器\" style=\"padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: black; margin: 10px 0px; letter-spacing: 2px; font-size: 14px; word-spacing: 2px;\">使用 session ID 的方式，每一次的会话都有一个编号，当对话中断后，下一次重新连接时，只要客户端给出这个编号，服务器如果有这个编号的记录，那么双方就可以继续使用以前的秘钥，而不用重新生成一把。目前所有的浏览器都支持这一种方法。但是这种方法有一个缺点是，session ID 只能够存在一台服务器上，如果我们的请求通过负载平衡被转移到了其他的服务器上，那么就无法恢复对话。</p>\n<h3 data-tool=\"mdnice编辑器\" style=\"margin-top: 30px; margin-bottom: 15px; padding: 0px; color: black; font-size: 16px; font-weight: bold; text-align: center;\"><span class=\"prefix\" style=\"display: none;\"></span><span class=\"content\" style=\"border-bottom: 2px solid #d89cf6;\">通过session ticket</span><span class=\"suffix\" style=\"display: none;\"></span></h3>\n<p data-tool=\"mdnice编辑器\" style=\"padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: black; margin: 10px 0px; letter-spacing: 2px; font-size: 14px; word-spacing: 2px;\">另一种方式是 session ticket 的方式，session ticket 是服务器在上一次对话中发送给客户的，这个 ticket 是加密的，只有服务器能够解密，里面包含了本次会话的信息，比如对话秘钥和加密方法等。这样不管我们的请求是否转移到其他的服务器上，当服务器将 ticket 解密以后，就能够获取上次对话的信息，就不用重新生成对话秘钥了。</p>\n<h2 data-tool=\"mdnice编辑器\" style=\"margin-top: 30px; margin-bottom: 15px; padding: 0px; font-weight: bold; color: black; font-size: 22px; text-align: left; margin: 20px 10px 0px 0px;\"><span class=\"prefix\" style=\"display: none;\"></span><span class=\"content\" style=\"font-size: 18px; font-weight: bold; display: inline-block; padding-left: 10px; border-left: 5px solid #916dd5;\">短轮询、长轮询和 WebSocket 间的区别？</span><span class=\"suffix\"></span></h2>\n<h3 data-tool=\"mdnice编辑器\" style=\"margin-top: 30px; margin-bottom: 15px; padding: 0px; color: black; font-size: 16px; font-weight: bold; text-align: center;\"><span class=\"prefix\" style=\"display: none;\"></span><span class=\"content\" style=\"border-bottom: 2px solid #d89cf6;\">短轮询</span><span class=\"suffix\" style=\"display: none;\"></span></h3>\n<p data-tool=\"mdnice编辑器\" style=\"padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: black; margin: 10px 0px; letter-spacing: 2px; font-size: 14px; word-spacing: 2px;\">短轮询的基本思路:</p>\n<ul data-tool=\"mdnice编辑器\" style=\"margin-top: 8px; margin-bottom: 8px; padding-left: 25px; color: black; font-size: 15px; list-style-type: circle;\">\n<li><section style=\"margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-size: 14px; font-weight: normal;\">浏览器每隔一段时间向浏览器发送 http 请求，服务器端在收到请求后，不论是否有数据更新，都直接进行\n响应。</section></li><li><section style=\"margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-size: 14px; font-weight: normal;\">这种方式实现的即时通信，本质上还是浏览器发送请求，服务器接受请求的一个过程，通过让客户端不断的进行请求，使得客户端能够模拟实时地收到服务器端的数据的变化。</section></li></ul>\n<p data-tool=\"mdnice编辑器\" style=\"padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: black; margin: 10px 0px; letter-spacing: 2px; font-size: 14px; word-spacing: 2px;\">优缺点👇</p>\n<ul data-tool=\"mdnice编辑器\" style=\"margin-top: 8px; margin-bottom: 8px; padding-left: 25px; color: black; font-size: 15px; list-style-type: circle;\">\n<li><section style=\"margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-size: 14px; font-weight: normal;\"><p style=\"padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: black; margin: 10px 0px; letter-spacing: 2px; font-size: 14px; word-spacing: 2px;\">优点是比较简单，易于理解。</p>\n</section></li><li><section style=\"margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-size: 14px; font-weight: normal;\"><p style=\"padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: black; margin: 10px 0px; letter-spacing: 2px; font-size: 14px; word-spacing: 2px;\">缺点是这种方式由于需要不断的建立 http 连接，严重浪费了服务器端和客户端的资源。当用户增加时，服务器端的压力就会变大，这是很不合理的。</p>\n</section></li></ul>\n<h3 data-tool=\"mdnice编辑器\" style=\"margin-top: 30px; margin-bottom: 15px; padding: 0px; color: black; font-size: 16px; font-weight: bold; text-align: center;\"><span class=\"prefix\" style=\"display: none;\"></span><span class=\"content\" style=\"border-bottom: 2px solid #d89cf6;\">长轮询</span><span class=\"suffix\" style=\"display: none;\"></span></h3>\n<p data-tool=\"mdnice编辑器\" style=\"padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: black; margin: 10px 0px; letter-spacing: 2px; font-size: 14px; word-spacing: 2px;\">长轮询的基本思路:</p>\n<ul data-tool=\"mdnice编辑器\" style=\"margin-top: 8px; margin-bottom: 8px; padding-left: 25px; color: black; font-size: 15px; list-style-type: circle;\">\n<li><section style=\"margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-size: 14px; font-weight: normal;\"><p style=\"padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: black; margin: 10px 0px; letter-spacing: 2px; font-size: 14px; word-spacing: 2px;\">首先由客户端向服务器发起请求，当服务器收到客户端发来的请求后，服务器端不会直接进行响应，而是先将\n这个请求挂起，然后判断服务器端数据是否有更新。</p>\n</section></li><li><section style=\"margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-size: 14px; font-weight: normal;\"><p style=\"padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: black; margin: 10px 0px; letter-spacing: 2px; font-size: 14px; word-spacing: 2px;\">如果有更新，则进行响应，如果一直没有数据，则到达一定的时间限制才返回。客户端 JavaScript 响应处理函数会在处理完服务器返回的信息后，再次发出请求，重新建立连接。</p>\n</section></li></ul>\n<p data-tool=\"mdnice编辑器\" style=\"padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: black; margin: 10px 0px; letter-spacing: 2px; font-size: 14px; word-spacing: 2px;\">优缺点👇</p>\n<ul data-tool=\"mdnice编辑器\" style=\"margin-top: 8px; margin-bottom: 8px; padding-left: 25px; color: black; font-size: 15px; list-style-type: circle;\">\n<li><section style=\"margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-size: 14px; font-weight: normal;\"><p style=\"padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: black; margin: 10px 0px; letter-spacing: 2px; font-size: 14px; word-spacing: 2px;\">长轮询和短轮询比起来，它的优点是<strong style=\"color: #916dd5; font-weight: bold;\"><span>「</span>明显减少了很多不必要的 http 请求次数<span>」</span></strong>，相比之下节约了资源。</p>\n</section></li><li><section style=\"margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-size: 14px; font-weight: normal;\"><p style=\"padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: black; margin: 10px 0px; letter-spacing: 2px; font-size: 14px; word-spacing: 2px;\">长轮询的缺点在于，连接挂起也会导致资源的浪费。</p>\n</section></li></ul>\n<h3 data-tool=\"mdnice编辑器\" style=\"margin-top: 30px; margin-bottom: 15px; padding: 0px; color: black; font-size: 16px; font-weight: bold; text-align: center;\"><span class=\"prefix\" style=\"display: none;\"></span><span class=\"content\" style=\"border-bottom: 2px solid #d89cf6;\">WebSocket</span><span class=\"suffix\" style=\"display: none;\"></span></h3>\n<ul data-tool=\"mdnice编辑器\" style=\"margin-top: 8px; margin-bottom: 8px; padding-left: 25px; color: black; font-size: 15px; list-style-type: circle;\">\n<li><section style=\"margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-size: 14px; font-weight: normal;\">WebSocket 是 Html5 定义的一个新协议，与传统的 http 协议不同，该协议允许由服务器主动的向客户端推送信息。</section></li><li><section style=\"margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-size: 14px; font-weight: normal;\">使用 WebSocket 协议的缺点是在服务器端的配置比较复杂。WebSocket 是一个全双工的协议，也就是通信双方是平等的，可以相互发送消息。</section></li></ul>\n<h2 data-tool=\"mdnice编辑器\" style=\"margin-top: 30px; margin-bottom: 15px; padding: 0px; font-weight: bold; color: black; font-size: 22px; text-align: left; margin: 20px 10px 0px 0px;\"><span class=\"prefix\" style=\"display: none;\"></span><span class=\"content\" style=\"font-size: 18px; font-weight: bold; display: inline-block; padding-left: 10px; border-left: 5px solid #916dd5;\">说一说正向代理和反向代理</span><span class=\"suffix\"></span></h2>\n<h3 data-tool=\"mdnice编辑器\" style=\"margin-top: 30px; margin-bottom: 15px; padding: 0px; color: black; font-size: 16px; font-weight: bold; text-align: center;\"><span class=\"prefix\" style=\"display: none;\"></span><span class=\"content\" style=\"border-bottom: 2px solid #d89cf6;\">正向代理</span><span class=\"suffix\" style=\"display: none;\"></span></h3>\n<p data-tool=\"mdnice编辑器\" style=\"padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: black; margin: 10px 0px; letter-spacing: 2px; font-size: 14px; word-spacing: 2px;\">我们常说的代理也就是指正向代理，正向代理的过程，它隐藏了真实的请求客户端，服务端不知道真实的客户端是谁，客户端请求的服务都被代理服务器代替来请求。</p>\n<h3 data-tool=\"mdnice编辑器\" style=\"margin-top: 30px; margin-bottom: 15px; padding: 0px; color: black; font-size: 16px; font-weight: bold; text-align: center;\"><span class=\"prefix\" style=\"display: none;\"></span><span class=\"content\" style=\"border-bottom: 2px solid #d89cf6;\">反向代理</span><span class=\"suffix\" style=\"display: none;\"></span></h3>\n<p data-tool=\"mdnice编辑器\" style=\"padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: black; margin: 10px 0px; letter-spacing: 2px; font-size: 14px; word-spacing: 2px;\">这种代理模式下，它隐藏了真实的服务端，当我们向一个网站发起请求的时候，背后可能有成千上万台服务器为我们服务，具体是哪一台，我们不清楚，我们只需要知道反向代理服务器是谁就行，而且反向代理服务器会帮我们把请求转发到真实的服务器那里去，一般而言反向代理服务器一般用来实现负载平衡。</p>\n<h2 data-tool=\"mdnice编辑器\" style=\"margin-top: 30px; margin-bottom: 15px; padding: 0px; font-weight: bold; color: black; font-size: 22px; text-align: left; margin: 20px 10px 0px 0px;\"><span class=\"prefix\" style=\"display: none;\"></span><span class=\"content\" style=\"font-size: 18px; font-weight: bold; display: inline-block; padding-left: 10px; border-left: 5px solid #916dd5;\">负载平衡的两种实现方式？</span><span class=\"suffix\"></span></h2>\n<ul data-tool=\"mdnice编辑器\" style=\"margin-top: 8px; margin-bottom: 8px; padding-left: 25px; color: black; font-size: 15px; list-style-type: circle;\">\n<li><section style=\"margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-size: 14px; font-weight: normal;\"><p style=\"padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: black; margin: 10px 0px; letter-spacing: 2px; font-size: 14px; word-spacing: 2px;\">一种是使用反向代理的方式，用户的请求都发送到反向代理服务上，然后由反向代理服务器来转发请求到真实的服务器上，以此来实现集群的负载平衡。</p>\n</section></li><li><section style=\"margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-size: 14px; font-weight: normal;\"><p style=\"padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: black; margin: 10px 0px; letter-spacing: 2px; font-size: 14px; word-spacing: 2px;\">另一种是 DNS 的方式，DNS 可以用于在冗余的服务器上实现负载平衡。因为现在一般的大型网站使用多台服务器提供服务，因此一个域名可能会对应多个服务器地址。当用户向网站域名请求的时候，DNS 服务器返回这个域名所对应的服务器 IP 地址的集合，但在每个回答中，会循环这些 IP 地址的顺序，用户一般会选择排在前面的地址发送请求。以此将用户的请求均衡的分配到各个不同的服务器上，这样来实现负载均衡。这种方式有一个缺点就是，由于 DNS 服务器中存在缓存，所以有可能一个服务器出现故障后，域名解析仍然返回的是那个 IP 地址，就会造成访问的问题。</p>\n</section></li></ul>\n<h2 data-tool=\"mdnice编辑器\" style=\"margin-top: 30px; margin-bottom: 15px; padding: 0px; font-weight: bold; color: black; font-size: 22px; text-align: left; margin: 20px 10px 0px 0px;\"><span class=\"prefix\" style=\"display: none;\"></span><span class=\"content\" style=\"font-size: 18px; font-weight: bold; display: inline-block; padding-left: 10px; border-left: 5px solid #916dd5;\">参考</span><span class=\"suffix\"></span></h2>\n<ul data-tool=\"mdnice编辑器\" style=\"margin-top: 8px; margin-bottom: 8px; padding-left: 25px; color: black; font-size: 15px; list-style-type: circle;\">\n<li><section style=\"margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-size: 14px; font-weight: normal;\"><a href=\"https://zhuanlan.zhihu.com/p/25028045\" style=\"text-decoration: none; word-wrap: break-word; color: #916dd5; font-weight: bolder; border-bottom: 1px solid #916dd5;\">听说『99% 的人都理解错了 HTTP 中 GET 与 POST 的区别』？？</a></section></li><li><section style=\"margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-size: 14px; font-weight: normal;\"><a href=\"https://harttle.land/2015/08/15/http-status-code.html#header-11\" style=\"text-decoration: none; word-wrap: break-word; color: #916dd5; font-weight: bolder; border-bottom: 1px solid #916dd5;\">如何理解HTTP响应的状态码？</a></section></li><li><section style=\"margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-size: 14px; font-weight: normal;\"><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Status\" style=\"text-decoration: none; word-wrap: break-word; color: #916dd5; font-weight: bolder; border-bottom: 1px solid #916dd5;\">HTTP 响应代码 | MDN</a></section></li><li><section style=\"margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-size: 14px; font-weight: normal;\"><a href=\"https://juejin.im/post/5eb7f811f265da7bbc7cc5bd\" style=\"text-decoration: none; word-wrap: break-word; color: #916dd5; font-weight: bolder; border-bottom: 1px solid #916dd5;\">图解 HTTP 缓存</a></section></li><li><section style=\"margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-size: 14px; font-weight: normal;\"><a href=\"https://juejin.im/post/5e1870736fb9a02fef3a5dcb#heading-40\" style=\"text-decoration: none; word-wrap: break-word; color: #916dd5; font-weight: bolder; border-bottom: 1px solid #916dd5;\">看完这篇HTTP，跟面试官扯皮就没问题了</a></section></li><li><section style=\"margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-size: 14px; font-weight: normal;\"><a href=\"https://lotabout.me/2019/Things-about-keepalive/\" style=\"text-decoration: none; word-wrap: break-word; color: #916dd5; font-weight: bolder; border-bottom: 1px solid #916dd5;\">HTTP keep-alive 二三事</a></section></li><li><section style=\"margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-size: 14px; font-weight: normal;\"><a href=\"https://juejin.im/post/6844903830916694030\" style=\"text-decoration: none; word-wrap: break-word; color: #916dd5; font-weight: bolder; border-bottom: 1px solid #916dd5;\">深入理解HTTPS工作原理</a></section></li><li><section style=\"margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-size: 14px; font-weight: normal;\"><a href=\"https://juejin.im/post/6844903608421449742\" style=\"text-decoration: none; word-wrap: break-word; color: #916dd5; font-weight: bolder; border-bottom: 1px solid #916dd5;\">看图学HTTPS</a></section></li><li><section style=\"margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-size: 14px; font-weight: normal;\"><a href=\"https://cloud.tencent.com/developer/article/1076547\" style=\"text-decoration: none; word-wrap: break-word; color: #916dd5; font-weight: bolder; border-bottom: 1px solid #916dd5;\">轮询、长轮询、长连接、websocket</a></section></li><li><section style=\"margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-size: 14px; font-weight: normal;\"><a href=\"http://www.ruanyifeng.com/blog/2016/06/dns.html\" style=\"text-decoration: none; word-wrap: break-word; color: #916dd5; font-weight: bolder; border-bottom: 1px solid #916dd5;\">DNS 原理入门</a></section></li></ul>\n<h2 data-tool=\"mdnice编辑器\" style=\"margin-top: 30px; margin-bottom: 15px; padding: 0px; font-weight: bold; color: black; font-size: 22px; text-align: left; margin: 20px 10px 0px 0px;\"><span class=\"prefix\" style=\"display: none;\"></span><span class=\"content\" style=\"font-size: 18px; font-weight: bold; display: inline-block; padding-left: 10px; border-left: 5px solid #916dd5;\"><strong style=\"color: #916dd5; font-weight: bold;\"><span>「</span>❤️ 感谢大家<span>」</span></strong></span><span class=\"suffix\"></span></h2>\n<p data-tool=\"mdnice编辑器\" style=\"padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: black; margin: 10px 0px; letter-spacing: 2px; font-size: 14px; word-spacing: 2px;\">如果你觉得这篇内容对你挺有有帮助的话：</p>\n<ol data-tool=\"mdnice编辑器\" style=\"margin-top: 8px; margin-bottom: 8px; padding-left: 25px; color: black; list-style-type: decimal; font-size: 15px;\">\n<li><section style=\"margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-size: 14px; font-weight: normal;\">点赞支持下吧，让更多的人也能看到这篇内容（收藏不点赞，都是耍流氓 -_-）</section></li><li><section style=\"margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-size: 14px; font-weight: normal;\">欢迎在留言区与我分享你的想法，也欢迎你在留言区记录你的思考过程。</section></li><li><section style=\"margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-size: 14px; font-weight: normal;\">觉得不错的话，也可以阅读TianTian近期梳理的文章（感谢掘友的鼓励与支持🌹🌹🌹）：\n<ul style=\"margin-top: 8px; margin-bottom: 8px; padding-left: 25px; color: black; font-size: 15px; list-style-type: circle;\">\n<li><section style=\"margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-size: 14px; font-weight: normal;\"><a href=\"https://juejin.im/post/6854573215830933512\" style=\"text-decoration: none; word-wrap: break-word; color: #916dd5; font-weight: bolder; border-bottom: 1px solid #916dd5;\">「一劳永逸」送你21道高频JavaScript手写面试题</a>(420+👍)</section></li><li><section style=\"margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-size: 14px; font-weight: normal;\"><a href=\"https://juejin.im/post/6854573215830933512\" style=\"text-decoration: none; word-wrap: break-word; color: #916dd5; font-weight: bolder; border-bottom: 1px solid #916dd5;\">「查缺补漏」送你18道浏览器面试题</a>(680+👍)</section></li><li><section style=\"margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-size: 14px; font-weight: normal;\"><a href=\"https://juejin.im/post/6854573211443544078\" style=\"text-decoration: none; word-wrap: break-word; color: #916dd5; font-weight: bolder; border-bottom: 1px solid #916dd5;\">「查缺补漏」送你 54 道 JavaScript 面试题</a>(580+👍)</section></li><li><section style=\"margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-size: 14px; font-weight: normal;\"><a href=\"https://juejin.im/post/6850418120755494925\" style=\"text-decoration: none; word-wrap: break-word; color: #916dd5; font-weight: bolder; border-bottom: 1px solid #916dd5;\">「算法与数据结构」链表的9个基本操作</a>(160+👍)</section></li><li><section style=\"margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-size: 14px; font-weight: normal;\"><a href=\"https://juejin.im/post/6850037261518684167\" style=\"text-decoration: none; word-wrap: break-word; color: #916dd5; font-weight: bolder; border-bottom: 1px solid #916dd5;\">「小技巧」写给男同胞的Chrome DevTools调试小技巧，效率🚀🚀🚀</a>(210+👍)</section></li><li><section style=\"margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-size: 14px; font-weight: normal;\"><a href=\"https://juejin.im/post/6847902222349500430\" style=\"text-decoration: none; word-wrap: break-word; color: #916dd5; font-weight: bolder; border-bottom: 1px solid #916dd5;\">「浏览器工作原理」写给女友的秘籍-渲染流程篇（1.1W+字）</a>(230+👍)</section></li><li><section style=\"margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-size: 14px; font-weight: normal;\"><a href=\"https://juejin.im/post/6846687601806557192\" style=\"text-decoration: none; word-wrap: break-word; color: #916dd5; font-weight: bolder; border-bottom: 1px solid #916dd5;\">「数组方法」从详细操作js数组到浅析v8中array.js</a>(220+👍)</section></li><li><section style=\"margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-size: 14px; font-weight: normal;\"><a href=\"https://juejin.im/post/6846687590540640263\" style=\"text-decoration: none; word-wrap: break-word; color: #916dd5; font-weight: bolder; border-bottom: 1px solid #916dd5;\">「浏览器工作原理」写给女友的秘籍-浏览器组成&amp;网络请求篇（1.2W字)</a>(240+👍)</section></li></ul>\n</section></li></ol>\n</section>", "user_name": "TianTianUp", "description": "个人微信：DayDay2021", "got_view_count": 229240, "category_name": "前端", "ctime": 1457483942}
{"tag_name": "前端", "concern_user_count": 455667, "user_id": "2295436007711214", "title": "一文理解Mac环境配置问题", "mark_content": "## 前言\n作为开发者，每当新安装某个软件，很容易会遇到电脑环境变量配置相关的问题，大部分情况只要按照软件的**readme**文档进行配置即可，如果有什么问题就google或者百度一下，但是作为开发者怎么能允许这么高频且可能长时间伴随我们的东西是一个黑盒呢！如果你对这块内容一知半解，**本文会从比较基本的指令说起**不妨花几分钟阅读一下本文。\n\n\n\n## 常用命令\n### MacOS\n**MacOS**本身是基于 **Unix内核** 的图形化操作系统，而 **linux** 是大佬**Linus**为了人们用到免费的类unix系统而开发，所以本质上**macOS**和**Linux**是同根同源的（可以理解为chrome和edge都是用chromium内核但是在外面套的壳不一样）。  \n所以两者大部分特性和命令都是相通的。同时mac开发环境认自带ruby、php、python2、bash等环境(以前还自带java，后来貌似某个版本给去掉了)。\n\n先来了解一下文件操作最基础常用的指令  \n\n| 命令 | 功能| 举例 |\n| :----:| :----: |:----: |\n| cd | 前往某目录 | cd ~/Desktop|\n| ls | 显示当前目录的内容 | ls |\n| ls -la | 详细显示当前目录内容（包含权限及隐藏文件） |ls -la|\n| pwd | 显示当前路径 |pwd|\n| cat | 查看某文件内容 |cat ./file.txt|\n| vim | 使用vim编辑某文件内容 | vim ./file.txt|\n| touch | 创建或修改文件 |touch ./test.txt|\n| rm | 删除文件 | rm ./file.txt|\n| rm -rf | 删除文件夹内容 |rm -rf ./dir|\n| mkdir | 创建文件夹 | mkdir dir|\n| rmdir | 删除文件夹 | rmdir ./dir|\n| mv | 移动或修改文件名 |mv file0.txt file1.txt|\n| mvdir | 移动或修改文件名 |mvdir dir0 dir1|\n| man | 查看指令 | man sudo|\n| sudo | 系统管理者的身份执行指令 | sudo vi /private/etc/hosts|\n\n### 常用操作指令\n我们通过几种不同的安装 **Homebrew** 的方式来分析我们在安装不同软件时常用的一些指令\n\n#### 通过ruby安装\n```\n/usr/bin/ruby -e \"$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)\"\n```\n先来看这条指令分两块分别是\n- ```/usr/bin/ruby -e```  \nruby是一门开源的动态编程语言，我作为一个前端程序员使用的比较少，但是这个命令我经常看到意思就是**使用ruby环境运行， -e 代表把后面的字符串当脚本执行**\n\n- ```\"$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)\"```  \n先来看 **$()** 的作用，```/usr/bin/ruby -e \"$(curl -fsSL https://xxx)\"```这条指令执行了两个命令先是将```\"$(curl -fsSL https://xxx)```的结果返回，再用```/usr/bin/ruby -e```执行之前命令返回的结果，那么 **$()** 的作用就是先完成 **$()** 中的命令行，然后将其结果替换出来。  \n再来说```curl -fsSL https://xxx```的作用，curl就是发出网络请求，然后获取数据的工具，而后面的```-fsSL```则是对应的一些参数其中```-L```是自动跳转重定向的页面 ```-fsS```则是对一些情况进行静默处理的，具体的内容大家可以自行找一下 **curl** 的文档，我就不想洗展开了。\n\n\n#### 通过bash或者sh安装\n```\n/bin/bash -c \"$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install.sh)\"\n```\n\n```\nsh -c \"$(curl -fsSL https://raw.github.com/robbyrussell/oh-my-zsh/master/tools/install.sh)\"\n```\n- **Bourne shell (sh)**  \nUNIX 最初使用，且在每种 UNIX 上都可以使用。\n在 shell 编程方面相当优秀，但在处理与用户的交互方面做得不如其他几种shell。（mac上用的的sh命令并不是这个，千万别弄混）\n- **bash(Bourne-Again Shell)**  \nLinux/MacOs 操作系统缺省的 shell。  \n是 Bourne shell 的扩展，与 Bourne shell 完全向后兼容。  \n在Bourne shell 的基础上增加、增强了很多特性。  \n可以提供如命令补全、命令编辑和命令历史表等功能。  \n有灵活和强大的编程接口，同时又有很友好的用户界面。  \n而mac中无论是**sh** 还是 **bash** 指的都是 **bash**\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/01334b2da1db49f580c0762fbe8b2d03~tplv-k3u1fbpfcp-zoom-1.image)\n**sh** 跟**bash**的区别，实际上是bash有没开启POSIX模式的区别\n简单说，sh是bash的一种特殊的模式，sh就是开启了POSIX标准的bash， ```sh``` 相当于 ```/bin/bash --posix```。\n\n\n## 常用配置\n### 软件配置\n接下来说一下我们通常使用的软件配置，绝大部分软件的配置都是存放在根目录的，只是因为在mac中以 `.` 为前缀做为隐藏文件存在。我们通过下面的指令看一下\n```\nls -la ~\n```\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a3241f5133a04e1fb574cbf6a8e84261~tplv-k3u1fbpfcp-zoom-1.image)\n我们对一些软件的配置修改本质上其实就是改这里面的文件，用git的配置作为例子(我先将.gitconfig删除了)  \n正常我们开始配置配置都会输入username 和 email\n```\ngit config --global user.name 'yourname'\ngit config --global user.name 'youremail'\n```\n![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d5963763159d421488f87a0a5db4a255~tplv-k3u1fbpfcp-zoom-1.image)\n正常我们想用使用git还要生成ssh秘钥\n```\nssh-keygen -t rsa -C 'youreamail'\n```\n那这个ssh就生成在了.ssh中\n![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5f02f176167a4d9f898c1674afd13aa4~tplv-k3u1fbpfcp-zoom-1.image)\nid_rsa.pub 就是你的公钥,id_rsa就是你的私钥，将公钥粘贴到指定的位置即可了。（私钥不要轻易泄露，想深入了解的可以看一下非对称加密的原理）\n\n正常来说你的绝大部分软件配置都是```~/.xx```文件或文件夹，所以配置遇到问题不要慌，直接找到配置文件看一下。  \n而通常配置一般分为3个等级，一般执行的权重按照 本地配置>用户配置>系统配置。还是用git举例刚才的命令中我用了--global代表的就是用户配置。下面是三种配置级别\n```\ngit config --system --list // 查看系统config\n\ngit config --global  --list // 查看当前用户（global）配置：\n\ngit config --local  --list // 查看当前仓库配置信息\n\n```\n--global 的情况已经说过了，--local 的话大家在git项目中通常都有一个.git文件 --local就是查看里面的配置信息，最后system我们执行一下，告诉我没有找到系统的配置文件，因为我没有配置过，所以不会有默认的。\n\n![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b1aaa16f54cc4cfdb8899972c26b05a8~tplv-k3u1fbpfcp-zoom-1.image)\n\n但是我们可以看到路径上有一个`/etc/` 通常很多系统级的配置文件会存在里面，有时候大家看到一些解决办法的时候往```/etc/``` 路径中修改或增加配置信息要注意点，本身权重很低里面的配置也很容易被global基本的配置覆盖。\n\n（如果你想将配置保存起来快速的用到其他电脑，只要找到对应的配置文件保存起来，替换到其他电脑即可）\n\n## 环境配置\n在mac环境下默认都会用到以下的几个配置  \n系统级别，对系统所有用户都生效\n```\n/etc/profile\n/etc/paths\n```\n- `/etc/profile`  第一个加载  \n涉及系统的环境，即环境变量相关。这里修改会对所有用户起作用,最先启动的就是这个命令，当然也是权重最低的，有时候遇到配置问题按照网上的修改这个文件却不生效可能就是权重不够。（没事不要改这个文件，终端的配置尽量放在一个地方\n\n- `/etc/paths` 第二个加载  \n全局环境变量配置文件,本身没有什么语法，一行为一条不接受注释之类的，没啥事也别改。\n![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ddb6ab08d7264d0083f0ce1560da6bfb~tplv-k3u1fbpfcp-zoom-1.image)\n\n用户级别\n```\n~/.bash_profile  // ~/.bash_profile -> ~/.bash_login -> ~/.profile -> ~/.bashrc\n~/.zshrc  // 这个并不是系统自带的而是oh-my-zsh自带的\n```\n\n先来说.bash_profile，正常在mac下读完系统的变量之后就会读取`.bash_profile`，如果找到了`.bash_profile`也就不会读后面三个文件了（linux系统有所不同）。所以，有时候解决某些配置问题时，可能人家给的答案并不是针对mac系统，**遇到配置问题需要修改配置，在mac系统下老老实实的用.bash_profile配置就好了**。\n\n再来说一下 `.zshrc`，这个并不是系统自带的，我们通常使用终端本质上是使用一个sh环境，系统自带的有时候不好用我们通常都会自己装一个，最常见的就是**oh-my-zsh**，之前提到了**系统自带的sh环境是bash**，那么装了**oh-my-zsh**之后我们启动的自然就是**zsh**，所以装了**oh-my-zsh**的用户启动的自然就是`~/.zshrc`也就不会读取`~/.bash_profile`文件了，不过一般我们通常都会在`./zshrc`文件的最后加一句`source ~/.bash_profile`来读一遍**bash**的配置。\n\n有的同学可能会遇到这样的问题，安装了某软件配置了环境变量在**~/.bash_profile** 中可是每次启动终端都要执行一次source命令还不知道为什么，如果你安装了**zsh**那么你要在.zshrc中添加 `source ~/.bash_profile`就好了。**如果我说的你能理解，那么配置方面的大部分问题应该都能搞定了**。\n\n最后说一下语法问题  \n本身这些配置文件都是遵守shell语法的，如果懒得看，我这边把我的.zshrc配置本身的注释去掉，给你解读一下。\n``` ruby\n\n# shell中export为导出变量的意思 下面中 $ZSH 就是使用这个变量\n# 同时我们可以在命令行 通过echo $XXX 来查看export过的信息\nexport ZSH=$HOME/.oh-my-zsh\n\n# 主题设置\nZSH_THEME=\"ys\"\n\n# 插件使用\nplugins=(git npm osx web-search zsh-syntax-highlighting sudo wd history last-working-dir)\n\n# 执行一下oh-my-zsh的配置\nsource $ZSH/oh-my-zsh.sh\n\n# 命令别名，可以在命令行通过定义好的命令 执行命令串 比如我再命令行使用pwc 就可以复制当前地址\nalias pwc=\"pwd | pbcopy; pwd\"\nalias p=\"projj find\"\n\n# 方法也是可以定义命令 可以直接调用方法名 执行里面的命令\ncdtmp() {\n   cd $(mktemp -d $HOME/Tmp/${1:-xu}-XXXX);\n}\n\nmkdir() {\n command mkdir -p \"$@\" && eval cd \"\\\"\\$$#\\\"\";\n}\n\n\n# 环境变量设置 shell export 出去的名称会被记住，比如CLASS_PATH就可能被外面的某个地方调用\n# 而环境变量的拼接一般就是export PATH = \"$PATH:XXX\"\n\nexport PATH=\"~/.bin:$PATH\"\n\nexport JAVA_HOME=\"/Library/Java/JavaVirtualMachines/openjdk-12.0.1.jdk/Contents/Home\"\nexport CLASS_PATH=\"$JAVA_HOME/lib\"\nexport PATH=\"$PATH:$JAVA_HOME/bin\"\n\n\nexport NVM_DIR=\"$HOME/.nvm\"\nexport PATH=\"$NVM_DIR/versions/node/v10.16.0/bin:$PATH\"\n\nnvm(){\n   unfunction \"nvm\"\n   [ -s \"$NVM_DIR/nvm.sh\" ] && \\. \"$NVM_DIR/nvm.sh\"   # This loads nvm\n   [ -s \"$NVM_DIR/bash_completion\" ] && \\. \"$NVM_DIR/bash_completion\"  # This loads nvm bash_↷\n\n   nvm \"$@\"\n}\n\nsource $HOME/.bash_profile\n```\n\n\n\n## 结束语\n本身这种环境配置并不复杂，只是人会懒得考虑能用就行，但是作为开发者这个可以必备技能，如果我写的有错误的地方，或者我写的不清楚导致您有疑问的地方，欢迎评论区讨论，如果对您有帮助希望您点个赞支持一下哈。", "user_name": "暮桥", "description": "", "got_view_count": 17935, "category_name": "前端", "ctime": 1457483942}
{"tag_name": "前端", "concern_user_count": 455667, "user_id": "712139267650141", "title": "RxJS 源码解析（五）—— Operator III", "mark_content": "> DevUI是一支兼具设计视角和工程视角的团队，服务于华为云[DevCloud](https://www.huaweicloud.com/devcloud/)平台和华为内部数个中后台系统，服务于设计师和前端工程师。<br>\n官方网站：[devui.design](https://devui.design/)<br>\nNg组件库：[ng-devui](https://github.com/DevCloudFE/ng-devui)（欢迎Star）<br>\n官方交流群：添加DevUI小助手（微信号：devui-official）<br>\nDevUIHelper插件：DevUIHelper-LSP（欢迎Star）\n\n## 引言\n\n在本文开始之前，先定义一些自定义术语，方便阅读。\n\n- 顶流：调用了操作符的流。\n- 上游流：操作符的内部订阅器所订阅的流。\n- 下游流：由操作符的内部订阅器管理的流。\n- 下游订阅：订阅了操作符生成的流的订阅者。\n\n\n\n在上一篇中，我描述了 OuterSubscriber 和 InnerSubscriber 的作用，并将几个 Join Creation Operator 的源码解析了一遍。下面，我们将进入的是 Transformation Operator 的源码分析。\n\n在知道了 OuterSubscriber 和 InnerSubscriber 是一种通过委托模式实现管理下游流订阅的方法后，我发现其实这种实现技巧用于很多的 operators。那么本篇及下一篇将会介绍更多这种类似的设计。\n\n\n\n（PS：为了方便描述，我拿了官网的相关的图片，时序图的阅读顺序是从左到右。）\n\n\n\n## 基础映射\n\n### map \n\n![](http://zcating.gitee.io/imagebed/rxjs_alz/map.png)\n\nmap 是最为基础的映射，他将上游流的值经过运算，转发给下游订阅。这部分源码不是很复杂，实际上就是做了一层转发。\n\n```typescript\nprotected _next(value: T) {\n  let result: R;\n  try {\n    result = this.project.call(this.thisArg, value, this.count++);\n  } catch (err) {\n    this.destination.error(err);\n    return;\n  }\n  this.destination.next(result);\n}\n```\n\n\n\n\n\n### scan\n\n![](http://zcating.gitee.io/imagebed/rxjs_alz/scan.png)\n\nScan 和 的作用跟 reduce 一样，传入一个函数把一组数据打平，但是跟 reduce 不一样的点在于，每一次结合完毕都会立刻返回结果。\n\n```typescript\nconst clicks1 = fromEvent(document, 'click');\nconst ones1 = clicks.pipe(mapTo(1));\nconst seed1 = 0;\nconst count1 = ones.pipe(\n  // 输入的是返回任意值的函数\n  scan((acc, one) => acc + one, seed)\n);\ncount.subscribe(x => console.log(x));\n\n```\n\n\n\n这部分的实现同样也不是很复杂，在拿到上游流数据后，使用 `accumulator` 对数据进行累加操作。\n\n```typescript\nprotected _next(value: T): void {\n  // 需要判断是否带有初始值。\n  if (!this.hasSeed) {\n    this.seed = value;\n    this.hasSeed = true;\n    this.destination.next(value);\n  } else {\n  \treturn this._tryNext(value);\n\t}\n}\n\nprivate _tryNext(value: T): void {\n  const index = this.index++;\n  let result: any;\n  try {\n  \t// 计算结果\n    result = this.accumulator(<R>this.seed, value, index);\n  } catch (err) {\n    this.destination.error(err);\n  }\n\t// 保存，以备下次使用\n  this.seed = result;\n  this.destination.next(result);\n}\n```\n\n\n\n\n\n## 五种基础复合映射\n\n*所谓复合映射，意思就是这些操作符接收的参数是一个带有上游流数据作为参数并返回 Observable 的函数，同时把其中的订阅数据转发给下游订阅。*\n\nmergeMap，switchMap，exhaustMap，concatMap，mergeScan 是五种复合映射操作符，它使得上游流的数据可以传递给下游流，并交由其处理。 concatMap 和 mergeScan 是 mergeMap 的一种特殊情况，所以我们只需要关注剩余的三种。\n\n mergeMap，switchMap，exhaustMap，这三种操作符的源码结构分为这三个部分：\n\n- 通过 lift 操作，将原有的流映射成新的流。\n- 实现 Operator 接口，通过 call 返回一个 Subscriber。\n- 通过继承 OuterSubscriber 实现这个 Subscriber。\n\n其中，前两个部分都拥有非常类似的结构，都是通过这种样板代码来进行编写。\n\n```typescript\nexport function someMap<T, R, O extends ObservableInput<any>>(\n  project: (value: T, index: number) => O,\n): OperatorFunction<T, ObservedValueOf<O> | R> {\n  return (source: Observable<T>) => source.lift(new SomeMapOperator(project));\n}\n\nclass SomeMapOperator<T, R> implements Operator<T, R> {\n  constructor(private project: (value: T, index: number) => ObservableInput<R>) {\n  }\n\n  call(Subscriber: Subscriber<R>, source: any): any {\n    return source.subscribe(new SomeMapSubscriber(Subscriber, this.project));\n  }\n}\n```\n\n\n\n通过 _innerSub 提供的内部注册方法，在里面创建 InnerSubscriber，并传入当前的 OuterSubscriber 。 \n\n```typescript\nprivate _innerSub(input: ObservableInput<R>, value: T, index: number): void {\n  const innerSubscriber = new InnerSubscriber(this, value, index);\n  const destination = this.destination as Subscription;\n  destination.add(innerSubscriber);\n  const innerSubscription = subscribeToResult<T, R>(this, input, undefined, undefined, innerSubscriber);\n  \n  // 因为这里的 input 可能不是 observable， 那么返回的\n  // 订阅结果也可能跟 innserSubscriber 相等，所以这里要\n  // 处理一下。\n  if (innerSubscription !== innerSubscriber) {\n    destination.add(innerSubscription);\n  }\n}\n```\n\n\n\n最终，交由 subscribeToResult 创建一个内部订阅来管理下游流。\n\n\n\n### mergeMap\n\n![](http://zcating.gitee.io/imagebed/rxjs_alz/mergeMap.png)\n\nmergeMap 提供的是一种合并操作，通过在内部维护了多个下游流的订阅，使得上游流可以将数据下发给多个下游流。它提供了一个并发数限制的参数，主要用于控制下游流并发的数量。\n\n```typescript\nexport function mergeMap<T, R, O extends ObservableInput<any>>(\n  project: (value: T, index: number) => O,\n  concurrent: number = Number.POSITIVE_INFINITY\n): OperatorFunction<T, ObservedValueOf<O> | R> {\n  return (source: Observable<T>) => source.lift(new MergeMapOperator(project, concurrent));\n}\n```\n\n\n\n下面，我们关注的点将转移到 MergeMapSubscriber 。首先看看它的数据结构。\n\n```typescript\nexport class MergeMapSubscriber<T, R> extends OuterSubscriber<T, R> {\n  // 标记是否已经完成\n  private hasCompleted: boolean = false;\n  // 上流 observable 的数据缓存 \n  private buffer: T[] = [];\n  // 当前正在开启的流的数量\n  private active: number = 0;\n  // 数据的索引\n  protected index: number = 0;\n\n  constructor(\n    // 外部传入的订阅者\n    destination: Subscriber<R>,\n    // 需要合并的 Observable 的工厂\n    private project: (value: T, index: number) => ObservableInput<R>,\n    // 并发数量\n    private concurrent: number = Number.POSITIVE_INFINITY,\n  ) {\n    super(destination);\n  }\n  ...\n}\n```\n\n\n\n#### Subscriber\n\nMergeMapSubscriber 的 _next 调用的时候，会比较 active （下游流的数量） 与 concurrent （最大并发数）的大小，active 小于 concurrent 则调用 _tryNext，否则将已经到来的数据放入缓冲区中，但是你知道的， JavaScript 并没有真正的并发，这就是一个异步队列。而每一次进行 _tryNext，都会通过 project 来创建一个下游流，同时让更新 active，将下游流传入并触发 _innerSub。\n\n```typescript\nprotected _next(value: T): void {\n  if (this.active < this.concurrent) {\n    this._tryNext(value);\n  } else {\n    this.buffer.push(value);\n  }\n}\n\nprotected _tryNext(value: T) {\n  let result: ObservableInput<R>;\n  const index = this.index++;\n  try {\n    result = this.project(value, index);\n  } catch (err) {\n    this.destination.error(err);\n    return;\n  }\n  this.active++;\n  // \n  this._innerSub(result, value, index);\n}\n```\n\n\n\n在上游流完成时，会触发 _complete。\n\n```typescript\nprotected _complete(): void {\n  this.hasCompleted = true;\n  if (this.active === 0 && this.buffer.length === 0) {\n    this.destination.complete();\n  }\n  this.unsubscribe();\n}\n```\n\n\n\n如果所有的下游流都已经完成，且缓冲区中没有数据，则通知下游订阅数据已经输出完毕。\n\n\n\n#### notify\n\nnotifyNext 就是单纯的将结果传递给下游订阅，而 notifyComplete 则有意思多了。\n\n通过 notifyComplete ，可以得知哪些流已经完成任务并且关闭。如果 buffer 中存在数据，那么将数据交由 _next 发送出去并创建新的下游流。过这种递归操作，可以将所有 buffer 中的数据都发送出去。最后判断上游流和下游流是不是都已经结束了，如果已经结束了，则通知下游订阅数据已经输出完毕。\n\n```typescript\nnotifyNext(\n  outerValue: T, innerValue: R,\n  outerIndex: number, innerIndex: number,\n  innerSub: InnerSubscriber<T, R>\n): void {\n  this.destination.next(innerValue);\n}\n\nnotifyComplete(innerSub: Subscription): void {\n  const buffer = this.buffer;\n  this.remove(innerSub);\n  this.active--;\n  if (buffer.length > 0) {\n    this._next(buffer.shift());\n  } else if (this.active === 0 && this.hasCompleted) {\n    this.destination.complete();\n  }\n}\n```\n\n\n\n### switchMap\n\n![](http://zcating.gitee.io/imagebed/rxjs_alz/switchMap.png)\n\nswitchMap 提供的是一个上游流为主的映射操作，当上游流的订阅数据到来的时候，旧的下游流会被取消订阅，然后重新订阅一组新的下游流。\n\n```typescript\nexport function switchMap<T, R, O extends ObservableInput<any>>(\n  project: (value: T, index: number) => O\n): OperatorFunction<T, ObservedValueOf<O>|R> {\n  return (source: Observable<T>) => source.lift(new SwitchMapOperator(project));\n}\n```\n\n\n\n#### Subscriber\n\ninnerSubscription 保存了当前下游流的订阅，所以这个操作符只会维护一个下游流的订阅。\n\n```typescript\nprivate index: number = 0;\nprivate innerSubscription: Subscription;\n```\n\n\n\n当进行 next 操作的时候，会先创建新的下游流，如果旧的下游流存在，那么会被取消订阅。\n\n```typescript\nprotected _next(value: T) {\n  let result: ObservableInput<R>;\n  const index = this.index++;\n  try {\n    // 上游流的数据到来了，创建新的下游流。\n    result = this.project(value, index);\n  } catch (error) {\n    this.destination.error(error);\n    return;\n  }\n\n  // 旧的下游流取消订阅\n  const innerSubscription = this.innerSubscription;\n  if (innerSubscription) {\n    innerSubscription.unsubscribe();\n  }\n\n  this._innerSub(result, value, index);\n}\n```\n\n\n\n该 Subscriber 重写了*_complete* 。这里意味着上游流已经输出完毕，那么如果下游订阅\n\n```\nprotected _complete(): void {\n  const {innerSubscription} = this;\n  if (!innerSubscription || innerSubscription.closed) {\n    super._complete();\n    return;\n  }\n  this.unsubscribe();\n}\n```\n\n\n\n\n\n#### notify\n\n跟之前一样， *notifyNext* 依旧是将下游流中的数据转发出去。主要关注点还是在于 *notifyComplete*。因为 *innerSubscription* 被置为空了，所以调用 *this.\\_complete* 无意义，不会触发到其父类函数。\n\n```typescript\nnotifyComplete(innerSub: Subscription): void {\n  const destination = this.destination as Subscription;\n  destination.remove(innerSub);\n  this.innerSubscription = null;\n  if (this.isStopped) {\n    super._complete();\n  }\n}\n```\n\n如果当前的下游流已经完成了，那么就要将它从下游订阅（destination）中移除，如果上游流已经停止（error 或者 complete 被调用，或者被取消订阅），那么还得调用 super._complete 表示已经完成。\n\n\n\n\n\n### exhaustMap\n\n![](http://zcating.gitee.io/imagebed/rxjs_alz/exhaustMap.png)\n\n跟 *switchMap* 相反， *exhaustMap* 提供了一种以下游流为主的映射操作。如果下游流已经开启，那么上游流之后到来的订阅数据都将会被抛弃，直到该下游流完成订阅。下游流完成订阅后，上游流的数据才会继续跟新的下游流结合，并形成新的订阅。\n\n```typescript\nexport function exhaustMap<T, R, O extends ObservableInput<any>>(\n  project: (value: T, index: number) => O,\n): OperatorFunction<T, ObservedValueOf<O>|R> {\n  return (source: Observable<T>) => source.lift(new ExhaustMapOperator(project));\n}\n```\n\n\n\n#### Subscriber\n\n *exhaustMap* 的实现很简单，通过维护 *hasSubscription* 这样一个内部状态，标记下游流是否被订阅了。 hasCompleted 则是上游流完成情况的标记。\n\n```typescript\nprivate hasSubscription = false;\nprivate hasCompleted = false;\n```\n\n\n\n订阅会调用 _next，标记下游流是否已经开启（订阅是否已经存在），如果未开启，则构建新的下游流，并标记 *hasSubscription* 为 *true*。 \n\n```typescript\nprotected _next(value: T): void {\n  if (!this.hasSubscription) {\n      let result: ObservableInput<R>;\n      const index = this.index++;\n      try {\n        result = this.project(value, index);\n      } catch (err) {\n        this.destination.error(err);\n        return;\n      }\n      // 标记为 true\n      this.hasSubscription = true;\n      this._innerSub(result, value, index);\n  }\n}\n```\n\n\n\n上游流和下游流的数据都已经输出完毕了，那么把完成信号传递给下游订阅。\n\n```typescript\nprotected _complete(): void {\n  this.hasCompleted = true;\n  if (!this.hasSubscription) {\n    this.destination.complete();\n  }\n  this.unsubscribe();\n}\n```\n\n\n\n#### notify\n\n如果下游流的数据输出完毕，那么就应该要将 *hasSubscription* 标记为 *false*。\n\n```typescript\nnotifyComplete(innerSub: Subscription): void {\n  const destination = this.destination as Subscription;\n  destination.remove(innerSub);\n\n  // 标记为 false\n  this.hasSubscription = false;\n\n  // 此处判断上游流是否已经完成\n  if (this.hasCompleted) {\n    this.destination.complete();\n  }\n}\n```\n\n\n\n### concatMap\n\n*concatMap* 是 mergeMap 的一种特殊形式。\n\n```typescript\nexport function concatMap<T, R, O extends ObservableInput<any>>(\n  project: (value: T, index: number) => O,\n): OperatorFunction<T, ObservedValueOf<O>|R> {\n  return mergeMap(project, 1);\n}\n```\n\n\n\n### mergeScan\n\nmergeScan 的源码跟 mergeMap 类似。只不过就是把传入的函数替换了一下，并且在内部缓存了上一个结合后的值。\n\n```typescript\nconst clicks2 = fromEvent(document, 'click');\nconst ones2 = click$.pipe(mapTo(1));\nconst seed2 = 0;\nconst count2 = one$.pipe(\n  // 输入一个 Observable 工厂\n  mergeScan((acc, one) => of(acc + one), seed),\n);\n```\n\n\n\n### concat & merge\n\n上一篇中，关于 concat 和 merge 两个相关的 operators 并没有讲到，因为这它们其实最终都是调用 mergeMap。 \n\n\n\n### 小结\n\n通过这三个不同的映射操作符，使得上游流可以通过一定的方式跟下游流结合。那么，结合一张图，可以看看相关操作符的关系。\n\n![ob_map_rlt](https://zcating.gitee.io/imagebed/rxjs_alz/ob_map_relation.png)\n\n对这些操作符分一下类。\n\n- 属于 Transformation Operators 的有：concatMap， concatMapTo， mergeMap， mergeMapTo， switchMap，switchMapTo，exhaustMap，exhaustMapTo。\n\n- 属于 Join Creation Operators 的有： merge, concat。\n\n- 属于 Join Operators 的有： mergeAll， concatAll， switchAll， startWith，endWith。\n\n\n\n## 零散的高阶操作符\n\n### expand\n\n![](http://zcating.gitee.io/imagebed/rxjs_alz/expand.png)\n\nexpand 将传入的 Observable 工厂进行递归操作。与上面的复合映射类似，expand 也是一种复合映射，只不过，他会不断的去复合下游流的数据，也就是类似上图的模式。\n\n\n\n#### Subscriber\n\n为了实现相对应的功能，expand 定义了以下数据结构。\n\n```typescript\nexport class ExpandSubscriber<T, R> extends OuterSubscriber<T, R> {\n  // 当前索引\n  private index: number = 0;\n  // 已启动的下游流的数量\n  private active: number = 0;\n  // 上游流是否已经完成\n  private hasCompleted: boolean = false;\n  // 对于索引的缓存数据\n  private buffer: any[];\n  // 下游流工厂\n  private project: (value: T, index: number) => ObservableInput<R>,\n\t// 并发数  \n \tprivate concurrent: number;\n}\n```\n\n\n\n上游流数据到来的时候，跟 mergeMap 比较类似，也会比较 active 和 concurrent，如果 active 大于 concurrent ，那么便会用buffer缓存上游流的数据，如果 active 小于 concurrent ，那么直接发送数据给到下游订阅，并订阅一个新的下游流。需要注意的一点，为了防止爆栈，expand 在这里加了一个判断条件，在 notify 中，将利用这一条件，来结束递归。\n\n```typescript\nprotected _next(value: any): void {\n  const destination = this.destination;\n\n  if (destination.closed) {\n    this._complete();\n    return;\n  }\n\n  const index = this.index++;\n  if (this.active < this.concurrent) {\n    destination.next(value);\n    try {\n      const { project } = this;\n      const result = project(value, index);\n      this.subscribeToProjection(result, value, index);\n    } catch (e) {\n      destination.error(e);\n    }\n  } else {\n    this.buffer.push(value);\n  }\n}\n// 订阅新的下游流\nprivate subscribeToProjection(result: any, value: T, index: number): void {\n  this.active++;\n  const destination = this.destination as Subscription;\n  destination.add(subscribeToResult<T, R>(this, result, value, index));\n}\n```\n\n\n\n当上游流完成时，需要标记 hasComplete 为 true。这一步是结束递归的重要标志。\n\n```typescript\nprotected _complete(): void {\n  this.hasCompleted = true;\n  if (this.hasCompleted && this.active === 0) {\n    this.destination.complete();\n  }\n\tthis.unsubscribe();\n}\n```\n\n\n\n\n\n### notify\n\n那么 expand 是怎么构成递归的呢，当下游流有数据到来的时候，他会直接调用 _next。最终形成了 ` _next -> subscribeToProjection -> next -> notifyNext -> _next` 这样的一条递归链。\n\n```typescript\nnotifyNext(\n  outerValue: T, \n  innerValue: R,\n\touterIndex: number, \n  innerIndex: number,\n\tinnerSub: InnerSubscriber<T, R>\n): void {\n\tthis._next(innerValue);\n}\n```\n\n\n\n下游流完成时，需要根据 hasCompleted 和 buffer 的状态来决定是否结束递归。在这里，也形成了一条这样的递归链： ` _next -> subscribeToProjection -> next -> notifyComplete -> _next`  。\n\n```typescript\nnotifyComplete(innerSub: Subscription): void {\n  const buffer = this.buffer;\n  const destination = this.destination as Subscription;\n  destination.remove(innerSub);\n  this.active--;\n  if (buffer && buffer.length > 0) {\n    this._next(buffer.shift());\n  }\n  if (this.hasCompleted && this.active === 0) {\n    this.destination.complete();\n  }\n}\n```\n\n\n\n\n\n### exhaust\n\n![](http://zcating.gitee.io/imagebed/rxjs_alz/exhaust.png)\n\nexhaust 是一种打平操作，它的源码并没有调用 exhaustMap。它的实现思路很简单，通过判断当前是否存在前一个下游流订阅（hasSubscription），来决定当前到来的下游流是否开启。\n\n```typescript\nprivate hasCompleted: boolean = false;\nprivate hasSubscription: boolean = false;\n\n\nprotected _next(value: T): void {\n  // 如果存在订阅，那么抛弃这个值\n  if (!this.hasSubscription) {\n    this.hasSubscription = true;\n    this.add(subscribeToResult(this, value));\n  }\n}\n\nprotected _complete(): void {\n  this.hasCompleted = true;\n  if (!this.hasSubscription) {\n    this.destination.complete();\n  }\n}\n\nnotifyComplete(innerSub: Subscription): void {\n  this.remove(innerSub);\n  this.hasSubscription = false;\n  if (this.hasCompleted) {\n    this.destination.complete();\n  }\n}\n```\n\n \n\n## 总结\n\n本篇主要的内容集中在分析操作符是如何进行数据的映射，那么下一篇将讲解的是 buffer 和 window 相关的缓存操作符是如何运行和实现的。 \n\n## 加入我们\n\n我们是DevUI团队，欢迎来这里和我们一起打造优雅高效的人机设计/研发体系。招聘邮箱：muyang2@huawei.com。\n\n\n作者：zcx（公众号：Coder写字的地方）\n\n原文链接：[https://mp.weixin.qq.com/s/lrawMOuHNj6GyQJMqK1Now](https://mp.weixin.qq.com/s/lrawMOuHNj6GyQJMqK1Now)\n\n---\n\n往期文章推荐\n\n[《好用到飞起！VSCode插件DevUIHelper设计开发全攻略（三）》](https://juejin.im/post/6856934676406370311)\n\n[《Web界面深色模式和主题化开发》](https://juejin.im/post/6844904167761248263)\n\n[《手把手教你搭建一个灰度发布环境》](https://juejin.im/post/6844904110601273357)\n", "user_name": "DevUI团队", "description": "DevUI，致力于打造业界领先的企业级UI组件库。https://github.com/DevCloudFE/ng-devui", "got_view_count": 68417, "category_name": "前端", "ctime": 1457483942}
{"tag_name": "Java", "concern_user_count": 252044, "user_id": "2796746683483751", "title": "Java8中你可能不知道的一些地方之Stream实战一", "mark_content": "<section id=\"nice\" data-tool=\"mdnice编辑器\" data-website=\"https://www.mdnice.com\" style=\"font-size: 16px; padding: 0 10px; word-spacing: 0px; word-break: break-word; word-wrap: break-word; text-align: left; line-height: 1.25; color: #2b2b2b; font-family: Optima-Regular, Optima, PingFangTC-Light, PingFangSC-light, PingFangTC-light; letter-spacing: 2px; background-image: linear-gradient(90deg, rgba(50, 0, 0, 0.04) 3%, rgba(0, 0, 0, 0) 3%), linear-gradient(360deg, rgba(50, 0, 0, 0.04) 3%, rgba(0, 0, 0, 0) 3%); background-size: 20px 20px; background-position: center center;\"><figure data-tool=\"mdnice编辑器\" style=\"margin: 0; margin-top: 10px; margin-bottom: 10px; display: flex; flex-direction: column; justify-content: center; align-items: center;\"><img src=\"https://cushier.coding.net/p/picture/d/picture/git/raw/master/20200810155052.png\" alt style=\"max-width: 100%; border-radius: 6px; display: block; margin: 20px auto; object-fit: contain; box-shadow: 2px 4px 7px #999;\"></figure>\n<p data-tool=\"mdnice编辑器\" style=\"padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: #2b2b2b; margin: 10px 0px; letter-spacing: 2px; font-size: 14px; word-spacing: 2px;\">说起流，我们会想起手机 ，电脑组装流水线，物流仓库商品包装流水线等等。如果把手机 ,电脑,包裹看做最终结果的话,那么加工商品前的各种零部件就可以看做数据源，而中间一系列的加工作业操作，就可以看做流的处理。</p>\n<h2 data-tool=\"mdnice编辑器\" style=\"margin-top: 30px; margin-bottom: 15px; padding: 0px; font-weight: bold; color: black; font-size: 22px; display: block; border-bottom: 4px solid #40B8FA;\"><span class=\"prefix\" style=\"display: flex; width: 20px; height: 20px; background-size: 20px 20px; background-image: url(https://my-wechat.mdnice.com/fullstack-1.png); margin-bottom: -22px;\"></span><span class=\"content\" style=\"display: flex; color: #40B8FA; font-size: 20px; margin-left: 25px;\">流的概念</span><span class=\"suffix\" style=\"display: flex; box-sizing: border-box; width: 200px; height: 10px; border-top-left-radius: 20px; background: RGBA(64, 184, 250, .5); color: rgb(255, 255, 255); font-size: 16px; letter-spacing: 0.544px; justify-content: flex-end; float: right; margin-top: -10px; box-sizing: border-box !important; overflow-wrap: break-word !important;\"></span></h2>\n<p data-tool=\"mdnice编辑器\" style=\"padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: #2b2b2b; margin: 10px 0px; letter-spacing: 2px; font-size: 14px; word-spacing: 2px;\">Java Se中对于流的操作有输入输出IO流,而Java8中引入的Stream 属于Java API中的一个新成员，它允许你以声明性方式处理数据集合，Stream 使用一种类似 SQL 语句从数据库查询数据的直观方式来提供一种对 Java 集合运算和表达的高阶抽象。 注意这里的流操作可以看做是对集合数据的处理。</p>\n<p data-tool=\"mdnice编辑器\" style=\"padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: #2b2b2b; margin: 10px 0px; letter-spacing: 2px; font-size: 14px; word-spacing: 2px;\">简单来说,流是一种数据渠道,用于操作数据源(集合、数组、文件等)所生产的元素序列。</p>\n<ul data-tool=\"mdnice编辑器\" style=\"margin-top: 8px; margin-bottom: 8px; padding-left: 25px; font-size: 15px; color: #595959; list-style-type: circle;\">\n<li><section style=\"margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; font-size: 14px; font-weight: normal; color: #595959;\">源-流会使用一个提供数据的源,如集合、数组或输入|输出资源。</section></li></ul>\n<p data-tool=\"mdnice编辑器\" style=\"padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: #2b2b2b; margin: 10px 0px; letter-spacing: 2px; font-size: 14px; word-spacing: 2px;\">从有序集生成流时会保留原有的顺序。由列表生成的流，其元素顺序与列表一致</p>\n<ul data-tool=\"mdnice编辑器\" style=\"margin-top: 8px; margin-bottom: 8px; padding-left: 25px; font-size: 15px; color: #595959; list-style-type: circle;\">\n<li><section style=\"margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; font-size: 14px; font-weight: normal; color: #595959;\">元素序列-就像集合一样，流也提供了一个接口,可以访问特定元素类型的一组有序值。</section></li><li><section style=\"margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; font-size: 14px; font-weight: normal; color: #595959;\">数据处理操作-流的数据处理功能支持类似于数据库的操作(数据筛选、过滤、排序等操作)。</section></li><li><section style=\"margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; font-size: 14px; font-weight: normal; color: #595959;\">流水线-多个流操作本身会返回一个流，多个操作就可以链接起来,成为数据处理的一道流水线。</section></li></ul>\n<h2 data-tool=\"mdnice编辑器\" style=\"margin-top: 30px; margin-bottom: 15px; padding: 0px; font-weight: bold; color: black; font-size: 22px; display: block; border-bottom: 4px solid #40B8FA;\"><span class=\"prefix\" style=\"display: flex; width: 20px; height: 20px; background-size: 20px 20px; background-image: url(https://my-wechat.mdnice.com/fullstack-1.png); margin-bottom: -22px;\"></span><span class=\"content\" style=\"display: flex; color: #40B8FA; font-size: 20px; margin-left: 25px;\">流&amp;集合</span><span class=\"suffix\" style=\"display: flex; box-sizing: border-box; width: 200px; height: 10px; border-top-left-radius: 20px; background: RGBA(64, 184, 250, .5); color: rgb(255, 255, 255); font-size: 16px; letter-spacing: 0.544px; justify-content: flex-end; float: right; margin-top: -10px; box-sizing: border-box !important; overflow-wrap: break-word !important;\"></span></h2>\n<ul data-tool=\"mdnice编辑器\" style=\"margin-top: 8px; margin-bottom: 8px; padding-left: 25px; font-size: 15px; color: #595959; list-style-type: circle;\">\n<li><section style=\"margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; font-size: 14px; font-weight: normal; color: #595959;\">计算的时期</section></li></ul>\n<figure data-tool=\"mdnice编辑器\" style=\"margin: 0; margin-top: 10px; margin-bottom: 10px; display: flex; flex-direction: column; justify-content: center; align-items: center;\"><img src=\"https://cushier.coding.net/p/picture/d/picture/git/raw/master/20200810155614.png\" alt style=\"max-width: 100%; border-radius: 6px; display: block; margin: 20px auto; object-fit: contain; box-shadow: 2px 4px 7px #999;\"></figure>\n<p data-tool=\"mdnice编辑器\" style=\"padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: #2b2b2b; margin: 10px 0px; letter-spacing: 2px; font-size: 14px; word-spacing: 2px;\">集合中数据都是计算完毕的数据，例如从数据库中查询用户记录 按用户id 查询 降序排列 然后通过list 接收用户记录，数据的计算已在放入集合前完成。</p>\n<p data-tool=\"mdnice编辑器\" style=\"padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: #2b2b2b; margin: 10px 0px; letter-spacing: 2px; font-size: 14px; word-spacing: 2px;\">流中数据按需计算，按照使用者的需要计算数据，例如通过搜索引擎进行搜索，搜索出来的条目并不是全部呈现出来的，而且先显示最符合的前 10 条或者前 20 条，只有在点击 “下一页” 的时候，才会再输出新的 10 条。流的计算也是这样，当用户需要对应数据时，Stream 才会对其进行计算处理。</p>\n<ul data-tool=\"mdnice编辑器\" style=\"margin-top: 8px; margin-bottom: 8px; padding-left: 25px; font-size: 15px; color: #595959; list-style-type: circle;\">\n<li><section style=\"margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; font-size: 14px; font-weight: normal; color: #595959;\">外部迭代与内部迭代</section></li></ul>\n<figure data-tool=\"mdnice编辑器\" style=\"margin: 0; margin-top: 10px; margin-bottom: 10px; display: flex; flex-direction: column; justify-content: center; align-items: center;\"><img src=\"https://cushier.coding.net/p/picture/d/picture/git/raw/master/20200810155717.png\" alt style=\"max-width: 100%; border-radius: 6px; display: block; margin: 20px auto; object-fit: contain; box-shadow: 2px 4px 7px #999;\"></figure>\n<p data-tool=\"mdnice编辑器\" style=\"padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: #2b2b2b; margin: 10px 0px; letter-spacing: 2px; font-size: 14px; word-spacing: 2px;\">把集合比作一个工厂的仓库的话，一开始工厂硬件比较落后，要对货物作什么修改，此时工人亲自走进仓库对货物进行处理，有时候还要将处理后的货物转运到另一个仓库中。此时对于开发者来说需要亲自去做迭代，一个个地找到需要的货物，并进行处理，这叫做外部迭代。</p>\n<p data-tool=\"mdnice编辑器\" style=\"padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: #2b2b2b; margin: 10px 0px; letter-spacing: 2px; font-size: 14px; word-spacing: 2px;\">当工厂发展起来后，配备了流水线作业，工厂只要根据需求设计出相应的流水线，然后工人只要把货物放到流水线上，就可以等着接收成果了，而且流水线还可以根据要求直接把货物输送到相应的仓库。</p>\n<p data-tool=\"mdnice编辑器\" style=\"padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: #2b2b2b; margin: 10px 0px; letter-spacing: 2px; font-size: 14px; word-spacing: 2px;\">这就叫做内部迭代，流水线已经帮你把迭代给完成了，你只需要说要干什么就可以了（即设计出合理的流水线）。相当于 Java8 引入的Stream 对数据的处理实现了”自动化”操作。</p>\n<h2 data-tool=\"mdnice编辑器\" style=\"margin-top: 30px; margin-bottom: 15px; padding: 0px; font-weight: bold; color: black; font-size: 22px; display: block; border-bottom: 4px solid #40B8FA;\"><span class=\"prefix\" style=\"display: flex; width: 20px; height: 20px; background-size: 20px 20px; background-image: url(https://my-wechat.mdnice.com/fullstack-1.png); margin-bottom: -22px;\"></span><span class=\"content\" style=\"display: flex; color: #40B8FA; font-size: 20px; margin-left: 25px;\">流操作过程</span><span class=\"suffix\" style=\"display: flex; box-sizing: border-box; width: 200px; height: 10px; border-top-left-radius: 20px; background: RGBA(64, 184, 250, .5); color: rgb(255, 255, 255); font-size: 16px; letter-spacing: 0.544px; justify-content: flex-end; float: right; margin-top: -10px; box-sizing: border-box !important; overflow-wrap: break-word !important;\"></span></h2>\n<figure data-tool=\"mdnice编辑器\" style=\"margin: 0; margin-top: 10px; margin-bottom: 10px; display: flex; flex-direction: column; justify-content: center; align-items: center;\"><img src=\"https://cushier.coding.net/p/picture/d/picture/git/raw/master/20200810155835.png\" alt style=\"max-width: 100%; border-radius: 6px; display: block; margin: 20px auto; object-fit: contain; box-shadow: 2px 4px 7px #999;\"></figure>\n<p data-tool=\"mdnice编辑器\" style=\"padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: #2b2b2b; margin: 10px 0px; letter-spacing: 2px; font-size: 14px; word-spacing: 2px;\">整个流操作就是一条流水线，将元素放在流水线上一个个地进行处理。需要注意的是:很多流操作本身就会返回一个流，所以多个操作可以直接连接起来， 如下图这样，操作可以进行链式调用，并且并行流还可以实现数据流并行处理操作。</p>\n<figure data-tool=\"mdnice编辑器\" style=\"margin: 0; margin-top: 10px; margin-bottom: 10px; display: flex; flex-direction: column; justify-content: center; align-items: center;\"><img src=\"https://cushier.coding.net/p/picture/d/picture/git/raw/master/20200810155909.png\" alt style=\"max-width: 100%; border-radius: 6px; display: block; margin: 20px auto; object-fit: contain; box-shadow: 2px 4px 7px #999;\"></figure>\n<p data-tool=\"mdnice编辑器\" style=\"padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: #2b2b2b; margin: 10px 0px; letter-spacing: 2px; font-size: 14px; word-spacing: 2px;\">总的来说，流操作过程分为三个阶段:</p>\n<ul data-tool=\"mdnice编辑器\" style=\"margin-top: 8px; margin-bottom: 8px; padding-left: 25px; font-size: 15px; color: #595959; list-style-type: circle;\">\n<li><section style=\"margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; font-size: 14px; font-weight: normal; color: #595959;\">创建</section></li></ul>\n<p data-tool=\"mdnice编辑器\" style=\"padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: #2b2b2b; margin: 10px 0px; letter-spacing: 2px; font-size: 14px; word-spacing: 2px;\">借助数据源创建流对象</p>\n<ul data-tool=\"mdnice编辑器\" style=\"margin-top: 8px; margin-bottom: 8px; padding-left: 25px; font-size: 15px; color: #595959; list-style-type: circle;\">\n<li><section style=\"margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; font-size: 14px; font-weight: normal; color: #595959;\">中间处理</section></li></ul>\n<p data-tool=\"mdnice编辑器\" style=\"padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: #2b2b2b; margin: 10px 0px; letter-spacing: 2px; font-size: 14px; word-spacing: 2px;\">筛选、切片、映射、排序等中间操作</p>\n<ul data-tool=\"mdnice编辑器\" style=\"margin-top: 8px; margin-bottom: 8px; padding-left: 25px; font-size: 15px; color: #595959; list-style-type: circle;\">\n<li><section style=\"margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; font-size: 14px; font-weight: normal; color: #595959;\">终止流</section></li></ul>\n<p data-tool=\"mdnice编辑器\" style=\"padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: #2b2b2b; margin: 10px 0px; letter-spacing: 2px; font-size: 14px; word-spacing: 2px;\">匹配、汇总、分组等终止操作</p>\n<h2 data-tool=\"mdnice编辑器\" style=\"margin-top: 30px; margin-bottom: 15px; padding: 0px; font-weight: bold; color: black; font-size: 22px; display: block; border-bottom: 4px solid #40B8FA;\"><span class=\"prefix\" style=\"display: flex; width: 20px; height: 20px; background-size: 20px 20px; background-image: url(https://my-wechat.mdnice.com/fullstack-1.png); margin-bottom: -22px;\"></span><span class=\"content\" style=\"display: flex; color: #40B8FA; font-size: 20px; margin-left: 25px;\">流的创建</span><span class=\"suffix\" style=\"display: flex; box-sizing: border-box; width: 200px; height: 10px; border-top-left-radius: 20px; background: RGBA(64, 184, 250, .5); color: rgb(255, 255, 255); font-size: 16px; letter-spacing: 0.544px; justify-content: flex-end; float: right; margin-top: -10px; box-sizing: border-box !important; overflow-wrap: break-word !important;\"></span></h2>\n<p data-tool=\"mdnice编辑器\" style=\"padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: #2b2b2b; margin: 10px 0px; letter-spacing: 2px; font-size: 14px; word-spacing: 2px;\">对流操作首先要创建对应的流，流的创建集中形式如下:</p>\n<figure data-tool=\"mdnice编辑器\" style=\"margin: 0; margin-top: 10px; margin-bottom: 10px; display: flex; flex-direction: column; justify-content: center; align-items: center;\"><img src=\"https://cushier.coding.net/p/picture/d/picture/git/raw/master/20200810160008.png\" alt style=\"max-width: 100%; border-radius: 6px; display: block; margin: 20px auto; object-fit: contain; box-shadow: 2px 4px 7px #999;\"></figure>\n<h3 data-tool=\"mdnice编辑器\" style=\"padding: 0px; color: black; font-size: 17px; font-weight: bold; text-align: center; position: relative; margin-top: 20px; margin-bottom: 20px;\"><span class=\"prefix\" style=\"display: none;\"></span><span class=\"content\" style=\"border-bottom: 2px solid RGBA(79, 177, 249, .65); color: #2b2b2b; padding-bottom: 2px;\"><span style=\"width: 30px; height: 30px; display: block; background-image: url(https://my-wechat.mdnice.com/fullstack-2.png); background-position: center; background-size: 30px; margin: auto; opacity: 1; background-repeat: no-repeat; margin-bottom: -8px;\"></span>1 集合创建流</span><span class=\"suffix\" style=\"display: none;\"></span></h3>\n<p data-tool=\"mdnice编辑器\" style=\"padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: #2b2b2b; margin: 10px 0px; letter-spacing: 2px; font-size: 14px; word-spacing: 2px;\">在 Java 8 中, 集合接口有两个方法来生成流：</p>\n<ul data-tool=\"mdnice编辑器\" style=\"margin-top: 8px; margin-bottom: 8px; padding-left: 25px; font-size: 15px; color: #595959; list-style-type: circle;\">\n<li><section style=\"margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; font-size: 14px; font-weight: normal; color: #595959;\">stream() − 为集合创建串行流。</section></li><li><section style=\"margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; font-size: 14px; font-weight: normal; color: #595959;\">parallelStream() − 为集合创建并行流。</section></li></ul>\n<p data-tool=\"mdnice编辑器\" style=\"padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: #2b2b2b; margin: 10px 0px; letter-spacing: 2px; font-size: 14px; word-spacing: 2px;\">示例代码如下:</p>\n<pre class=\"custom\" data-tool=\"mdnice编辑器\" style=\"margin-top: 10px; margin-bottom: 10px;\"><code class=\"hljs\" style=\"overflow-x: auto; padding: 16px; color: #abb2bf; background: #282c34; display: -webkit-box; font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; border-radius: 0px; font-size: 12px; -webkit-overflow-scrolling: touch; letter-spacing: 0px;\"><span class=\"hljs-function\" style=\"line-height: 26px;\"><span class=\"hljs-keyword\" style=\"color: #c678dd; line-height: 26px;\">public</span>&nbsp;<span class=\"hljs-keyword\" style=\"color: #c678dd; line-height: 26px;\">static</span>&nbsp;<span class=\"hljs-keyword\" style=\"color: #c678dd; line-height: 26px;\">void</span>&nbsp;<span class=\"hljs-title\" style=\"color: #61aeee; line-height: 26px;\">main</span><span class=\"hljs-params\" style=\"line-height: 26px;\">(String[]&nbsp;args)</span>&nbsp;</span>{<br>&nbsp;&nbsp;&nbsp;&nbsp;<span class=\"hljs-comment\" style=\"color: #5c6370; font-style: italic; line-height: 26px;\">/**<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*&nbsp;定义集合l1&nbsp;并为集合创建串行流<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*/</span><br>&nbsp;&nbsp;&nbsp;&nbsp;List&lt;String&gt;&nbsp;l1&nbsp;=&nbsp;Arrays.asList(<span class=\"hljs-string\" style=\"color: #98c379; line-height: 26px;\">\"周星驰\"</span>,&nbsp;<span class=\"hljs-string\" style=\"color: #98c379; line-height: 26px;\">\"周杰伦\"</span>,&nbsp;<span class=\"hljs-string\" style=\"color: #98c379; line-height: 26px;\">\"周星星\"</span>,&nbsp;<span class=\"hljs-string\" style=\"color: #98c379; line-height: 26px;\">\"周润发\"</span>);<br>&nbsp;&nbsp;&nbsp;&nbsp;<span class=\"hljs-comment\" style=\"color: #5c6370; font-style: italic; line-height: 26px;\">//&nbsp;返回串行流</span><br>&nbsp;&nbsp;&nbsp;&nbsp;l1.stream();<br>&nbsp;&nbsp;&nbsp;&nbsp;<span class=\"hljs-comment\" style=\"color: #5c6370; font-style: italic; line-height: 26px;\">//&nbsp;返回并行流</span><br>&nbsp;&nbsp;&nbsp;&nbsp;l1.parallelStream();<br>}<br></code></pre>\n<p data-tool=\"mdnice编辑器\" style=\"padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: #2b2b2b; margin: 10px 0px; letter-spacing: 2px; font-size: 14px; word-spacing: 2px;\">上述操作得到的流是通过原始数据转换过来的流，除了这种流创建的基本操作外，对于流的创建还有以下几种方式。</p>\n<h3 data-tool=\"mdnice编辑器\" style=\"padding: 0px; color: black; font-size: 17px; font-weight: bold; text-align: center; position: relative; margin-top: 20px; margin-bottom: 20px;\"><span class=\"prefix\" style=\"display: none;\"></span><span class=\"content\" style=\"border-bottom: 2px solid RGBA(79, 177, 249, .65); color: #2b2b2b; padding-bottom: 2px;\"><span style=\"width: 30px; height: 30px; display: block; background-image: url(https://my-wechat.mdnice.com/fullstack-2.png); background-position: center; background-size: 30px; margin: auto; opacity: 1; background-repeat: no-repeat; margin-bottom: -8px;\"></span>2 值创建流</span><span class=\"suffix\" style=\"display: none;\"></span></h3>\n<p data-tool=\"mdnice编辑器\" style=\"padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: #2b2b2b; margin: 10px 0px; letter-spacing: 2px; font-size: 14px; word-spacing: 2px;\">Stream.of(T...) ： Stream.of(\"aa\", \"bb\") 生成流</p>\n<pre class=\"custom\" data-tool=\"mdnice编辑器\" style=\"margin-top: 10px; margin-bottom: 10px;\"><code class=\"hljs\" style=\"overflow-x: auto; padding: 16px; color: #abb2bf; background: #282c34; display: -webkit-box; font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; border-radius: 0px; font-size: 12px; -webkit-overflow-scrolling: touch; letter-spacing: 0px;\"><span class=\"hljs-comment\" style=\"color: #5c6370; font-style: italic; line-height: 26px;\">//值创建流&nbsp;生成一个字符串流</span><br>Stream&lt;String&gt;&nbsp;stream&nbsp;=&nbsp;Stream.of(<span class=\"hljs-string\" style=\"color: #98c379; line-height: 26px;\">\"java8\"</span>,&nbsp;<span class=\"hljs-string\" style=\"color: #98c379; line-height: 26px;\">\"Spring\"</span>,&nbsp;<span class=\"hljs-string\" style=\"color: #98c379; line-height: 26px;\">\"SpringCloud\"</span>);<br>stream.forEach(System.out::println);<br></code></pre>\n<h3 data-tool=\"mdnice编辑器\" style=\"padding: 0px; color: black; font-size: 17px; font-weight: bold; text-align: center; position: relative; margin-top: 20px; margin-bottom: 20px;\"><span class=\"prefix\" style=\"display: none;\"></span><span class=\"content\" style=\"border-bottom: 2px solid RGBA(79, 177, 249, .65); color: #2b2b2b; padding-bottom: 2px;\"><span style=\"width: 30px; height: 30px; display: block; background-image: url(https://my-wechat.mdnice.com/fullstack-2.png); background-position: center; background-size: 30px; margin: auto; opacity: 1; background-repeat: no-repeat; margin-bottom: -8px;\"></span>3 数组创建流</span><span class=\"suffix\" style=\"display: none;\"></span></h3>\n<p data-tool=\"mdnice编辑器\" style=\"padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: #2b2b2b; margin: 10px 0px; letter-spacing: 2px; font-size: 14px; word-spacing: 2px;\">根据参数的数组类型创建对应的流。</p>\n<ul data-tool=\"mdnice编辑器\" style=\"margin-top: 8px; margin-bottom: 8px; padding-left: 25px; font-size: 15px; color: #595959; list-style-type: circle;\">\n<li><section style=\"margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; font-size: 14px; font-weight: normal; color: #595959;\">Arrays.stream(T[ ])</section></li><li><section style=\"margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; font-size: 14px; font-weight: normal; color: #595959;\">Arrays.stream(int[ ])</section></li><li><section style=\"margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; font-size: 14px; font-weight: normal; color: #595959;\">Arrays.stream(double[ ])</section></li><li><section style=\"margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; font-size: 14px; font-weight: normal; color: #595959;\">Arrays.stream(long[ ])</section></li></ul>\n<pre class=\"custom\" data-tool=\"mdnice编辑器\" style=\"margin-top: 10px; margin-bottom: 10px;\"><code class=\"hljs\" style=\"overflow-x: auto; padding: 16px; color: #abb2bf; background: #282c34; display: -webkit-box; font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; border-radius: 0px; font-size: 12px; -webkit-overflow-scrolling: touch; letter-spacing: 0px;\">&nbsp;<span class=\"hljs-comment\" style=\"color: #5c6370; font-style: italic; line-height: 26px;\">/**<br>&nbsp;*&nbsp;这里以int&nbsp;为例&nbsp;&nbsp;&nbsp;long&nbsp;double&nbsp;不再举例<br>&nbsp;*/</span><br>&nbsp;Stream&nbsp;stream&nbsp;=&nbsp;Arrays.stream(Arrays.asList(<span class=\"hljs-number\" style=\"color: #d19a66; line-height: 26px;\">10</span>,&nbsp;<span class=\"hljs-number\" style=\"color: #d19a66; line-height: 26px;\">20</span>,&nbsp;<span class=\"hljs-number\" style=\"color: #d19a66; line-height: 26px;\">30</span>,&nbsp;<span class=\"hljs-number\" style=\"color: #d19a66; line-height: 26px;\">40</span>).toArray());<br>&nbsp;<span class=\"hljs-comment\" style=\"color: #5c6370; font-style: italic; line-height: 26px;\">//&nbsp;根据数组索引范围创建指定Stream</span><br>&nbsp;stream&nbsp;=&nbsp;Arrays.stream(Arrays.asList(<span class=\"hljs-number\" style=\"color: #d19a66; line-height: 26px;\">10</span>,&nbsp;<span class=\"hljs-number\" style=\"color: #d19a66; line-height: 26px;\">20</span>,&nbsp;<span class=\"hljs-number\" style=\"color: #d19a66; line-height: 26px;\">30</span>,&nbsp;<span class=\"hljs-number\" style=\"color: #d19a66; line-height: 26px;\">40</span>).toArray(),&nbsp;<span class=\"hljs-number\" style=\"color: #d19a66; line-height: 26px;\">0</span>,&nbsp;<span class=\"hljs-number\" style=\"color: #d19a66; line-height: 26px;\">2</span>);<br></code></pre>\n<h3 data-tool=\"mdnice编辑器\" style=\"padding: 0px; color: black; font-size: 17px; font-weight: bold; text-align: center; position: relative; margin-top: 20px; margin-bottom: 20px;\"><span class=\"prefix\" style=\"display: none;\"></span><span class=\"content\" style=\"border-bottom: 2px solid RGBA(79, 177, 249, .65); color: #2b2b2b; padding-bottom: 2px;\"><span style=\"width: 30px; height: 30px; display: block; background-image: url(https://my-wechat.mdnice.com/fullstack-2.png); background-position: center; background-size: 30px; margin: auto; opacity: 1; background-repeat: no-repeat; margin-bottom: -8px;\"></span>4 文件生成流</span><span class=\"suffix\" style=\"display: none;\"></span></h3>\n<pre class=\"custom\" data-tool=\"mdnice编辑器\" style=\"margin-top: 10px; margin-bottom: 10px;\"><code class=\"hljs\" style=\"overflow-x: auto; padding: 16px; color: #abb2bf; background: #282c34; display: -webkit-box; font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; border-radius: 0px; font-size: 12px; -webkit-overflow-scrolling: touch; letter-spacing: 0px;\">stream&nbsp;=&nbsp;Files.lines(Paths.get(<span class=\"hljs-string\" style=\"color: #98c379; line-height: 26px;\">\"C:\\\\java\\\\jdbc.properties\"</span>));<br>System.out.println(stream.collect(Collectors.toList()));<br><span class=\"hljs-comment\" style=\"color: #5c6370; font-style: italic; line-height: 26px;\">//&nbsp;指定字符集编码</span><br>stream&nbsp;=&nbsp;Files.lines(Paths.get(<span class=\"hljs-string\" style=\"color: #98c379; line-height: 26px;\">\"C:\\\\java\\\\jdbc.properties\"</span>),&nbsp;Charset.forName(<span class=\"hljs-string\" style=\"color: #98c379; line-height: 26px;\">\"utf-8\"</span>));<br>System.out.println(stream.collect(Collectors.toList()));<br></code></pre>\n<h3 data-tool=\"mdnice编辑器\" style=\"padding: 0px; color: black; font-size: 17px; font-weight: bold; text-align: center; position: relative; margin-top: 20px; margin-bottom: 20px;\"><span class=\"prefix\" style=\"display: none;\"></span><span class=\"content\" style=\"border-bottom: 2px solid RGBA(79, 177, 249, .65); color: #2b2b2b; padding-bottom: 2px;\"><span style=\"width: 30px; height: 30px; display: block; background-image: url(https://my-wechat.mdnice.com/fullstack-2.png); background-position: center; background-size: 30px; margin: auto; opacity: 1; background-repeat: no-repeat; margin-bottom: -8px;\"></span>5 函数生成流</span><span class=\"suffix\" style=\"display: none;\"></span></h3>\n<p data-tool=\"mdnice编辑器\" style=\"padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: #2b2b2b; margin: 10px 0px; letter-spacing: 2px; font-size: 14px; word-spacing: 2px;\">两个方法：</p>\n<ul data-tool=\"mdnice编辑器\" style=\"margin-top: 8px; margin-bottom: 8px; padding-left: 25px; font-size: 15px; color: #595959; list-style-type: circle;\">\n<li><section style=\"margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; font-size: 14px; font-weight: normal; color: #595959;\">iterate ： 依次对每个新生成的值应用函数</section></li><li><section style=\"margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; font-size: 14px; font-weight: normal; color: #595959;\">generate ：接受一个函数，生成一个新的值</section></li></ul>\n<pre class=\"custom\" data-tool=\"mdnice编辑器\" style=\"margin-top: 10px; margin-bottom: 10px;\"><code class=\"hljs\" style=\"overflow-x: auto; padding: 16px; color: #abb2bf; background: #282c34; display: -webkit-box; font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; border-radius: 0px; font-size: 12px; -webkit-overflow-scrolling: touch; letter-spacing: 0px;\">&nbsp;<span class=\"hljs-comment\" style=\"color: #5c6370; font-style: italic; line-height: 26px;\">//&nbsp;重100&nbsp;开始&nbsp;生成偶数流</span><br>&nbsp;Stream.iterate(<span class=\"hljs-number\" style=\"color: #d19a66; line-height: 26px;\">100</span>,&nbsp;n&nbsp;-&gt;&nbsp;n&nbsp;+&nbsp;<span class=\"hljs-number\" style=\"color: #d19a66; line-height: 26px;\">2</span>);<br>&nbsp;<span class=\"hljs-comment\" style=\"color: #5c6370; font-style: italic; line-height: 26px;\">//&nbsp;产生1-100&nbsp;随机数</span><br>&nbsp;Stream.generate(()&nbsp;-&gt;(<span class=\"hljs-keyword\" style=\"color: #c678dd; line-height: 26px;\">int</span>)&nbsp;(Math.random()&nbsp;*&nbsp;<span class=\"hljs-number\" style=\"color: #d19a66; line-height: 26px;\">100</span>&nbsp;+&nbsp;<span class=\"hljs-number\" style=\"color: #d19a66; line-height: 26px;\">1</span>));<br></code></pre>\n<h2 data-tool=\"mdnice编辑器\" style=\"margin-top: 30px; margin-bottom: 15px; padding: 0px; font-weight: bold; color: black; font-size: 22px; display: block; border-bottom: 4px solid #40B8FA;\"><span class=\"prefix\" style=\"display: flex; width: 20px; height: 20px; background-size: 20px 20px; background-image: url(https://my-wechat.mdnice.com/fullstack-1.png); margin-bottom: -22px;\"></span><span class=\"content\" style=\"display: flex; color: #40B8FA; font-size: 20px; margin-left: 25px;\">流中间操作</span><span class=\"suffix\" style=\"display: flex; box-sizing: border-box; width: 200px; height: 10px; border-top-left-radius: 20px; background: RGBA(64, 184, 250, .5); color: rgb(255, 255, 255); font-size: 16px; letter-spacing: 0.544px; justify-content: flex-end; float: right; margin-top: -10px; box-sizing: border-box !important; overflow-wrap: break-word !important;\"></span></h2>\n<p data-tool=\"mdnice编辑器\" style=\"padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: #2b2b2b; margin: 10px 0px; letter-spacing: 2px; font-size: 14px; word-spacing: 2px;\">流的中间操作分为三大类:筛选切片、映射、排序。</p>\n<p data-tool=\"mdnice编辑器\" style=\"padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: #2b2b2b; margin: 10px 0px; letter-spacing: 2px; font-size: 14px; word-spacing: 2px;\">筛选切片:类似sql 中where 条件判断的意思，对元素进行筛选操作</p>\n<p data-tool=\"mdnice编辑器\" style=\"padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: #2b2b2b; margin: 10px 0px; letter-spacing: 2px; font-size: 14px; word-spacing: 2px;\">映射:对元素结果进行转换 ，优点类似select 字段意思或者对元素内容进行转换处理</p>\n<p data-tool=\"mdnice编辑器\" style=\"padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: #2b2b2b; margin: 10px 0px; letter-spacing: 2px; font-size: 14px; word-spacing: 2px;\">排序:比较好理解 ，常用sql 中按字段升序 降序操作</p>\n<figure data-tool=\"mdnice编辑器\" style=\"margin: 0; margin-top: 10px; margin-bottom: 10px; display: flex; flex-direction: column; justify-content: center; align-items: center;\"><img src=\"https://cushier.coding.net/p/picture/d/picture/git/raw/master/20200810161131.png\" alt style=\"max-width: 100%; border-radius: 6px; display: block; margin: 20px auto; object-fit: contain; box-shadow: 2px 4px 7px #999;\"></figure>\n<p data-tool=\"mdnice编辑器\" style=\"padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: #2b2b2b; margin: 10px 0px; letter-spacing: 2px; font-size: 14px; word-spacing: 2px;\">流中间操作数据准备（这里以订单数据处理为例）</p>\n<pre class=\"custom\" data-tool=\"mdnice编辑器\" style=\"margin-top: 10px; margin-bottom: 10px;\"><code class=\"hljs\" style=\"overflow-x: auto; padding: 16px; color: #abb2bf; background: #282c34; display: -webkit-box; font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; border-radius: 0px; font-size: 12px; -webkit-overflow-scrolling: touch; letter-spacing: 0px;\"><span class=\"hljs-meta\" style=\"color: #61aeee; line-height: 26px;\">@Data</span><br><span class=\"hljs-keyword\" style=\"color: #c678dd; line-height: 26px;\">public</span>&nbsp;<span class=\"hljs-class\" style=\"line-height: 26px;\"><span class=\"hljs-keyword\" style=\"color: #c678dd; line-height: 26px;\">class</span>&nbsp;<span class=\"hljs-title\" style=\"color: #e6c07b; line-height: 26px;\">Order</span>&nbsp;</span>{<br>&nbsp;&nbsp;&nbsp;&nbsp;<span class=\"hljs-comment\" style=\"color: #5c6370; font-style: italic; line-height: 26px;\">//&nbsp;订单id</span><br>&nbsp;&nbsp;&nbsp;&nbsp;<span class=\"hljs-keyword\" style=\"color: #c678dd; line-height: 26px;\">private</span>&nbsp;Integer&nbsp;id;<br>&nbsp;&nbsp;&nbsp;&nbsp;<span class=\"hljs-comment\" style=\"color: #5c6370; font-style: italic; line-height: 26px;\">//&nbsp;订单用户id</span><br>&nbsp;&nbsp;&nbsp;&nbsp;<span class=\"hljs-keyword\" style=\"color: #c678dd; line-height: 26px;\">private</span>&nbsp;Integer&nbsp;userId;<br>&nbsp;&nbsp;&nbsp;&nbsp;<span class=\"hljs-comment\" style=\"color: #5c6370; font-style: italic; line-height: 26px;\">//&nbsp;订单编号</span><br>&nbsp;&nbsp;&nbsp;&nbsp;<span class=\"hljs-keyword\" style=\"color: #c678dd; line-height: 26px;\">private</span>&nbsp;String&nbsp;orderNo;<br>&nbsp;&nbsp;&nbsp;&nbsp;<span class=\"hljs-comment\" style=\"color: #5c6370; font-style: italic; line-height: 26px;\">//&nbsp;订单日期</span><br>&nbsp;&nbsp;&nbsp;&nbsp;<span class=\"hljs-keyword\" style=\"color: #c678dd; line-height: 26px;\">private</span>&nbsp;Date&nbsp;orderDate;<br>&nbsp;&nbsp;&nbsp;&nbsp;<span class=\"hljs-comment\" style=\"color: #5c6370; font-style: italic; line-height: 26px;\">//&nbsp;收货地址</span><br>&nbsp;&nbsp;&nbsp;&nbsp;<span class=\"hljs-keyword\" style=\"color: #c678dd; line-height: 26px;\">private</span>&nbsp;String&nbsp;address;<br>&nbsp;&nbsp;&nbsp;&nbsp;<span class=\"hljs-comment\" style=\"color: #5c6370; font-style: italic; line-height: 26px;\">//&nbsp;创建时间</span><br>&nbsp;&nbsp;&nbsp;&nbsp;<span class=\"hljs-keyword\" style=\"color: #c678dd; line-height: 26px;\">private</span>&nbsp;Date&nbsp;createDate;<br>&nbsp;&nbsp;&nbsp;&nbsp;<span class=\"hljs-comment\" style=\"color: #5c6370; font-style: italic; line-height: 26px;\">//&nbsp;更新时间</span><br>&nbsp;&nbsp;&nbsp;&nbsp;<span class=\"hljs-keyword\" style=\"color: #c678dd; line-height: 26px;\">private</span>&nbsp;Date&nbsp;updateDate;<br>&nbsp;&nbsp;&nbsp;&nbsp;<span class=\"hljs-comment\" style=\"color: #5c6370; font-style: italic; line-height: 26px;\">//&nbsp;订单状态&nbsp;&nbsp;0-未支付&nbsp;&nbsp;1-已支付&nbsp;&nbsp;2-待发货&nbsp;&nbsp;3-已发货&nbsp;&nbsp;4-已接收&nbsp;&nbsp;5-已完成</span><br>&nbsp;&nbsp;&nbsp;&nbsp;<span class=\"hljs-keyword\" style=\"color: #c678dd; line-height: 26px;\">private</span>&nbsp;Integer&nbsp;status;<br>&nbsp;&nbsp;&nbsp;&nbsp;<span class=\"hljs-comment\" style=\"color: #5c6370; font-style: italic; line-height: 26px;\">//&nbsp;是否有效&nbsp;&nbsp;1-有效订单&nbsp;&nbsp;0-无效订单</span><br>&nbsp;&nbsp;&nbsp;&nbsp;<span class=\"hljs-keyword\" style=\"color: #c678dd; line-height: 26px;\">private</span>&nbsp;Integer&nbsp;isValid;<br>&nbsp;&nbsp;&nbsp;&nbsp;<span class=\"hljs-comment\" style=\"color: #5c6370; font-style: italic; line-height: 26px;\">//订单总金额</span><br>&nbsp;&nbsp;&nbsp;&nbsp;<span class=\"hljs-keyword\" style=\"color: #c678dd; line-height: 26px;\">private</span>&nbsp;&nbsp;Double&nbsp;total;<br>&nbsp;&nbsp;}<br><br>Order&nbsp;order01&nbsp;=&nbsp;<span class=\"hljs-keyword\" style=\"color: #c678dd; line-height: 26px;\">new</span>&nbsp;Order(<span class=\"hljs-number\" style=\"color: #d19a66; line-height: 26px;\">1</span>,&nbsp;<span class=\"hljs-number\" style=\"color: #d19a66; line-height: 26px;\">10</span>,&nbsp;<span class=\"hljs-string\" style=\"color: #98c379; line-height: 26px;\">\"20190301\"</span>,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class=\"hljs-keyword\" style=\"color: #c678dd; line-height: 26px;\">new</span>&nbsp;Date(),&nbsp;<span class=\"hljs-string\" style=\"color: #98c379; line-height: 26px;\">\"上海市-浦东区\"</span>,&nbsp;<span class=\"hljs-keyword\" style=\"color: #c678dd; line-height: 26px;\">new</span>&nbsp;Date(),&nbsp;<span class=\"hljs-keyword\" style=\"color: #c678dd; line-height: 26px;\">new</span>&nbsp;Date(),&nbsp;<span class=\"hljs-number\" style=\"color: #d19a66; line-height: 26px;\">4</span>,&nbsp;<span class=\"hljs-number\" style=\"color: #d19a66; line-height: 26px;\">1</span>,&nbsp;<span class=\"hljs-number\" style=\"color: #d19a66; line-height: 26px;\">100.0</span>);<br>Order&nbsp;order02&nbsp;=&nbsp;<span class=\"hljs-keyword\" style=\"color: #c678dd; line-height: 26px;\">new</span>&nbsp;Order(<span class=\"hljs-number\" style=\"color: #d19a66; line-height: 26px;\">2</span>,&nbsp;<span class=\"hljs-number\" style=\"color: #d19a66; line-height: 26px;\">30</span>,&nbsp;<span class=\"hljs-string\" style=\"color: #98c379; line-height: 26px;\">\"20190302\"</span>,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class=\"hljs-keyword\" style=\"color: #c678dd; line-height: 26px;\">new</span>&nbsp;Date(),&nbsp;<span class=\"hljs-string\" style=\"color: #98c379; line-height: 26px;\">\"北京市四惠区\"</span>,&nbsp;<span class=\"hljs-keyword\" style=\"color: #c678dd; line-height: 26px;\">new</span>&nbsp;Date(),&nbsp;<span class=\"hljs-keyword\" style=\"color: #c678dd; line-height: 26px;\">new</span>&nbsp;Date(),&nbsp;<span class=\"hljs-number\" style=\"color: #d19a66; line-height: 26px;\">1</span>,&nbsp;<span class=\"hljs-number\" style=\"color: #d19a66; line-height: 26px;\">1</span>,&nbsp;<span class=\"hljs-number\" style=\"color: #d19a66; line-height: 26px;\">2000.0</span>);<br>Order&nbsp;order03&nbsp;=&nbsp;<span class=\"hljs-keyword\" style=\"color: #c678dd; line-height: 26px;\">new</span>&nbsp;Order(<span class=\"hljs-number\" style=\"color: #d19a66; line-height: 26px;\">3</span>,&nbsp;<span class=\"hljs-number\" style=\"color: #d19a66; line-height: 26px;\">20</span>,&nbsp;<span class=\"hljs-string\" style=\"color: #98c379; line-height: 26px;\">\"20190303\"</span>,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class=\"hljs-keyword\" style=\"color: #c678dd; line-height: 26px;\">new</span>&nbsp;Date(),&nbsp;<span class=\"hljs-string\" style=\"color: #98c379; line-height: 26px;\">\"北京市-朝阳区\"</span>,&nbsp;<span class=\"hljs-keyword\" style=\"color: #c678dd; line-height: 26px;\">new</span>&nbsp;Date(),&nbsp;<span class=\"hljs-keyword\" style=\"color: #c678dd; line-height: 26px;\">new</span>&nbsp;Date(),&nbsp;<span class=\"hljs-number\" style=\"color: #d19a66; line-height: 26px;\">4</span>,&nbsp;<span class=\"hljs-number\" style=\"color: #d19a66; line-height: 26px;\">1</span>,&nbsp;<span class=\"hljs-number\" style=\"color: #d19a66; line-height: 26px;\">500.0</span>);<br>Order&nbsp;order04&nbsp;=&nbsp;<span class=\"hljs-keyword\" style=\"color: #c678dd; line-height: 26px;\">new</span>&nbsp;Order(<span class=\"hljs-number\" style=\"color: #d19a66; line-height: 26px;\">4</span>,&nbsp;<span class=\"hljs-number\" style=\"color: #d19a66; line-height: 26px;\">40</span>,&nbsp;<span class=\"hljs-string\" style=\"color: #98c379; line-height: 26px;\">\"20190304\"</span>,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class=\"hljs-keyword\" style=\"color: #c678dd; line-height: 26px;\">new</span>&nbsp;Date(),&nbsp;<span class=\"hljs-string\" style=\"color: #98c379; line-height: 26px;\">\"北京市-大兴区\"</span>,&nbsp;<span class=\"hljs-keyword\" style=\"color: #c678dd; line-height: 26px;\">new</span>&nbsp;Date(),&nbsp;<span class=\"hljs-keyword\" style=\"color: #c678dd; line-height: 26px;\">new</span>&nbsp;Date(),&nbsp;<span class=\"hljs-number\" style=\"color: #d19a66; line-height: 26px;\">4</span>,&nbsp;<span class=\"hljs-number\" style=\"color: #d19a66; line-height: 26px;\">1</span>,&nbsp;<span class=\"hljs-number\" style=\"color: #d19a66; line-height: 26px;\">256.0</span>);<br>Order&nbsp;order05&nbsp;=&nbsp;<span class=\"hljs-keyword\" style=\"color: #c678dd; line-height: 26px;\">new</span>&nbsp;Order(<span class=\"hljs-number\" style=\"color: #d19a66; line-height: 26px;\">5</span>,&nbsp;<span class=\"hljs-number\" style=\"color: #d19a66; line-height: 26px;\">40</span>,&nbsp;<span class=\"hljs-string\" style=\"color: #98c379; line-height: 26px;\">\"20190304\"</span>,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class=\"hljs-keyword\" style=\"color: #c678dd; line-height: 26px;\">new</span>&nbsp;Date(),&nbsp;<span class=\"hljs-string\" style=\"color: #98c379; line-height: 26px;\">\"上海市-松江区\"</span>,&nbsp;<span class=\"hljs-keyword\" style=\"color: #c678dd; line-height: 26px;\">new</span>&nbsp;Date(),&nbsp;<span class=\"hljs-keyword\" style=\"color: #c678dd; line-height: 26px;\">new</span>&nbsp;Date(),&nbsp;<span class=\"hljs-number\" style=\"color: #d19a66; line-height: 26px;\">4</span>,&nbsp;<span class=\"hljs-number\" style=\"color: #d19a66; line-height: 26px;\">1</span>,&nbsp;<span class=\"hljs-number\" style=\"color: #d19a66; line-height: 26px;\">1000.0</span>);<br>ordersList&nbsp;=&nbsp;Arrays.asList(order01,&nbsp;order02,&nbsp;order03,&nbsp;order04,&nbsp;order05);<br></code></pre>\n<h2 data-tool=\"mdnice编辑器\" style=\"margin-top: 30px; margin-bottom: 15px; padding: 0px; font-weight: bold; color: black; font-size: 22px; display: block; border-bottom: 4px solid #40B8FA;\"><span class=\"prefix\" style=\"display: flex; width: 20px; height: 20px; background-size: 20px 20px; background-image: url(https://my-wechat.mdnice.com/fullstack-1.png); margin-bottom: -22px;\"></span><span class=\"content\" style=\"display: flex; color: #40B8FA; font-size: 20px; margin-left: 25px;\">筛选&amp;切片</span><span class=\"suffix\" style=\"display: flex; box-sizing: border-box; width: 200px; height: 10px; border-top-left-radius: 20px; background: RGBA(64, 184, 250, .5); color: rgb(255, 255, 255); font-size: 16px; letter-spacing: 0.544px; justify-content: flex-end; float: right; margin-top: -10px; box-sizing: border-box !important; overflow-wrap: break-word !important;\"></span></h2>\n<ul data-tool=\"mdnice编辑器\" style=\"margin-top: 8px; margin-bottom: 8px; padding-left: 25px; font-size: 15px; color: #595959; list-style-type: circle;\">\n<li><section style=\"margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; font-size: 14px; font-weight: normal; color: #595959;\">筛选有效订单</section></li></ul>\n<pre class=\"custom\" data-tool=\"mdnice编辑器\" style=\"margin-top: 10px; margin-bottom: 10px;\"><code class=\"hljs\" style=\"overflow-x: auto; padding: 16px; color: #abb2bf; background: #282c34; display: -webkit-box; font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; border-radius: 0px; font-size: 12px; -webkit-overflow-scrolling: touch; letter-spacing: 0px;\"><span class=\"hljs-comment\" style=\"color: #5c6370; font-style: italic; line-height: 26px;\">//&nbsp;过滤有效订单</span><br>ordersList.stream().filter((order)&nbsp;-&gt;&nbsp;order.getIsValid()&nbsp;==&nbsp;<span class=\"hljs-number\" style=\"color: #d19a66; line-height: 26px;\">1</span>)<br>&nbsp;&nbsp;&nbsp;&nbsp;.forEach(System.out::println);<br></code></pre>\n<ul data-tool=\"mdnice编辑器\" style=\"margin-top: 8px; margin-bottom: 8px; padding-left: 25px; font-size: 15px; color: #595959; list-style-type: circle;\">\n<li><section style=\"margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; font-size: 14px; font-weight: normal; color: #595959;\">筛选有效订单 取第一页数据(每页2条记录)</section></li></ul>\n<pre class=\"custom\" data-tool=\"mdnice编辑器\" style=\"margin-top: 10px; margin-bottom: 10px;\"><code class=\"hljs\" style=\"overflow-x: auto; padding: 16px; color: #abb2bf; background: #282c34; display: -webkit-box; font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; border-radius: 0px; font-size: 12px; -webkit-overflow-scrolling: touch; letter-spacing: 0px;\">&nbsp;<span class=\"hljs-comment\" style=\"color: #5c6370; font-style: italic; line-height: 26px;\">//&nbsp;过滤有效订单&nbsp;取第一页数据(每页2条记录)&nbsp;</span><br>&nbsp;ordersList.stream().filter((order)&nbsp;-&gt;&nbsp;order.getIsValid()&nbsp;==&nbsp;<span class=\"hljs-number\" style=\"color: #d19a66; line-height: 26px;\">1</span>)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;.limit(<span class=\"hljs-number\" style=\"color: #d19a66; line-height: 26px;\">2</span>)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;.forEach(System.out::println);<br></code></pre>\n<ul data-tool=\"mdnice编辑器\" style=\"margin-top: 8px; margin-bottom: 8px; padding-left: 25px; font-size: 15px; color: #595959; list-style-type: circle;\">\n<li><section style=\"margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; font-size: 14px; font-weight: normal; color: #595959;\">筛选订单集合有效订单 取最后一条记录</section></li></ul>\n<pre class=\"custom\" data-tool=\"mdnice编辑器\" style=\"margin-top: 10px; margin-bottom: 10px;\"><code class=\"hljs\" style=\"overflow-x: auto; padding: 16px; color: #abb2bf; background: #282c34; display: -webkit-box; font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; border-radius: 0px; font-size: 12px; -webkit-overflow-scrolling: touch; letter-spacing: 0px;\"><span class=\"hljs-comment\" style=\"color: #5c6370; font-style: italic; line-height: 26px;\">//&nbsp;过滤订单集合有效订单&nbsp;取最后一条记录</span><br>ordersList.stream().filter((order)&nbsp;-&gt;&nbsp;order.getIsValid()&nbsp;==&nbsp;<span class=\"hljs-number\" style=\"color: #d19a66; line-height: 26px;\">1</span>)<br>&nbsp;&nbsp;&nbsp;&nbsp;.skip(ordersList.size()&nbsp;-&nbsp;<span class=\"hljs-number\" style=\"color: #d19a66; line-height: 26px;\">2</span>)&nbsp;&nbsp;<span class=\"hljs-comment\" style=\"color: #5c6370; font-style: italic; line-height: 26px;\">//&nbsp;跳过前ordersList.size()-2&nbsp;记录</span><br>&nbsp;&nbsp;&nbsp;&nbsp;.forEach(System.out::println);<br></code></pre>\n<ul data-tool=\"mdnice编辑器\" style=\"margin-top: 8px; margin-bottom: 8px; padding-left: 25px; font-size: 15px; color: #595959; list-style-type: circle;\">\n<li><section style=\"margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; font-size: 14px; font-weight: normal; color: #595959;\">筛选有效订单 取第3页数据(每页2条记录)</section></li></ul>\n<pre class=\"custom\" data-tool=\"mdnice编辑器\" style=\"margin-top: 10px; margin-bottom: 10px;\"><code class=\"hljs\" style=\"overflow-x: auto; padding: 16px; color: #abb2bf; background: #282c34; display: -webkit-box; font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; border-radius: 0px; font-size: 12px; -webkit-overflow-scrolling: touch; letter-spacing: 0px;\"><span class=\"hljs-comment\" style=\"color: #5c6370; font-style: italic; line-height: 26px;\">//&nbsp;过滤有效订单&nbsp;取第3页数据(每页2条记录)&nbsp;并打印到控制台</span><br>ordersList.stream().filter((order)&nbsp;-&gt;&nbsp;order.getIsValid()&nbsp;==&nbsp;<span class=\"hljs-number\" style=\"color: #d19a66; line-height: 26px;\">1</span>)<br>&nbsp;&nbsp;&nbsp;&nbsp;.skip((<span class=\"hljs-number\" style=\"color: #d19a66; line-height: 26px;\">3</span>&nbsp;-&nbsp;<span class=\"hljs-number\" style=\"color: #d19a66; line-height: 26px;\">1</span>)&nbsp;*&nbsp;<span class=\"hljs-number\" style=\"color: #d19a66; line-height: 26px;\">2</span>)<br>&nbsp;&nbsp;&nbsp;&nbsp;.limit(<span class=\"hljs-number\" style=\"color: #d19a66; line-height: 26px;\">2</span>)<br>&nbsp;&nbsp;&nbsp;&nbsp;.forEach(System.out::println);<br></code></pre>\n<ul data-tool=\"mdnice编辑器\" style=\"margin-top: 8px; margin-bottom: 8px; padding-left: 25px; font-size: 15px; color: #595959; list-style-type: circle;\">\n<li><section style=\"margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; font-size: 14px; font-weight: normal; color: #595959;\">筛选无效订单去除重复订单号记录</section></li></ul>\n<pre class=\"custom\" data-tool=\"mdnice编辑器\" style=\"margin-top: 10px; margin-bottom: 10px;\"><code class=\"hljs\" style=\"overflow-x: auto; padding: 16px; color: #abb2bf; background: #282c34; display: -webkit-box; font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; border-radius: 0px; font-size: 12px; -webkit-overflow-scrolling: touch; letter-spacing: 0px;\"><span class=\"hljs-comment\" style=\"color: #5c6370; font-style: italic; line-height: 26px;\">//&nbsp;过滤无效订单&nbsp;去除重复订单号记录&nbsp;&nbsp;重写Order&nbsp;equals&nbsp;与&nbsp;hashCode&nbsp;方法</span><br>ordersList.stream().filter((order)&nbsp;-&gt;&nbsp;order.getIsValid()&nbsp;==&nbsp;<span class=\"hljs-number\" style=\"color: #d19a66; line-height: 26px;\">0</span>)<br>&nbsp;&nbsp;&nbsp;&nbsp;.distinct()<br>&nbsp;&nbsp;&nbsp;&nbsp;.forEach(System.out::println);<br></code></pre>\n<h2 data-tool=\"mdnice编辑器\" style=\"margin-top: 30px; margin-bottom: 15px; padding: 0px; font-weight: bold; color: black; font-size: 22px; display: block; border-bottom: 4px solid #40B8FA;\"><span class=\"prefix\" style=\"display: flex; width: 20px; height: 20px; background-size: 20px 20px; background-image: url(https://my-wechat.mdnice.com/fullstack-1.png); margin-bottom: -22px;\"></span><span class=\"content\" style=\"display: flex; color: #40B8FA; font-size: 20px; margin-left: 25px;\">映射</span><span class=\"suffix\" style=\"display: flex; box-sizing: border-box; width: 200px; height: 10px; border-top-left-radius: 20px; background: RGBA(64, 184, 250, .5); color: rgb(255, 255, 255); font-size: 16px; letter-spacing: 0.544px; justify-content: flex-end; float: right; margin-top: -10px; box-sizing: border-box !important; overflow-wrap: break-word !important;\"></span></h2>\n<ul data-tool=\"mdnice编辑器\" style=\"margin-top: 8px; margin-bottom: 8px; padding-left: 25px; font-size: 15px; color: #595959; list-style-type: circle;\">\n<li><section style=\"margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; font-size: 14px; font-weight: normal; color: #595959;\">过滤有效订单,获取所有订单编号</section></li></ul>\n<pre class=\"custom\" data-tool=\"mdnice编辑器\" style=\"margin-top: 10px; margin-bottom: 10px;\"><code class=\"hljs\" style=\"overflow-x: auto; padding: 16px; color: #abb2bf; background: #282c34; display: -webkit-box; font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; border-radius: 0px; font-size: 12px; -webkit-overflow-scrolling: touch; letter-spacing: 0px;\"><span class=\"hljs-comment\" style=\"color: #5c6370; font-style: italic; line-height: 26px;\">//过滤有效订单，获取所有订单编号</span><br>ordersList.stream().filter((order)&nbsp;-&gt;&nbsp;order.getIsValid()&nbsp;==&nbsp;<span class=\"hljs-number\" style=\"color: #d19a66; line-height: 26px;\">1</span>)<br>&nbsp;&nbsp;&nbsp;&nbsp;.map((order)&nbsp;-&gt;&nbsp;order.getOrderNo())<br>&nbsp;&nbsp;&nbsp;&nbsp;.forEach(System.out::println);<br></code></pre>\n<ul data-tool=\"mdnice编辑器\" style=\"margin-top: 8px; margin-bottom: 8px; padding-left: 25px; font-size: 15px; color: #595959; list-style-type: circle;\">\n<li><section style=\"margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; font-size: 14px; font-weight: normal; color: #595959;\">过滤有效订单 ,并分离每个订单下收货地址市区信息</section></li></ul>\n<pre class=\"custom\" data-tool=\"mdnice编辑器\" style=\"margin-top: 10px; margin-bottom: 10px;\"><code class=\"hljs\" style=\"overflow-x: auto; padding: 16px; color: #abb2bf; background: #282c34; display: -webkit-box; font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; border-radius: 0px; font-size: 12px; -webkit-overflow-scrolling: touch; letter-spacing: 0px;\">ordersList.stream().map(o&nbsp;-&gt;&nbsp;o.getAddress()<br>&nbsp;&nbsp;&nbsp;&nbsp;.split(<span class=\"hljs-string\" style=\"color: #98c379; line-height: 26px;\">\"-\"</span>))<br>&nbsp;&nbsp;&nbsp;&nbsp;.flatMap(Arrays::stream)<br>&nbsp;&nbsp;&nbsp;&nbsp;.forEach(System.out::println);<br></code></pre>\n<h2 data-tool=\"mdnice编辑器\" style=\"margin-top: 30px; margin-bottom: 15px; padding: 0px; font-weight: bold; color: black; font-size: 22px; display: block; border-bottom: 4px solid #40B8FA;\"><span class=\"prefix\" style=\"display: flex; width: 20px; height: 20px; background-size: 20px 20px; background-image: url(https://my-wechat.mdnice.com/fullstack-1.png); margin-bottom: -22px;\"></span><span class=\"content\" style=\"display: flex; color: #40B8FA; font-size: 20px; margin-left: 25px;\">排序</span><span class=\"suffix\" style=\"display: flex; box-sizing: border-box; width: 200px; height: 10px; border-top-left-radius: 20px; background: RGBA(64, 184, 250, .5); color: rgb(255, 255, 255); font-size: 16px; letter-spacing: 0.544px; justify-content: flex-end; float: right; margin-top: -10px; box-sizing: border-box !important; overflow-wrap: break-word !important;\"></span></h2>\n<ul data-tool=\"mdnice编辑器\" style=\"margin-top: 8px; margin-bottom: 8px; padding-left: 25px; font-size: 15px; color: #595959; list-style-type: circle;\">\n<li><section style=\"margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; font-size: 14px; font-weight: normal; color: #595959;\">过滤有效订单 根据用户id 进行排序</section></li></ul>\n<pre class=\"custom\" data-tool=\"mdnice编辑器\" style=\"margin-top: 10px; margin-bottom: 10px;\"><code class=\"hljs\" style=\"overflow-x: auto; padding: 16px; color: #abb2bf; background: #282c34; display: -webkit-box; font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; border-radius: 0px; font-size: 12px; -webkit-overflow-scrolling: touch; letter-spacing: 0px;\"><span class=\"hljs-comment\" style=\"color: #5c6370; font-style: italic; line-height: 26px;\">//过滤有效订单&nbsp;根据用户id&nbsp;进行排序</span><br>ordersList.stream().filter((order)&nbsp;-&gt;&nbsp;order.getIsValid()&nbsp;==&nbsp;<span class=\"hljs-number\" style=\"color: #d19a66; line-height: 26px;\">1</span>)<br>&nbsp;&nbsp;&nbsp;&nbsp;.sorted((o1,&nbsp;o2)&nbsp;-&gt;&nbsp;o1.getUserId()&nbsp;-&nbsp;o2.getUserId())<br>&nbsp;&nbsp;&nbsp;&nbsp;.forEach(System.out::println);&nbsp;&nbsp;<br><br>&nbsp;<span class=\"hljs-comment\" style=\"color: #5c6370; font-style: italic; line-height: 26px;\">//或者等价写法&nbsp;</span><br>ordersList.stream().filter((order)&nbsp;-&gt;&nbsp;order.getIsValid()&nbsp;==&nbsp;<span class=\"hljs-number\" style=\"color: #d19a66; line-height: 26px;\">1</span>)<br>&nbsp;&nbsp;&nbsp;&nbsp;.sorted(Comparator.comparingInt(Order::getUserId))<br>&nbsp;&nbsp;&nbsp;&nbsp;.forEach(System.out::println);<br></code></pre>\n<ul data-tool=\"mdnice编辑器\" style=\"margin-top: 8px; margin-bottom: 8px; padding-left: 25px; font-size: 15px; color: #595959; list-style-type: circle;\">\n<li><section style=\"margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; font-size: 14px; font-weight: normal; color: #595959;\">过滤有效订单 ,根据订单状态排序 如果订单状态相同根据订单创建时间排序</section></li></ul>\n<pre class=\"custom\" data-tool=\"mdnice编辑器\" style=\"margin-top: 10px; margin-bottom: 10px;\"><code class=\"hljs\" style=\"overflow-x: auto; padding: 16px; color: #abb2bf; background: #282c34; display: -webkit-box; font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; border-radius: 0px; font-size: 12px; -webkit-overflow-scrolling: touch; letter-spacing: 0px;\"><span class=\"hljs-comment\" style=\"color: #5c6370; font-style: italic; line-height: 26px;\">//过滤有效订单&nbsp;&nbsp;如果订单状态相同&nbsp;根据订单创建时间排序&nbsp;反之根据订单状态排序</span><br>ordersList.stream().filter((order)&nbsp;-&gt;&nbsp;order.getIsValid()&nbsp;==&nbsp;<span class=\"hljs-number\" style=\"color: #d19a66; line-height: 26px;\">1</span>)<br>&nbsp;&nbsp;&nbsp;&nbsp;.sorted((o1,&nbsp;o2)&nbsp;-&gt;&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class=\"hljs-keyword\" style=\"color: #c678dd; line-height: 26px;\">if</span>&nbsp;(o1.getStatus().equals(o2.getStatus()))&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class=\"hljs-keyword\" style=\"color: #c678dd; line-height: 26px;\">return</span>&nbsp;o1.getCreateDate().compareTo(o2.getCreateDate());<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;<span class=\"hljs-keyword\" style=\"color: #c678dd; line-height: 26px;\">else</span>&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class=\"hljs-keyword\" style=\"color: #c678dd; line-height: 26px;\">return</span>&nbsp;o1.getStatus().compareTo(o2.getStatus());<br>&nbsp;&nbsp;&nbsp;&nbsp;}})<br>&nbsp;&nbsp;&nbsp;&nbsp;.forEach(System.out::println);<br><br><br><span class=\"hljs-comment\" style=\"color: #5c6370; font-style: italic; line-height: 26px;\">//&nbsp;等价形式</span><br>ordersList.stream().filter((order)&nbsp;-&gt;&nbsp;order.getIsValid()&nbsp;==&nbsp;<span class=\"hljs-number\" style=\"color: #d19a66; line-height: 26px;\">1</span>)<br>&nbsp;&nbsp;&nbsp;&nbsp;.sorted(Comparator.comparing(Order::getCreateDate)<br>&nbsp;&nbsp;&nbsp;&nbsp;.thenComparing(Comparator.comparing(Order::getStatus)))<br>&nbsp;&nbsp;&nbsp;&nbsp;.forEach(System.out::println);<br></code></pre>\n", "user_name": "同一片蓝天下", "description": "一个呆萌の小小程序员", "got_view_count": 2085, "category_name": "后端", "ctime": 1457483880}
{"tag_name": "ECMAScript 6", "concern_user_count": 156509, "user_id": "3825956197502558", "title": "一文带你了解ES6 Module", "mark_content": "## 前言\n\n> 大家好，我是**Frank**。我们每天都在用 `import` 、`export`，但好像从没有真正了解过它，那么今天我们就一起来了解一下。\n\n## 正文\n> 我们都知道，`es6` 之前Javascript从未提供过模块的概念，像Ruby的 `required` 、Python的 `import` ，甚至CSS都有 `@import` 。说到 `es6` 的模块我们就需要说一下模块的由来。\n\n> 在JS初期，因为JS逻辑都比较简单，内容也比较少，所以就没有模块化、工程化的概念。但随着前端技术的发展，前端逻辑也越来越复杂，如果我们把内容都写到一个文件里，那势必会造成不可维护。于是，JS也像后端语言一样推出了模块化、工程化的概念。\n\n### 1.commonJS\n> 在说 `es6` 模块以前，我们先来看一下后端普遍使用的打包方式，commonJS的一些特性。\n\n+ 同步加载\n> 也就是串行执行，后面的任务要等到前面任务执行完才能继续执行。\n\n+ 语法\n> commonJS中使用 `require` 引入，`module.exports` 输出。\n\n+ 执行顺序：\n> `commonJS输出的是一个值得拷贝`。也就是说，一旦输出一个值（该值会被缓存起来），模块内部的变化就不会影响到这个值。过程大概是，先将引入模块执行一遍，再执行后面的方法，等到内容执行完，生成一个变量存储需要输出的内容。仔细阅读以下代码\n```javascript\n// module.js\nlet a = 1;\nfunction foo(){\n    a++;\n}\nmodule.exports = {foo, a};\n\n// index.js\nlet {foo, a} = require('./module.js');\nconsole.log(a); // 1\nfoo();\nconsole.log(a); // 1\n```\n+ 意义\n> commonJS的意义在于将聚类的方法和变量等限定的私有域中，同时支持导入和导出，将上下游模块无缝衔接，每个模块具有独立的空间，互不干扰。\n\n\n### 2.import、export\n> ES6以后出现的import、export很好的实现了模块功能。核心思想是尽量`静态化`，使得`编译时`就能确定依赖关系，以及输出和输入的变量。而commonJS是在运行时确定这些东西。\n\n+ 因为这个原因，有产生了以下两个问题：\n> 1.`import`、`export`都必须写在模块顶层\n> 2.引入的模块应该是可以静态分析的，所以不允许运行时改变。也就是路径中不能使用变量。即无法实现如下代码中展示的require的功能\n```javascript\n// commonJS require\nlet path = './module'\nlet module = require(path);\n```\n\n+ 异步加载\n> 也就是并发执行，模块`几乎`同时导入，后面模块不需要等待前面模块导入完成。\n\n+ 语法\n> `ES6 Module`中使用`import`引入，`export`输出。\n\n+ 执行顺序\n> `ES6 Module 输出的是值的动态引用`，不会缓存。还是相同的代码，对比commonJS\n```javascript\n// module.js\nlet a = 1;\nfunction foo(){\n    a++;\n}\nexport {foo, a};\n\n// index.js\nlet {foo, a} = require('./module.js');\nconsole.log(a); // 1\nfoo();\nconsole.log(a); // 2\n```\n\n+ `import` 可以执行模块，多次`import`只会执行一次，`import`在静态解析阶段执行\n```javascript\nimport foo from './module';\nimport foo from './module';\n```\n> 以上代码中`foo`只会被导入一次\n\n+ `import * as module from './module'`引入`module.js`中所有的方法并存放到变量`module`中。\n\n+ 为模块指定默认输出，一个文件中只能有一个`export default`，且后面不能跟变量声明的语句\n```javascript\n// 与普通输出的区别\nexport default function add(){}\nimport add from './add'\n\nexport function add(){}\nimport {add} from './add'\n```\n> 本质上，`export default` 就是输出一个叫 `default` 的变量或者方法，然后系统允许你为它重命名。所以下面写法也是等效的\n\n```javascript\nfunction add(){}\n\nexport {add as default}; // 等同于export default add\n\nimport {default as foo} from './module'; // 等同于import foo from './module'\n```\n\n### 3.export 与 import 的复合写法\n\n```javascript\nexport {foo,bar} from 'module';\n// 等同于\nimport {foo,bar} from 'module;\nexport {foo,bar}\n```\n> 上面代码中，`export`和`import`语句可以结合为一行代码。但是，写成一行以后，`foo`和`bar`实际上没有被导入当前模块，只是相当于当前对外转发了这两个接口，导致当前模块不能直接使用`foo`，`bar`。\n\n### 4.跨模块常量\n+ const声明的常量只能在当前代码块中有效。如果想设置跨模块的常量，可以采用以下写法：\n```javascript\nexport const db = {\n    a: '1',\n    b: '2',\n    ...\n}\n\nimport {db} from './module';\n```\n> vue项目中props应用，这样子组件就可以自己修改props中的属性，而不需要通过调用父组件的方法了。\n```javascript\n// 父组件\n<Child :userInfo=\"userIinfo\"/>\ndata(){\n    return{\n        userInfo:{\n            name: '小明',\n            age:18\n        }\n    }\n}\n// 子组件\nprops:{\n    value(){\n        type: Object\n    }\n},\ncreated(){\n    this.value.name = '小红';\n}\n```\n\n### 5.import()函数\n+ 上文我们说过，import的模块需要静态分析，所以不能用于动态加载。也就不能完成`required`同样的功能\n```javascript\nconst path = './' + fileName;\nconst myModule = required(path);\n```\n> 因此，引入了import()函数，返回一个Promise对象\n```javascript\nimport (path).then(res=>{\n    console.log(res)\n}).catch(err=>{\n    console.log(res)\n})\n```\n+ 这个函数的引入起到的很好的作用，比如我们在做多语言加载的时候，我们需要引入语言包，但是我们又不想一次性将所有语言包全部引入，我们只需要引入需要的语言包就可以了，那么就用到了import()函数，下面是一个按需加载语言包的例子\n\n```javascript\nexport function loadLanguageAsync(lang){\n  if (i18n.locale !== lang){\n    if (!loadedLanguages.includes(lang)){\n      return import(/* webpackChunkName: \"lang-[request]\" */ '@/lang/' + lang).then(msgs=>{\n        i18n.setLocaleMessage(lang, msgs.default);\n        loadedLanguages.push(lang);\n        return setI18nLanguage(lang);\n      })\n    }\n    return Promise.resolve(setI18nLanguage(lang));\n  }\n  return Promise.resolve(lang);\n}\n```\n\n### 6.浏览器加载\n#### 传统方法\n+ `script`标签默认是同步加载的，加上`defer`和`async`就会开启异步加载。区别：\n> `defer`要等到整个页面在内存中正常渲染结束，才会执行；`async`一旦下载完，渲染引擎就会中断渲染，执行这个脚本以后，再继续渲染。另外，如果有多个`defer`脚本，会按照他们在页面中出现的顺序加载，而多个`async`脚本，是不能保证按顺序加载\n\n#### es6模块加载\n+ 浏览器加载 `es6` 模块，也是用 `<script>` 标签，不过要加入 `type=\"module\"` 属性。添加该属性后，默认开启 `defer` 属性。若想开启 `async` 属性，可以直接添加。作用同上。\n+ html中引用示例\n```javascript\n<script type=\"module\">\n    import {add, redis} from './module';\n</script>\n```\n\n#### node.js加载\n> node中原本存在的commonJS与es6的模块加载并不兼容。因此node中做了限制\n> `.mjs` 文件总是以es6模块加载； `.cjs` 文件总是以commonJS加载， `.js` 文件的加载取决于 `package.json` 中type字段，若 `type=\"module\"` 则以es6模块加载，默认commonJS\n\n## 后记\n以上是我学习`ES6 Module`之后的收获，跟大家分享，欢迎勘误，谢谢~~", "user_name": "Frank。", "description": "", "got_view_count": 396, "category_name": "前端", "ctime": 1457483942}
{"tag_name": "CSS", "concern_user_count": 258450, "user_id": "4248168659429511", "title": "CSS的解析和计算", "mark_content": "通过上一篇《DOM 的解析》，我们已经知道当浏览器接收到 HTML 文本后，会将它解析成 Token ，再构建成 DOM 树。下面我们继续分析浏览器渲染流程的样式计算，即 CSS的解析和计算。\n\n### 一、收集CSS规则\n\n浏览器开始处理 CSS 的第一步就是收集 CSS 规则。CSS 的规则来源有三种：\n\n1.  内联规则\n2.  外联规则\n3.  行内规则\n\n如果浏览器遇到了一个 `<link>` 标签，`rel` 属性是 `stylesheet`，那么它会触发资源加载，根据标签里的 `href` 属性下载该资源。这个加载是异步的，不会影响DOM树的构建。\n\n当遇到一个`<style>` 标签，整个`<style>` 标签解析结束的时候，浏览器会收集`<style>` 标签里的规则，存到一个地方。行内样式不收集。\n\n收集完 CSS 规则后，会解析 CSS 。具体过程还是先进行词法分析，生成 Token。和 HTML 解析不同的是，CSS 词法分析后，还需要进行语法分析。解析后会生成相应的规则对象，并push到规则数组中。对象的内容可以通过 `document.styleSheets` 查看。\n\n![Untitled.png (3306×1090)](https://s3.us-west-2.amazonaws.com/secure.notion-static.com/59481319-51fb-43c0-9a82-f5a6c6bc7714/Untitled.png?X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=AKIAT73L2G45O3KS52Y5%2F20200810%2Fus-west-2%2Fs3%2Faws4_request&X-Amz-Date=20200810T142459Z&X-Amz-Expires=86400&X-Amz-Signature=42f4033deacc09b217dab7905773678e47e17d3859c129022cd4f9ebfe70847c&X-Amz-SignedHeaders=host&response-content-disposition=filename%20%3D%22Untitled.png%22)  \n\n### 二、解析CSS选择器\n\n此时，CSS 规则已经被解析并放到一个规则数组里了。那么什么时候开始计算 CSS 呢？\n\n通常情况下，当 HTML 解析完一个开始标签后就开始计算 CSS。原因是 CSS4 之前，不支持父选择器。所以在一个开始标签解析完后，所有的样式规则都已经收集完毕（一些特殊情况除外，如：style标签写在 body 里，这样会重新计算）。\n\nCSS 规则的选择器是从右向左匹配。从右向左匹配时，如果当前元素不匹配，就可以直接跳过了。如果从左向右，要等到匹配最后一个选择器才能知道当前元素是否匹配。显然从右向左匹配效率会更高。\n\n举个例子：\n\n    <html>\n      <head>\n        <style>\n          body div img {\n            width: 500px;\n            height: 300px;\n          }\n        </style>\n      </head>\n      <body>\n          <div>\n            <img />\n          </div>\n      </body>\n    </html>\n\n上面代码中的 <style> 里的内容，大体会被解析成如下格式：\n\n    rule: { \n    \ttype: 'rule',\n      selectors: ['body div img'],\n      declarations: [{\n        type: 'declaration',\n        property: 'width',\n        value: '500px',\n      }, {\n        type: 'declaration',\n        property: 'height',\n        value: '300px',\n      }],\n    }\n\nselectors 是这条规则的选择器，declarations 是这条规则的内容。下面我们来看看，当解析完 <img/> 时，会如何计算 <img/> 的 CSS 规则。\n\n### 三、拆分选择器\n\nCSS 选择器由简单到复杂可以分成以下几种。\n\n*   简单选择器：针对某一特征判断是否选中元素。\n*   复合选择器：连续写在一起的简单选择器，针对元素自身特征选择单个元素。\n*   复杂选择器：由“（空格）”、“ >”、“ ~”、“ +”、“ ||”等符号连接的复合选择器，根据父元素或者前序元素检查单个元素。\n*   选择器列表：由逗号分隔的复杂选择器，表示“或”的关系。\n\n示例代码中的 `selectors: ['body div img']` 是由空格连接的复杂选择器。空格表示匹配子孙元素。复杂选择器显然是不能直接匹配标签的，所以要把这个复杂选择器拆分。我们可以把标签名拆分出来：\n\n     const selectorParts = ['body', 'div', 'img'];\n\n### 四、选择器匹配\n\n下一步就要匹配这些选择器了。当解析完`<img />` 后，浏览器会取 selectorParts 的最后一项：'img'，和当前元素 match。match 函数里实现了判断各种选择器是否和元素匹配。match 函数实现大体如下：\n\n    function match(element, selector) {\n      // element: {\n      //   type: 'element',\n      //   tagName: 'img',\n      //   children: [],\n      //   attributes: [{ \n      //     name: 'id', \n      //     value: 'myid' \n      //   }, {\n      //     name: 'class', \n      //     value: 'myclass' \n    \t//   }],\n      // }\n      //\n      // selector: 'img'\n\n      if (selector.charAt(0) === '#') {\n    \t\t// id选择器\n        const attr = element.attributes.filter(attr => attr.name === 'id')[0];\n        if (attr && attr.value === selector.replace('#', '')) {\n          return true;\n        }\n      } else if (selector.charAt(0) === '.') {\n    \t\t// class选择器\n        const attr = element.attributes.filter(attr => attr.name === 'class')[0];\n        if (attr && typeof attr.value === 'string') {\n          // 处理空格的多个class选择器\n          const classList = attr.value.split(' ');\n          if (classList.includes(selector.replace('.', ''))) {\n            return true;\n          }\n        }\n    \t} else if () {\n         // 其他选择器\n    \t\t ......\n      } else if (element.tagName === selector) {\n    \t\t// 标签选择器\n        return true;\n      }\n      return false;\n    }\n\n如果匹配。下一步就是取 selectorParts 的倒数第二项：'div'，看是否和 img 标签的父元素匹配。就这样依次匹配 selectorParts 中的元素，直到结束。如果一直匹配，则表示选择器匹配了当前元素。选择器下的 CSS 规则就会添加到这个元素中。\n\n### 五、根据权重（Specificity）计算最终的 ComputedStyle\n\n接下来就到了计算权重的时候了。在 HTML 标准中，对于样式权重，描述的比较模糊。标准是对于不同的选择器，使用不同数量级的数字来计算权重。在比较早的 IE 中是使用 10 倍或者更多倍数来计算权重。这样做的问题就是如果有足够数量的低权重选择器，就会覆盖高权重的选择器。\n\n所以现代浏览器，会使用一个四位的数组来表示权重，第一位权重最高，逐渐递减。\n\n一般数组的第一位表示行内样式，第二位表示 id 选择器，第三位表示 class 选择器，第四位表示 tagName 选择器。\n\n这样在比较权重时是同级别与同级别比较，不会出现数量多而导致的权重覆盖问题。如果将来有新标准，调整数组的大小和位置就能满足要求。\n\n下面我们来看一下代码如何实现：\n\n    if (matched) {\n      const sp = specificity(rule.selectors[0]);\n      const computedStyle = element.computedStyle;\n      for (let declaration of rule.declarations) {\n        if (!computedStyle[declaration.property]) {\n          computedStyle[declaration.property] = {};\n        }\n        if (\n          !computedStyle[declaration.property].specificity ||\n          compara(computedStyle[declaration.property].specificity, sp) < 0\n        ) {\n          computedStyle[declaration.property].value = declaration.value;\n          computedStyle[declaration.property].specificity = sp;\n        }\n      }\n    }\n\n如果选择器匹配了当前规则那么，就要根据权重来计算 computedStyle。\n\n我们来看一下 specificity 函数是如何实现的：\n\n    function specificity(selector) {\n      // p[0]: inline-style\n      // p[1]: id\n      // p[2]: class\n      // p[3]: tagName\n      let p = [0, 0, 0, 0];\n      const selectorParts = selector.split(' ');\n      for (let part of selectorParts) {\n        if (part.charAt(0) === '#') {\n          p[1] += 1;\n        } else if (part.charAt(0) === '.') {\n          p[2] += 1;\n        } else {\n          p[3] += 1;\n        }\n      }\n      return p;\n    }\n\n首先，新建一个长度为 4 的数组 p。里面的每一位存放的就是上面提到的四个不同权重选择器的值。每当匹配到一个选择器，这个选择器的值就加一。本文只是实现最基础的选择器，在真实的浏览器中还要处理更复杂的复合选择器等逻辑。不过处理的方式都是一样的。\n\n下一步就是遍历 cssRules 里的每条规则了。如果在 computedStyle 中这条规则没有 specificity 属性，说明这条规则还没计算过权重，要把这个规则加上权重和值。\n\n如果有 specificity 属性，那么就要和当前的选择器权重进行比较，compara 函数的实现如下：\n\n    function compara(sp1, sp2) {\n      if (sp1[0] - sp2[0]) {\n        return sp1[0] - sp2[0];\n      }\n      if (sp1[1] - sp2[1]) {\n        return sp1[1] - sp2[1];\n      }\n      if (sp1[2] - sp2[2]) {\n        return sp1[2] - sp2[2];\n      }\n      return sp1[3] - sp2[3];\n    }\n\n逻辑很简单，就是逐位对比。用相同级别的选择器去做比较。比较出权重的大小后，按权重大小判断是否应该添加该规则。\n\n### !important\n\n另外关于权重还有一个很常见的语法就是 !important。!important 会直接覆盖上述的那几类选择器。但是 !important 不是 CSS 标准。一般来说，在业务开发中，严禁使用 !important，除非是修复紧急线上 bug，在正常的业务开发中，使用 !important 会给调试带来巨大的麻烦。那么如何覆盖 !important 呢？!important 同样可以写多个，数量多的会覆盖数量少的。\n\n### 总结\n\n通过遍历每条 CSS 规则，然后计算权重，再比较权重，从而算出最终的 ComputedStyle。到此，浏览器是如何将 CSS 从一条条规则变成后面布局及渲染所需要的 ComputedStyle 规则的原理揭示出来了。本文是以实现一个 ToyCSSParser 的形式来展示浏览器解析 CSS 规则的原理，现实中浏览器要处理的规则和情况会复杂的多。但整体原理不变，不过复杂度大大增加。本文源码如下：\n\n[huyinglin/ToyBrowser](https://github.com/huyinglin/ToyBrowser/blob/master/parser/cssParser.js)", "user_name": "六月的雨_", "description": "台球，前端", "got_view_count": 98, "category_name": "前端", "ctime": 1457483942}
{"tag_name": "前端", "concern_user_count": 455667, "user_id": "4388906147515367", "title": "如何写技术文章", "mark_content": "> 本文作者文蔺，奇舞团前端开发工程师，[点击查看原文](https://juejin.im/post/6858621112277237767/)\n\n今年在组内推动常态化的分享活动，协助一些同学选题并审阅 ppt 和文章，一直想就其间种种问题做一次总结。虽然自己不怎么动手写博客，但因负责编辑[奇舞周刊<small>（weekly.75team.com）</small>](https://weekly.75team.com/)的缘故，这几年接触了大量优秀的文章，耳濡目染，对技术文章的写作也形成了一些自己的看法。\n\n本文将从准备工作、文章结构、注意事项等方面展开，希望对乐于分享的同学有一定启发。\n\n## 准备工作\n\n动手写文章前，须依次明确两点：目标受众；写作思路。\n\n### 明确目标受众\n\n谁会看我们的文章？谁会对我们的文章感兴趣？这是撰写文章的首要问题。\n\n动手前，一定要先想好你的目标受众，即文章面向哪些读者。要充分考虑读者的背景。面向的读者不同，语言风格、展现形式等也须有所不同。以技术科普文章为例，你需要提供充足的背景知识，通过场景化、故事性的方式切入主题，并提供一系列简单、可复现的示例。\n\n### 梳理写作思路\n\n明确受众之后，可以用某种结构化的形式梳理写作思路，如带有层级的列表、思维导图等。如下图所示，正式写作本文前，我使用 markdown 梳理了本文写作的大致思路。\n\n![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/fa705306eca942d59ff942b51c375804~tplv-k3u1fbpfcp-zoom-1.image)\n\n再经几番调整，文章的基本框架便有了，可以开始撰写初稿。当然，这个基本框架也会随着写作的推进不断动态调整。\n\n### 曲线办法\n\n另外，这里提供一个曲线解决问题的懒人思路。该思路来源于各类技术大会实录。\n\n写文章前，你也可以先做一份 ppt（结构清晰、内容精美者为佳），并将 ppt 转换为图片逐次放入文稿中。\n\n写作时，只当自己在面对观众做现场 presentation，将要说的话适当润色，插入到每张 ppt 前后。注意配以适当的转折语句。\n\n这样的好处有三：图文并茂，适合阅读；信息密度较纯文字高；传达文字不足以完成的信息。\n\n## 文章结构\n\n优秀文章套路基本相似，问题文章则各有各的缺点。这里我用“起承转合”四字来概括基本套路。\n\n### “起”\n\n忘了是谁说的，好的开头是成功的一半。\n\n一般来说，在文章开头，你需要交代写作缘起，如业务遭遇痛点、线上神秘 bug 等。\n\n而后，简要介绍文章将从哪些方面展开、达到什么目的，而读者能从中获得何种收获。\n\n### “承”\n\n承接开头，开始按事先整理的大纲，切入正题。可以开始详细介绍相关场景、探索解决方案的历程。\n\n需要注意的是，始终不能忘记目标受众。根据目标受众特点，注意在必要的地方，提供必要的背景知识，如某项技术的发展历史及相关术语介绍。\n\n### “转”\n\n经过前面的充分铺垫，话题转入突破阶段。可以详细介绍你所寻找到的突破方案及其效果。如有多种方案，建议同时列出，并加以对比。\n\n### “合”\n\n回顾全文，适当总结：\n\n- 文章解决了什么问题？\n- 还可以进行哪些方向的探索？\n- 有何不足之处？\n- 展望未来\n\n## 注意事项\n\n在写作过程中，有一些细节需要注意。\n\n切忌以下问题 ——\n\n- 罗列大量术语：全无背景介绍，直接开始罗列一堆概念\n- 粘贴长篇代码：大篇幅引用代码，影响阅读体验\n- 风格变化无常：时而严肃、学术风，时而卖萌、抖机灵\n- 内容贪图简便：使用代码块、图片或 blockquote **完全取代正文**\n\n有以上问题且难以克服者，建议使用前述“曲线办法”，可能一定效果。\n\n## 总结\n\n以上谈了一些技术文章写作的套路，但更重要的还是日常积累。\n\n当然，日常学习时也要有所甄别，拥抱精品，远离次品。\n\n最新一期的奇舞周刊（[第 359 期](https://weekly.75team.com/issue359.html)）选取的两篇文章质量甚好，附录如下 ——\n\n- [悟空活动中台 - H5 活动加载优化](https://mp.weixin.qq.com/s/6gtVR0nVNcZvREjwftZgzA) <small>（发表于公众号“vivo 互联网技术”）</small>\n- [从 2.9 秒到 0.6 秒，信息流首屏提效 80% 的秘诀](https://mp.weixin.qq.com/s/dGO7cvhnr0cWdeu7O2v5Eg) <small>（发表于公众号“FEPulse”）</small>\n\n另，写完上文之后，有同学给我转发[《如何写好一篇技术文章》](https://juejin.im/post/6844903504922804238)，同样建议阅读。", "user_name": "奇舞周刊", "description": "喜欢听月影讲故事", "got_view_count": 179785, "category_name": "阅读", "ctime": 1457483895}
{"tag_name": "Vue.js", "concern_user_count": 263220, "user_id": "1873223545523101", "title": "解决页面需要上下左右选中元素的问题，富操作", "mark_content": "## 前言\n\n纯粹是因为无聊吧，然后就是突发奇想。\n\n我以前开发过web端的收银系统。之前更早的时候也是做过零售软件方面的实施，通常在门店的时候收银员为了更为快速的去收银，是很少会去用鼠标的。都是键盘解决。但是web操作系统页面有一个问题。就是你的通过tab等方式其实不是很方便。然后我们还有商品列表也需要通过键盘方式选中返回。如果通过鼠标，在一些门店每天都是几万的销售额中，是非常累人，且效率低下的。这次开发的这个插件也是为了解决这方面的问题。\n\n目前做到了基本的上下左右，属于初步的完成。未经业务实战。但是我想还是比较OK的。\n\n源码地址：https://github.com/ht-sauce/dream/blob/master/src/components/CustomCom/RichOperate/index.vue\n\n## 原理：\n\n首先，我们想要键盘上面操作选中dom元素。有本身的tap，上下左右等等，也可以使用tabindex，方式。但是这些都无法说使得操作统一方便。规则较为混乱，并且我们都知道div是么有焦点这个状态的。\n\n那么我们想要实现的情况下，那么就需要自己造轮子了。我们自己来定义并且实现这一套规则。\n\n1、监听键盘的上下左右\n\n2、随着元素的上下左右进行数据移动。\n\n吐槽一下，如果是jquery时代，怕是要麻烦很多。\n\n## 实现左右移动\n\n左右移动其实很简单，我们只要操作元素的数组的index对应的增加减就可以了。所以代码简单的不行。\n\n同理，我们要操作元素的上下也可以这样实现。但是我的目的是要普适性的实现。那么左右我们是根据既定规则来实现的。\n\n## 定义插入的数组的元素结构\n\n    // 设置绑定的初始数据\n    this.dhtSetList({\n      bindData: value, // 绑定数据\n      self: this, // 本身\n      select: false, // 是否被选中\n    })\n\n这里其实比较简单能看出来，第一个是绑定的数据。第二个是vue当前实例本身。第三个就是状态，可以不管。\n\n插入的顺序决定了左右移动的顺序\n\n## 上下移动\n\n上下移动最麻烦的是我们不能按数组的index进行移动。要根据元素本身的上下位置进行移动。\n\n代码原理讲解：\n\n1、过滤同级别元素\n\n2、上过滤掉比自己低的，下过滤比自己高的\n\n3、对元素的高低进行排序，上最小，下最小的元素。\n\n4、如果上下存在一样的Y轴数据，那么比较X大小，得到最小X进行返回，X如果还有多个，那么默认返回第一个\n\n    // 上下移动\n    topOrbottomMove(type) {\n      let currentIndex = this.lastTimeLi() // 上一次的index,也是当前的index\n      const list = this.list\n      // 当前\n      const currentLi = list[currentIndex]\n      const currentLiDom = currentLi.self.$el.getBoundingClientRect()\n      const currentY = currentLiDom.y\n      const currentX = currentLiDom.x\n\n      const relativeList = []\n      list.forEach((item, index) => {\n        const { y, x } = item.self.$el.getBoundingClientRect()\n        relativeList.push({\n          li: item,\n          y: currentY - y,\n          x: Math.abs(currentX - x),\n          index,\n        })\n      })\n      // 过滤通等级元素\n      const eliminate = relativeList.filter(item => item.y !== 0)\n      if (type === 'top') {\n        // 往上过滤比自己低的\n        const topEliminate = eliminate.filter(item => item.y > 0)\n        if (topEliminate.length === 0) {\n          // 最终发送确认值\n          this.sendEmit({ item: list[currentIndex], index: currentIndex })\n        } else {\n          topEliminate.sort((a, b) => a.y - b.y)\n          const xArr = topEliminate.filter(item => item.y === topEliminate[0].y)\n          if (xArr.length > 1) {\n            xArr.sort((a, b) => a.x - b.x)\n            this.sendEmit({ item: xArr[0], index: xArr[0].index })\n          } else {\n            this.sendEmit({ item: xArr[0], index: xArr[0].index })\n          }\n        }\n      }\n      if (type === 'bottom') {\n        // 往下过滤比自己高的\n        const bottomEliminate = eliminate.filter(item => item.y < 0)\n        if (bottomEliminate.length === 0) {\n          // 最终发送确认值\n          this.sendEmit({ item: list[currentIndex], index: currentIndex })\n        } else {\n          bottomEliminate.sort((a, b) => b.y - a.y)\n          const xArr = bottomEliminate.filter(item => item.y === bottomEliminate[0].y)\n          if (xArr.length > 1) {\n            xArr.sort((a, b) => a.x - b.x)\n            this.sendEmit({ item: xArr[0], index: xArr[0].index })\n          } else {\n            this.sendEmit({ item: xArr[0], index: xArr[0].index })\n          }\n        }\n      }\n    },\n\n## 使用\n\n昨天看了下文章被掘金大大推首页了，不好意思太糊弄。这里贴一下使用方式。\n\n核心使用方式：\n\n    RichOperate: () => import('@/components/CustomCom/RichOperate/index'),\n\n这个是组件的核心内容，会暴露出props和一个provide分发的dhtSetList函数，函数本身已经处理好了当前操作列表的是否重复问题\n\n这段代码会判断你的组件的本身是否重复\n\n    // 判断是否已经存在数据列表内部\n    this.list.forEach(item => {  \n    if (item.self === self) {    \n    item.bindData = bindData \n       alike = true  \n    }\n    })\n\n然后我的给的源代码的文件边上还有一个item文件，这个是子组件。一般推荐大家按这样的方式去封装一下自己的内容。\n\n    <template>\n      <div class=\"rich-operate-item\" ref=\"richOperateItem\">\n        <slot></slot>\n      </div>\n    </template>\n\n    <script>\n    export default {\n      name: 'RichOperateItem',\n      inject: ['dhtSetList'],\n      props: {\n        value: null, // 当前绑定的数据\n      },\n      data() {\n        return {\n          select: false,\n        }\n      },\n      watch: {\n        value: {\n          deep: true,\n          immediate: true,\n          handler(value) {\n            // 设置绑定的初始数据\n            this.dhtSetList({\n              bindData: value, // 绑定数据\n              self: this, // 本身\n              select: false, // 是否被选中\n            })\n          },\n        },\n      },\n      mounted() {},\n    }\n    </script\n\n导入为<span>RichOperateItme: () => import('@/components/CustomCom/RichOperate/item'),</span>\n\n最后使用的时候就像这样\n\n    <rich-operate switch :index=\"5\" class=\"test\">\n      <rich-operate-itme :value=\"shiyan\">\n        <div class=\"ceshi\"></div>\n      </rich-operate-itme>\n      <rich-operate-itme>\n        <div class=\"ceshi\"></div>\n      </rich-operate-itme>\n    </rich-operate>\n\n但是这样存在一个问题，我不知道是否对于组件库的组件本身的结构是否产生影响。  \n\n如果产生影响的话，那么建议使用\n\n    this.dhtSetList({ \n     bindData: value, // 绑定数据\n      self: this, // 本身 \n     select: false, // 是否被选中})\n\n不过这个也存在一定的问题。我这里传递进去了是组件本身this。这样做的目的是为了等vuedom渲染完成之后自动绑定dom节点。\n\n主要是这些。关于props传值，大家看源码吧。我习惯写注释，还是挺全面的。\n\n## 总结\n\n基本原理其实挺简单的。\n\n注意我这里为了保证每个子组件用了provide、inject方式进行数据分发。示例中是单独定义了一个子的组件，但是只要根据规则传递数据，那么也就没有什么问题了。\n\n注意，使用了provide、inject分发数据会导致全局存在。意思是子代组件都能得到inject的内容。\n\n主要是提供一个思路。并且给予一定的源码。\n\n今年也是自己够任性，又太高傲。生活依旧不稳，但是接下来我主要目标是vue3和typescript。两者结合使用。", "user_name": "htSauce", "description": "座右铭：贫穷限制了想象力", "got_view_count": 66957, "category_name": "前端", "ctime": 1457483942}
{"tag_name": "机器学习", "concern_user_count": 133308, "user_id": "782508009724749", "title": "pandas | 详解DataFrame中的apply与applymap方法", "mark_content": "本文始发于个人公众号：TechFlow，原创不易，求个关注\n\n<br>\n\n<section id=\"nice\" data-tool=\"mdnice编辑器\" data-website=\"https://www.mdnice.com\" style=\"color: black; line-height: 1.6; word-spacing: 0px; letter-spacing: 0px; word-break: break-word; word-wrap: break-word; text-align: left; font-family: Optima-Regular, Optima, PingFangSC-light, PingFangTC-light, 'PingFang SC', Cambria, Cochin, Georgia, Times, 'Times New Roman', serif; font-size: 14px; padding: 10px;\"><p data-tool=\"mdnice编辑器\" style=\"padding-top: 8px; padding-bottom: 8px; margin: 0; line-height: 26px; color: black; font-size: 14px;\">今天是<strong style=\"font-weight: bold; color: black;\">pandas数据处理</strong>专题的第5篇文章，我们来聊聊pandas的一些高级运算。</p>\n<p data-tool=\"mdnice编辑器\" style=\"padding-top: 8px; padding-bottom: 8px; margin: 0; line-height: 26px; color: black; font-size: 14px;\">在上一篇文章当中，我们介绍了panads的一些计算方法，比如两个dataframe的四则运算，以及dataframe填充Null的方法。今天这篇文章我们来聊聊dataframe中的广播机制，以及apply函数的使用方法。</p>\n<h2 data-tool=\"mdnice编辑器\" style=\"margin-top: 30px; margin-bottom: 15px; padding: 0px; font-size: 22px; text-align: center; position: relative; font-weight: bold; color: black; line-height: 1.1em; padding-top: 12px; padding-bottom: 12px; margin: 70px 30px 30px; border: 1px solid #000;\"><span style=\"float: left; display: block; width: 90%; border-top: 1px solid #000; height: 1px; line-height: 1px; margin-left: -5px; margin-top: -17px;\"> </span><span class=\"prefix\" style=\"display: block; width: 3px; margin: 0 0 0 5%; height: 3px; line-height: 3px; overflow: hidden; background-color: #000; box-shadow: 3px 0 #000,\n    0 3px #000,\n    -3px 0 #000,\n    0 -3px #000;\"></span><span class=\"content\" style=\"display: block; -webkit-box-reflect: below 0em -webkit-gradient(linear,left top,left bottom, from(rgba(0,0,0,0)),to(rgba(255,255,255,0.1)));\">dataframe广播</span><span class=\"suffix\" style=\"display: block; width: 3px; margin: 0 0 0 95%; height: 3px; line-height: 3px; overflow: hidden; background-color: #000; box-shadow: 3px 0 #000,\n    0 3px #000,\n    -3px 0 #000,\n    0 -3px #000;\"></span><span style=\"float: right; display: block; width: 90%; border-bottom: 1px solid #000; height: 1px; line-height: 1px; margin-right: -5px; margin-top: 16px;\"> </span></h2>\n<p data-tool=\"mdnice编辑器\" style=\"padding-top: 8px; padding-bottom: 8px; margin: 0; line-height: 26px; color: black; font-size: 14px;\"><strong style=\"font-weight: bold; color: black;\">广播机制</strong>我们其实并不陌生， 我们在之前介绍numpy的专题文章当中曾经介绍过广播。当我们对两个尺寸不一致的数组进行运算的时候，系统会自动将其中维度较小的那个填充成和另外一个一样再进行计算。</p>\n<p data-tool=\"mdnice编辑器\" style=\"padding-top: 8px; padding-bottom: 8px; margin: 0; line-height: 26px; color: black; font-size: 14px;\">比如我们将一个二维数组减去一个一维数组，numpy会先将一位数组拓展到二维之后再进行减法运算。看起来就像是二维数组的每一行分别减去了这一个一维数组一样。可以理解成我们将减去这一个一维数组的操作广播到了二维数组的每一行或者是每一列当中。</p>\n<figure data-tool=\"mdnice编辑器\" style=\"margin: 0; margin-top: 10px; margin-bottom: 10px; display: flex; flex-direction: column; justify-content: center; align-items: center;\"><img src=\"https://tva1.sinaimg.cn/large/007S8ZIlgy1gh0lyfw456j30j308vdga.jpg\" alt style=\"display: block; margin: 0 auto; max-width: 100%; box-shadow: rgba(170, 170, 170, 0.48) 0px 0px 6px 0px; border-radius: 4px; margin-top: 10px;\"></figure>\n<p data-tool=\"mdnice编辑器\" style=\"padding-top: 8px; padding-bottom: 8px; margin: 0; line-height: 26px; color: black; font-size: 14px;\">在上面这个例子当中我们创建了一个numpy的数组，然后减去了它的第一行。我们对比下最后的结果会发现，arr数组当中的每一行都减去了它的第一行。</p>\n<p data-tool=\"mdnice编辑器\" style=\"padding-top: 8px; padding-bottom: 8px; margin: 0; line-height: 26px; color: black; font-size: 14px;\">同样的操作在dataframe也一样可以进行。</p>\n<figure data-tool=\"mdnice编辑器\" style=\"margin: 0; margin-top: 10px; margin-bottom: 10px; display: flex; flex-direction: column; justify-content: center; align-items: center;\"><img src=\"https://tva1.sinaimg.cn/large/007S8ZIlgy1gh0m3ir30oj30ii09xt90.jpg\" alt style=\"display: block; margin: 0 auto; max-width: 100%; box-shadow: rgba(170, 170, 170, 0.48) 0px 0px 6px 0px; border-radius: 4px; margin-top: 10px;\"></figure>\n<p data-tool=\"mdnice编辑器\" style=\"padding-top: 8px; padding-bottom: 8px; margin: 0; line-height: 26px; color: black; font-size: 14px;\">我们当然也可以对某一列进行广播，但是dataframe四则运算的广播机制默认对行生效，如果要对列使用的话，我们需要使用算术运算方法，并且指定希望匹配的轴。</p>\n<figure data-tool=\"mdnice编辑器\" style=\"margin: 0; margin-top: 10px; margin-bottom: 10px; display: flex; flex-direction: column; justify-content: center; align-items: center;\"><img src=\"https://tva1.sinaimg.cn/large/007S8ZIlgy1gh0m3efevtj30fd04hq2y.jpg\" alt style=\"display: block; margin: 0 auto; max-width: 100%; box-shadow: rgba(170, 170, 170, 0.48) 0px 0px 6px 0px; border-radius: 4px; margin-top: 10px;\"></figure>\n<h2 data-tool=\"mdnice编辑器\" style=\"margin-top: 30px; margin-bottom: 15px; padding: 0px; font-size: 22px; text-align: center; position: relative; font-weight: bold; color: black; line-height: 1.1em; padding-top: 12px; padding-bottom: 12px; margin: 70px 30px 30px; border: 1px solid #000;\"><span style=\"float: left; display: block; width: 90%; border-top: 1px solid #000; height: 1px; line-height: 1px; margin-left: -5px; margin-top: -17px;\"> </span><span class=\"prefix\" style=\"display: block; width: 3px; margin: 0 0 0 5%; height: 3px; line-height: 3px; overflow: hidden; background-color: #000; box-shadow: 3px 0 #000,\n    0 3px #000,\n    -3px 0 #000,\n    0 -3px #000;\"></span><span class=\"content\" style=\"display: block; -webkit-box-reflect: below 0em -webkit-gradient(linear,left top,left bottom, from(rgba(0,0,0,0)),to(rgba(255,255,255,0.1)));\">函数与映射</span><span class=\"suffix\" style=\"display: block; width: 3px; margin: 0 0 0 95%; height: 3px; line-height: 3px; overflow: hidden; background-color: #000; box-shadow: 3px 0 #000,\n    0 3px #000,\n    -3px 0 #000,\n    0 -3px #000;\"></span><span style=\"float: right; display: block; width: 90%; border-bottom: 1px solid #000; height: 1px; line-height: 1px; margin-right: -5px; margin-top: 16px;\"> </span></h2>\n<p data-tool=\"mdnice编辑器\" style=\"padding-top: 8px; padding-bottom: 8px; margin: 0; line-height: 26px; color: black; font-size: 14px;\">pandas的另外一个优点是<strong style=\"font-weight: bold; color: black;\">兼容了numpy</strong>当中的一些运算方法和函数，使得我们也可以将一些numpy当中的函数运用在DataFrame上，这样就大大拓展了使用方法以及运算方法。</p>\n<p data-tool=\"mdnice编辑器\" style=\"padding-top: 8px; padding-bottom: 8px; margin: 0; line-height: 26px; color: black; font-size: 14px;\">比如我们要将DataFrame当中所有的元素变成它的平方，我们利用numpy的square方法可以很容易做到：</p>\n<figure data-tool=\"mdnice编辑器\" style=\"margin: 0; margin-top: 10px; margin-bottom: 10px; display: flex; flex-direction: column; justify-content: center; align-items: center;\"><img src=\"https://tva1.sinaimg.cn/large/007S8ZIlgy1gh0n1z0wz7j30em048dfu.jpg\" alt style=\"display: block; margin: 0 auto; max-width: 100%; box-shadow: rgba(170, 170, 170, 0.48) 0px 0px 6px 0px; border-radius: 4px; margin-top: 10px;\"></figure>\n<p data-tool=\"mdnice编辑器\" style=\"padding-top: 8px; padding-bottom: 8px; margin: 0; line-height: 26px; color: black; font-size: 14px;\">我们可以将DataFrame作为numpy函数的参数传入，但如果我们想要自己定义一个方法并且应用在DataFrame上怎么办？</p>\n<p data-tool=\"mdnice编辑器\" style=\"padding-top: 8px; padding-bottom: 8px; margin: 0; line-height: 26px; color: black; font-size: 14px;\">我们可以利用<strong style=\"font-weight: bold; color: black;\">apply方法</strong>很容易地实现这一点，apply方法有些像是Python原生的map方法，可以对DataFrame当中的每一个元素做一个映射计算。我们只需要在apply方法当中传入我们想要应用在DataFrame上的方法即可，也就是说它接受的参数是一个函数，这是一个很典型的函数式编程的应用。</p>\n<p data-tool=\"mdnice编辑器\" style=\"padding-top: 8px; padding-bottom: 8px; margin: 0; line-height: 26px; color: black; font-size: 14px;\">比如我们想要对DataFrame进行平方操作，我们也可以将np.square函数当做参数传入。</p>\n<figure data-tool=\"mdnice编辑器\" style=\"margin: 0; margin-top: 10px; margin-bottom: 10px; display: flex; flex-direction: column; justify-content: center; align-items: center;\"><img src=\"https://tva1.sinaimg.cn/large/007S8ZIlgy1gh0n6crfjtj30ew04d3yj.jpg\" alt style=\"display: block; margin: 0 auto; max-width: 100%; box-shadow: rgba(170, 170, 170, 0.48) 0px 0px 6px 0px; border-radius: 4px; margin-top: 10px;\"></figure>\n<p data-tool=\"mdnice编辑器\" style=\"padding-top: 8px; padding-bottom: 8px; margin: 0; line-height: 26px; color: black; font-size: 14px;\">apply方法除了可以用在一整个DataFrame上之外，我们也可以让它应用在<strong style=\"font-weight: bold; color: black;\">某一行</strong>或者是<strong style=\"font-weight: bold; color: black;\">某一列</strong>或者是某一个部分上，应用的方法都是一样的。比如我们可以这样对DataFrame当中的某一行以及某一列应用平方这个方法。</p>\n<figure data-tool=\"mdnice编辑器\" style=\"margin: 0; margin-top: 10px; margin-bottom: 10px; display: flex; flex-direction: column; justify-content: center; align-items: center;\"><img src=\"https://tva1.sinaimg.cn/large/007S8ZIlgy1gh0nbxn2zcj30jv06xglx.jpg\" alt style=\"display: block; margin: 0 auto; max-width: 100%; box-shadow: rgba(170, 170, 170, 0.48) 0px 0px 6px 0px; border-radius: 4px; margin-top: 10px;\"></figure>\n<p data-tool=\"mdnice编辑器\" style=\"padding-top: 8px; padding-bottom: 8px; margin: 0; line-height: 26px; color: black; font-size: 14px;\">另外，apply中函数的作用域并不只局限在元素，我们也可以写出作用在一行或者是一列上的函数。比如我们想要计算出DataFrame当中每一列的最大值，我们可以这样写：</p>\n<figure data-tool=\"mdnice编辑器\" style=\"margin: 0; margin-top: 10px; margin-bottom: 10px; display: flex; flex-direction: column; justify-content: center; align-items: center;\"><img src=\"https://tva1.sinaimg.cn/large/007S8ZIlgy1gh0ndoflp7j30hz03lmx6.jpg\" alt style=\"display: block; margin: 0 auto; max-width: 100%; box-shadow: rgba(170, 170, 170, 0.48) 0px 0px 6px 0px; border-radius: 4px; margin-top: 10px;\"></figure>\n<p data-tool=\"mdnice编辑器\" style=\"padding-top: 8px; padding-bottom: 8px; margin: 0; line-height: 26px; color: black; font-size: 14px;\">这个匿名函数当中的<strong style=\"font-weight: bold; color: black;\">x其实是一个Series</strong>，那这里的max就是Series自带的max方法。也就是说apply的作用范围是Series，虽然最终的效果是每一个元素都被改变了，但是<strong style=\"font-weight: bold; color: black;\">apply的作用域并不是元素而是Series</strong>。我们通过apply操作行或者列，行和列将改变应用到每一个元素。</p>\n<p data-tool=\"mdnice编辑器\" style=\"padding-top: 8px; padding-bottom: 8px; margin: 0; line-height: 26px; color: black; font-size: 14px;\">同样我们也可以将apply的应用对象限定为行，同样我们需要通过传入axis来限定，我们可以传入axis='columns'，也可以指定axis=1，这两者的效果是一样的。</p>\n<figure data-tool=\"mdnice编辑器\" style=\"margin: 0; margin-top: 10px; margin-bottom: 10px; display: flex; flex-direction: column; justify-content: center; align-items: center;\"><img src=\"https://tva1.sinaimg.cn/large/007S8ZIlgy1gh0oq7gu4qj30gl036glm.jpg\" alt style=\"display: block; margin: 0 auto; max-width: 100%; box-shadow: rgba(170, 170, 170, 0.48) 0px 0px 6px 0px; border-radius: 4px; margin-top: 10px;\"></figure>\n<p data-tool=\"mdnice编辑器\" style=\"padding-top: 8px; padding-bottom: 8px; margin: 0; line-height: 26px; color: black; font-size: 14px;\">另外，apply返回的结果并不一定只能是标量，也可以是多个值组成的list或者是Series，其实两者也是一样的，因为即使返回List也会被转化成Series。</p>\n<figure data-tool=\"mdnice编辑器\" style=\"margin: 0; margin-top: 10px; margin-bottom: 10px; display: flex; flex-direction: column; justify-content: center; align-items: center;\"><img src=\"https://tva1.sinaimg.cn/large/007S8ZIlgy1gh0p8xq95xj30ng08xgm9.jpg\" alt style=\"display: block; margin: 0 auto; max-width: 100%; box-shadow: rgba(170, 170, 170, 0.48) 0px 0px 6px 0px; border-radius: 4px; margin-top: 10px;\"></figure>\n<p data-tool=\"mdnice编辑器\" style=\"padding-top: 8px; padding-bottom: 8px; margin: 0; line-height: 26px; color: black; font-size: 14px;\">最后我们来介绍一下applymap，它是<strong style=\"font-weight: bold; color: black;\">元素级的map</strong>，我们可以用它来操作DataFrame中的每一个元素。比如我们可以用它来转换DataFrame当中数据的格式。</p>\n<figure data-tool=\"mdnice编辑器\" style=\"margin: 0; margin-top: 10px; margin-bottom: 10px; display: flex; flex-direction: column; justify-content: center; align-items: center;\"><img src=\"https://tva1.sinaimg.cn/large/007S8ZIlgy1gh0q4zy56tj30gf04b0st.jpg\" alt style=\"display: block; margin: 0 auto; max-width: 100%; box-shadow: rgba(170, 170, 170, 0.48) 0px 0px 6px 0px; border-radius: 4px; margin-top: 10px;\"></figure>\n<p data-tool=\"mdnice编辑器\" style=\"padding-top: 8px; padding-bottom: 8px; margin: 0; line-height: 26px; color: black; font-size: 14px;\">之所以我们叫它applymap而不是map，是因为在Series的方法当中，已经有了map，所以为了区分创建了applymap。</p>\n<p data-tool=\"mdnice编辑器\" style=\"padding-top: 8px; padding-bottom: 8px; margin: 0; line-height: 26px; color: black; font-size: 14px;\">这里要注意，如果将上面代码中的applymap改成apply是会报错的。报错的原因也很简单，因为apply方法的作用域不是元素而是Series，Series并不支持这样的操作。</p>\n<h2 data-tool=\"mdnice编辑器\" style=\"margin-top: 30px; margin-bottom: 15px; padding: 0px; font-size: 22px; text-align: center; position: relative; font-weight: bold; color: black; line-height: 1.1em; padding-top: 12px; padding-bottom: 12px; margin: 70px 30px 30px; border: 1px solid #000;\"><span style=\"float: left; display: block; width: 90%; border-top: 1px solid #000; height: 1px; line-height: 1px; margin-left: -5px; margin-top: -17px;\"> </span><span class=\"prefix\" style=\"display: block; width: 3px; margin: 0 0 0 5%; height: 3px; line-height: 3px; overflow: hidden; background-color: #000; box-shadow: 3px 0 #000,\n    0 3px #000,\n    -3px 0 #000,\n    0 -3px #000;\"></span><span class=\"content\" style=\"display: block; -webkit-box-reflect: below 0em -webkit-gradient(linear,left top,left bottom, from(rgba(0,0,0,0)),to(rgba(255,255,255,0.1)));\">总结</span><span class=\"suffix\" style=\"display: block; width: 3px; margin: 0 0 0 95%; height: 3px; line-height: 3px; overflow: hidden; background-color: #000; box-shadow: 3px 0 #000,\n    0 3px #000,\n    -3px 0 #000,\n    0 -3px #000;\"></span><span style=\"float: right; display: block; width: 90%; border-bottom: 1px solid #000; height: 1px; line-height: 1px; margin-right: -5px; margin-top: 16px;\"> </span></h2>\n<p data-tool=\"mdnice编辑器\" style=\"padding-top: 8px; padding-bottom: 8px; margin: 0; line-height: 26px; color: black; font-size: 14px;\">今天的文章我们主要介绍了pandas当中apply与applymap的使用方法， 这两个方法在我们日常操作DataFrame的数据非常常用，可以说是手术刀级的api。熟练掌握对于我们搞定数据处理非常有帮助，如果大家理解Python中原生的map方法的应用，相信一定也可以很顺利地理解今天的文章。</p>\n<p data-tool=\"mdnice编辑器\" style=\"padding-top: 8px; padding-bottom: 8px; margin: 0; line-height: 26px; color: black; font-size: 14px;\">今天的文章到这里就结束了，如果喜欢本文的话，请来一波<strong style=\"font-weight: bold; color: black;\">素质三连</strong>，给我一点支持吧（<strong style=\"font-weight: bold; color: black;\">关注、转发、点赞</strong>）。</p>\n<span style=\"font-size: 15px; display: block; text-align: center; margin-top: 50px; color: #999; border-bottom: 1px solid #eee;\">- END -</span></section>\n\n![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/52483df9a44947f2a6442e76dadbb96b~tplv-k3u1fbpfcp-zoom-1.image)", "user_name": "承志", "description": "公众号：TechFlow", "got_view_count": 52683, "category_name": "人工智能", "ctime": 1500876664}
{"tag_name": "Java", "concern_user_count": 252044, "user_id": "1538972007286157", "title": "持续输出面试题系列之ZooKeeper篇", "mark_content": "## 开篇介绍\n大家好，我是`Java最全面试题库`的提裤姐，今天这篇是JavaEE面试题系列的第十二篇，主要总结了ZooKeeper相关的面试题；在后续，会沿着第一篇开篇的知识线路一直总结下去，做到日更！如果我能做到百日百更，希望你也可以跟着百日百刷，一百天养成一个好习惯。\n\n## ZooKeeper是什么？\nZooKeeper是一个开放源码的`分布式协调服务`，它是集群的管理者，监视着集群中各个节点的状态根据节点提交的反馈进行下一步合理操作。最终，将简单易用的接口和性能高效、功能稳定的系统提供给用户。\n\n分布式应用程序可以基于Zookeeper实现诸如数据发布/订阅、负载均衡、命名服务、分布式协调/通知、集群管理、Master选举、分布式锁和分布式队列等功能。\n\nZookeeper保证了如下分布式一致性特性：\n- 顺序一致性\n- 原子性\n- 单一视图\n- 可靠性\n- 实时性（最终一致性）\n\n客户端的读请求可以被集群中的任意一台机器处理，如果读请求在节点上注册了监听器，这个监听器也是由所连接的zookeeper机器来处理。对于写请求，这些请求会同时发给其他zookeeper机器并且达成一致后，请求才会返回成功。因此，随着zookeeper的集群机器增多，读请求的吞吐会提高但是写请求的吞吐会下降。\n\n有序性是zookeeper中非常重要的一个特性，所有的更新都是全局有序的，每个更新都有一个唯一的时间戳，这个时间戳称为`zxid（Zookeeper Transaction Id）`。而读请求只会相对于更新有序，也就是读请求的返回结果中会带有这个zookeeper最新的zxid。\n\n## ZooKeeper和dubbo的区别？\n**Zookeeper**: \nzookeeper用来注册服务和进行负载均衡，哪一个服务由哪一个机器来提供必需让调用者知道，\n简单来说就是ip地址和服务名称的对应关系。当然也可以通过硬编码的方式把这种对应关系在调用方业务代码中实现，但是如果提供服务的机器挂掉，调用者无法知晓，如果不更改代码会继续请求挂掉的机器提供服务。 zookeeper通过`心跳机制`可以检测挂掉的机器并将挂掉机器的ip和服务对应关系从列表中删除。至于支持高并发,简单来说就是横向扩展,在不更改代码的情况通过添加机器来提高运算能力。通过添加新的机器向 zookeeper注册服务，服务的提供者多了能服务的客户就多了。\n\n**dubbo**:\n是管理中间层的工具，在业务层到数据仓库间有非常多服务的接入和服务提供者需要调度，dubbo提供一个框架解决这个问题。\n\n**zookeeper和 dubbo的关系：**\nDubbo将注册中心进行抽象，它可以外接不同的存储媒介给注册中心提供服务，有 ZooKeeper, Memcached, Redis等。\n\n>注意这里的 dubbo只是一个框架，这个框架中要完成调度必须要有一个分布式的注册中心，储存所有服务的元数据，可以用zk，也可以用别的。\n\n\n## Zookeeper的java客户端都有哪些?\n- zk自带的 zkclient\n- Apache开源的 Curator\n\n## ZooKeeper提供了什么？\n- 文件系统\n- 通知机制\n\n## 说说ZooKeeper文件系统\n Zookeeper提供一个多层级的节点命名空间(节点称为 znode)。与文件系统不同的是，这些节点都可以设置关联的数据，而文件系统中只有文件节点可以存放数据而目录节点不行。\n\n Zookeeper为了保证高吞吐和低延迟，在内存中维护了这个树状的目录结构，这种特性使得 Zookeeper不能用于存放大量的数据,每个节点的存放数据上限为1M。\n\n## 说说ZAB协议？\nZAB协议是为分布式协调服务Zookeeper专门设计的一种支持`崩溃恢复的原子广播协议`。\n\nZAB协议包括两种基本的模式：`崩溃恢复`和`消息广播`。\n\n当整个zookeeper集群刚刚启动或者Leader服务器宕机、重启或者网络故障导致不存在过半的服务器与Leader服务器保持正常通信时，所有进程（服务器）进入崩溃恢复模式，首先选举产生新的Leader服务器，然后集群中Follower服务器开始与新的Leader服务器进行数据同步，当集群中超过半数机器与该Leader服务器完成数据同步之后，退出恢复模式进入消息广播模式，Leader服务器开始接收客户端的事务请求生成事物提案来进行事务请求处理。\n\n## Znode有哪些类型\n- `PERSISTENT-持久节点`\n除非手动删除，否则节点一直存在于Zookeeper上\n\n- `EPHEMERAL-临时节点`\n临时节点的生命周期与客户端会话绑定，一旦客户端会话失效（客户端与zookeeper连接断开不一定会话失效），那么这个客户端创建的所有临时节点都会被移除。\n\n- `PERSISTENT_SEQUENTIAL-持久顺序节点`\n基本特性同持久节点，只是增加了顺序属性，节点名后边会追加一个由父节点维护的自增整型数字。\n\n- `EPHEMERAL_SEQUENTIAL-临时顺序节点`\n基本特性同临时节点，增加了顺序属性，节点名后边会追加一个由父节点维护的自增整型数字。\n\n## Zookeeper节点宕机如何处理？\nZookeeper本身也是集群，推荐配置`不少于3个服务器`。Zookeeper自身也要保证当一个节点宕机时，其他节点会继续提供服务。\n如果是一个Follower宕机，还有2台服务器提供访问，因为Zookeeper上的数据是有多个副本的，数据并不会丢失；\n如果是一个Leader宕机，Zookeeper会选举出新的Leader。\n\nZK集群的机制是只要超过半数的节点正常，集群就能正常提供服务。\n只有在ZK节点挂得太多，只剩一半或不到一半节点能工作，集群才失效。\n\n所以：\n- 3个节点的cluster可以挂掉1个节点(leader可以得到2票>1.5)\n- 2个节点的cluster不能挂掉任何1个节点(leader可以得到1票<=1)\n\n## Zookeeper有哪几种几种部署模式?\nZookeeper有三种部署模式：\n- `单机部署`：一台集群上运行\n- `集群部署`：多台集群运行\n- `伪集群部署`：一台集群启动多个 Zookeeper实例运行\n\n## Zookeeper的典型应用场景？\nZookeeper是一个典型的`发布/订阅模式`的分布式数据管理与协调框架，开发人员可以使用它来进行分布式数据的发布和订阅。\n通过对 Zookeeper中丰富的数据节点进行交叉使用，配合 `Watcher事件通知机制`，可以非常方便的构建一系列分布式应用，会涉及的核心功能：\n- 数据发布/订阅\n- 负载均衡\n- 命名服务\n- 分布式协调/通知\n- 集群管理\n- Master选举\n- 分布式锁\n- 分布式队列\n\n## 说一下Zookeeper Watcher机制\nZookeeper允许客户端向服务端的某个 Znode注册个 Watcher监听，当服务端的一些指定事件触发了这个 Watcher，服务端会向指定客户端发送一个事件通知来实现分布式的通知功能，客户端根据 Watcher通知状态和事件类型做出业务上的改变。\n\n工作机制：\n- 客户端注册 watcher\n- 服务端处理watcher\n- 客户端回调 watcher\n\n## 客户端注册Watcher的流程？\n1、客户端注册`Watcher实现`\n2、调用`getData()`/`getChildren()`/`exist()`三个API，传入Watcher对象\n3、标记请求request，封装Watcher到`WatchRegistration`\n4、封装成`Packet`对象，发服务端发送request\n5、收到服务端响应后，将Watcher注册到`ZKWatcherManager`中进行管理\n6、请求返回，完成注册。\n\n## 服务端处理Watcher的流程？\n1、`服务端接收Watcher并存储`\n接收到客户端请求，处理请求判断是否需要注册Watcher，需要的话将数据节点的节点路径和ServerCnxn（ServerCnxn代表一个客户端和服务端的连接，实现了Watcher的process接口，此时可以看成一个Watcher对象）存储在WatcherManager的WatchTable和watch2Paths中去。\n\n2、`Watcher触发`\n- 以服务端接收到 setData() 事务请求触发NodeDataChanged事件为例：\n- 封装WatchedEvent\n- 将通知状态（SyncConnected）、事件类型（NodeDataChanged）以及节点路径封装成一个WatchedEvent对象\n- 查询Watcher\n- 从WatchTable中根据节点路径查找Watcher\n没找到；说明没有客户端在该数据节点上注册过Watcher\n找到；提取并从WatchTable和Watch2Paths中删除对应Watcher（从这里可以看出Watcher在服务端是一次性的，触发一次就失效了）\n\n3、`调用process方法来触发Watcher`\n这里process主要就是通过ServerCnxn对应的TCP连接发送Watcher事件通知。\n\n## 客户端回调 Watcher流程？\n1、客户端`SendThread`线程接收事件通知，交由 EventThread线程回调 Watcher。\n2、客户端的Watcher机制同样是一次性的，一旦被触发后，该 Watcher就失效了。\n\n## Zookeeper对节点的 watch监听通知是永久的吗?为什么不是永久的?\n不是永久的。\n官方声明：一个 Watch事件是一个次性的触发器，当被设置了 Watch的数据发生了改变的时候，则服务器将这个改变发送给设置了 Watch的客户端，以便通知它们。\n\n原因：\n如果服务端变动频繁，而监听的客户端很多情况下，每次变动都要通知到所有的客户端，给网络和服务器造成很大压力。一般是客户端执行`getData`（“/节点”，true），如果节点A发生了变更或删除，客户端会得到它的 watch事件，但是在之后节点A又发生了变更，而客户端又没有设置 watch事件，就不再给客户端发送。\n>在实际应用中，很多情况下，我们的客户端不需要知道服务端的每一次变动，我只要最新的数据即可。\n\n## 说说ACL权限控制机制\n1、`权限模式（Scheme）`\nIP：从IP地址粒度进行权限控制\nDigest：最常用，用类似于 username:password 的权限标识来进行权限配置，便于区分不同应用来进行权限控制\nWorld：最开放的权限控制方式，是一种特殊的digest模式，只有一个权限标识“world:anyone”\nSuper：超级用户\n\n2、`授权对象`\n授权对象指的是权限赋予的用户或一个指定实体，例如IP地址或是机器灯。\n\n3、`权限 Permission`\n- CREATE：数据节点创建权限，允许授权对象在该Znode下创建子节点\n- DELETE：子节点删除权限，允许授权对象删除该数据节点的子节点\n- READ：数据节点的读取权限，允许授权对象访问该数据节点并读取其数据内容或子节点列表等\n- WRITE：数据节点更新权限，允许授权对象对该数据节点进行更新操作\n- ADMIN：数据节点管理权限，允许授权对象对该数据节点进行ACL相关设置操作\n\n## 服务器有哪些角色？\n1、`Leader`\n事务请求的唯一调度和处理者，保证集群事务处理的顺序性\n集群内部各服务的调度者\n\n2、`Follower`\n处理客户端的非事务请求，转发事务请求给Leader服务器\n参与事务请求Proposal的投票\n参与Leader选举投票\n\n3、`Observer`\n处理客户端的非事务请求，转发事务请求给Leader服务器\n不参与任何形式的投票\n\n## Zookeeper 下 Server工作状态有哪些？\n1、`LOOKING`：寻找Leader状态。当服务器处于该状态时，它会认为当前集群中没有Leader，因此需要进入Leader选举状态。\n2、`FOLLOWING`：跟随者状态。表明当前服务器角色是Follower。\n3、`LEADING`：领导者状态。表明当前服务器角色是Leader。\n4、`OBSERVING`：观察者状态。表明当前服务器角色是Observer。\n\n## 集群支持动态添加机器吗？\n其实就是水平扩容，Zookeeper在这方面不太好。\n两种方式：\n- `全部重启`：关闭所有 Zookeeper服务，修改配置之后启动。不影响之前客户端的会话。\n- `逐个重启`：在过半存活即可用的原则下一台机器重启不影响整个集群对外提供服务。（这是比较常用的方式）\n\n>3.5版本开始支持动态扩容。\n\n## 什么是Chroot？\n3.2.0版本后，添加了特性，该特性允许每个客户端为自己设置一个命名空间。如果一个客户端设置了 Chroot，那么该客户端对服务器的任何操作，都将会被限制在其自己的命名空间下。\n\n>通过设置 Chroot，能够将一个客户端应用与 Zookeeper服务端的一颗子树相对应，在那些多个应用公用一个 Zookeeper集群的场景下，对实现不同应用间的相互隔离非常有帮助。", "user_name": "程序媛小红", "description": "我可能是个假开发", "got_view_count": 3475, "category_name": "后端", "ctime": 1457483880}
{"tag_name": "Flutter", "concern_user_count": 34101, "user_id": "219558055779576", "title": "[Flutter翻译]在Flutter中为linux编写插件", "mark_content": "> 原文地址：https://medium.com/@yashjohri1200/writing-plugins-for-linux-in-flutter-38e46bd7872f\n>\n> 原文作者：https://medium.com/@yashjohri1200\n>\n> 发布时间：2020年8月10日 - 2分钟阅读\n\n嘿，希望你在这次流行病中没事。我们都知道Flutter最近用[canonical](https://medium.com/flutter/announcing-flutter-linux-alpha-with-canonical-19eb824590a9)扩展了对linux的支持。有了这个，我们现在可以更容易地用Flutter为linux构建和部署应用程序了。\n\n# 从升级Flutter开始\n\n```shell\nflutter channel master\nflutter upgrade\n```\n\n# 在Flutter中启用Linux支持\n\n```shell\nflutter config --enable-linux-desktop\n```\n\n# 让我们创建一个简单的电池插件\n\n在这个例子中，我们将创建一个插件，它将为我们提供电池百分比水平和它的技术。\n\n```shell\nflutter create -t plugin --platforms=linux battery\n```\n\n# 分析环境\n\n在你的插件文件夹中，你会得到一个`lib`文件夹，其中包含`battery.dart`文件，它将处理你的方法通道，一个`example`文件夹，其中包含一个示例应用程序来演示你的插件的使用，还有一个`linux`文件夹，其中包含battery_plugin.cc文件，它将处理你的平台级方法。平台级的代码是用Linux的C++编写的。\n\n每当有来自Flutter的调用时，函数`battery_plugin_handle_method_call`将被调用。我们可以通过调用`fl_method_call_get_name(method_call)`函数来获取方法。响应将以`FlMethodResponse`数据类型从linux平台发送到flutter。\n\n在linux中，我们要处理的数据类型是`FlValue`。FlValue的一些例子是：\n\n对于字符串：\n\n```cpp\nstring flutter = \"Flutter\".g_autoptr(FlValue);\ng_autoptr(FlValue) converted = fl_value_new_string(flutter.c_str());\n```\n\n对于Maps：\n\n```cpp\n// Initialize a map.\ng_autoptr(FlValue) mapExample = fl_value_new_map();\nstring flutter = \"Flutter\", dart = \"Dart\";\n// Set a value in map.\nfl_value_set(mapExample, fl_value_new_string(flutter.c_str()),               fl_value_new_string(dart.c_str()));\n// First parameter is the variable.\n// Second parameter is the key.\n// Third paramter is its value.\n```\n\n为了将FlValue转换为响应，我们必须使用：\n\n```cpp\ng_autoptr(FlMethodResponse) response = FL_METHOD_RESPONSE(fl_method_success_response_new(value));\n// It takes a FlValue as its parameter.\n```\n\n更多关于`FlValue`的信息可以在[这里](https://engine.chinmaygarde.com/fl__value_8h.html#a248fb199aa2cc2b92f692067e2d15cd9)找到。\n\n# 让我们开始工作\n\n在`lib/battery.dart`文件中，添加一个函数来调用`getBatteryData`方法，像这样：\n\n```dart\nstatic Future<Map<String, dynamic>> get getBatteryLevel async {\n    final Map<String, dynamic> version = Map<String, dynamic>.from(\n        await _channel.invokeMethod('getBatteryData')\n    );\n    return version;\n}\n```\n\n这就是我们在flutter应用中要调用的getter。现在在`linux/battery_plugin.cc`中，我们必须为我们的`getBatteryData`方法通道添加一个条件。\n\n```cpp\nif (strcmp(method, \"getPlatformVersion\") == 0) {\n  /*\n   * already implemented.\n   */\n} else if (strcmp(method, \"getBatteryData\") == 0) {\n  g_autoptr(FlValue) batteryData = fl_value_new_map();\n  string command = \"cat /sys/class/power_supply/BAT1/capacity\";\n  char buffer[256];\n  FILE * pipe = popen(command.c_str(), \"r\");\n  while (!feof(pipe)) {\n    if (fgets(buffer, 128, pipe) != NULL) {\n      fl_value_set(batteryData, fl_value_new_string(\"capacity\"), fl_value_new_string(buffer));\n    }\n  }\n  pclose(pipe);\n\n  command = \"cat /sys/class/power_supply/BAT1/technology\";\n  pipe = popen(command.c_str(), \"r\");\n  while (!feof(pipe)) {\n    if (fgets(buffer, 128, pipe) != NULL) {\n      fl_value_set(batteryData, fl_value_new_string(\"technology\"), fl_value_new_string(buffer));\n    }\n  }\n  pclose(pipe);\n\n  response = FL_METHOD_RESPONSE(fl_method_success_response_new(batteryData));\n}\n```\n\n> 注意：这不是整个battery_plugin.cc，只是我们实现的部分。\n\n在这里，我们使用C++中的管道来提取Linux命令的输出。我们使用文件`/sys/class/power_supply/BAT1/capacity`来获取电池的百分比水平，使用`/sys/class/power_supply/BAT1/technology`来获取其技术。\n\n# 现在到前台\n\n这是我们的`main.dart`文件，它使用电池插件来获取电池数据。\n\n```dart\nimport 'package:flutter/material.dart';\nimport 'dart:async';\n\nimport 'package:flutter/services.dart';\nimport 'package:battery/battery.dart';\n\nvoid main() {\n  runApp(MyApp());\n}\n\nclass MyApp extends StatefulWidget {\n  @override\n  _MyAppState createState() => _MyAppState();\n}\n\nclass _MyAppState extends State<MyApp> {\n  String capacity = \"Unknown\", technology = \"Unknown\";\n\n  @override\n  void initState() {\n    super.initState();\n    initPlatformState();\n  }\n\n  // Platform messages are asynchronous, so we initialize in an async method.\n  Future<void> initPlatformState() async {\n    Map<String, dynamic> batteryDataLocal;\n    // Platform messages may fail, so we use a try/catch PlatformException.\n    try {\n      batteryDataLocal = await Battery.getBatteryLevel;\n    } on PlatformException {\n      batteryDataLocal = <String, dynamic>{\n        'capacity': 'Failed to get capacity',\n        'technology': 'Failed to get technology',\n      };\n    }\n\n    // If the widget was removed from the tree while the asynchronous platform\n    // message was in flight, we want to discard the reply rather than calling\n    // setState to update our non-existent appearance.\n    if (!mounted) return;\n\n    setState(() {\n      capacity = batteryDataLocal[\"capacity\"];\n      technology = batteryDataLocal[\"technology\"];\n    });\n  }\n\n  @override\n  Widget build(BuildContext context) {\n    return MaterialApp(\n      home: Scaffold(\n        appBar: AppBar(\n          title: const Text('Plugin example app'),\n        ),\n        body: Center(\n          child: Text(\n            'Battery is : $capacity\\nTechnology is : $technology',\n          ),\n        ),\n      ),\n    );\n  }\n}\n```\n\n# 运行应用程序\n\n```shell\nflutter run -d linux\n```\n\n要获得详细的调试数据，请使用：\n\n```shell\nflutter run -d linux -v\n```\n\n# 就这样吧\n\n这是应用程序作为linux可执行文件运行的截图。\n\n![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/20fc2c74ca5d42d5ba1e6f9a39e7c642~tplv-k3u1fbpfcp-zoom-1.image)\n> 电池插件示例\n\n**Github : https://github.com/yash1200/flutter_battery_linux**\n\n---\n\n通过( www.DeepL.com/Translator )（免费版）翻译", "user_name": "Sunbreak", "description": "Flutter技术专家", "got_view_count": 15506, "category_name": "前端", "ctime": 1457483942}
{"tag_name": "Vue.js", "concern_user_count": 263220, "user_id": "2418581313687390", "title": "vue3.0 响应式原理(超详细)", "mark_content": "\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20200809155509890.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3psX0FsaWVu,size_16,color_FFFFFF,t_70)\n\n\n## 一 基于proxy的Observer\n\n### 1 什么是proxy\n**Proxy 对象用于定义基本操作的自定义行为（如属性查找、赋值、枚举、函数调用等）。**\n\nproxy是es6新特性，为了对目标的作用主要是通过handler对象中的拦截方法拦截目标对象target的某些行为（如属性查找、赋值、枚举、函数调用等）。\n\n````js\n/* target: 目标对象，待要使用 Proxy 包装的目标对象（可以是任何类型的对象，包括原生数组，函数，甚至另一个代理）。 */\n/* handler: 一个通常以函数作为属性的对象，各属性中的函数分别定义了在执行各种操作时代理 proxy 的行为。 */ \nconst proxy = new Proxy(target, handler);\n\n````\n\n### 2 为什么要用proxy，改用proxy之后的利与弊\n\n\n > **  3.0 将带来一个基于 Proxy 的 observer 实现，它可以提供覆盖语言 (JavaScript——译注) 全范围的响应式能力，消除了当前 Vue 2 系列中基于 Object.defineProperty 所存在的一些局限，这些局限包括：1 对属性的添加、删除动作的监测； 2 对数组基于下标的修改、对于 .length 修改的监测； 3 对 Map、Set、WeakMap 和 WeakSet 的支持；；\n\nvue2.0 用 **Object.defineProperty** 作为响应式原理的实现，但是会有它的局限性，比如 **无法监听数组基于下标的修改，不支持 Map、Set、WeakMap 和 WeakSet等缺陷** ，所以改用了proxy解决了这些问题，这也意味着vue3.0将放弃对低版本浏览器的兼容（兼容版本ie11以上）。\n\n\n### 3 proxy中hander对象的基本用法\n\n**vue3.0 响应式用到的捕获器（接下来会重点介绍）**\n\n**handler.has()**                      ->  **in 操作符** 的捕捉器。    **(vue3.0 用到)**\n**handler.get()**                      ->  **属性读取**  操作的捕捉器。 **(vue3.0 用到)**\n**handler.set()**                      ->  **属性设置*** 操作的捕捉器。 **(vue3.0 用到)**\n**handler.deleteProperty()**           ->  **delete 操作符** 的捕捉器。**(vue3.0 用到)**\n**handler.ownKeys()**                  ->  **Object.getOwnPropertyNames 方法和 Object.getOwnPropertySymbols 方法**的捕捉器。**(vue3.0 用到)**\n\n**vue3.0 响应式没用到的捕获器（有兴趣的同学可以研究一下**）\n\n**handler.getPrototypeOf()**           ->  **Object.getPrototypeOf** 方法的捕捉器。\n**handler.setPrototypeOf()**           ->  **Object.setPrototypeOf** 方法的捕捉器。\n**handler.isExtensible()**             ->  **Object.isExtensible** 方法的捕捉器。\n**handler.preventExtensions()**        ->  **Object.preventExtensions** 方法的捕捉器。\n**handler.getOwnPropertyDescriptor()** ->  **Object.getOwnPropertyDescriptor** 方法的捕捉器。\n**handler.defineProperty()**           ->  **Object.defineProperty** 方法的捕捉器。\n**handler.apply()**                    ->  **函数调用操作** 的捕捉器。\n**handler.construct()**                ->  **new 操作符**  的捕捉器。\n\n#### ① has捕获器\n\n**has(target, propKey)**\n\ntarget:目标对象\n\npropKey:待拦截属性名\n\n作用:  拦截判断target对象是否含有属性propKey的操作\n\n拦截操作： **propKey in proxy**;   不包含for...in循环\n\n对应Reflect: **Reflect.has(target, propKey)**\n\n🌰例子：\n\n````js\nconst handler = {\n    has(target, propKey){\n        /*\n        * 做你的操作\n        */\n        return propKey in target\n    }\n}\nconst proxy = new Proxy(target, handler)\n\n````\n\n#### ② get捕获器\n\n**get(target, propKey, receiver)**\n\ntarget:目标对象\n\npropKey:待拦截属性名\n\nreceiver: proxy实例\n\n返回： 返回读取的属性\n\n作用：拦截对象属性的读取\n\n拦截操作：proxy[propKey]或者点运算符\n\n对应Reflect：  **Reflect.get(target, propertyKey[, receiver])**       \n\n🌰例子：\n\n````js\nconst handler = {\n    get: function(obj, prop) {\n        return prop in obj ? obj[prop] : '没有此水果';\n    }\n}\n\nconst foot = new Proxy({}, handler)\nfoot.apple = '苹果'\nfoot.banana = '香蕉';\n\nconsole.log(foot.apple, foot.banana);    /* 苹果 香蕉 */\nconsole.log('pig' in foot, foot.pig);    /* false 没有此水果 */\n````\n\n**特殊情况**\n\n````js\nconst person = {};\nObject.defineProperty(person, 'age', {\n  value: 18, \n  writable: false,\n  configurable: false\n})\nconst proxPerson = new Proxy(person, {\n  get(target,propKey) {\n    return 20\n    //应该return 18;不能返回其他值，否则报错\n  }\n})\nconsole.log( proxPerson.age ) /* 会报错 */\n````\n\n#### ③ set捕获器\n\n**set(target,propKey, value,receiver)**\n\ntarget:目标对象\n\npropKey:待拦截属性名\n\nvalue:新设置的属性值\n\nreceiver: proxy实例\n\n返回：严格模式下返回true操作成功；否则失败，报错\n\n作用： 拦截对象的属性赋值操作\n\n拦截操作： proxy[propkey] = value\n\n对应Reflect：  **Reflect.set(obj, prop, value, receiver)**       \n\n````js\nlet validator = {\n  set: function(obj, prop, value) {\n    if (prop === 'age') {\n      if (!Number.isInteger(value)) { /* 如果年龄不是整数 */\n        throw new TypeError('The age is not an integer')\n      }\n      if (value > 200) {  /* 超出正常的年龄范围 */\n        throw new RangeError('The age seems invalid')\n      }\n    }\n    obj[prop] = value\n    // 表示成功\n    return true\n  }\n}\nlet person = new Proxy({}, validator)\nperson.age = 100\nconsole.log(person.age)  // 100\nperson.age = 'young'     // 抛出异常: Uncaught TypeError: The age is not an integer\nperson.age = 300         // 抛出异常: Uncaught RangeError: The age seems invalid\n````\n**当对象的属性writable为false时，该属性不能在拦截器中被修改**\n\n````js\nconst person = {};\nObject.defineProperty(person, 'age', {\n    value: 18,\n    writable: false,\n    configurable: true,\n});\n\nconst handler = {\n    set: function(obj, prop, value, receiver) {\n        return Reflect.set(...arguments);\n    },\n};\nconst proxy = new Proxy(person, handler);\nproxy.age = 20;\nconsole.log(person) // {age: 18} 说明修改失败\n````\n\n\n#### ④ deleteProperty 捕获器\n\n**deleteProperty(target, propKey)**\n\ntarget:目标对象\n\npropKey:待拦截属性名\n\n返回：严格模式下只有返回true, 否则报错\n\n作用： 拦截删除target对象的propKey属性的操作\n\n拦截操作： delete proxy[propKey]\n\n对应Reflect：  **Reflect.delete(obj, prop)**     \n\n````js\n\nvar foot = { apple: '苹果' , banana:'香蕉'  }\nvar proxy = new Proxy(foot, {\n  deleteProperty(target, prop) {\n    console.log('当前删除水果 :',target[prop])\n    return delete target[prop]\n  }\n});\ndelete proxy.apple\nconsole.log(foot)\n\n/*\n运行结果：\n'当前删除水果 : 苹果'\n{  banana:'香蕉'  }\n*/\n````\n**特殊情况： 属性是不可配置属性时，不能删除**\n\n````js\nvar foot = {  apple: '苹果' }\nObject.defineProperty(foot, 'banana', {\n   value: '香蕉', \n   configurable: false\n})\nvar proxy = new Proxy(foot, {\n  deleteProperty(target, prop) {\n    return delete target[prop];\n  }\n})\ndelete proxy.banana /* 没有效果 */\nconsole.log(foot)\n````\n\n#### ⑤ownKeys 捕获器\n\n**ownKeys(target)**\n\ntarget：目标对象\n\n返回： 数组（数组元素必须是字符或者Symbol,其他类型报错）\n\n作用： 拦截获取键值的操作\n\n拦截操作：\n\n**1 Object.getOwnPropertyNames(proxy)**\n\n**2 Object.getOwnPropertySymbols(proxy)**\n\n**3 Object.keys(proxy)**\n\n**4 for...in...循环**\n\n对应Reflect：**Reflect.ownKeys()**\n\n\n ````js\nvar obj = { a: 10, [Symbol.for('foo')]: 2 };\nObject.defineProperty(obj, 'c', {\n    value: 3, \n    enumerable: false\n})\nvar p = new Proxy(obj, {\n  ownKeys(target) {\n    return [...Reflect.ownKeys(target), 'b', Symbol.for('bar')]\n  }\n})\nconst keys = Object.keys(p)  // ['a']\n// 自动过滤掉Symbol/非自身/不可遍历的属性\n\n/* 和Object.keys()过滤性质一样，只返回target本身的可遍历属性 */\nfor(let prop in p) { \n  console.log('prop-',prop) /* prop-a */\n}\n\n/* 只返回拦截器返回的非Symbol的属性，不管是不是target上的属性 */\nconst ownNames = Object.getOwnPropertyNames(p)  /* ['a', 'c', 'b'] */\n\n/* 只返回拦截器返回的Symbol的属性，不管是不是target上的属性*/\nconst ownSymbols = Object.getOwnPropertySymbols(p)// [Symbol(foo), Symbol(bar)]\n\n/*返回拦截器返回的所有值*/\nconst ownKeys = Reflect.ownKeys(p)\n// ['a','c',Symbol(foo),'b',Symbol(bar)]\n\n ````\n\n\n## 二 vue3.0 如何建立响应式\n\nvue3.0 建立响应式的方法有两种：\n第一个就是运用composition-api中的reactive直接构建响应式，composition-api的出现我们可以在.vue文件中，直接用setup()函数来处理之前的大部分逻辑，也就是说我们没有必要在 export default{ } 中在声明生命周期 ， data(){} 函数，watch{} , computed{} 等 ，取而代之的是我们在setup函数中，用vue3.0 reactive watch 生命周期api来到达同样的效果，这样就像react-hooks一样提升代码的复用率，逻辑性更强。\n\n第二个就是用传统的 data(){ return{} } 形式 ,vue3.0没有放弃对vue2.0写法的支持，而是对vue2.0的写法是完全兼容的，提供了**applyOptions** 来处理options形式的vue组件。但是options里面的data , watch , computed等处理逻辑，还是用了composition-api中的API对应处理。\n\n### 1 composition-api  reactive\n\nReactive 相当于当前的 Vue.observable () API，经过reactive处理后的函数能变成响应式的数据，类似于option api里面的vue处理data函数的返回值。\n\n我们用一个todoList的demo试着尝尝鲜。\n````js\n\nconst { reactive , onMounted } = Vue\nsetup(){\n    const state = reactive({\n        count:0,\n        todoList:[]\n    })\n    /* 生命周期mounted */\n    onMounted(() => {\n       console.log('mounted')\n    })\n    /* 增加count数量 */\n    function add(){\n        state.count++\n    } \n    /* 减少count数量 */\n    function del(){\n        state.count--\n    }\n    /* 添加代办事项 */\n    function addTodo(id,title,content){\n        state.todoList.push({\n            id,\n            title,\n            content,\n            done:false\n        })\n    }\n    /* 完成代办事项 */\n    function complete(id){\n        for(let i = 0; i< state.todoList.length; i++){\n            const currentTodo = state.todoList[i] \n            if(id === currentTodo.id){\n                state.todoList[i] = {\n                    ...currentTodo,\n                    done:true\n                } \n                break\n            }\n        }\n    }\n    return {\n        state,\n        add,\n        del,\n        addTodo,\n        complete\n    }\n}\n\n````\n\n### 2 options data\n\noptions形式的和vue2.0并没有什么区别\n\n````js\nexport default {\n    data(){\n        return{\n            count:0,\n            todoList:[] \n        }\n    },\n    mounted(){\n        console.log('mounted')\n    }\n    methods:{\n        add(){\n            this.count++\n        },\n        del(){\n            this.count--\n        },\n        addTodo(id,title,content){\n           this.todoList.push({\n               id,\n               title,\n               content,\n               done:false\n           })\n        },\n        complete(id){\n            for(let i = 0; i< this.todoList.length; i++){\n                const currentTodo = this.todoList[i] \n                if(id === currentTodo.id){\n                    this.todoList[i] = {\n                        ...currentTodo,\n                        done:true\n                    } \n                    break\n                }\n            }\n        }\n    }\n}\n\n````\n\n## 三 响应式原理初探\n\n### 不同类型的Reactive\nvue3.0可以根据业务需求引进不同的API方法。这里需要\n\n#### ① reactive\n\n建立响应式reactive，返回proxy对象，这个reactive可以深层次递归，也就是如果发现展开的属性值是**引用类型**的而且被**引用**，还会用reactive**递归处理**。而且属性是可以被修改的。\n\n#### ② shallowReactive\n\n建立响应式shallowReactive，返回proxy对象。和reactive的区别是只建立一层的响应式，也就是说如果发现展开属性是**引用类型**也不会**递归**。\n\n#### ③ readonly\n\n返回的proxy处理的对象，可以展开递归处理，但是属性是只读的，不能修改。可以做props传递给子组件使用。\n\n#### ④ shallowReadonly\n\n返回经过处理的proxy对象，但是建立响应式属性是只读的，不展开引用也不递归转换，可以这用于为有状态组件创建props代理对象。\n\n### 储存对象与proxy\n\n上文中我们提及到。用Reactive处理过并返回的对象是一个proxy对象，假设存在很多组件，或者在一个组件中被多次reactive，就会有很多对proxy对象和它代理的原对象。为了能把proxy对象和原对象建立关系，vue3.0采用了WeakMap去储存这些对象关系。WeakMaps 保持了对键名所引用的对象的弱引用，即垃圾回收机制不将该引用考虑在内。只要所引用的对象的其他引用都被清除，垃圾回收机制就会释放该对象所占用的内存。也就是说，一旦不再需要，WeakMap 里面的键名对象和所对应的键值对会自动消失，不用手动删除引用。\n\n\n````js\nconst rawToReactive = new WeakMap<any, any>()\nconst reactiveToRaw = new WeakMap<any, any>()\nconst rawToReadonly = new WeakMap<any, any>() /* 只读的 */\nconst readonlyToRaw = new WeakMap<any, any>() /* 只读的 */\n````\n\nvue3.0 用readonly来设置被拦截器拦截的对象能否被修改，可以满足之前的props不能被修改的单向数据流场景。\n我们接下来重点讲一下接下来的四个weakMap的储存关系。\n\n**rawToReactive**\n\n键值对 ： { [targetObject] : obseved  } \n\ntarget（键）:目标对象值(这里可以理解为**reactive**的第一个参数。)\nobsered（值）:经过proxy代理之后的proxy对象。 \n\n**reactiveToRaw**\nreactiveToRaw 储存的刚好与 rawToReactive的键值对是相反的。\n键值对 { [obseved] : targetObject }\n\n\n**rawToReadonly**\n\n键值对 ： { [target] : obseved  } \n\ntarget（键）：目标对象。\nobsered（值）:经过proxy代理之后的只读属性的proxy对象。 \n\n**readonlyToRaw**\n储存状态与rawToReadonly刚好相反。\n\n\n### reactive入口解析 \n接下来我们重点从reactive开始讲。\n\n#### reactive({ ...object }) 入口\n\n````js\n/* TODO: */\nexport function reactive(target: object) {\n  if (readonlyToRaw.has(target)) {\n    return target\n  }\n  return createReactiveObject(\n    target,                   /* 目标对象 */\n    rawToReactive,            /* { [targetObject] : obseved  }   */\n    reactiveToRaw,            /* { [obseved] : targetObject }  */\n    mutableHandlers,          /* 处理 基本数据类型 和 引用数据类型 */\n    mutableCollectionHandlers /* 用于处理 Set, Map, WeakMap, WeakSet 类型 */\n  )\n}\n````\n**reactive**函数的作用就是通过createReactiveObject方法产生一个proxy,而且针对不同的数据类型给定了不同的处理方法。\n\n\n#### createReactiveObject\n之前说到的createReactiveObject，我们接下来看看createReactiveObject发生了什么。\n\n````js\nconst collectionTypes = new Set<Function>([Set, Map, WeakMap, WeakSet])\nfunction createReactiveObject(\n  target: unknown,\n  toProxy: WeakMap<any, any>,\n  toRaw: WeakMap<any, any>,\n  baseHandlers: ProxyHandler<any>,\n  collectionHandlers: ProxyHandler<any>\n) {\n  /* 判断目标对象是否被effect */\n  /* observed 为经过 new Proxy代理的函数 */\n  let observed = toProxy.get(target) /* { [target] : obseved  } */\n  if (observed !== void 0) { /* 如果目标对象已经被响应式处理，那么直接返回proxy的observed对象 */\n    return observed\n  }\n  if (toRaw.has(target)) { /* { [observed] : target  } */\n    return target\n  }\n  /* 如果目标对象是 Set, Map, WeakMap, WeakSet 类型，那么 hander函数是 collectionHandlers 否侧目标函数是baseHandlers */\n  const handlers = collectionTypes.has(target.constructor)\n    ? collectionHandlers\n    : baseHandlers\n   /* TODO: 创建响应式对象  */\n  observed = new Proxy(target, handlers)\n  /* target 和 observed 建立关联 */\n  toProxy.set(target, observed)\n  toRaw.set(observed, target)\n  /* 返回observed对象 */\n  return observed\n}\n````\n\n\n通过上面源码创建proxy对象的大致流程是这样的：\n①首先判断目标对象有没有被proxy响应式代理过，如果是那么直接返回对象。\n②然后通过判断目标对象是否是[ Set, Map, WeakMap, WeakSet  ]数据类型来选择是用**collectionHandlers** ， 还是**baseHandlers->就是reactive传进来的mutableHandlers**作为proxy的hander对象。\n③最后通过真正使用new proxy来创建一个observed ，然后通过rawToReactive reactiveToRaw 保存 target和observed键值对。\n\n大致流程图：\n\n![在这里插入图片描述](https://img-blog.csdnimg.cn/2020080915460594.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3psX0FsaWVu,size_16,color_FFFFFF,t_70)\n\n\n\n\n## 四 拦截器对象baseHandlers -> mutableHandlers\n\n\n之前我们介绍过baseHandlers就是调用reactive方法createReactiveObject传进来的mutableHandlers对象。\n我们先来看一下mutableHandlers对象\n\n**mutableHandlers**\n\n### 拦截器的作用域\n\n````ts\nexport const mutableHandlers: ProxyHandler<object> = {\n  get,\n  set,\n  deleteProperty,\n  has,\n  ownKeys\n}\n````\nvue3.0 用到了以上几个拦截器，我们在上节已经介绍了这几个拦截器的基本用法,首先我们对几个基本用到的拦截器在做一下回顾。\n\n①get,对数据的读取属性进行拦截，包括 target.点语法  和 target[]\n\n②set，对数据的存入属性进行拦截 。\n\n③deleteProperty delete操作符进行拦截。\n\n**vue2.0**不能对对象的**delete操作符**进行属性拦截。\n\n例子🌰： \n````js\ndelete object.a\n````\n是无法监测到的。\n\n**vue3.0**proxy中**deleteProperty** 可以拦截 **delete 操作符**，这就表述vue3.0响应式可以监听到属性的删除操作。\n\n④has，对 in 操作符进行属性拦截。\n\n**vue2.0**不能对对象的**in操作符**进行属性拦截。\n\n例子 \n````js\na in object\n````\nhas 是为了解决如上问题。这就表示了vue3.0可以对 **in 操作符** 进行拦截。\n\n⑤ownKeys **Object.keys(proxy)** ,**for...in...循环** **Object.getOwnPropertySymbols(proxy)** ， **Object.getOwnPropertyNames(proxy)** 拦截器\n\n例子 \n````js\nObject.keys(object)\n````\n说明vue3.0可以对以上这些方法进行拦截。\n\n## 五 组件初始化阶段\n\n\n如果我们想要弄明白整个响应式原理。那么组件初始化，到初始化过程中composition-api的reactive处理data，以及编译阶段对data属性进行依赖收集是分不开的。vue3.0提供了一套从初始化，到render过程中依赖收集，到组件更新,到组件销毁完整响应式体系，我们很难从一个角度把东西讲明白，所以在正式讲拦截器对象如何收集依赖，派发更新之前，我们看看effect做了些什么操作。\n\n\n### 1 effect -> 新的渲染watcher\n\nvue3.0用effect副作用钩子来代替vue2.0watcher。我们都知道在vue2.0中，有渲染watcher专门负责数据变化后的从新渲染视图。vue3.0改用effect来代替watcher达到同样的效果。\n\n我们先简单介绍一下mountComponent流程，后面的文章会详细介绍mount阶段的\n#### 1 mountComponent 初始化mountComponent\n\n````js\n  // 初始化组件\n  const mountComponent: MountComponentFn = (\n    initialVNode,\n    container,\n    anchor,\n    parentComponent,\n    parentSuspense,\n    isSVG,\n    optimized\n  ) => {\n    /* 第一步: 创建component 实例   */\n    const instance: ComponentInternalInstance = (initialVNode.component = createComponentInstance(\n      initialVNode,\n      parentComponent,\n      parentSuspense\n    ))\n\n    /* 第二步 ： TODO:初始化 初始化组件,建立proxy , 根据字符窜模版得到 */\n    setupComponent(instance)\n    /* 第三步：建立一个渲染effect，执行effect */\n    setupRenderEffect(\n      instance,     // 组件实例\n      initialVNode, //vnode  \n      container,    // 容器元素\n      anchor,\n      parentSuspense,\n      isSVG,\n      optimized\n    )   \n  }\n````\n上面是整个mountComponent的主要分为了三步，我们这里分别介绍一下每个步骤干了什么：\n**① 第一步: 创建component 实例 。**\n**② 第二步：初始化组件,建立proxy ,根据字符窜模版得到render函数。生命周期钩子函数处理等等**\n**③ 第三步：建立一个渲染effect，执行effect。**\n\n从如上方法中我们可以看到，在**setupComponent**已经构建了响应式对象，但是还没有**初始化收集依赖**。\n\n\n#### 2 setupRenderEffect 构建渲染effect \n\n````js\n const setupRenderEffect: SetupRenderEffectFn = (\n    instance,\n    initialVNode,\n    container,\n    anchor,\n    parentSuspense,\n    isSVG,\n    optimized\n  ) => {\n    /* 创建一个渲染 effect */\n    instance.update = effect(function componentEffect() {\n      //...省去的内容后面会讲到\n    },{ scheduler: queueJob })\n  }\n````\n**为了让大家更清楚的明白响应式原理，我这只保留了和响应式原理有关系的部分代码。**\n\n**setupRenderEffect的作用**\n\n**① 创建一个effect，并把它赋值给组件实例的update方法，作为渲染更新视图用。**\n**② componentEffect作为回调函数形式传递给effect作为第一个参数**\n\n#### 3 effect做了些什么\n\n````js\nexport function effect<T = any>(\n  fn: () => T,\n  options: ReactiveEffectOptions = EMPTY_OBJ\n): ReactiveEffect<T> {\n  const effect = createReactiveEffect(fn, options)\n  /* 如果不是懒加载 立即执行 effect函数 */\n  if (!options.lazy) {\n    effect()\n  }\n  return effect\n}\n````\n**effect作用如下**\n\n**① 首先调用。createReactiveEffect**\n**② 如果不是懒加载 立即执行 由createReactiveEffect创建出来的ReactiveEffect函数**\n\n#### 4 ReactiveEffect\n\n````js\nfunction createReactiveEffect<T = any>(\n  fn: (...args: any[]) => T, /**回调函数 */\n  options: ReactiveEffectOptions\n): ReactiveEffect<T> {\n  const effect = function reactiveEffect(...args: unknown[]): unknown {\n    try {\n        enableTracking()\n        effectStack.push(effect) //往effect数组中里放入当前 effect\n        activeEffect = effect //TODO: effect 赋值给当前的 activeEffect\n        return fn(...args) //TODO:    fn 为effect传进来 componentEffect\n      } finally {\n        effectStack.pop() //完成依赖收集后从effect数组删掉这个 effect\n        resetTracking() \n        /* 将activeEffect还原到之前的effect */\n        activeEffect = effectStack[effectStack.length - 1]\n    }\n  } as ReactiveEffect\n  /* 配置一下初始化参数 */\n  effect.id = uid++\n  effect._isEffect = true\n  effect.active = true\n  effect.raw = fn\n  effect.deps = [] /* TODO:用于收集相关依赖 */\n  effect.options = options\n  return effect\n}\n````\ncreateReactiveEffect\n\n**createReactiveEffect**的作用主要是配置了一些初始化的参数，然后包装了之前传进来的fn，**重要的一点是把当前的effect赋值给了activeEffect,这一点非常重要，和收集依赖有着直接的关系**\n\n\n\n在这里留下了一个疑点，\n\n**①为什么要用effectStack数组来存放这里effect**\n\n### 总结\n\n我们这里个响应式初始化阶段进行总结 \n\n**① setupComponent创建组件，调用composition-api,处理options（构建响应式）得到Observer对象。**\n\n**② 创建一个渲染effect，里面包装了真正的渲染方法componentEffect，添加一些effect初始化属性。**\n\n**③ 然后立即执行effect，然后将当前渲染effect赋值给activeEffect**\n\n最后我们用一张图来解释一下整个流程。\n\n![在这里插入图片描述](https://img-blog.csdnimg.cn/2020080915560862.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3psX0FsaWVu,size_16,color_FFFFFF,t_70)\n\n## 六 依赖收集，get做了些什么？\n\n### 1 回归mutableHandlers中的get方法\n\n#### 1 不同类型的get\n\n````js\n/* 深度get */\nconst get = /*#__PURE__*/ createGetter()\n/* 浅get */\nconst shallowGet = /*#__PURE__*/ createGetter(false, true)\n/* 只读的get */\nconst readonlyGet = /*#__PURE__*/ createGetter(true)\n/* 只读的浅get */\nconst shallowReadonlyGet = /*#__PURE__*/ createGetter(true, true)\n````\n上面我们可以知道，对于之前讲的四种不同的建立响应式方法，对应了四种不同的get,下面是一一对应关系。\n\n**reactive ---------> get**\n\n**shallowReactive --------> shallowGet**\n\n**readonly ----------> readonlyGet**\n \n**shallowReadonly --------------->   shallowReadonlyGet**\n\n四种方法都是调用了createGetter方法，只不过是参数的配置不同，我们这里那第一个get方法做参考，接下来探索一下createGetter。\n\n#### createGetter\n\n````js\nfunction createGetter(isReadonly = false, shallow = false) {\n  return function get(target: object, key: string | symbol, receiver: object) {\n    const res = Reflect.get(target, key, receiver)\n    /* 浅逻辑 */\n    if (shallow) {\n      !isReadonly && track(target, TrackOpTypes.GET, key)\n      return res\n    }\n    /* 数据绑定 */\n    !isReadonly && track(target, TrackOpTypes.GET, key)\n    return isObject(res)\n      ? isReadonly\n        ?\n          /* 只读属性 */\n          readonly(res)\n          /*  */\n        : reactive(res)\n      : res\n  }\n}\n````\n这就是createGetter主要流程，**特殊的数据类型**和**ref**我们暂时先不考虑。\n这里用了一些流程判断，我们用流程图来说明一下这个函数主要做了什么？\n\n![在这里插入图片描述](https://img-blog.csdnimg.cn/2020080915563418.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3psX0FsaWVu,size_16,color_FFFFFF,t_70)\n\n\n\n我们可以得出结论：\n**在vue2.0的时候。响应式是在初始化的时候就深层次递归处理了**\n但是\n\n**与vue2.0不同的是,即便是深度响应式我们也只能在获取上一级get之后才能触发下一级的深度响应式。**\n比如\n````js\nsetup(){\n const state = reactive({ a:{ b:{} } })\n return {\n     state\n }\n}\n````\n**在初始化的时候，只有a的一层级建立了响应式，b并没有建立响应式，而当我们用state.a的时候，才会真正的将b也做响应式处理，也就是说我们访问了上一级属性后，下一代属性才会真正意义上建立响应式**\n\n这样做好处是，\n**1 初始化的时候不用递归去处理对象，造成了不必要的性能开销。**\n**2 有一些没有用上的state，这里就不需要在深层次响应式处理。*\n\n### 2 track->依赖收集器\n\n我们先来看看track源码：\n\n#### track做了些什么\n````js\n\n/* target 对象本身 ，key属性值  type 为 'GET' */\nexport function track(target: object, type: TrackOpTypes, key: unknown) {\n  /* 当打印或者获取属性的时候 console.log(this.a) 是没有activeEffect的 当前返回值为0  */\n  let depsMap = targetMap.get(target)\n  if (!depsMap) {\n    /*  target -map-> depsMap  */\n    targetMap.set(target, (depsMap = new Map()))\n  }\n  let dep = depsMap.get(key)\n  if (!dep) {\n    /* key : dep dep观察者 */\n    depsMap.set(key, (dep = new Set()))\n  }\n   /* 当前activeEffect */\n  if (!dep.has(activeEffect)) {\n    /* dep添加 activeEffect */\n    dep.add(activeEffect)\n    /* 每个 activeEffect的deps 存放当前的dep */\n    activeEffect.deps.push(dep)\n  }\n}\n````\n里面主要引入了两个概念 **targetMap** 和 **depsMap**\n\n**targetMap**\n键值对 proxy  :  depsMap \nproxy ： 为reactive代理后的 Observer对象 。\ndepsMap ：为存放依赖dep的 map 映射。\n\n**depsMap**\n键值对：key : deps\nkey 为当前get访问的属性名，\ndeps 存放effect的set数据类型。\n\n**我们知道track作用大致是，首先根据 proxy对象，获取存放deps的depsMap，然后通过访问的属性名key获取对应的dep,然后将当前激活的effect存入当前dep收集依赖。**\n\n主要作用\n**①找到与当前proxy 和 key对应的dep。**\n**②dep与当前activeEffect建立联系，收集依赖。**\n\n为了方便理解，**targetMap** 和 **depsMap**的关系，下面我们用一个例子来说明：\n例子：\n父组件A\n````html\n\n<div id=\"app\" >\n  <span>{{ state.a }}</span>\n  <span>{{ state.b }}</span>\n<div>\n<script>\nconst { createApp, reactive } = Vue\n\n/* 子组件 */\nconst Children ={\n    template=\"<div> <span>{{ state.c }}</span> </div>\",\n    setup(){\n       const state = reactive({\n          c:1\n       })\n       return {\n           state\n       }\n    }\n}\n/* 父组件 */\ncreateApp({\n   component:{\n       Children\n   } \n   setup(){\n       const state = reactive({\n           a:1,\n           b:2\n       })\n       return {\n           state\n       }\n   }\n})mount('#app')\n\n</script>\n\n````\n\n我们用一幅图表示如上关系：\n\n\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20200809155701302.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3psX0FsaWVu,size_16,color_FFFFFF,t_70)\n\n\n### 渲染effect函数如何触发get\n\n我们在前面说过，创建一个渲染renderEffect，然后把赋值给activeEffect，最后执行renderEffect ，在这个期间是怎么做依赖收集的呢，让我们一起来看看,update函数中做了什么，我们回到之前讲的componentEffect逻辑上来\n\n````js\nfunction componentEffect() {\n    if (!instance.isMounted) {\n        let vnodeHook: VNodeHook | null | undefined\n        const { el, props } = initialVNode\n        const { bm, m, a, parent } = instance\n        /* TODO: 触发instance.render函数，形成树结构 */\n        const subTree = (instance.subTree = renderComponentRoot(instance))\n        if (bm) {\n          //触发 beforeMount声明周期钩子\n          invokeArrayFns(bm)\n        }\n        patch(\n            null,\n            subTree,\n            container,\n            anchor,\n            instance,\n            parentSuspense,\n            isSVG\n        )\n        /* 触发声明周期 mounted钩子 */\n        if (m) {\n          queuePostRenderEffect(m, parentSuspense)\n        }\n        instance.isMounted = true\n      } else {\n        // 更新组件逻辑\n        // ......\n      }\n}\n\n\n````\n\n**这边代码大致首先会通过renderComponentRoot方法形成树结构，这里要注意的是，我们在最初mountComponent的setupComponent方法中，已经通过编译方法compile编译了template模版的内容，state.a state.b等抽象语法树，最终返回的render函数在这个阶段会被触发，在render函数中在模版中的表达式 state.a state.b 点语法会被替换成data中真实的属性，这时候就进行了真正的依赖收集，触发了get方法。接下来就是触发生命周期 beforeMount ,然后对整个树结构重新patch,patch完毕后，调用mounted钩子**\n\n### 依赖收集流程总结\n\n\n① 首先执行renderEffect ，赋值给activeEffect ，调用renderComponentRoot方法，然后触发render函数。\n\n② 根据render函数，解析经过compile，语法树处理过后的模版表达式，访问真实的data属性，触发get。\n\n③ get方法首先经过之前不同的reactive，通过track方法进行依赖收集。\n\n④ track方法通过当前proxy对象target,和访问的属性名key来找到对应的dep。\n\n⑤ 将dep与当前的activeEffect建立起联系。将activeEffect压入dep数组中，（此时的dep中已经含有当前组件的渲染effect,这就是响应式的根本原因）如果我们触发set，就能在数组中找到对应的effect，依次执行。\n\n最后我们用一个流程图来表达一下依赖收集的流程。\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20200809155729316.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3psX0FsaWVu,size_16,color_FFFFFF,t_70)\n\n\n## 七 set 派发更新\n\n接下来我们set部分逻辑。\n\n````js\n\nconst set = /*#__PURE__*/ createSetter()\n/* 浅逻辑 */\nconst shallowSet = /*#__PURE__*/ createSetter(true)\n````\nset也是分两个逻辑，set和shallowSet,两种方法都是由createSetter产生，我们这里主要以set进行剖析。\n\n### createSetter创建set\n\n````js\nfunction createSetter(shallow = false) {\n  return function set(\n    target: object,\n    key: string | symbol,\n    value: unknown,\n    receiver: object\n  ): boolean {\n    const oldValue = (target as any)[key]\n    /* shallowSet逻辑 */\n\n    const hadKey = hasOwn(target, key)\n    const result = Reflect.set(target, key, value, receiver)\n    /* 判断当前对象，和存在reactiveToRaw 里面是否相等 */\n    if (target === toRaw(receiver)) {\n      if (!hadKey) { /* 新建属性 */\n        /*  TriggerOpTypes.ADD -> add */\n        trigger(target, TriggerOpTypes.ADD, key, value)\n      } else if (hasChanged(value, oldValue)) {\n        /* 改变原有属性 */\n        /*  TriggerOpTypes.SET -> set */\n        trigger(target, TriggerOpTypes.SET, key, value, oldValue)\n      }\n    }\n    return result\n  }\n}\n````\n**createSetter的流程大致是这样的**\n\n**① 首先通过toRaw判断当前的proxy对象和建立响应式存入reactiveToRaw的proxy对象是否相等。**\n**② 判断target有没有当前key,如果存在的话，改变属性，执行trigger(target, TriggerOpTypes.SET, key, value, oldValue)。**\n**③ 如果当前key不存在，说明是赋值新属性，执行trigger(target, TriggerOpTypes.ADD, key, value)。**\n\n### trigger\n\n````js\n/* 根据value值的改变，从effect和computer拿出对应的callback ，然后依次执行 */\nexport function trigger(\n  target: object,\n  type: TriggerOpTypes,\n  key?: unknown,\n  newValue?: unknown,\n  oldValue?: unknown,\n  oldTarget?: Map<unknown, unknown> | Set<unknown>\n) {\n  /* 获取depssMap */\n  const depsMap = targetMap.get(target)\n  /* 没有经过依赖收集的 ，直接返回 */\n  if (!depsMap) {\n    return\n  }\n  const effects = new Set<ReactiveEffect>()        /* effect钩子队列 */\n  const computedRunners = new Set<ReactiveEffect>() /* 计算属性队列 */\n  const add = (effectsToAdd: Set<ReactiveEffect> | undefined) => {\n    if (effectsToAdd) {\n      effectsToAdd.forEach(effect => {\n        if (effect !== activeEffect || !shouldTrack) {\n          if (effect.options.computed) { /* 处理computed逻辑 */\n            computedRunners.add(effect)  /* 储存对应的dep */\n          } else {\n            effects.add(effect)  /* 储存对应的dep */\n          }\n        }\n      })\n    }\n  }\n\n  add(depsMap.get(key))\n\n  const run = (effect: ReactiveEffect) => {\n    if (effect.options.scheduler) { /* 放进 scheduler 调度*/\n      effect.options.scheduler(effect)\n    } else {\n      effect() /* 不存在调度情况，直接执行effect */\n    }\n  }\n\n  //TODO: 必须首先运行计算属性的更新，以便计算的getter\n  //在任何依赖于它们的正常更新effect运行之前，都可能失效。\n\n  computedRunners.forEach(run) /* 依次执行computedRunners 回调*/\n  effects.forEach(run) /* 依次执行 effect 回调（ TODO: 里面包括渲染effect ）*/\n}\n````\n我们这里保留了trigger的核心逻辑\n\n**① 首先从targetMap中，根据当前proxy找到与之对应的depsMap。**\n**② 根据key找到depsMap中对应的deps，然后通过add方法分离出对应的effect回调函数和computed回调函数。**\n**③ 依次执行computedRunners 和 effects 队列里面的回调函数，如果发现需要调度处理,放进scheduler事件调度**\n\n值得注意的的是：\n\n**此时的effect队列中有我们上述负责渲染的renderEffect，还有通过effectAPI建立的effect，以及通过watch形成的effect。我们这里只考虑到渲染effect。至于后面的情况会在接下来的文章中和大家一起分享。**\n\n我们用一幅流程图说明一下set过程。\n\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20200809155749287.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3psX0FsaWVu,size_16,color_FFFFFF,t_70)\n\n## 八 总结\n\n我们总结一下整个数据绑定建立响应式大致分为三个阶段\n\n1 初始化阶段： 初始化阶段通过组件初始化方法形成对应的**proxy**对象，然后形成一个负责渲染的effect。\n\n2 get依赖收集阶段：通过解析template，替换真实data属性，来触发get,然后通过**stack**方法，通过proxy对象和key形成对应的deps，将负责渲染的effect存入deps。（这个过程还有其他的effect，比如watchEffect存入deps中 ）。\n\n3 set派发更新阶段：当我们 this[key] = value 改变属性的时候，首先通过**trigger**方法，通过proxy对象和key找到对应的deps，然后给deps分类分成computedRunners和effect,然后依次执行，如果需要**调度**的，直接放入调度。\n\n **微信扫码关注公众号，定期分享技术文章**\n\n             \n ![在这里插入图片描述](https://img-blog.csdnimg.cn/20200603103334627.jpg#pic_center)", "user_name": "我不是外星人", "description": "", "got_view_count": 3077, "category_name": "前端", "ctime": 1457483942}
{"tag_name": "JavaScript", "concern_user_count": 343215, "user_id": "2119514149895512", "title": "前端10个灵魂拷问 吃透这些你就能摆脱初级前端工程师！", "mark_content": "\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6039fc0ddce54be49046a9c272eff7cd~tplv-k3u1fbpfcp-zoom-1.image) \n \n> 网上参差不弃的面试题，本文由浅入深，让你在做面试官的时候，能够辨别出面试者是不是真的有点东西，也能让你去面试中级前端工程师更有底气。但是切记把背诵面试题当成了你的唯一求职方向\n\n- 越是开放性的题目，更能体现回答者的水平，一场好的面试，不仅能发现面试者的不足，也能找到他的闪光点，还能提升面试官自身的技术\n\n### 1.`Css`和`Html`合并在第一个题目，请简述你让一个元素在窗口中消失以及垂直水平居中的方法，还有`Flex`布局的理解\n\n\n标准答案：百度上当然很多，这里不做阐述，好的回答思路是：\n* 元素消失的方案先列出来， `display:none`和`visibility: hidden;`的区别，拓展到`vue`框架的`v-if`和`v-show`的区别，可以搭配回流和重绘来讲解\n\n#### 回流必将引起重绘，重绘不一定会引起回流\n\n##### 回流(Reflow)：\n>  当`Render Tree`中部分或全部元素的尺寸、结构、或某些属性发生改变时，浏览器重新渲染部分或全部文档的过程称为回流\n\n* 下面内容会导致回流:\n * 页面首次渲染\n * 浏览器窗口大小发生改变\n * 元素尺寸或位置发生改变\n * 元素内容变化（文字数量或图片大小等等）\n * 元素字体大小变化\n * 添加或者删除可见的DOM元素\n * 激活CSS伪类（例如：:hover）\n * 查询某些属性或调用某些方法\n\n* 一些常用且会导致回流的属性和方法：\n\n * clientWidth、clientHeight、clientTop、clientLeft\n * offsetWidth、offsetHeight、offsetTop、offsetLeft\n * scrollWidth、scrollHeight、scrollTop、scrollLeft\n * scrollIntoView()、scrollIntoViewIfNeeded()\n * getComputedStyle()\n * getBoundingClientRect()\n * scrollTo()\n \n\n#### 重绘\n> 当页面中元素样式的改变并不影响它在文档流中的位置时（例如：color、background-color、visibility等），浏览器会将新样式赋予给元素并重新绘制它，这个过程称为重绘。\n\n#### 性能影响对比： \n\n![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d94aef9c8f064f6baa4c335f4be9983e~tplv-k3u1fbpfcp-zoom-1.image)\n \n\n[原文出处，感谢作者][1]\n\n* 列出元素垂直居中的方案，以及各种方案的缺陷\n\n[16种居中方案，感谢作者][2]\n\n* 讲出`flex`常用的场景，以及`flex 1`做了什么 \n\n[阮一峰老师的Flex布局][3]\n\n> 上面的问题如果答得非常好，在重绘和回流这块要下大功夫。这点是前端性能优化的基础，而性能优化是前端最重要的核心基础技能点，也是面试官最看中的基础之一\n\n\n\n\n\n\n### 2.你对`This`了解吗，有自己实现过`call,apply,bind`吗？\n\n[50行`javaScript`代码实现call,apply,bind][4]\n\n这是一个很基础的技能点，考察你对闭包，函数调用的理解程度，我感觉我写得比较简单容易懂\n\n### 3.如何减少重绘和回流的次数：\n\n ![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/345c2632d626430c88569741450c9309~tplv-k3u1fbpfcp-zoom-1.image)\n\n\n### 4.你对前端的异步编程有哪些了解呢\n\n这个题目如果回答非常完美，那么可以判断这个人已经脱离了初级前端工程师，前端的核心就是异步编程，这个题目也是体现前端工程师基础是否扎实的最重要依据。\n\n\n\n还是老规矩，从易到难吧\n\n#### 传统的定时器，异步编程：\n```\nsetTimeout(),setInterval()等。\n\n缺点：当同步的代码比较多的时候，不确定异步定时器的任务时候能在指定的时间执行。\n\n例如：\n\n在第100行执行代码 setTimeout(()=>{console.log(1)},1000)//1s后执行里面函数\n\n但是后面可能有10000行代码+很多计算的任务，例如循环遍历，那么1s后就无法输出console.log(1)\n\n可能要到2s甚至更久\n\nsetInterval跟上面同理 当同步代码比较多时，不确保每次能在一样的间隔执行代码，\n\n如果是动画，那么可能会掉帧\n\n```\n\n#### `ES6`的异步编程：\n> `promise generator async`\n \n- ``` new promise((resolve,reject)=>{ resolve() }).then()....```\n-缺点： 仍然没有摆脱回掉函数，虽然改善了回掉地狱\n \n- `generator`函数 调用next()执行到下一个yeild的代码内容，如果传入参数则作为上一个`yield`的返回值\n -缺点：不够自动化\n\n- `async await`\n- 只有async函数内部可以用await,将异步代码变成同步书写，但是由于async函数本身返回一个promise,也很容易产生async嵌套地狱\n \n\n\n### `requestAnimationFrame`和`requestIdleCallback`：\n\n> 传统的`javascript `动画是通过定时器 `setTimeout `或者 `setInterval` 实现的。但是定时器动画一直存在两个问题\n\n- 第一个就是动画的循时间环间隔不好确定，设置长了动画显得不够平滑流畅，设置短了浏览器的重绘频率会达到瓶颈，推荐的最佳循环间隔是`17ms`（大多数电脑的显示器刷新频率是`60Hz，1000ms/60`）；\n\n- 第二个问题是定时器第二个时间参数只是指定了多久后将动画任务添加到浏览器的UI线程队列中，如果UI线程处于忙碌状态，那么动画不会立刻执行。为了解决这些问题，H5 中加入了 `requestAnimationFrame`以及`requestIdleCallback`\n\n- `requestAnimationFrame` 会把每一帧中的所有 DOM 操作集中起来，在一次重绘或回流中就完成，并且重绘或回流的时间间隔紧紧跟随浏览器的刷新频率\n\n- 在隐藏或不可见的元素中，`requestAnimationFrame` 将不会进行重绘或回流，这当然就意味着更少的 CPU、GPU 和内存使用量\n\n- `requestAnimationFrame` 是由浏览器专门为动画提供的 `API`，在运行时浏览器会自动优化方法的调用，并且如果页面不是激活状态下的话，动画会自动暂停，有效节省了` CPU` 开销\n\n#### 性能对比：\n\n\n ![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4531de12698d46618cc7e963fa7f4b67~tplv-k3u1fbpfcp-zoom-1.image)\n\n- `requestAnimationFrame`的回调会在每一帧确定执行，属于高优先级任务，而`requestIdleCallback`的回调则不一定，属于低优先级任务。\n\n- 我们所看到的网页，都是浏览器一帧一帧绘制出来的，通常认为`FPS为60`的时候是比较流畅的，而FPS为个位数的时候就属于用户可以感知到的卡顿了，那么在一帧里面浏览器都要做哪些事情呢，如下所示：\n\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1493a3df93bb42949e86f2e22bae7aa7~tplv-k3u1fbpfcp-zoom-1.image)\n\n- 图中一帧包含了用户的交互、js的执行、以及requestAnimationFrame的调用，布局计算以及页面的重绘等工作。\n\n- 假如某一帧里面要执行的任务不多，在不到16ms（1000/60)的时间内就完成了上述任务的话，那么这一帧就会有一定的空闲时间，这段时间就恰好可以用来执行requestIdleCallback的回调，如下图所示：\n\n \n![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6caeb53fcf23485fbc5209984840dc4f~tplv-k3u1fbpfcp-zoom-1.image)\n\n\n\n### 5.简述浏览器的`Eventloop`和`Node.js`的`Eventloop`\n\n#### 浏览器的`EventLoop` \n\n\n ![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1ef86699c22b4b6aa356b3d5a54b77ea~tplv-k3u1fbpfcp-zoom-1.image)\n\n> 不想解释太多，看图\n\n#### `Node.js`的`EventLoop` \n\n\n ![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c8c9e6d5b6fa407fa2ff17b1d821210c~tplv-k3u1fbpfcp-zoom-1.image)\n\n#### 特别提示：网上大部分`Node.js`的`EventLoop`的面试题，都会有`BUG`，代码量和计算量太少，很可能还没有执行到微任务的代码，定时器就到时间被执行了\n\n\n### 6.闭包与`V8`垃圾回收机制：\n\n> JS 的垃圾回收机制的基本原理是：\n\n- 找出那些不再继续使用的变量，然后释放其占用的内存，垃圾收集器会按照固定的时间间隔周期性地执行这一操作。\n\n- V8 的垃圾回收策略主要基于分代式垃圾回收机制，在 V8 中，将内存分为新生代和老生代，新生代的对象为存活时间较短的对象，老生代的对象为存活事件较长或常驻内存的对象。\n\n\n ![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/cd3b1a0ccf7644168728f92e5cee6e21~tplv-k3u1fbpfcp-zoom-1.image)\n- V8 堆的整体大小等于新生代所用内存空间加上老生代的内存空间，而只能在启动时指定，意味着运行时无法自动扩充，如果超过了极限值，就会引起进程出错。\n\n#### `Scavenge` 算法\n- 在分代的基础上，新生代的对象主要通过 Scavenge 算法进行垃圾回收，在 Scavenge 具体实现中，主要采用了一种复制的方式的方法—— Cheney 算法。\n\n- Cheney 算法将堆内存一分为二，一个处于使用状态的空间叫 From 空间，一个处于闲置状态的空间称为 To 空间。分配对象时，先是在 From 空间中进行分配。\n\n- 当开始进行垃圾回收时，会检查 From 空间中的存活对象，将其复制到 To 空间中，而非存活对象占用的空间将会被释放。完成复制后，From 空间和 To 空间的角色发生对换。\n\n\n\n ![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f01b71ee6ba644e4bb72a0b8215d7dc2~tplv-k3u1fbpfcp-zoom-1.image)\n- 当一个对象经过多次复制后依然存活，他将会被认为是生命周期较长的对象，随后会被移动到老生代中，采用新的算法进行管理。\n\n- 还有一种情况是，如果复制一个对象到 To 空间时，To 空间占用超过了 25%，则这个对象会被直接晋升到老生代空间中。\n \n\n#### 标记-清除和标记-整理算法\n- 对于老生代中的对象，主要采用标记-清除和标记-整理算法。标记-清除 和前文提到的标记一样，与 Scavenge 算法相比，标记清除不会将内存空间划为两半，标记清除在标记阶段会标记活着的对象，而在内存回收阶段，它会清除没有被标记的对象。\n\n- 而标记整理是为了解决标记清除后留下的内存碎片问题。\n\n#### 增量标记（`Incremental Marking`）算法\n- 前面的三种算法，都需要将正在执行的 JavaScript 应用逻辑暂停下来，待垃圾回收完毕后再恢复。这种行为叫作“全停顿”（stop-the-world）。\n\n- 在 V8 新生代的分代回收中，只收集新生代，而新生代通常配置较小，且存活对象较少，所以全停顿的影响不大，而老生代就相反了。\n\n- 为了降低全部老生代全堆垃圾回收带来的停顿时间，V8将标记过程分为一个个的子标记过程，同时让垃圾回收标记和JS应用逻辑交替进行，直到标记阶段完成。\n\n ![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/abd14220969b4741ad402a06f1705452~tplv-k3u1fbpfcp-zoom-1.image)\n- 经过增量标记改进后，垃圾回收的最大停顿时间可以减少到原来的 1/6 左右。\n\n#### 内存泄漏\n\n- 内存泄漏（Memory Leak）是指程序中己动态分配的堆内存由于某种原因程序未释放或无法释放，造成系统内存的浪费，导致程序运行速度减慢甚至系统崩溃等严重后果。\n\n- 内存泄漏的常见场景：\n\n* 缓存:存在内存中数据一只没有被清掉\n\n* 作用域未释放（闭包）\n* 无效的 DOM 引用\n* 没必要的全局变量\n* 定时器未清除(`React`中的合成事件，还有原生事件的绑定区别)\n* 事件监听为清空\n* 内存泄漏优化\n\n### 7.你熟悉哪些通信协议，它们的优缺点？\n\n[通信协议全解][5]\n\n- 我的这篇文章非常详细介绍了 `http1.0 http1.1 http2.0 https websocket`等协议\n\n### 8.从输入`url`地址栏，发生了什么？由此来介绍如何性能优化：\n\n[性能优化不完全手册][6]\n\n[如何优化你的超大型React应用][7]\n\n- 我的这两篇文章基本上涵盖了前端基础的性能优化，后期我会再出专栏。\n\n### 9.浏览器的缓存实现，请您介绍：\n\n1.`preload,prefetch,dns-prefetch`等\n\n[什么是preload][8]\n\n- 使用 preload 指令的好处包括：\n\n- 允许浏览器来设定资源加载的优先级因此可以允许前端开发者来优化指定资源的加载。\n\n- 赋予浏览器决定资源类型的能力，因此它能分辨这个资源在以后是否可以重复利用。\n\n- 浏览器可以通过指定 as 属性来决定这个请求是否符合 content security policy。\n\n- 浏览器可以基于资源的类型（比如 image/webp）来发送适当的 accept 头。\n \n\n#### `Prefetch`\n\n- `Prefetch` 是一个低优先级的资源提示，允许浏览器在后台（空闲时）获取将来可能用得到的资源，并且将他们存储在浏览器的缓存中。一旦一个页面加载完毕就会开始下载其他的资源，然后当用户点击了一个带有 prefetched 的连接，它将可以立刻从缓存中加载内容。\n \n\n#### `DNS Prefetching`\n\n- `DNS prefetching` 允许浏览器在用户浏览页面时在后台运行 DNS 的解析。如此一来，DNS 的解析在用户点击一个链接时已经完成，所以可以减少延迟。可以在一个 link 标签的属性中添加 rel=\"dns-prefetch'  来对指定的 URL 进行` DNS prefetching`，我们建议`Google fonts，Google Analytics` 和` CDN` 进行处理。\n\n\n \n2.`servece-worker`,`PWA`渐进式web应用 \n\n[PWA文档][9]\n\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d1abade1fb454d4cb7c6d198b92ed9b5~tplv-k3u1fbpfcp-zoom-1.image)\n\n3.`localstorage,sessionstorage,cookie,session`等。\n[浏览器的会话存储和持久性存储][10]\n4.浏览器缓存的实现机制的实现\n\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/595c27f811fc4e14bacee79d929a45ce~tplv-k3u1fbpfcp-zoom-1.image)\n\n\n### 10.同源策略是什么，跨域解决办法，`cookie`可以跨域吗？\n [跨域解决的办法][11]\n\nQ：为什么会出现跨域问题？\n\nA：出于浏览器的同源策略限制，浏览器会拒绝跨域请求。 \n\n * 注：严格的说，浏览器并不是拒绝所有的跨域请求，实际上拒绝的是跨域的读操作。浏览器的同源限制策略是这样执行的：\n\n- 通常浏览器允许进行跨域写操作（Cross-origin writes），如链接，重定向；\n\n- 通常浏览器允许跨域资源嵌入（Cross-origin embedding），如 img、script 标签；\n\n- 通常浏览器不允许跨域读操作（Cross-origin reads）。\n\nQ：什么情况才算作跨域？ \n\n A：非同源请求，均为跨域。名词解释：同源 —— 如果两个页面拥有相同的协议（protocol），端口（port）和主机（host），那么这两个页面就属于同一个源（origin）。\n\nQ：为什么有跨域需求? \n\n - A：场景 —— 工程服务化后，不同职责的服务分散在不同的工程中，往往这些工程的域名是不同的，但一个需求可能需要对应到多个服务，这时便需要调用不同服务的接口，因此会出现跨域。\n\n- 方法：`JSONP`,`CORS`,`postmessage`,`webscoket`，反向代理服务器等。\n \n#### 最后\n\n* 大家感觉写得不错，可以点个赞和关注\n* 顺便关注下我的公众号： `前端巅峰`\n \n\n  [1]: https://juejin.im/post/5a9923e9518825558251c96a\n  [2]: https://juejin.im/post/58f818bbb123db006233ab2a\n  [3]: http://www.ruanyifeng.com/blog/2015/07/flex-grammar.html\n  [4]: https://segmentfault.com/a/1190000020044435\n  [5]: https://segmentfault.com/a/1190000019891825\n  [6]: https://segmentfault.com/a/1190000018827395\n  [7]: https://juejin.im/post/5d35d3ecf265da1bc23fb654\n  [8]: https://juejin.im/post/5b5984b851882561da216311\n  [9]: https://lavas.baidu.com/pwa/README\n  [10]: https://juejin.im/post/5ad5b9116fb9a028e014fb19\n  [11]: https://juejin.im/post/59c132415188256bb018e825", "user_name": "Peter谭老师", "description": "公众号 : 前端巅峰", "got_view_count": 34022, "category_name": "前端", "ctime": 1457483942}
{"tag_name": "Java", "concern_user_count": 252044, "user_id": "712139234346894", "title": "丢弃掉那些BeanUtils工具类吧，MapStruct真香！！！", "mark_content": "在前几天的文章《[为什么阿里巴巴禁止使用Apache Beanutils进行属性的copy？][1]》中，我曾经对几款属性拷贝的工具类进行了对比。\n\n然后在评论区有些读者反馈说MapStruct才是真的香，于是我就抽时间了解了一下MapStruct。结果我发现，这真的是一个神仙框架，炒鸡香。\n\n这一篇文章就来简单介绍下MapStruct的用法，并且再和其他几个工具类进行一下对比。\n\n### 为什么需要MapStruct ？\n\n首先，我们先说一下MapStruct这类框架适用于什么样的场景，为什么市面上会有这么多的类似的框架。\n\n在软件体系架构设计中，分层式结构是最常见，也是最重要的一种结构。很多人都对三层架构、四层架构等并不陌生。\n\n甚至有人说：**\"计算机科学领域的任何问题都可以通过增加一个间接的中间层来解决，如果不行，那就加两层。\"**\n\n但是，随着软件架构分层越来越多，那么各个层次之间的数据模型就要面临着相互转换的问题，典型的就是我们可以在代码中见到各种O，如DO、DTO、VO等。\n\n一般情况下，同样一个数据模型，我们在不同的层次要使用不同的数据模型。**如在数据存储层，我们使用DO来抽象一个业务实体；在业务逻辑层，我们使用DTO来表示数据传输对象；到了展示层，我们又把对象封装成VO来与前端进行交互。**\n\n那么，数据的从前端透传到数据持久化层（从持久层透传到前端），就需要进行对象之间的互相转化，即在不同的对象模型之间进行映射。\n\n通常我们可以使用get/set等方式逐一进行字段映射操作，如：\n\n    personDTO.setName(personDO.getName());\n    personDTO.setAge(personDO.getAge());\n    personDTO.setSex(personDO.getSex());\n    personDTO.setBirthday(personDO.getBirthday());\n    \n\n但是，编写这样的映射代码是一项冗长且容易出错的任务。MapStruct等类似的框架的目标是通过自动化的方式尽可能多地简化这项工作。\n\n### MapStruct的使用\n\nMapStruct（https://mapstruct.org/ ）是一种代码生成器，它极大地简化了基于\"约定优于配置\"方法的Java bean类型之间映射的实现。生成的映射代码使用纯方法调用，因此快速、类型安全且易于理解。\n\n> 约定优于配置，也称作按约定编程，是一种软件设计范式，旨在减少软件开发人员需做决定的数量，获得简单的好处，而又不失灵活性。\n\n假设我们有两个类需要进行互相转换，分别是PersonDO和PersonDTO，类定义如下：\n\n    public class PersonDO {\n        private Integer id;\n        private String name;\n        private int age;\n        private Date birthday;\n        private String gender;\n    }\n    \n    public class PersonDTO {\n        private String userName;\n        private Integer age;\n        private Date birthday;\n        private Gender gender;\n    }\n    \n\n我们演示下如何使用MapStruct进行bean映射。\n\n想要使用MapStruct，首先需要依赖他的相关的jar包，使用maven依赖方式如下：\n\n    ...\n    <properties>\n        <org.mapstruct.version>1.3.1.Final</org.mapstruct.version>\n    </properties>\n    ...\n    <dependencies>\n        <dependency>\n            <groupId>org.mapstruct</groupId>\n            <artifactId>mapstruct</artifactId>\n            <version>${org.mapstruct.version}</version>\n        </dependency>\n    </dependencies>\n    ...\n    <build>\n        <plugins>\n            <plugin>\n                <groupId>org.apache.maven.plugins</groupId>\n                <artifactId>maven-compiler-plugin</artifactId>\n                <version>3.8.1</version>\n                <configuration>\n                    <source>1.8</source> <!-- depending on your project -->\n                    <target>1.8</target> <!-- depending on your project -->\n                    <annotationProcessorPaths>\n                        <path>\n                            <groupId>org.mapstruct</groupId>\n                            <artifactId>mapstruct-processor</artifactId>\n                            <version>${org.mapstruct.version}</version>\n                        </path>\n                        <!-- other annotation processors -->\n                    </annotationProcessorPaths>\n                </configuration>\n            </plugin>\n        </plugins>\n    </build>\n    \n\n因为MapStruct需要在编译器生成转换代码，所以需要在maven-compiler-plugin插件中配置上对mapstruct-processor的引用。这部分在后文会再次介绍。\n\n之后，我们需要定义一个做映射的接口，主要代码如下：\n\n    @Mapper\n    interface PersonConverter {\n        PersonConverter INSTANCE = Mappers.getMapper(PersonConverter.class);\n    \n        @Mappings(@Mapping(source = \"name\", target = \"userName\"))\n        PersonDTO do2dto(PersonDO person);\n    }\n    \n\n使用注解 `@Mapper`定义一个Converter接口，在其中定义一个do2dto方法，方法的入参类型是PersonDO，出参类型是PersonDTO，这个方法就用于将PersonDO转成PersonDTO。\n\n测试代码如下：\n\n    public static void main(String[] args) {\n        PersonDO personDO = new PersonDO();\n        personDO.setName(\"Hollis\");\n        personDO.setAge(26);\n        personDO.setBirthday(new Date());\n        personDO.setId(1);\n        personDO.setGender(Gender.MALE.name());\n        PersonDTO personDTO = PersonConverter.INSTANCE.do2dto(personDO);\n        System.out.println(personDTO);\n    }\n    \n\n输出结果：\n\n    PersonDTO{userName='Hollis', age=26, birthday=Sat Aug 08 19:00:44 CST 2020, gender=MALE}\n    \n\n可以看到，我们使用MapStruct完美的将PersonDO转成了PersonDTO。\n\n上面的代码可以看出，MapStruct的用法比较简单，主要依赖`@Mapper`注解。\n\n但是我们知道，大多数情况下，我们需要互相转换的两个类之间的属性名称、类型等并不完全一致，还有些情况我们并不想直接做映射，那么该如何处理呢？\n\n其实MapStruct在这方面也是做的很好的。\n\n### MapStruct处理字段映射\n\n首先，可以明确的告诉大家，如果要转换的两个类中源对象属性与目标对象属性的类型和名字一致的时候，会自动映射对应属性。\n\n那么，如果遇到特殊情况如何处理呢？\n\n#### 名字不一致如何映射\n\n如上面的例子中，在PersonDO中用name表示用户名称，而在PersonDTO中使用userName表示用户名，那么如何进行参数映射呢。\n\n这时候就要使用`@Mapping`注解了，只需要在方法签名上，使用该注解，并指明需要转换的源对象的名字和目标对象的名字就可以了，如将name的值映射给userName，可以使用如下方式：\n\n    @Mapping(source = \"name\", target = \"userName\")\n    \n\n#### 可以自动映射的类型\n\n除了名字不一致以外，还有一种特殊情况，那就是类型不一致，如上面的例子中，在PersonDO中用String类型表示用户性别，而在PersonDTO中使用一个Genter的枚举表示用户性别。\n\n这时候类型不一致，就需要涉及到互相转换的问题\n\n其实，MapStruct会对部分类型自动做映射，不需要我们做额外配置，如例子中我们将String类型自动转成了枚举类型。\n\n一般情况下，对于以下情况可以做自动类型转换：\n\n*   基本类型及其他们对应的包装类型。\n*   基本类型的包装类型和String类型之间\n*   String类型和枚举类型之间\n\n#### 自定义常量\n\n如果我们在转换映射过程中，想要给一些属性定义一个固定的值，这个时候可以使用 constant\n\n    @Mapping(source = \"name\", constant = \"hollis\")\n    \n\n#### 类型不一致的如何映射\n\n还是上面的例子，如果我们需要在Person这个对象中增加家庭住址这个属性，那么我们一般在PersonoDTO中会单独定义一个HomeAddress类来表示家庭住址，而在Person类中，我们一般使用String类型表示家庭住址。\n\n这就需要在HomeAddress和String之间使用JSON进行互相转化，这种情况下，MapStruct也是可以支持的。\n\n    public class PersonDO {\n        private String name;\n        private String address;\n    }\n    \n    public class PersonDTO {\n        private String userName;\n        private HomeAddress address;\n    }\n    @Mapper\n    interface PersonConverter {\n        PersonConverter INSTANCE = Mappers.getMapper(PersonConverter.class);\n    \n        @Mapping(source = \"userName\", target = \"name\")\n        @Mapping(target = \"address\",expression = \"java(homeAddressToString(dto2do.getAddress()))\")\n        PersonDO dto2do(PersonDTO dto2do);\n    \n        default String homeAddressToString(HomeAddress address){\n            return JSON.toJSONString(address);\n        }\n    }\n    \n\n我们只需要在PersonConverter中在定义一个方法（因为PersonConverter是一个接口，所以在JDK 1.8以后的版本中可以定义一个default方法），这个方法的作用就是将HomeAddress转换成String类型。\n\n> default方法：Java 8 引入的新的语言特性，用关键字default来标注，被default所标注的方法，需要提供实现，而子类可以选择实现或者不实现该方法\n\n然后在dto2do方法上，通过以下注解方式即可实现类型的转换：\n\n    @Mapping(target = \"address\",expression = \"java(homeAddressToString(dto2do.getAddress()))\")\n    \n\n上面这种是自定义的类型转换，还有一些类型的转换是MapStruct本身就支持的，如String和Date之间的转换：\n\n    @Mapping(target = \"birthday\",dateFormat = \"yyyy-MM-dd HH:mm:ss\")\n    \n\n以上，简单介绍了一些常用的字段映射的方法，也是我自己在工作中经常遇到的几个场景，更多的情况大家可以查看官方的示例（https://github.com/mapstruct/mapstruct-examples）。\n\n### MapStruct的性能\n\n前面说了这么多MapStruct的用法，可以看出MapStruct的使用还是比较简单的，并且字段映射上面的功能很强大，那么他的性能到底怎么样呢？\n\n参考《[为什么阿里巴巴禁止使用Apache Beanutils进行属性的copy？][1]》中的示例，我们对MapStruct进行性能测试。\n\n分别执行1000、10000、100000、1000000次映射的耗时分别为：0ms、1ms、3ms、6ms。\n\n可以看到，**MapStruct的耗时相比较于其他几款工具来说是非常短的**。\n\n那么，为什么MapStruct的性能可以这么好呢？\n\n其实，MapStruct和其他几类框架最大的区别就是：**与其他映射框架相比，MapStruct在编译时生成bean映射，这确保了高性能，可以提前将问题反馈出来，也使得开发人员可以彻底的错误检查。**\n\n还记得前面我们在引入MapStruct的依赖的时候，特别在maven-compiler-plugin中增加了mapstruct-processor的支持吗？\n\n并且我们在代码中使用了很多MapStruct提供的注解，这使得在编译期，MapStruct就可以直接生成bean映射的代码，相当于代替我们写了很多setter和getter。\n\n如我们在代码中定义了以下一个Mapper：\n\n    @Mapper\n    interface PersonConverter {\n        PersonConverter INSTANCE = Mappers.getMapper(PersonConverter.class);\n    \n        @Mapping(source = \"userName\", target = \"name\")\n        @Mapping(target = \"address\",expression = \"java(homeAddressToString(dto2do.getAddress()))\")\n        @Mapping(target = \"birthday\",dateFormat = \"yyyy-MM-dd HH:mm:ss\")\n        PersonDO dto2do(PersonDTO dto2do);\n    \n        default String homeAddressToString(HomeAddress address){\n            return JSON.toJSONString(address);\n        }\n    }\n    \n\n经过代码编译后，会自动生成一个PersonConverterImpl：\n\n    @Generated(\n        value = \"org.mapstruct.ap.MappingProcessor\",\n        date = \"2020-08-09T12:58:41+0800\",\n        comments = \"version: 1.3.1.Final, compiler: javac, environment: Java 1.8.0_181 (Oracle Corporation)\"\n    )\n    class PersonConverterImpl implements PersonConverter {\n    \n        @Override\n        public PersonDO dto2do(PersonDTO dto2do) {\n            if ( dto2do == null ) {\n                return null;\n            }\n    \n            PersonDO personDO = new PersonDO();\n    \n            personDO.setName( dto2do.getUserName() );\n            if ( dto2do.getAge() != null ) {\n                personDO.setAge( dto2do.getAge() );\n            }\n            if ( dto2do.getGender() != null ) {\n                personDO.setGender( dto2do.getGender().name() );\n            }\n    \n            personDO.setAddress( homeAddressToString(dto2do.getAddress()) );\n    \n            return personDO;\n        }\n    }\n    \n\n在运行期，对于bean进行映射的时候，就会直接调用PersonConverterImpl的dto2do方法，这样就没有什么特殊的事情要做了，只是在内存中进行set和get就可以了。\n\n所以，因为在编译期做了很多事情，所以MapStruct在运行期的性能会很好，并且还有一个好处，那就是可以把问题的暴露提前到编译期。\n\n使得如果代码中字段映射有问题，那么应用就会无法编译，强制开发者要解决这个问题才行。\n\n### 总结\n\n本文介绍了一款Java中的字段映射工具类，MapStruct，他的用法比较简单，并且功能非常完善，可以应付各种情况的字段映射。\n\n并且因为他是编译期就会生成真正的映射代码，使得运行期的性能得到了大大的提升。\n\n强烈推荐，真的很香！！！\n\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4c4d9540fd2845ef9399a6ebe91edf22~tplv-k3u1fbpfcp-zoom-1.image)\n\n [1]: https://www.hollischuang.com/archives/5337", "user_name": "HollisChuang", "description": "微信公众号：Hollis(hollischuang) ，博客：www.hollischuang.com", "got_view_count": 826003, "category_name": "后端", "ctime": 1457483880}
{"tag_name": "Java", "concern_user_count": 252044, "user_id": "2682464104616023", "title": "小六六学Netty系列之Java BIO", "mark_content": "# 前言\n>文本已收录至我的GitHub仓库，欢迎Star：https://github.com/bin392328206/six-finger                             \n> **种一棵树最好的时间是十年前，其次是现在**   \n>我知道很多人不玩**qq**了,但是怀旧一下,欢迎加入六脉神剑Java菜鸟学习群，群聊号码：**549684836** 鼓励大家在技术的路上写博客\n\n## 絮叨 \n这个系列是8月的计划，大概能写个十来篇的文章，估计是要的 ，所以说要是原创是不可能的，我不是找了很多学习资料，然后肯定会copy很多，所以说我还是得好好学习，把学习记录记录一下。还是那句话，学习是螺旋上升的，加油的。小伙伴们\n\n\n## I/O模型 \n\n### I/O 模型基本说明\n\n> I/O 模型简单的理解：就是用什么样的通道进行数据的发送和接收，很大程度上决定了程序通信的性能\n\n> Java共支持3种网络编程模型/IO模式：BIO、NIO、AIO\n\n- Java BIO ： 同步并阻塞(传统阻塞型)，服务器实现模式为一个连接一个线程，即客户端有连接请求时服务器端就需要启动一个线程进行处理，如果这个连接不做任何事情会造成不必要的线程开销 \n\n- Java NIO ： 同步非阻塞，服务器实现模式为一个线程处理多个请求(连接)，即客户端发送的连接请求都会注册到多路复用器上，多路复用器轮询到连接有I/O请求就进行处理 \n\n- Java AIO(NIO.2) ： 异步非阻塞，AIO 引入异步通道的概念，采用了 Proactor 模式，简化了程序编写，有效的请求才启动线程，它的特点是先由操作系统完成后才通知服务端程序启动线程去处理，一般适用于连接数较多且连接时间较长的应用\n\n\n### BIO、NIO、AIO适用场景分析\n\n- BIO方式适用于连接数目比较小且固定的架构，这种方式对服务器资源要求比较高，并发局限于应用中，JDK1.4以前的唯一选择，但程序简单易理解。\n\n- NIO方式适用于连接数目多且连接比较短（轻操作）的架构，比如聊天服务器，弹幕系统，服务器间通讯等。编程比较复杂，JDK1.4开始支持。\n\n- AIO方式使用于连接数目多且连接比较长（重操作）的架构，比如相册服务器，充分调用OS参与并发操作，编程比较复杂，JDK7开始支持。\n\n## Java BIO 基本介绍\n\nJava BIO 就是传统的java io 编程，其相关的类和接口在 java.io \nBIO(blocking I/O) ： \n\n同步阻塞，服务器实现模式为一个连接一个线程，即客户端有连接请求时服务器端就需要启动一个线程进行处理，如果这个连接不做任何事情会造成不必要的线程开销，可以通过线程池机制改善(实现多个客户连接服务器)。 【后有应用实例】\n\n\n## Java BIO 工作机制\n\n\n工作原理图\n\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/682ade66810a45c08196378dc406d6d7~tplv-k3u1fbpfcp-zoom-1.image)\n\n\n### BIO编程简单流程\n \n 就是任何一个网络通信框架都是一样的，就好比tomcat对吧，我们来看看他们基本流程，并且我们自己用代码去实现一下这个流程吧，这样我们就能对整个bio有了很清晰的了解了，他的步骤分为以下几步\n \n- 服务器端启动一个ServerSocket\n- 客户端启动Socket对服务器进行通信，默认情况下服务器端需要对每个客户 建立一个线程与之通讯\n- 客户端发出请求后, 先咨询服务器是否有线程响应，如果没有则会等待，或者被拒绝\n- 如果有响应，客户端线程会等待请求结束后，在继续执行\n\n\n## Java BIO 应用实例\n实例说明：\n使用BIO模型编写一个服务器端，监听6666端口，当有客户端连接时，就启动一个线程与之通讯。\n\n要求使用线程池机制改善，可以连接多个客户端.\n服务器端可以接收客户端发送的数据(telnet 方式即可)。\n\n\n### 具体的实现代码，和演示\n\n```\npackage com.itheima.mq.rocketmq;\n\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.net.ServerSocket;\nimport java.net.Socket;\nimport java.util.concurrent.ExecutorService;\nimport java.util.concurrent.Executors;\n\n/**\n * @author 小六六\n * @version 1.0\n * @date 2020/8/1 13:22\n */\npublic class BIOServer {\n\n    public static void main(String[] args) throws Exception {\n\n        //创建一个线程池,每连接到一个客户端，就启动一个线程和客户端进行通信\n        ExecutorService newCachedThreadPool = Executors.newCachedThreadPool();\n\n        @SuppressWarnings(\"resource\")\n        ServerSocket server=new ServerSocket(6666);\n        System.out.println(\"tomcat服务器启动...\");\n        while(true){\n            //阻塞， 等待客户端连接\n            final Socket socket = server.accept();\n            System.out.println(\"连接到一个客户端！\");\n            newCachedThreadPool.execute(new Runnable() {\n\n                @Override\n                public void run() {\n                    //业务处理\n                    handler(socket);\n                }\n            });\n        }\n\n    }\n\n    /**\n     * 处理\n     * @param socket\n     */\n    public static void handler(Socket socket){\n        try {\n            byte[] bytes = new byte[1024];\n            InputStream inputStream = socket.getInputStream();\n\n            while(true){\n                //读客户端数据 阻塞\n                int read = inputStream.read(bytes);\n                if(read != -1){\n                    System.out.println(new String(bytes, 0, read));\n                }else{\n                    break;\n                }\n            }\n\n        } catch (Exception e) {\n            e.printStackTrace();\n        }finally{\n            try {\n                System.out.println(\"关闭和client的连接..\");\n                socket.close();\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n        }\n    }\n}\n\n```\n上面的代码 用的也是jdk自带的线程池，怎么说呢，其实我看到很多开源框架都用了自带的线程池，就连阿里的框架也是nacos，其实说什么自己的线程池会oom啥的，这个得自测了才行。\n\n### 测试结果\n\n这边小六六没有自己写客户端了，而是用的telent \n\n![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ed97c3b384ff4dbc998e2d9f7cf341ea~tplv-k3u1fbpfcp-zoom-1.image)\n\n\n### 总结一下 \n\n- 第一个我们要 搞一个serverSocket\n\n- ServerSocket server=new ServerSocket(6666);\n\n- 然后通过  final Socket socket = server.accept()，获得一个socket 对象，当客户端没有发送信息给服务端的时候，此时的线程是阻塞的。之后就是相互通信了\n\n\n## 结尾\n\n我们来看看BIO这种IO模型有什么问题\n\n- 每个请求都需要创建独立的线程，与对应的客户端进行数据 Read，业务处理，数据 Write 。\n- 当并发数较大时，需要创建大量线程来处理连接，系统资源占用较大。\n- 连接建立后，如果当前线程暂时没有数据可读，则线程就阻塞在 Read 操作上，造成线程资源浪费\n\n\n\n![](https://user-gold-cdn.xitu.io/2020/4/7/1715405b9c95d021?w=900&h=500&f=png&s=109836)\n\n## 日常求赞\n> 好了各位，以上就是这篇文章的全部内容了，能看到这里的人呀，都是**真粉**。\n\n> 创作不易，各位的支持和认可，就是我创作的最大动力，我们下篇文章见\n\n>六脉神剑 | 文 【原创】如果本篇博客有任何错误，请批评指教，不胜感激 ！\n\n\n\n\n", "user_name": "六脉神剑", "description": "种一棵树最好的时间是十年前，其次是现在", "got_view_count": 75931, "category_name": "后端", "ctime": 1457483880}
{"tag_name": "Java", "concern_user_count": 252044, "user_id": "3650034333660590", "title": "简直骚操作，ThreadLocal还能当缓存用", "mark_content": "## 背景说明\n\n有朋友问我一个关于接口优化的问题，他的优化点很清晰，由于接口中调用了内部很多的 service 去组成了一个完成的业务功能。每个 service 中的逻辑都是独立的，这样就导致了很多查询是重复的，看下图你就明白了。\n\n![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f3f6d31f7d6349898608ad6dbef8d6fd~tplv-k3u1fbpfcp-zoom-1.image)\n\n## 上层查询传递下去\n\n对于这种场景最好的就是在上层将需要的数据查询出来，然后传递到下层去消费。这样就不用重复查询了。\n\n![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b491752c4d6548748e97846f444af574~tplv-k3u1fbpfcp-zoom-1.image)\n\n如果开始写代码的时候是这样做的没问题，但很多时候，之前写的时候都是独立的，或者复用的老逻辑，里面就是有独立的查询。\n\n如果要做优化就只能将老的方法重载一个，将需要的信息直接传递过去。\n\n```plain\npublic void xxx(int goodsId) {\n    Goods goods = goodsService.get(goodsId);\n    .....\n}\npublic void xxx(Goods goods) {\n    .....\n}\n```\n\n## 加缓存\n\n如果你的业务场景允许数据有一定延迟，那么重复调用你可以直接通过加缓存来解决。这样的好处在于不会重复查询数据库，而是直接从缓存中取数据。\n\n更大的好处在于对于优化类的影响最小，原有的代码逻辑都不用改变，只需要在查询的方法上加注解进行缓存即可。\n\n```plain\npublic void xxx(int goodsId) {\n    Goods goods = goodsService.get(goodsId);\n    .....\n}\npublic void xxx(Goods goods) {\n    Goods goods = goodsService.get(goodsId);\n    .....\n}\nclass GoodsService {\n    @Cached(expire = 10, timeUnit = TimeUnit.SECONDS)\n    public Goods get(int goodsId) {\n        return dao.findById(goodsId);\n    }\n}\n```\n\n如果你的业务场景不允许有缓存的话，上面这个方法就不能用了。那么是不是还得改代码，将需要的信息一层层往下传递呢？\n\n## 自定义线程内的缓存\n\n我们总结下目前的问题：\n\n1. 同一次请求内，多次相同的查询获取 RPC 等的调用。\n2. 数据实时性要求高，不适合加缓存，主要是加缓存也不好设置过期时间，除非采用数据变更主动更新缓存的方式。\n3. 只需要在这一次请求里缓存即可，不影响其他地方。\n4. 不想改动已有代码。\n\n总结后发现这个场景适合用 ThreadLocal 来传递数据，对已有代码改动量最小，而且也只对当前线程生效，不会影响其他线程。\n\n```plain\npublic void xxx(int goodsId) {\n    Goods goods = ThreadLocal.get();\n    if (goods == null) {\n        goods = goodsService.get(goodsId);\n    }\n    .....\n}\n```\n\n上面代码就是使用了 ThreadLocal 来获取数据，如果有的话就直接使用，不用去重新查询，没有的话就去查询，不影响老逻辑。\n\n虽然能实现效果，但是不太好，不够优雅。也不够通用，如果一次请求内要缓存多种类型的数据怎么处理? ThreadLocal 就不能存储固定的类型。还有就是老的逻辑还是得改，加了个判断。\n\n下面介绍一种比较优雅的方式：\n\n1. 自定义缓存注解，加在查询的方法上。\n2. 定义切面切到加了缓存注解的方法上，第一次获取返回值存入 ThreadLocal。第二次直接从 ThreadLocal 中取值返回。\n3. ThreadLocal 中存储 Map，Key 为某方法的某一标识，这样可以缓存多种类型的结果。\n4. 在 Filter 中将 ThreadLocal 进行 remove 操作，因为线程是复用的，使用完需要清空。\n\n注意：ThreadLocal 不能跨线程，如果有跨线程需求，请使用阿里的 ttl 来装饰。\n\n![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d53cba0e9f9245c28f81b71a09672ab2~tplv-k3u1fbpfcp-zoom-1.image)\n\n### 注解定义\n\n```plain\n@Target({ ElementType.METHOD })\n@Retention(RetentionPolicy.RUNTIME)\npublic @interface ThreadLocalCache {\n    /**\n     * 缓存key，支持SPEL表达式\n     * @return\n     */\n    String key() default \"\";\n}\n```\n\n### 存储定义\n\n```plain\n/**\n * 线程内缓存管理\n *\n * @作者 尹吉欢\n * @时间 2020-07-12 10:47\n */\npublic class ThreadLocalCacheManager {\n    private static ThreadLocal<Map> threadLocalCache = new ThreadLocal<>();\n    public static void setCache(Map value) {\n        threadLocalCache.set(value);\n    }\n    public static Map getCache() {\n        return threadLocalCache.get();\n    }\n    public static void removeCache() {\n        threadLocalCache.remove();\n    }\n    public static void removeCache(String key) {\n        Map cache = threadLocalCache.get();\n        if (cache != null) {\n            cache.remove(key);\n        }\n    }\n}\n```\n\n### 切面定义\n\n```plain\n/**\n * 线程内缓存\n *\n * @作者 尹吉欢\n * @时间 2020-07-12 10:48\n */\n@Aspect\npublic class ThreadLocalCacheAspect {\n    @Around(value = \"@annotation(localCache)\")\n    public Object aroundAdvice(ProceedingJoinPoint joinpoint, ThreadLocalCache localCache) throws Throwable {\n        Object[] args = joinpoint.getArgs();\n        Method method = ((MethodSignature) joinpoint.getSignature()).getMethod();\n        String className = joinpoint.getTarget().getClass().getName();\n        String methodName = method.getName();\n        String key = parseKey(localCache.key(), method, args, getDefaultKey(className, methodName, args));\n        Map cache = ThreadLocalCacheManager.getCache();\n        if (cache == null) {\n            cache = new HashMap();\n        }\n        Map finalCache = cache;\n        Map<String, Object> data = new HashMap<>();\n        data.put(\"methodName\", className + \".\" + methodName);\n        Object cacheResult =  CatTransactionManager.newTransaction(() -> {\n            if (finalCache.containsKey(key)) {\n                return finalCache.get(key);\n            }\n            return null;\n        }, \"ThreadLocalCache\", \"CacheGet\", data);\n        if (cacheResult != null) {\n            return cacheResult;\n        }\n        return CatTransactionManager.newTransaction(() -> {\n            Object result = null;\n            try {\n                result = joinpoint.proceed();\n            } catch (Throwable throwable) {\n                throw new RuntimeException(throwable);\n            }\n            finalCache.put(key, result);\n            ThreadLocalCacheManager.setCache(finalCache);\n            return result;\n        }, \"ThreadLocalCache\", \"CachePut\", data);\n    }\n    private String getDefaultKey(String className, String methodName, Object[] args) {\n        String defaultKey = className + \".\" + methodName;\n        if (args != null) {\n            defaultKey = defaultKey + \".\" + JsonUtils.toJson(args);\n        }\n        return defaultKey;\n    }\n    private String parseKey(String key, Method method, Object[] args, String defaultKey){\n        if (!StringUtils.hasText(key)) {\n            return defaultKey;\n        }\n        LocalVariableTableParameterNameDiscoverer nameDiscoverer = new LocalVariableTableParameterNameDiscoverer();\n        String[] paraNameArr = nameDiscoverer.getParameterNames(method);\n        ExpressionParser parser = new SpelExpressionParser();\n        StandardEvaluationContext context = new StandardEvaluationContext();\n        for(int i = 0;i < paraNameArr.length; i++){\n            context.setVariable(paraNameArr[i], args[i]);\n        }\n        try {\n            return parser.parseExpression(key).getValue(context, String.class);\n        } catch (SpelEvaluationException e) {\n            // 解析不出SPEL默认为类名+方法名+参数\n            return defaultKey;\n        }\n    }\n}\n```\n\n### 过滤器定义\n\n```plain\n/**\n * 线程缓存过滤器\n *\n * @作者 尹吉欢\n * @个人微信 jihuan900\n * @微信公众号 猿天地\n * @GitHub https://github.com/yinjihuan\n * @作者介绍 http://cxytiandi.com/about\n * @时间 2020-07-12 19:46\n */\n@Slf4j\npublic class ThreadLocalCacheFilter implements Filter {\n    @Override\n    public void doFilter(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain) throws IOException, ServletException {\n        filterChain.doFilter(servletRequest, servletResponse);\n        // 执行完后清除缓存\n        ThreadLocalCacheManager.removeCache();\n    }\n}\n```\n\n### 自动配置类\n\n```plain\n@Configuration\npublic class ThreadLocalCacheAutoConfiguration {\n    @Bean\n    public FilterRegistrationBean idempotentParamtFilter() {\n        FilterRegistrationBean registration = new FilterRegistrationBean();\n        ThreadLocalCacheFilter filter = new ThreadLocalCacheFilter();\n        registration.setFilter(filter);\n        registration.addUrlPatterns(\"/*\");\n        registration.setName(\"thread-local-cache-filter\");\n        registration.setOrder(1);\n        return registration;\n    }\n    @Bean\n    public ThreadLocalCacheAspect threadLocalCacheAspect() {\n        return new ThreadLocalCacheAspect();\n    }\n}\n```\n\n### 使用案例\n\n```plain\n@Service\npublic class TestService {\n    /**\n     * ThreadLocalCache 会缓存，只对当前线程有效\n     * @return\n     */\n    @ThreadLocalCache\n    public String getName() {\n        System.out.println(\"开始查询了\");\n        return \"yinjihaun\";\n    }\n    /**\n     * 支持SPEL表达式\n     * @param id\n     * @return\n     */\n    @ThreadLocalCache(key = \"#id\")\n    public String getName(String id) {\n        System.out.println(\"开始查询了\");\n        return \"yinjihaun\" + id;\n    }\n}\n```\n\n功能代码： [https://github.com/yinjihuan/kitty](https://github.com/yinjihuan/kitty)\n\n案例代码： [https://github.com/yinjihuan/kitty-samples](https://github.com/yinjihuan/kitty-samples)\n\n**_关于作者_** _：尹吉欢，简单的技术爱好者，《Spring Cloud 微服务-全栈技术与案例解析》, 《Spring Cloud 微服务 入门 实战与进阶》作者, 公众号_ **_猿天地_** _发起人。个人微信_ **_jihuan900_** _,欢迎勾搭。_\n\n> 感兴趣的可以关注下我的微信公众号 **猿天地**，更多技术文章第一时间阅读。我的GitHub也有一些开源的代码 https://github.com/yinjihuan\n\n![](https://user-gold-cdn.xitu.io/2020/1/7/16f7dc266b81d71e?w=800&h=400&f=png&s=68150)", "user_name": "猿天地", "description": "欢迎大家关注我的微信公众号‘猿天地’， 猿天地由《Spring Cloud微服务-全", "got_view_count": 130391, "category_name": "后端", "ctime": 1457483880}
{"tag_name": "面试", "concern_user_count": 285352, "user_id": "3227821869407208", "title": "跨域（CORS）产生原因分析与解决方案，这一次彻底搞懂它", "mark_content": "Cross-origin Resource Sharing 中文名称 “**跨域资源共享**” 简称 “**CORS**”，它突破了一个请求在浏览器发出只能在同源的情况下向服务器获取数据的限制。\n\n本文会先从一个示例开始，分析是浏览器还是服务器的限制，之后讲解什么时候会产生预检请求，在整个过程中，也会讲解一下解决该问题的实现方法，文末会再总结如何使用 Node.js 中的 cors 模块和 Nginx 反向代理来解决跨域问题。\n\n文中使用 Node.js 做一些 Demo 的演示，每一小节之后也会给予代码的 Demo 地址。\n\n## 浏览器还是服务器的限制\n\n先思考下，CORS 是浏览器端还是服务器端的限制？为了更好的说明这个问题，从一段示例开始。\n\n### 从一段示例开始\n\n**index.html**\n\n创建 index.html 使用 fetch 调用 http://127.0.0.1:3011/api/data\n\n```html\n<body>\n  <!-- <script src=\"https://cdn.bootcdn.net/ajax/libs/fetch/3.0.0/fetch.min.js\"></script> -->\n  <script>\n    fetch('http://127.0.0.1:3011/api/data');\n  </script>\n</body>\n```\n\n**client.js**\n\n创建 client.js 用来加载上面 index.html。设置端口为 3010。\n\n```js\nconst http = require('http');\nconst fs = require('fs');\nconst PORT = 3010;\nhttp.createServer((req, res) => {\n  fs.createReadStream('index.html').pipe(res);\n}).listen(PORT);\n```\n\n**server.js**\n\n创建 server.js 开启一个服务，根据不同的请求返回不同的响应。设置端口为 3011。\n\n```js\nconst http = require('http');\nconst PORT = 3011;\n\nhttp.createServer((req, res) => {\n  const url = req.url;\n  console.log('request url: ', url);\n  if (url === '/api/data') {\n    return res.end('ok!');\n  }\n  if (url === '/script') {\n    return res.end('console.log(\"hello world!\");');\n  }\n}).listen(PORT);\n\nconsole.log('Server listening on port ', PORT);\n```\n\n### 测试分析原因\n\n运行上面的 client.js、server.js 浏览器输入 http://127.0.0.1:3010 在 Chrome 浏览器中打开 Network 项查看请求信息，如下所示：\n\n\n![](https://imgkr2.cn-bj.ufileos.com/aa6e4452-7d55-4cac-8d74-6487f89a3615.png?UCloudPublicKey=TOKEN_8d8b72be-579a-4e83-bfd0-5f6ce1546f13&Signature=AVEIaiaohnMHJbQt2Hqv6DkOClc%253D&Expires=1597153359)\n\n\n左侧是使用 fetch 请求的 127.0.0.1:3011/api/data 接口，在请求头里可以看到有 Origin 字段，显示了我们当前的请求信息。另外还有三个 Sec-Fetch-* 开头的字段，这是一个新的草案 **[Fetch Metadata Request Headers](https://w3c.github.io/webappsec-fetch-metadata/ \"Fetch Metadata Request Headers\")**。\n\n其中 Sec-Fetch-Mode 表示请求的模式，通过左右两侧结果对比也可以看出左侧是跨域的。Sec-Fetch-Site 表示的是这个请求是同源还是跨域，由于我们这两个请求都是由 3010 端口发出去请求 3011 端口，是不符合同源策略的。\n\n看下浏览器 Console 下的日志信息，根据提示得知原因是从 “http://127.0.0.1:3010” 访问 “http://127.0.0.1:3011/api/data” 被 CORS 策略阻止了，没有 “Access-Control-Allow-Origin” 标头。\n\n\n![](https://imgkr2.cn-bj.ufileos.com/0aeeba1c-23e6-43af-a4fc-1a098e7481c4.png?UCloudPublicKey=TOKEN_8d8b72be-579a-4e83-bfd0-5f6ce1546f13&Signature=KFpDjSxmznVjQl%252FPJ1AkLGOutBw%253D&Expires=1597153404)\n\n\n\n在看下服务端的日志，因为请求 3011 服务，所以就看下 3011 服务的日志信息：\n\n```\nServer listening on port  3011\nrequest url:  /script\nrequest url:  /api/data\n```\n\n在服务端是有收到请求信息的，说明服务端是正常工作的。\n\n我们也可以在终端通过 curl 命令测试下，在终端脱离浏览器环境也是可以正常请求的。\n\n```\n$ curl http://127.0.0.1:3011/api/data\nok!\n```\n\n本节代码示例：\n\n```\ngithub.com/qufei1993/http-protocol/tree/master/example/cors/01\n```\n\n### 总结回答最开始提出的问题\n\n**浏览器限制了从脚本内发起的跨源 HTTP 请求**，例如 **XMLHttpRequest** 和我们本示例中使用的 **Fetch API 都是遵循的同源策略**。\n\n当一个请求在浏览器端发送出去后，服务端是会收到的并且也会处理和响应，只不过浏览器在解析这个请求的响应之后，发现不属于浏览器的**同源策略**（地址里面的协议、域名和端口号均相同）也没有包含正确的 CORS 响应头，返回结果被浏览器给拦截了。\n\n## 预检请求\n\n预检请求是在发送实际的请求之前，客户端会先发送一个 OPTIONS 方法的请求向服务器确认，如果通过之后，浏览器才会发起真正的请求，这样可以避免跨域请求对服务器的用户数据造成影响。\n\n看到这里你可能有疑问为什么上面的示例没有预检请求？因为 **CORS 将请求分为了两类：简单请求和非简单请求**。我们上面的情况属于简单请求，所以也就没有了预检请求。\n\n让我们继续在看下简单请求和非简单请求是如何定义的。\n\n### 预检请求定义\n\n根据 MDN 的文档定义，请求方法为：GET、POST、HEAD，请求头 Content-Type 为：text/plain、multipart/form-data、application/x-www-form-urlencoded 的就属于 “简单请求” 不会触发 CORS 预检请求。\n\n例如，如果请求头的 Content-Type 为 application/json 就会触发 CORS 预检请求，这里也会称为 “非简单请求”。\n\n[“MDN 文档 developer.mozilla.org/en-US/docs/Web/HTTP/CORS 简单请求”](https://developer.mozilla.org/en-US/docs/Web/HTTP/CORS \"“MDN 文档 developer.mozilla.org/en-US/docs/Web/HTTP/CORS 简单请求”\") 有更多关于简单请求的字段定义。\n\n### 预检请求示例\n\n通过一个示例学习下预检请求。\n\n#### 设置客户端\n\n为 index.html 里的 fetch 方法增加一些设置，设置请求的方法为 PUT，请求头增加一个自定义字段 Test-Cors。\n\n```html\n<script>\n  fetch('http://127.0.0.1:3011/api/data', {\n    method: 'PUT',\n    headers: {\n      'Content-Type': 'text/plain',\n      'Test-Cors': 'abc'\n    }\n  });\n</script>\n```\n\n上述代码在浏览器执行时会发现是一个非简单请求，就会先执行一个预检请求，Request Headers 会有如下信息：\n\n```\nOPTIONS /api/data HTTP/1.1\nHost: 127.0.0.1:3011\nAccess-Control-Request-Method: PUT\nAccess-Control-Request-Headers: content-type,test-cors\nOrigin: http://127.0.0.1:3010\nSec-Fetch-Mode: cors\n```\n\n可以看到有一个 OPTIONS 是预检请求使用的方法，该方法是在 HTTP/1.1 协议中所定义的，还有一个重要的字段 **Origin 表示请求来自哪个源**，服务端则可以根据这个字段判断是否是合法的请求源，例如 Websocket 中因为没有了同源策略限制，服务端可以根据这个字段来判断。\n\n**Access-Control-Request-Method** 告诉服务器，实际请求将使用 PUT 方法。\n\n**Access-Control-Request-Headers** 告诉服务器，实际请求将使用两个头部字段 content-type,test-cors。这里如果 content-type 指定的为简单请求中的几个值，Access-Control-Request-Headers 在告诉服务器时，实际请求将只有 test-cors 这一个头部字段。\n\n#### 设置服务端\n\n上面讲解了客户端的设置，同样的要使请求能够正常响应，还需服务端的支持。\n\n修改我们的 server.js 重点是设置 Response Headers 代码如下所示：\n\n```js\nres.writeHead(200, {\n  'Access-Control-Allow-Origin': 'http://127.0.0.1:3010',\n  'Access-Control-Allow-Headers': 'Test-CORS, Content-Type',\n  'Access-Control-Allow-Methods': 'PUT,DELETE',\n  'Access-Control-Max-Age': 86400\n});\n```\n\n为什么是以上配置？首先预检请求时，浏览器给了服务器几个重要的信息 Origin、Method 为 PUT、Headers 为 content-type,test-cors 服务端在收到之后，也要做些设置，给予回应。\n\nAccess-Control-Allow-Origin 表示 “http://127.0.0.1:3010” 这个请求源是可以访问的，该字段也可以设置为 “*” 表示允许任意跨源请求。\n\nAccess-Control-Allow-Methods 表示服务器允许客户端使用 PUT、DELETE 方法发起请求，可以一次设置多个，表示服务器所支持的所有跨域方法，而不单是当前请求那个方法，这样好处是为了避免多次预检请求。\n\nAccess-Control-Allow-Headers 表示服务器允许请求中携带 Test-CORS、Content-Type 字段，也可以设置多个。\n\nAccess-Control-Max-Age 表示该响应的有效期，单位为秒。在有效时间内，浏览器无须为同一请求再次发起预检请求。还有一点需要注意，该值要小于浏览器自身维护的最大有效时间，否则是无效的。\n\n看下增加了预检请求的效果，第一次先发出了 OPTIONS 请求，并且在请求头设置了本次请求的方法和 Headers 信息，服务端在 Response 也做了回应，在 OPTIONS 成功之后，浏览器紧跟着才发起了我们本次需要的真实请求，如图右侧所示 Resquest Method 为 PUT。\n\n\n![](https://imgkr2.cn-bj.ufileos.com/c443c689-1991-4581-badc-1536acba30e9.png?UCloudPublicKey=TOKEN_8d8b72be-579a-4e83-bfd0-5f6ce1546f13&Signature=6vNXQMcBptT7RN0Kw1vCSa50mzU%253D&Expires=1597153441)\n\n\n本节代码示例：\n```\ngithub.com/qufei1993/http-protocol/tree/master/example/cors/02\n```\n\n## CORS 与认证\n\n对于跨域的 XMLHttpRequest 或 Fetch 请求，浏览器是不会发送身份凭证信息的。例如我们要在跨域请求中发送 Cookie 信息，就要做些设置：\n\n为了能看到效果，我先自定义了一个 cookie 信息 id=NodejsRoadmap。\n\n重点是设置认证字段，本文中 fetch 示例设置 **credentials: \"include\"** 如果是 XMLHttpRequest 则设置 **withCredentials:\"include\"**\n\n```html\n<body>\n  <script>\n    document.cookie = `id=NodejsRoadmap`;\n    fetch('http://127.0.0.1:3011/api/data', {\n      method: 'PUT',\n      headers: {\n        'Content-Type': 'application/json',\n        'Test-Cors': 'abc',\n      },\n      credentials: \"include\"\n    });\n  </script>\n</body>\n```\n\n经过以上设置，浏览器发送实际请求时会向服务器发送 Cookies，同时服务器也需要在响应中设置 Access-Control-Allow-Credentials 响应头\n\n```js\nres.writeHead(200, {\n  'Access-Control-Allow-Origin': 'http://127.0.0.1:3010',\n  'Access-Control-Allow-Credentials': true\n});\n```\n\n如果服务端不设置浏览器就不会正常响应，会报一个跨域错误，如下所示：\n\n```\nAccess to fetch at 'http://127.0.0.1:3011/api/data' from origin 'http://127.0.0.1:3010' has been blocked by CORS policy: Response to preflight request doesn't pass access control check: The value of the 'Access-Control-Allow-Credentials' header in the response is '' which must be 'true' when the request's credentials mode is 'include'.\n```\n\n还有一点需要注意，如果我们在请求中设置了 **credentials: \"include\"** 服务端就不能设置 **Access-Control-Allow-Origin: \"*\"** 只能设置为一个明确的地址。\n\n本节代码示例：\n\n```\ngithub.com/qufei1993/http-protocol/tree/master/example/cors/03\n```\n\n## 解决跨域问题的几种方法\n\n通过上面的分析了解跨域产生的原因之后，解决其实并不难，上面的讲解中其实也提供了解决方案，例如在 Node.js 中我们可以设置响应头部字段 Access-Control-Allow-Origin、Access-Control-Expose-Headers、Access-Control-Allow-Methods 等，但是在实际开发中这样设置难免繁琐，下面介绍几种常用的解决方法。\n\n### 使用 CORS 模块\n\n在 Node.js 中推荐你使用 cors 模块 [github.com/expressjs/cors](https://github.com/expressjs/cors \"github.com/expressjs/cors\")。 \n\n在我们本节的示例中，一直使用的 Node.js 原生模块来编写我们的示例，在引入 cors 模块后，可以按照如下方式改写：\n\n```js\nconst http = require('http');\nconst PORT = 3011;\nconst corsMiddleware = require('cors')({\n  origin: 'http://127.0.0.1:3010',\n  methods: 'PUT,DELETE',\n  allowedHeaders: 'Test-CORS, Content-Type',\n  maxAge: 1728000,\n  credentials: true,\n});\n\nhttp.createServer((req, res) => {\n  const { url, method } = req;\n  console.log('request url:', url, ', request method:', method);\n  const nextFn = () => {\n    if (method === 'PUT' && url === '/api/data') {\n      return res.end('ok!');\n    }\n    return res.end();\n  }\n  corsMiddleware(req, res, nextFn);\n}).listen(PORT);\n```\n\ncors 在预检请求之后或在预检请求里并选项中设置了 preflightContinue 属性之后才会执行 nextFn 这个函数，如果预检失败就不会执行 nextFn 函数。\n\n如果你用的 Express.js 框架，使用起来也很简单，如下所示：\n\n```js\nconst express = require('express')\nconst cors = require('cors')\nconst app = express()\n\napp.use(cors());\n```\n\n### JSONP\n\n浏览器是允许像 link、img、script 标签在路径上加载一些内容进行请求，是允许跨域的，那么 jsonp 的实现原理就是在 script 标签里面加载了一个链接，去访问服务器的某个请求，返回内容。\n\n```html\n<body>\n  <script>\n    // fetch('http://127.0.0.1:3011/api/data', {\n    //   method: 'PUT',\n    //   headers: {\n    //     'Content-Type': 'application/json',\n    //     'Test-Cors': 'abc',\n    //   },\n    //   credentials: \"include\"\n    // });\n    <srcipt src=\"http://127.0.0.1:3011/api/data\"></srcipt>\n  </script>\n</body>\n```\n\n相比上面 CORS 模块，JSONP 只支持 GET 请求，显然是没有 CORS 模块强大的。\n\n### Nginx 代理服务器配置跨域\n\n使用 Nginx 代理服务器之后，请求不会直接到达我们的 Node.js 服务器端，请求会先经过 Nginx 在设置一些跨域等信息之后再由 Nginx 转发到我们的 Node.js 服务端，所以这个时候我们的 Nginx 服务器去监听的 3011 端口，我们把 Node.js 服务的端口修改为 30011，简单配置如下所示：\n\n```conf\nserver {\n  listen          3011;\n  server_name     localhost;\n\n  location / {\n    if ($request_method = 'OPTIONS') {\n      add_header 'Access-Control-Allow-Origin' 'http://127.0.0.1:3010';\n      add_header 'Access-Control-Allow-Methods' 'PUT,DELETE';\n      add_header 'Access-Control-Allow-Headers' 'Test-CORS, Content-Type';\n      add_header 'Access-Control-Max-Age' 1728000;\n      add_header 'Access-Control-Allow-Credentials' 'true';\n      add_header 'Content-Length' 0;\n      return 204;\n    }\n\n    add_header 'Access-Control-Allow-Origin' 'http://127.0.0.1:3010';\n    add_header 'Access-Control-Allow-Credentials' 'true';\n\n    proxy_pass http://127.0.0.1:30011;\n    proxy_set_header Host $host;\n  }\n}\n```\n\n本节代码示例：\n\n```\ngithub.com/qufei1993/http-protocol/tree/master/example/cors/04\n```\n\n## 总结\n\n如果你是一个前端开发者，在工作难免会遇到跨域问题，虽然它属于浏览器的同源策略限制，但是要想解决这问题还需浏览器端与服务端的共同支持，希望读到这篇文章的读者能够理解跨域产生的原因，最后给予的几个解决方案，也希望能解决你对于跨域这个问题的困惑。\n\n**作者简介**：五月君，软件设计师，公众号「Nodejs技术栈」作者。", "user_name": "五月君", "description": "公众号 “Nodejs技术栈” 作者，专注 Nodejs 相关技术栈分享", "got_view_count": 59209, "category_name": "前端", "ctime": 1457483942}
{"tag_name": "Java", "concern_user_count": 252044, "user_id": "448256477237560", "title": "超详细Canal入门，看这篇就够了！", "mark_content": "# 思维导图\n\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20200808151414675.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3llaG9uZ3poaTE5OTQ=,size_16,color_FFFFFF,t_70#pic_center)\n\n> 本文章已收录到个人博客网站(我爱B站)：me.lovebilibili.com\n\n# 前言\n\n我们都知道一个系统最重要的是数据，数据是保存在数据库里。但是很多时候不单止要保存在数据库中，还要同步保存到Elastic Search、HBase、Redis等等。\n\n这时我注意到阿里开源的框架**Canal**，他可以很方便地**同步数据库的增量数据到其他的存储应用**。所以在这里总结一下，分享给各位读者参考~\n\n# 一、什么是canal\n\n我们先看官网的介绍\n\n> canal，译意为水道/管道/沟渠，主要用途是基于 **MySQL 数据库增量日志解析**，提供**增量数据订阅和消费**。\n\n这句介绍有几个关键字：**增量日志，增量数据订阅和消费**。\n\n这里我们可以简单地把canal理解为一个用来**同步增量数据的一个工具**。\n\n接下来我们看一张官网提供的示意图：\n\n![](https://imgconvert.csdnimg.cn/aHR0cHM6Ly9zdGF0aWMubG92ZWJpbGliaWxpLmNvbS9waWMvY2FuYWxfc3l0LnBuZw?x-oss-process=image/format,png)\n\ncanal的工作原理就是**把自己伪装成MySQL slave，模拟MySQL slave的交互协议向MySQL Mater发送 dump协议，MySQL mater收到canal发送过来的dump请求，开始推送binary log给canal，然后canal解析binary log，再发送到存储目的地**，比如MySQL，Kafka，Elastic Search等等。\n\n# 二、canal能做什么\n\n以下参考[canal官网](https://github.com/alibaba/canal)。\n\n与其问canal能做什么，不如说数据同步有什么作用。\n\n但是canal的数据同步**不是全量的，而是增量**。基于binary log增量订阅和消费，canal可以做：\n\n- 数据库镜像\n- 数据库实时备份\n- 索引构建和实时维护\n- 业务cache(缓存)刷新\n- 带业务逻辑的增量数据处理\n\n# 三、如何搭建canal\n\n## 3.1 首先有一个MySQL服务器\n\n当前的 canal 支持源端 MySQL 版本包括 5.1.x , 5.5.x , 5.6.x , 5.7.x , 8.0.x\n\n我的Linux服务器安装的MySQL服务器是5.7版本。\n\nMySQL的安装这里就不演示了，比较简单，网上也有很多教程。\n\n然后在MySQL中需要创建一个用户，并授权：\n\n```sql\n-- 使用命令登录：mysql -u root -p\n-- 创建用户 用户名：canal 密码：Canal@123456\ncreate user 'canal'@'%' identified by 'Canal@123456';\n-- 授权 *.*表示所有库\ngrant SELECT, REPLICATION SLAVE, REPLICATION CLIENT on *.* to 'canal'@'%' identified by 'Canal@123456';\n```\n\n下一步在MySQL配置文件my.cnf设置如下信息：\n\n```yml\n[mysqld]\n# 打开binlog\nlog-bin=mysql-bin\n# 选择ROW(行)模式\nbinlog-format=ROW\n# 配置MySQL replaction需要定义，不要和canal的slaveId重复\nserver_id=1\n```\n\n改了配置文件之后，重启MySQL，使用命令查看是否打开binlog模式：\n\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20200808151606261.png#pic_center)\n\n查看binlog日志文件列表：\n\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20200808151715291.png#pic_center)\n\n查看当前正在写入的binlog文件：\n\n![在这里插入图片描述](https://img-blog.csdnimg.cn/2020080815153247.png#pic_center)\n\nMySQL服务器这边就搞定了，很简单。\n\n## 3.2 安装canal\n\n去官网下载页面进行下载：https://github.com/alibaba/canal/releases\n\n我这里下载的是1.1.4的版本：\n\n![在这里插入图片描述](https://img-blog.csdnimg.cn/2020080815145065.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3llaG9uZ3poaTE5OTQ=,size_16,color_FFFFFF,t_70#pic_center)\n\n解压**canal.deployer-1.1.4.tar.gz**，我们可以看到里面有四个文件夹：\n\n![](https://imgconvert.csdnimg.cn/aHR0cHM6Ly9zdGF0aWMubG92ZWJpbGliaWxpLmNvbS9waWMvdGFyX29uZS5wbmc?x-oss-process=image/format,png)\n\n接着打开配置文件conf/example/instance.properties，配置信息如下：\n\n```properties\n## mysql serverId , v1.0.26+ will autoGen\n## v1.0.26版本后会自动生成slaveId，所以可以不用配置\n# canal.instance.mysql.slaveId=0\n\n# 数据库地址\ncanal.instance.master.address=127.0.0.1:3306\n# binlog日志名称\ncanal.instance.master.journal.name=mysql-bin.000001\n# mysql主库链接时起始的binlog偏移量\ncanal.instance.master.position=154\n# mysql主库链接时起始的binlog的时间戳\ncanal.instance.master.timestamp=\ncanal.instance.master.gtid=\n\n# username/password\n# 在MySQL服务器授权的账号密码\ncanal.instance.dbUsername=canal\ncanal.instance.dbPassword=Canal@123456\n# 字符集\ncanal.instance.connectionCharset = UTF-8\n# enable druid Decrypt database password\ncanal.instance.enableDruid=false\n\n# table regex .*\\\\..*表示监听所有表 也可以写具体的表名，用，隔开\ncanal.instance.filter.regex=.*\\\\..*\n# mysql 数据解析表的黑名单，多个表用，隔开\ncanal.instance.filter.black.regex=\n```\n\n我这里用的是win10系统，所以在bin目录下找到startup.bat启动：\n\n启动就报错，坑呀：\n\n![](https://imgconvert.csdnimg.cn/aHR0cHM6Ly9zdGF0aWMubG92ZWJpbGliaWxpLmNvbS9waWMvY2FuYWxfNC5wbmc?x-oss-process=image/format,png)\n\n要修改一下启动的脚本startup.bat：\n\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20200808151858871.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3llaG9uZ3poaTE5OTQ=,size_16,color_FFFFFF,t_70#pic_center)\n\n然后再启动脚本：\n\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20200808151912493.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3llaG9uZ3poaTE5OTQ=,size_16,color_FFFFFF,t_70#pic_center)\n\n这就启动成功了。\n\n# Java客户端操作\n\n首先引入maven依赖：\n\n```xml\n<dependency>\n    <groupId>com.alibaba.otter</groupId>\n    <artifactId>canal.client</artifactId>\n    <version>1.1.4</version>\n</dependency>\n```\n\n然后创建一个canal项目，使用SpringBoot构建，如图所示：\n\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20200808151936163.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3llaG9uZ3poaTE5OTQ=,size_16,color_FFFFFF,t_70#pic_center)\n\n在CannalClient类使用Spring Bean的生命周期函数afterPropertiesSet()：\n\n```java\n@Component\npublic class CannalClient implements InitializingBean {\n\n    private final static int BATCH_SIZE = 1000;\n\n    @Override\n    public void afterPropertiesSet() throws Exception {\n        // 创建链接\n        CanalConnector connector = CanalConnectors.newSingleConnector(new InetSocketAddress(\"127.0.0.1\", 11111), \"example\", \"\", \"\");\n        try {\n            //打开连接\n            connector.connect();\n            //订阅数据库表,全部表\n            connector.subscribe(\".*\\\\..*\");\n            //回滚到未进行ack的地方，下次fetch的时候，可以从最后一个没有ack的地方开始拿\n            connector.rollback();\n            while (true) {\n                // 获取指定数量的数据\n                Message message = connector.getWithoutAck(BATCH_SIZE);\n                //获取批量ID\n                long batchId = message.getId();\n                //获取批量的数量\n                int size = message.getEntries().size();\n                //如果没有数据\n                if (batchId == -1 || size == 0) {\n                    try {\n                        //线程休眠2秒\n                        Thread.sleep(2000);\n                    } catch (InterruptedException e) {\n                        e.printStackTrace();\n                    }\n                } else {\n                    //如果有数据,处理数据\n                    printEntry(message.getEntries());\n                }\n                //进行 batch id 的确认。确认之后，小于等于此 batchId 的 Message 都会被确认。\n                connector.ack(batchId);\n            }\n        } catch (Exception e) {\n            e.printStackTrace();\n        } finally {\n            connector.disconnect();\n        }\n    }\n\n    /**\n     * 打印canal server解析binlog获得的实体类信息\n     */\n    private static void printEntry(List<Entry> entrys) {\n        for (Entry entry : entrys) {\n            if (entry.getEntryType() == EntryType.TRANSACTIONBEGIN || entry.getEntryType() == EntryType.TRANSACTIONEND) {\n                //开启/关闭事务的实体类型，跳过\n                continue;\n            }\n            //RowChange对象，包含了一行数据变化的所有特征\n            //比如isDdl 是否是ddl变更操作 sql 具体的ddl sql beforeColumns afterColumns 变更前后的数据字段等等\n            RowChange rowChage;\n            try {\n                rowChage = RowChange.parseFrom(entry.getStoreValue());\n            } catch (Exception e) {\n                throw new RuntimeException(\"ERROR ## parser of eromanga-event has an error , data:\" + entry.toString(), e);\n            }\n            //获取操作类型：insert/update/delete类型\n            EventType eventType = rowChage.getEventType();\n            //打印Header信息\n            System.out.println(String.format(\"================》; binlog[%s:%s] , name[%s,%s] , eventType : %s\",\n                    entry.getHeader().getLogfileName(), entry.getHeader().getLogfileOffset(),\n                    entry.getHeader().getSchemaName(), entry.getHeader().getTableName(),\n                    eventType));\n            //判断是否是DDL语句\n            if (rowChage.getIsDdl()) {\n                System.out.println(\"================》;isDdl: true,sql:\" + rowChage.getSql());\n            }\n            //获取RowChange对象里的每一行数据，打印出来\n            for (RowData rowData : rowChage.getRowDatasList()) {\n                //如果是删除语句\n                if (eventType == EventType.DELETE) {\n                    printColumn(rowData.getBeforeColumnsList());\n                    //如果是新增语句\n                } else if (eventType == EventType.INSERT) {\n                    printColumn(rowData.getAfterColumnsList());\n                    //如果是更新的语句\n                } else {\n                    //变更前的数据\n                    System.out.println(\"------->; before\");\n                    printColumn(rowData.getBeforeColumnsList());\n                    //变更后的数据\n                    System.out.println(\"------->; after\");\n                    printColumn(rowData.getAfterColumnsList());\n                }\n            }\n        }\n    }\n\n    private static void printColumn(List<Column> columns) {\n        for (Column column : columns) {\n            System.out.println(column.getName() + \" : \" + column.getValue() + \"    update=\" + column.getUpdated());\n        }\n    }\n}\n```\n\n以上就完成了Java客户端的代码。这里不做具体的处理，仅仅是打印，先有个直观的感受。\n\n最后我们开始测试，首先启动MySQL、Canal Server，还有刚刚写的Spring Boot项目。然后创建表：\n\n```sql\nCREATE TABLE `tb_commodity_info` (\n  `id` varchar(32) NOT NULL,\n  `commodity_name` varchar(512) DEFAULT NULL COMMENT '商品名称',\n  `commodity_price` varchar(36) DEFAULT '0' COMMENT '商品价格',\n  `number` int(10) DEFAULT '0' COMMENT '商品数量',\n  `description` varchar(2048) DEFAULT '' COMMENT '商品描述',\n  PRIMARY KEY (`id`)\n) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COMMENT='商品信息表';\n```\n\n然后我们在控制台就可以看到如下信息：\n\n![](https://imgconvert.csdnimg.cn/aHR0cHM6Ly9zdGF0aWMubG92ZWJpbGliaWxpLmNvbS9waWMvY2FuYWxfMTAucG5n?x-oss-process=image/format,png)\n\n如果新增一条数据到表中：\n\n```sql\nINSERT INTO tb_commodity_info VALUES('3e71a81fd80711eaaed600163e046cc3','叉烧包','3.99',3,'又大又香的叉烧包，老人小孩都喜欢');\n```\n\n控制台可以看到如下信息：\n\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20200809230414536.png#pic_center)\n\n# 总结\n\ncanal的好处在于**对业务代码没有侵入**，因为是**基于监听binlog日志去进行同步数据的**。实时性也能做到准实时，其实是很多企业一种比较常见的数据同步的方案。\n\n通过上面的学习之后，我们应该都明白canal是什么，它的原理，还有用法。实际上这仅仅只是入门，因为实际项目中我们不是这样玩的...\n\n实际项目我们是**配置MQ模式，配合RocketMQ或者Kafka，canal会把数据发送到MQ的topic中，然后通过消息队列的消费者进行处理**。\n\n![](https://imgconvert.csdnimg.cn/aHR0cHM6Ly9zdGF0aWMubG92ZWJpbGliaWxpLmNvbS9waWMvY2FuYWxfMTIucG5n?x-oss-process=image/format,png)\n\nCanal的部署也是支持集群的，需要配合ZooKeeper进行集群管理。\n\nCanal还有一个简单的Web管理界面。\n\n下一篇就讲一下**集群部署Canal，配合使用Kafka，同步数据到Redis**。\n\n参考资料：[Canal官网](https://github.com/alibaba/canal)\n\n## 絮叨\n\n上面所有例子的代码都上传Github了：\n\n> https://github.com/yehongzhi/mall\n\n**如果你觉得这篇文章对你有用，点个赞吧**~\n\n**你的点赞是我创作的最大动力**~\n\n想第一时间看到我更新的文章，可以微信搜索公众号「`java技术爱好者`」，**拒绝做一条咸鱼，我是一个努力让大家记住的程序员。我们下期再见！！！**\n\n> 能力有限，如果有什么错误或者不当之处，请大家批评指正，一起学习交流！", "user_name": "java技术爱好者", "description": "一个不想成为作家的程序员，不是一个好厨师", "got_view_count": 12010, "category_name": "后端", "ctime": 1457483880}
{"tag_name": "GitHub", "concern_user_count": 330249, "user_id": "1574156384091320", "title": "GitHub 热点速览 Vol.32：VScode 韭菜基金插件，极大提高“工作”效率", "mark_content": "作者：HelloGitHub-**小鱼干**\n\n> 摘要：有什么比干着本职工作——编码，而又兼顾“外快”——炒股更有开心的事情呢？leek-fund 就是这么一个极大提升你工作幸福度和效率的插件，可随时关注上证指数 & 实时基金数据。除了 leek-fund 这个插件，本周特推 simdjson 也是一大效率杀器，它可以每秒解析千兆字节的 JSON，除了效率，周获 1000+ star 的 955.WLB 则关注你的生活和工作，让你平衡二者，也不失为一个提升你找工作效率 repo…\n\n以下内容摘录自微博[@HelloGitHub](https://www.weibo.com/hellogithub/) 的 GitHub Trending 及 Hacker News 热帖（简称 HN 热帖），选项标准：`新发布` | `实用` | `有趣`，根据项目 release 时间分类，发布时间不超过 7 day 的项目会标注 `New`，无该标志则说明项目 release 超过一周。由于本文篇幅有限，还有部分项目未能在本文展示，望周知 🌝\n\n- 本文目录\n    - 1. 本周特推\n        - 1.1 json 解析大杀器：simdjson\n        - 1.2 安全工程：how-to-secure-anything\n    - 2. GitHub Trending 周榜\n        - 2.1 万物皆可动：first-order-model\n        - 2.2 平衡生活和工作：955.WLB\n        - 2.3 VSCode 韭菜基金插件：leek-fund\n        - 2.4 cat 克隆版：bat\n        - 2.5 rust 小练习：rustlings\n        - 2.6 深度学习引擎：oneflow\n        - 2.7 资源监视器：bpytop\n    - 3. Emoji Time\n    - 4. 推荐阅读\n\n## 1. 本周特推\n\n### 1.1 json 解析大杀器：simdjson\n\n**本周 star 增长数：1400+**\n\nsimdjson 是一个每秒解析千兆字节的 JSON 解析工具。simdjson 库使用常用的 SIMD 指令和微并行算法来解析 JSON，速度比其他解析器快 2.5 倍。\n\n> GitHub 地址→https://github.com/simdjson/simdjson\n\n![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d7f155c3742a4eeeaa37c6ae84c7da0c~tplv-k3u1fbpfcp-zoom-1.image)\n\n### 1.2 安全工程：how-to-secure-anything\n\n**本周 star 增长数：2800+**\n\nhow-to-secure-anything 是一个安全工程课程，收录了大量同安全相关的资料，从最基础的安全工程是什么讲起，到已知的安全最佳实践，到安全模型构建、增强防御方法、科学查找漏洞，终于安全工程的未来展望，是一份详细全面的安全工程教程。\n\n> GitHub 地址→https://github.com/veeral-patel/how-to-secure-anything\n\n![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f4f6e50b14634770832a6ff9bfa6ecfb~tplv-k3u1fbpfcp-zoom-1.image)\n\n## 2. GitHub Trending 周榜\n\n### 2.1 万物皆可动：first-order-model\n\n**本周 star 增长数：600+**\n\nfirst-order-model 这个模型可以对视频中的对象进行动画处理，并生成视频序列。基于这个模型，可以实现图片换装，静态小马跑起来，特朗普和权力游戏角色对话等等功能。\n\n> GitHub 地址→https://github.com/AliaksandrSiarohin/first-order-model\n\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/96150a07e59f443b8faefec9beafd755~tplv-k3u1fbpfcp-zoom-1.image)\n\n### 2.2 平衡生活和工作：955.WLB\n\n**本周 star 增长数：1100+**\n\n955.WLB 是一份 955 不加班的公司名单，如果你想要找一份 955 的工作，不妨 pick 这份名单。\n\n> GitHub 地址→https://github.com/formulahendry/955.WLB\n\n![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e6a59a9a23ff4d26b36dfa4b2540f713~tplv-k3u1fbpfcp-zoom-1.image)\n\n### 2.3 VSCode 韭菜基金插件：leek-fund\n\n**本周 star 增长数：150+**\n\n`New` leek-fund 是一个 VSCode 插件，在编码的时候随时关注实时股票&基金数据。功能主要有：\n- 基金涨跌查看，可自定义配置基金代码，支持查看基金历史净值详情\n- 股票涨跌查看，可自定义配置股票代码，支持查看股票实时 K 线图\n- 左侧菜单面板\n- 底部状态 bar\n- 支持 GUI 操作新增&删除 基金 和 股票\n- 每天 9~15 点之间轮询刷新数据（刷新频率最低 3 秒，可配置）\n- 支持升序/降序排序\n\n> GitHub 地址→https://github.com/giscafer/leek-fund\n\n![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e87f7007c7964c1fbd58276f0ea872ad~tplv-k3u1fbpfcp-zoom-1.image)\n\n### 2.4 cat 克隆版：bat\n\n**本周 star 增长数：750+**\n\nbat 是一个 cat 命令的一个克隆版，带有语法高亮、集成 git 等特性。\n\n> GitHub 地址→https://github.com/sharkdp/bat\n\n![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/837419e3ed4947bf855b3732697124ac~tplv-k3u1fbpfcp-zoom-1.image)\n\n### 2.5 rust 小练习：rustlings\n\n**本周 star 增长数：900+**\n\nrustlings 收录一些关于 rust 的小练习，方便你阅读和编写 rust 代码。\n\n> GitHub 地址→https://github.com/rust-lang/rustlings\n\n![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0dbc9f784b0948fc99cbdf0e9b1ab6b6~tplv-k3u1fbpfcp-zoom-1.image)\n\n### 2.6 深度学习引擎：oneflow\n\n**本周 star 增长数：800+**\n\noneflow 是国内一流科技开源的深度学习框架，oneflow 团队的目标是研发一个通用框架自动解决这些问题，让那些没有框架研发能力的团队也能够享受分布式 GPU 集群带来的效率。\n\n> GitHub 地址→https://github.com/Oneflow-Inc/oneflow\n\n### 2.7 资源监视器：bpytop\n\n**本周 star 增长数：2700+**\n\nbpytop 是基于 Python 语言的 Linux / OSX / FreeBSD 资源监视，用于显示处理器，内存，磁盘，网络和进程的使用情况和状态。\n\n> GitHub 地址→https://github.com/aristocratos/bpytop\n\n![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/15c73b4f2a17416c9994a163aac29632~tplv-k3u1fbpfcp-zoom-1.image)\n\n## 3. TTime\n\nTalk Time (^o^)/ 你永远不知道在 GitHub 会找到什么有意思的项目，本篇 TT 话题 #让你惊呆了的 GitHub 项目# ，评论区就坐吧 😊\n\n依旧我先来，这是一个本周 Twitter 上和 HN 上讨论热烈的项目——通过微信小程序控制小强的移动 [手动狗头] 围观地址在这里：https://github.com/chuangzhu/insect-robot/tree/2f466f8a04e431f5b42ae0229402c28271fdfaf2\n\n![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b94075abef354082806acf5d10ddee92~tplv-k3u1fbpfcp-zoom-1.image)\n\n还有前年的口红色号项目… 🤔 下面，交给你来说说你遇到过的 amazing GitHub repo 啦~~ \n\n## 4. 推荐阅读 \n\n- [GitHub 热点速览 Vol.31：在？跑个 GitHub 评分如何？](https://juejin.im/post/6856915146116333575)\n- [GitHub 热点速览 Vol.30：那些提升效率的小工具们](https://juejin.im/post/6855129007793537037)\n- [GitHub 热点速览 Vol.29：程序员资料大全](https://juejin.im/post/6854573212936699912)\n\n以上为 2020 年第 32 个工作周的 GitHub Trending 🎉如果你 Pick 其他好玩、实用的 GitHub 项目，记得来 [HelloGitHub](https://github.com/521xueweihan/HelloGitHub) issue 区和我们分享下哟 🌝 \n\n> HelloGitHub 交流群现已全面开放，添加微信号：HelloGitHub 为好友入群，可同前端、Java、Go 等各界大佬谈笑风生、切磋技术~\n\n---\n\n![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a4fd97bf46764353a5fd7ca91214a1d6~tplv-k3u1fbpfcp-zoom-1.image)\n\n**关注公众号加入交流群**\n\n\n\n", "user_name": "HelloGitHub", "description": "分享 GitHub 上有趣、入门级的开源项目", "got_view_count": 217139, "category_name": "阅读", "ctime": 1457483895}
{"tag_name": "Java", "concern_user_count": 252044, "user_id": "2647279732263159", "title": "教你启用HTTPS，让你的网站也能通过https访问", "mark_content": "<section id=\"nice\" data-tool=\"mdnice编辑器\" data-website=\"https://www.mdnice.com\" style=\"padding: 0 10px; word-spacing: 0px; word-wrap: break-word; text-align: left; font-family: Optima-Regular, Optima, PingFangSC-light, PingFangTC-light, 'PingFang SC', Cambria, Cochin, Georgia, Times, 'Times New Roman', serif; line-height: 1.6; letter-spacing: .034em; color: rgb(63, 63, 63); font-size: 16px; word-break: all;\"><p data-tool=\"mdnice编辑器\" style=\"font-size: 16px; padding-bottom: 8px; margin: 0; padding-top: 23px; color: rgb(74,74,74); line-height: 1.75em;\">大家好，我是小菜，一个渴望在互联网行业做到蔡不菜的小菜。可柔可刚，点赞则柔，白嫖则刚！\n<strong style=\"font-weight: bold; line-height: 1.75em; color: rgb(74,74,74);\">死鬼~看完记得给我来个三连哦！</strong><img src=\"https://user-gold-cdn.xitu.io/2020/4/11/17169c46045528af?w=240&amp;h=224&amp;f=jpeg&amp;s=7529\" alt style=\"display: block; margin: 0 auto; max-width: 100%; border-radius: 4px; margin-bottom: 25px;\"></p>\n<blockquote data-tool=\"mdnice编辑器\" style=\"font-size: 0.9em; overflow: auto; overflow-scrolling: touch; background: rgba(0, 0, 0, 0.05); color: #6a737d; padding-top: 10px; padding-bottom: 10px; padding-left: 20px; padding-right: 10px; margin-bottom: 20px; margin-top: 20px; padding: 15px 20px; line-height: 27px; background-color: rgb(239, 239, 239); border-left: none; display: block;\">\n<p style=\"padding-bottom: 8px; padding-top: 23px; margin: 0px; line-height: 26px; padding: 0px; font-size: 15px; color: rgb(89,89,89);\">本文主要介绍 <code style=\"font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: rgb(60, 112, 198);\">如何启用HTTPS</code></p>\n<p style=\"padding-bottom: 8px; padding-top: 23px; margin: 0px; line-height: 26px; padding: 0px; font-size: 15px; color: rgb(89,89,89);\">如有需要，可以参考</p>\n<p style=\"padding-bottom: 8px; padding-top: 23px; margin: 0px; line-height: 26px; padding: 0px; font-size: 15px; color: rgb(89,89,89);\">如有帮助，不忘 <strong style=\"font-weight: bold; line-height: 1.75em; color: rgb(74,74,74);\">点赞</strong> ❥</p>\n</blockquote>\n<h3 data-tool=\"mdnice编辑器\" style=\"margin-top: 30px; margin-bottom: 15px; padding: 0px; font-weight: bold; color: black; font-size: 20px;\"><span style=\"background-image: url(https://my-wechat.mdnice.com/mountain_1.png); background-size: 15px 15px; display: inline-block; width: 15px; height: 15px; line-height: 15px; margin-bottom: -1px;\"></span><span class=\"prefix\" style=\"display: none;\"></span><span class=\"content\" style=\"font-size: 16px; font-weight: bold; display: inline-block; margin-left: 8px; color: rgb(60,112,198);\">一、准备工作</span><span class=\"suffix\" style=\"display: none;\"></span></h3>\n<ul data-tool=\"mdnice编辑器\" style=\"margin-top: 8px; margin-bottom: 8px; padding-left: 25px; color: black; list-style-type: disc;\">\n<li><section style=\"margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;\">服务器一台（可以购买阿里云轻量应用服务器，比较便宜）</section></li><li><section style=\"margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;\">SSL证书 （可以注册阿里云免费证书，安全性较差）</section></li><li><section style=\"margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;\">域名一个 （可以在万网上购买并要进行备案）</section></li><li><section style=\"margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;\">本地打包好的项目（博主是使用springboot开发，所以打包好的是jar包而不是war包）</section></li><li><section style=\"margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;\"><code style=\"font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: rgb(60, 112, 198);\">ftp</code>客户端</section></li></ul>\n<p data-tool=\"mdnice编辑器\" style=\"font-size: 16px; padding-bottom: 8px; margin: 0; padding-top: 23px; color: rgb(74,74,74); line-height: 1.75em;\"><em style=\"font-style: italic; color: black;\">首先在服务器上搭建好环境（数据库，jdk之类的），因为演示的项目是由<code style=\"font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: rgb(60, 112, 198);\">SpringBoot</code>搭建，有内置运行容器，所以不用Tomcat。</em></p>\n<h4 data-tool=\"mdnice编辑器\" style=\"margin-top: 30px; margin-bottom: 15px; padding: 0px; font-weight: bold; color: black; font-size: 18px;\"><span class=\"prefix\" style=\"display: none;\"></span><span class=\"content\">1）SSL证书</span><span class=\"suffix\" style=\"display: none;\"></span></h4>\n<p data-tool=\"mdnice编辑器\" style=\"font-size: 16px; padding-bottom: 8px; margin: 0; padding-top: 23px; color: rgb(74,74,74); line-height: 1.75em;\">可以上阿里云申请免费版的<code style=\"font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: rgb(60, 112, 198);\">SSL</code>证书，也可以访问<code style=\"font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: rgb(60, 112, 198);\">FreeSSL</code>网站进行注册免费的证书\n<img src=\"https://img-blog.csdnimg.cn/20200308123216857.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzI4NzIzOQ==,size_16,color_FFFFFF,t_70\" alt=\" \" style=\"display: block; margin: 0 auto; max-width: 100%; border-radius: 4px; margin-bottom: 25px;\"></p>\n<h4 data-tool=\"mdnice编辑器\" style=\"margin-top: 30px; margin-bottom: 15px; padding: 0px; font-weight: bold; color: black; font-size: 18px;\"><span class=\"prefix\" style=\"display: none;\"></span><span class=\"content\">2）域名备案成功后需要进行解析</span><span class=\"suffix\" style=\"display: none;\"></span></h4>\n<p data-tool=\"mdnice编辑器\" style=\"font-size: 16px; padding-bottom: 8px; margin: 0; padding-top: 23px; color: rgb(74,74,74); line-height: 1.75em;\">到阿里云控制台，进入域名管理\n<img src=\"https://img-blog.csdnimg.cn/20200308124447722.png\" alt=\" \" style=\"display: block; margin: 0 auto; max-width: 100%; border-radius: 4px; margin-bottom: 25px;\">\n<img src=\"https://img-blog.csdnimg.cn/2020030812450570.png\" alt=\" \" style=\"display: block; margin: 0 auto; max-width: 100%; border-radius: 4px; margin-bottom: 25px;\">\n<img src=\"https://img-blog.csdnimg.cn/20200308124534492.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzI4NzIzOQ==,size_16,color_FFFFFF,t_70\" alt=\" \" style=\"display: block; margin: 0 auto; max-width: 100%; border-radius: 4px; margin-bottom: 25px;\"></p>\n<h4 data-tool=\"mdnice编辑器\" style=\"margin-top: 30px; margin-bottom: 15px; padding: 0px; font-weight: bold; color: black; font-size: 18px;\"><span class=\"prefix\" style=\"display: none;\"></span><span class=\"content\">3）解析完成后在这块点击证书申请，填写相关信息</span><span class=\"suffix\" style=\"display: none;\"></span></h4>\n<p data-tool=\"mdnice编辑器\" style=\"font-size: 16px; padding-bottom: 8px; margin: 0; padding-top: 23px; color: rgb(74,74,74); line-height: 1.75em;\"><img src=\"https://img-blog.csdnimg.cn/20200308123451479.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzI4NzIzOQ==,size_16,color_FFFFFF,t_70\" alt=\" \" style=\"display: block; margin: 0 auto; max-width: 100%; border-radius: 4px; margin-bottom: 25px;\">\n<img src=\"https://img-blog.csdnimg.cn/20200308123551767.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzI4NzIzOQ==,size_16,color_FFFFFF,t_70\" alt=\" \" style=\"display: block; margin: 0 auto; max-width: 100%; border-radius: 4px; margin-bottom: 25px;\">\n申请好后经过审核 ，然后便可以点击下载\n<img src=\"https://img-blog.csdnimg.cn/20200308123711279.png\" alt=\" \" style=\"display: block; margin: 0 auto; max-width: 100%; border-radius: 4px; margin-bottom: 25px;\"></p>\n<h4 data-tool=\"mdnice编辑器\" style=\"margin-top: 30px; margin-bottom: 15px; padding: 0px; font-weight: bold; color: black; font-size: 18px;\"><span class=\"prefix\" style=\"display: none;\"></span><span class=\"content\">4）注入<code>ServletWebServerFactory</code></span><span class=\"suffix\" style=\"display: none;\"></span></h4>\n<p data-tool=\"mdnice编辑器\" style=\"font-size: 16px; padding-bottom: 8px; margin: 0; padding-top: 23px; color: rgb(74,74,74); line-height: 1.75em;\">在我们<code style=\"font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: rgb(60, 112, 198);\">SpringBoot</code>项目中的<strong style=\"font-weight: bold; line-height: 1.75em; color: rgb(74,74,74);\">启动类</strong>中注入<code style=\"font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: rgb(60, 112, 198);\">ServletWebServerFactory</code>：</p>\n<pre class=\"custom\" data-tool=\"mdnice编辑器\" style=\"margin-top: 10px; margin-bottom: 10px; border-radius: 5px; box-shadow: rgba(0, 0, 0, 0.55) 0px 2px 10px;\"><span style=\"display: block; background: url(https://my-wechat.mdnice.com/point.png); height: 30px; width: 100%; background-size: 40px; background-repeat: no-repeat; background-color: #1E1E1E; margin-bottom: -7px; border-radius: 5px; background-position: 10px 10px;\"></span><code class=\"hljs\" style=\"overflow-x: auto; padding: 16px; color: #DCDCDC; display: -webkit-box; font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; font-size: 12px; -webkit-overflow-scrolling: touch; padding-top: 15px; background: #1E1E1E; border-radius: 5px;\"><span class=\"hljs-meta\" style=\"color: #9B9B9B; line-height: 26px;\">@Bean</span><br><span class=\"hljs-function\" style=\"color: #DCDCDC; line-height: 26px;\"><span class=\"hljs-keyword\" style=\"color: #569CD6; line-height: 26px;\">public</span>&nbsp;ServletWebServerFactory&nbsp;<span class=\"hljs-title\" style=\"color: #DCDCDC; line-height: 26px;\">servletContainer</span><span class=\"hljs-params\" style=\"color: #DCDCDC; line-height: 26px;\">()</span></span>{<br>&nbsp;&nbsp;&nbsp;&nbsp;TomcatServletWebServerFactory&nbsp;tomcat&nbsp;=&nbsp;<span class=\"hljs-keyword\" style=\"color: #569CD6; line-height: 26px;\">new</span>&nbsp;TomcatServletWebServerFactory();<br>&nbsp;&nbsp;&nbsp;&nbsp;tomcat.addAdditionalTomcatConnectors(createHTTPConnector());<br>&nbsp;&nbsp;&nbsp;&nbsp;<span class=\"hljs-keyword\" style=\"color: #569CD6; line-height: 26px;\">return</span>&nbsp;tomcat;<br>}<br><br><span class=\"hljs-function\" style=\"color: #DCDCDC; line-height: 26px;\"><span class=\"hljs-keyword\" style=\"color: #569CD6; line-height: 26px;\">private</span>&nbsp;Connector&nbsp;<span class=\"hljs-title\" style=\"color: #DCDCDC; line-height: 26px;\">createHTTPConnector</span><span class=\"hljs-params\" style=\"color: #DCDCDC; line-height: 26px;\">()</span>&nbsp;</span>{<br>&nbsp;&nbsp;&nbsp;&nbsp;Connector&nbsp;connector&nbsp;=&nbsp;<span class=\"hljs-keyword\" style=\"color: #569CD6; line-height: 26px;\">new</span>&nbsp;Connector(<span class=\"hljs-string\" style=\"color: #D69D85; line-height: 26px;\">\"org.apache.coyote.http11.Http11NioProtocol\"</span>);<br>&nbsp;&nbsp;&nbsp;&nbsp;<span class=\"hljs-comment\" style=\"color: #57A64A; font-style: italic; line-height: 26px;\">//同时启用http（8080）、https（8866）两个端口</span><br>&nbsp;&nbsp;&nbsp;&nbsp;connector.setScheme(<span class=\"hljs-string\" style=\"color: #D69D85; line-height: 26px;\">\"http\"</span>);<br>&nbsp;&nbsp;&nbsp;&nbsp;connector.setSecure(<span class=\"hljs-keyword\" style=\"color: #569CD6; line-height: 26px;\">false</span>);<br>&nbsp;&nbsp;&nbsp;&nbsp;connector.setPort(<span class=\"hljs-number\" style=\"color: #B8D7A3; line-height: 26px;\">8080</span>);<br>&nbsp;&nbsp;&nbsp;&nbsp;connector.setRedirectPort(<span class=\"hljs-number\" style=\"color: #B8D7A3; line-height: 26px;\">8866</span>);<br>&nbsp;&nbsp;&nbsp;&nbsp;<span class=\"hljs-keyword\" style=\"color: #569CD6; line-height: 26px;\">return</span>&nbsp;connector;<br>}<br></code></pre>\n<p data-tool=\"mdnice编辑器\" style=\"font-size: 16px; padding-bottom: 8px; margin: 0; padding-top: 23px; color: rgb(74,74,74); line-height: 1.75em;\">然后在<code style=\"font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: rgb(60, 112, 198);\">application.properties</code>配置文件中添加\n<img src=\"https://img-blog.csdnimg.cn/20200308124149288.png\" alt=\" \" style=\"display: block; margin: 0 auto; max-width: 100%; border-radius: 4px; margin-bottom: 25px;\">\n<em style=\"font-style: italic; color: black;\">这里注意是<code style=\"font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: rgb(60, 112, 198);\">server.ssl.key-store-password</code>而不是 <code style=\"font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: rgb(60, 112, 198);\">server.ssl.key-password</code></em></p>\n<h4 data-tool=\"mdnice编辑器\" style=\"margin-top: 30px; margin-bottom: 15px; padding: 0px; font-weight: bold; color: black; font-size: 18px;\"><span class=\"prefix\" style=\"display: none;\"></span><span class=\"content\">5）打包项目</span><span class=\"suffix\" style=\"display: none;\"></span></h4>\n<p data-tool=\"mdnice编辑器\" style=\"font-size: 16px; padding-bottom: 8px; margin: 0; padding-top: 23px; color: rgb(74,74,74); line-height: 1.75em;\">将<code style=\"font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: rgb(60, 112, 198);\">自己打包好的项目和下载下来的证书</code>放到<code style=\"font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: rgb(60, 112, 198);\">usr/develop/project</code> 文件夹下，文件夹目录可以自己选择。</p>\n<p data-tool=\"mdnice编辑器\" style=\"font-size: 16px; padding-bottom: 8px; margin: 0; padding-top: 23px; color: rgb(74,74,74); line-height: 1.75em;\">为了方便我自己建了几个脚本方便运行。</p>\n<ul data-tool=\"mdnice编辑器\" style=\"margin-top: 8px; margin-bottom: 8px; padding-left: 25px; color: black; list-style-type: disc;\">\n<li><section style=\"margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;\"><p style=\"font-size: 16px; padding-bottom: 8px; margin: 0; padding-top: 23px; color: rgb(74,74,74); line-height: 1.75em;\"><code style=\"font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: rgb(60, 112, 198);\">vim start.sh</code></p>\n<p style=\"font-size: 16px; padding-bottom: 8px; margin: 0; padding-top: 23px; color: rgb(74,74,74); line-height: 1.75em;\">建立启动脚本，内容如下：</p>\n</section></li></ul>\n<pre class=\"custom\" data-tool=\"mdnice编辑器\" style=\"margin-top: 10px; margin-bottom: 10px; border-radius: 5px; box-shadow: rgba(0, 0, 0, 0.55) 0px 2px 10px;\"><span style=\"display: block; background: url(https://my-wechat.mdnice.com/point.png); height: 30px; width: 100%; background-size: 40px; background-repeat: no-repeat; background-color: #1E1E1E; margin-bottom: -7px; border-radius: 5px; background-position: 10px 10px;\"></span><code class=\"hljs\" style=\"overflow-x: auto; padding: 16px; color: #DCDCDC; display: -webkit-box; font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; font-size: 12px; -webkit-overflow-scrolling: touch; padding-top: 15px; background: #1E1E1E; border-radius: 5px;\">nohup&nbsp;java&nbsp;-jar&nbsp;自己的项目名称.jar&nbsp;&amp;<br></code></pre>\n<ul data-tool=\"mdnice编辑器\" style=\"margin-top: 8px; margin-bottom: 8px; padding-left: 25px; color: black; list-style-type: disc;\">\n<li><section style=\"margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;\"><p style=\"font-size: 16px; padding-bottom: 8px; margin: 0; padding-top: 23px; color: rgb(74,74,74); line-height: 1.75em;\"><code style=\"font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: rgb(60, 112, 198);\">vim stop.sh</code></p>\n<p style=\"font-size: 16px; padding-bottom: 8px; margin: 0; padding-top: 23px; color: rgb(74,74,74); line-height: 1.75em;\">建立停止脚本，内容如下：</p>\n</section></li></ul>\n<pre class=\"custom\" data-tool=\"mdnice编辑器\" style=\"margin-top: 10px; margin-bottom: 10px; border-radius: 5px; box-shadow: rgba(0, 0, 0, 0.55) 0px 2px 10px;\"><span style=\"display: block; background: url(https://my-wechat.mdnice.com/point.png); height: 30px; width: 100%; background-size: 40px; background-repeat: no-repeat; background-color: #1E1E1E; margin-bottom: -7px; border-radius: 5px; background-position: 10px 10px;\"></span><code class=\"hljs\" style=\"overflow-x: auto; padding: 16px; color: #DCDCDC; display: -webkit-box; font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; font-size: 12px; -webkit-overflow-scrolling: touch; padding-top: 15px; background: #1E1E1E; border-radius: 5px;\">PID=$(ps&nbsp;-ef&nbsp;|&nbsp;grep&nbsp;自己的项目名称.jar&nbsp;|&nbsp;grep&nbsp;-v&nbsp;grep&nbsp;|&nbsp;awk&nbsp;'{&nbsp;print&nbsp;$2&nbsp;}')<br>if&nbsp;[&nbsp;-z&nbsp;\"$PID\"&nbsp;]<br>then<br>&nbsp;&nbsp;&nbsp;&nbsp;echo&nbsp;Application&nbsp;is&nbsp;already&nbsp;stopped<br>else<br>&nbsp;&nbsp;&nbsp;&nbsp;echo&nbsp;kill&nbsp;$PID<br>&nbsp;&nbsp;&nbsp;&nbsp;kill&nbsp;-9&nbsp;$PID<br>fi<br></code></pre>\n<ul data-tool=\"mdnice编辑器\" style=\"margin-top: 8px; margin-bottom: 8px; padding-left: 25px; color: black; list-style-type: disc;\">\n<li><section style=\"margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;\"><p style=\"font-size: 16px; padding-bottom: 8px; margin: 0; padding-top: 23px; color: rgb(74,74,74); line-height: 1.75em;\"><code style=\"font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: rgb(60, 112, 198);\">vim run.sh</code></p>\n<p style=\"font-size: 16px; padding-bottom: 8px; margin: 0; padding-top: 23px; color: rgb(74,74,74); line-height: 1.75em;\">建立运行脚本，内容如下</p>\n</section></li></ul>\n<pre class=\"custom\" data-tool=\"mdnice编辑器\" style=\"margin-top: 10px; margin-bottom: 10px; border-radius: 5px; box-shadow: rgba(0, 0, 0, 0.55) 0px 2px 10px;\"><span style=\"display: block; background: url(https://my-wechat.mdnice.com/point.png); height: 30px; width: 100%; background-size: 40px; background-repeat: no-repeat; background-color: #1E1E1E; margin-bottom: -7px; border-radius: 5px; background-position: 10px 10px;\"></span><code class=\"hljs\" style=\"overflow-x: auto; padding: 16px; color: #DCDCDC; display: -webkit-box; font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; font-size: 12px; -webkit-overflow-scrolling: touch; padding-top: 15px; background: #1E1E1E; border-radius: 5px;\">echo&nbsp;stop&nbsp;application<br>source&nbsp;stop.sh<br>echo&nbsp;start&nbsp;application<br>source&nbsp;start.sh<br></code></pre>\n<p data-tool=\"mdnice编辑器\" style=\"font-size: 16px; padding-bottom: 8px; margin: 0; padding-top: 23px; color: rgb(74,74,74); line-height: 1.75em;\">然后在终端输入 <code style=\"font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: rgb(60, 112, 198);\">./run.sh</code>\n如果提示没有权限，则输入</p>\n<pre class=\"custom\" data-tool=\"mdnice编辑器\" style=\"margin-top: 10px; margin-bottom: 10px; border-radius: 5px; box-shadow: rgba(0, 0, 0, 0.55) 0px 2px 10px;\"><span style=\"display: block; background: url(https://my-wechat.mdnice.com/point.png); height: 30px; width: 100%; background-size: 40px; background-repeat: no-repeat; background-color: #1E1E1E; margin-bottom: -7px; border-radius: 5px; background-position: 10px 10px;\"></span><code class=\"hljs\" style=\"overflow-x: auto; padding: 16px; color: #DCDCDC; display: -webkit-box; font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; font-size: 12px; -webkit-overflow-scrolling: touch; padding-top: 15px; background: #1E1E1E; border-radius: 5px;\">chmod&nbsp;u+x&nbsp;*.sh<br></code></pre>\n<p data-tool=\"mdnice编辑器\" style=\"font-size: 16px; padding-bottom: 8px; margin: 0; padding-top: 23px; color: rgb(74,74,74); line-height: 1.75em;\">然后再输入 <code style=\"font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: rgb(60, 112, 198);\">./run.sh</code>\n这样我们的程序就启动了，然后我们在浏览器上就可以通过<code style=\"font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: rgb(60, 112, 198);\">https://域名:端口号</code>访问自己的项目了</p>\n<figure data-tool=\"mdnice编辑器\" style=\"margin: 0; margin-top: 10px; margin-bottom: 10px; display: flex; flex-direction: column; justify-content: center; align-items: center;\"><img src=\"https://imgconvert.csdnimg.cn/aHR0cHM6Ly93d3cuNTJkb3V0dS5jbi9zdGF0aWMvdGVtcC9waWMvOWJkNjhkMTUwZjA3ODdjNTYwYTQzOWRhMzU5YTU4MGEucG5n?x-oss-process=image/format,png#pic_center\" alt=\"看完不赞，都是坏蛋\" style=\"display: block; margin: 0 auto; max-width: 100%; border-radius: 4px; margin-bottom: 25px;\"><figcaption style=\"margin-top: 5px; text-align: center; color: #888; display: block; font-size: 12px; font-family: PingFangSC-Light;\">看完不赞，都是坏蛋</figcaption></figure>\n<blockquote data-tool=\"mdnice编辑器\" style=\"font-size: 0.9em; overflow: auto; overflow-scrolling: touch; background: rgba(0, 0, 0, 0.05); color: #6a737d; padding-top: 10px; padding-bottom: 10px; padding-left: 20px; padding-right: 10px; margin-bottom: 20px; margin-top: 20px; padding: 15px 20px; line-height: 27px; background-color: rgb(239, 239, 239); border-left: none; display: block;\">\n<p style=\"padding-bottom: 8px; padding-top: 23px; margin: 0px; line-height: 26px; padding: 0px; font-size: 15px; color: rgb(89,89,89);\">今天的你多努力一点，明天的你就能少说一句求人的话！</p>\n<p style=\"padding-bottom: 8px; padding-top: 23px; margin: 0px; line-height: 26px; padding: 0px; font-size: 15px; color: rgb(89,89,89);\"><em style=\"font-style: italic; color: black;\">我是小菜，一个和你一起学习的男人。</em> <code style=\"font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: rgb(60, 112, 198);\">💋</code></p>\n</blockquote>\n</section>", "user_name": "蔡不菜丶", "description": "公众号：小菜良记", "got_view_count": 28340, "category_name": "后端", "ctime": 1457483880}
{"tag_name": "前端", "concern_user_count": 455667, "user_id": "2858385961407853", "title": "面试造火箭，看下这些大厂原题", "mark_content": "> 需求已改活已加，加班通宵看朝霞。\n> 终是上线已延期，bug还是改不完。\n\n面试造火箭，工作拧螺丝，虽然我只想拧螺丝，可是我需要用造火箭的技术去寻找拧螺丝的工作，如何能在面试过程中让自己处于不败的地步呢，刷题是一个比较好的捷径，今天就汇总了一些比较经典的面试题进行了汇总，分享给大家。\n>本文中的所有题目首发于公众号【前端有的玩】，小编每天都会整理一道两道面试题，然后推送给所有的朋友，关注小编，每天带你去刷面试题，不想当咸鱼，想要换工作，还在犹豫什么，关注 === 大厂offer。\n\n### 题目一\n\n#### 题目介绍\n\n如下为一段代码，请完善sum函数，使得 sum(1,2,3,4,5,6) 函数返回值为 21 ,需要在 sum 函数中调用 asyncAdd 函数，且不能修改asyncAdd函数\n\n```javascript\n/**\n * 请在 sum函数中调用此函数，完成数值计算\n * @param {*} a 要相加的第一个值\n * @param {*} b 要相加的第二个值\n * @param {*} callback 相加之后的回调函数\n */\nfunction asyncAdd(a,b,callback) {\n  setTimeout(function(){\n   callback(null, a+b)\n  },1000)\n}\n\n/**\n * 请在此方法中调用asyncAdd方法，完成数值计算\n * @param  {...any} rest 传入的参数\n */\nasync function sum(...rest) {\n  // 请在此处完善代码\n}\n\nlet start = window.performance.now()\nsum(1, 2, 3, 4, 5, 6).then(res => {\n  // 请保证在调用sum方法之后，返回结果21\n  console.log(res)\n  console.log(`程序执行共耗时: ${window.performance.now() - start}`)\n})\n```\n\n本题根据程序输出时间不同,可以划分为三个难度等级\n\n1. 青铜难度， 输出时长大于6秒\n2. 白银难度， 输出时长大于3秒\n3. 王者难度， 输出时长大于1秒\n\n#### 答案\n\n1. 青铜难度\n\n```javascript\nasync function sum(...rest) {\n  // 取出来第一个作为初始值\n  let result = rest.shift()\n  // 通过for of 遍历 rest, 依次相加\n  for(let num of rest) {\n    // 使用promise 获取相加结果\n    result = await new Promise(resolve => {\n      asyncAdd(result, num, (_,res) => {\n        resolve(res)\n      })\n    })\n  }\n  // 返回执行结果\n  return result\n}\n\n// 执行成功，执行时长大于6秒\nsum1(1, 2, 3, 4, 5,6).then(res => {\n  console.log(`计算结果为:${res}`)\n})\n\n```\n\n\n\n2. 白银难度\n\n在青铜难度，我们把数组里面的每一项依次相加。但是也可以进行一些优化，可以并发执行多个，比如 `sum(1,2,3,4,5,6)`，可以同时执行 `1+2`,`3+4`,`5+6`,这样就可以提升执行效率\n\n```javascript\nasync function sum(...rest) {\n  // 如果传的值少于2个，则直接返回\n  if (rest.length <= 1) {\n    return rest[0] || 0\n  }\n  const promises = []\n  // 遍历将数组里面的值两个两个的执行\n  for (let i = 0; i < rest.length; i += 2) {\n    promises.push(\n      new Promise(resolve => {\n        // 如果 rest[i+1] 是 undefined, 说明数组长度是奇数，这个是最后一个\n        if (rest[i + 1] === undefined) {\n          resolve(rest[i])\n        } else {\n          // 调用asyncAdd 进行计算\n          asyncAdd(rest[i], rest[i + 1], (_, result) => {\n            resolve(result)\n          })\n        }\n      })\n    )\n  }\n  // 获取第一次计算结果\n  const result = await Promise.all(promises)\n  // 然后将第一次获取到的结果即 [3,7,11] 再次调用 sum执行\n  return await sum(...result)\n}\n\n// 执行成功，执行时长大于3秒小于4秒\nsum1(1, 2, 3, 4, 5,6).then(res => {\n  console.log(`计算结果为:${res}`)\n})\n```\n\n\n\n3. 王者难度\n\n```javascript\nasync function sum(...rest) {\n  let result = 0\n  // 隐氏类型转换， 对象 + 数字，会先调用对象的toString 方法\n  const obj = {}\n  obj.toString = function() {\n    return result\n  }\n  const promises = []\n  for(let num of rest) {\n    promises.push(new Promise((resolve) => {\n      asyncAdd(obj, num, (_, res) => {\n        resolve(res)\n      })\n    }).then(res => {\n      // 在这里将 result的值改变之后，obj.toString 的返回值就变了，这时候下一个setTimeout调用时就使用了新值\n      result = res\n    }))\n  }\n  await Promise.all(promises)\n  return result\n}\n\n// 执行成功，执行时长大于1秒小于2秒\nsum1(1, 2, 3, 4, 5,6).then(res => {\n  console.log(`计算结果为:${res}`)\n})\n```\n\n因为`js`是执行在单线程里面的，所以上面的代码，我们在`for of`将所有的计算放到`promises`数组里面，然后通过`Promise.all`去一次性执行，这时候并不需要考虑到底先执行哪两个数字相加。因为单线程的原因，我们可以保证这几个`Promise`是依次执行的，这时候`obj.toString`返回值就是上一个`Promise`的返回值，多跑几遍代码你就懂了哦\n\n### 题目二\n\n#### 题目介绍\n\n请说明以下代码各输出了什么?\n\n```javascript\nconsole.log(typeof (() => {}))\n\nconsole.log(typeof ['前端有的玩','公众号'])\n\nconsole.log(typeof null)\n\nconsole.log(typeof undefined)\n\nconsole.log(typeof Function.prototype)\n\nconsole.log('子君' instanceof String)\n\nconsole.log(new Date() instanceof Date)\n```\n\n#### 答案\n\n```javascript\n// 输出 function\nconsole.log(typeof (() => {}))\n\n// 输出 object\nconsole.log(typeof ['前端有的玩','公众号'])\n\n// 输出 object\nconsole.log(typeof null)\n\n// 输出 undefined\nconsole.log(typeof undefined)\n\n// 输出 function \nconsole.log(typeof Function.prototype)\n\n// 输出 false\nconsole.log('子君' instanceof String)\n\n// 输出 true\nconsole.log(new Date() instanceof Date)\n```\n\n需要注意的是，对于 `typeof`, 可以正确判断除了`null`之外的所有基本类型，而对于引用类型，除了函数外其他都会被判断为`object`。\n\n对于`instanceof`,无法判断基本类型，但可以正确判断引用类型\n\n### 题目三\n\n#### 题目介绍\n\n请实现一个`instanceof`,让以下代码可正常运行\n\n```javascript\n/**\n 自定义instanceof \n*/\nfunction instanceOf(left, right) {\n    // 请完善以下代码，不能使用原生instanceof\n}\n\nclass A{}\nclass B extends A {}\nclass C{}\n\nconst b = new B()\n// 输出 true\nconsole.log(instanceOf(b,B))\n// 输出 true\nconsole.log(instanceOf(b,A))\n// 输出 false\nconsole.log(instanceOf(b,C))\n```\n\n#### 答案\n\n本题主要考察`instanceof`的判断原理，`instanceof`主要的实现原理就是只要右边变量的 `prototype` 在左边变量的原型链上即可。因此，`instanceof` 在查找的过程中会遍历左边变量的原型链，直到找到右边变量的 `prototype`，如果查找失败，则会返回 `false`。\n\n```javascript\n/**\n  自定义instanceof \n*/\nfunction instanceOf(left, right) {\n  let proto = left.__proto__\n  while(proto){\n    if(proto === right.prototype){\n       return true\n    }\n    proto = proto.__proto__\n  }  \n  return false\n}\n\nclass A{}\nclass B extends A {}\nclass C{}\n\nconst b = new B()\n// 输出 true\nconsole.log(instanceOf(b,B))\n// 输出 true\nconsole.log(instanceOf(b,A))\n// 输出 false\nconsole.log(instanceOf(b,C))\n```\n\n### 题目四\n\n#### 题目介绍\n\n请模拟实现`new`操作符，使下面代码正常运行\n\n```javascript\nfunction myNew(constructor, ...rest) {\n // 请在此处完善代码，不能直接使用 new 操作符\n}\nfunction Fun(name,sex) {\n  this.name = name\n  this.sex = sex\n}\nFun.prototype.getUserInfo = function() {\n  return `我的姓名${this.name},我的性别${this.sex}`\n}\n\nconst fun = myNew(Fun,'子君','男')\n// 我的姓名子君，我的性别男\nconsole.log(fun.getUserInfo())\n```\n\n#### 答案\n\n这道题考察的是使用`new操作符`调用构造函数所经历的阶段:\n\n1. 创建一个新的对象;\n2. 将构造函数的作用域赋给新的对象;\n3. 执行构造函数中的代码;\n4. 返回新的对象;\n\n```javascript\nfunction myNew(constructor, ...rest) {\n  if (typeof constructor !== 'function') {\n        return constructor;\n    }\n    //创建新的对象,关联构造函数的原型对象\n    const _constructor = Object.create(constructor.prototype);\n    //执行构造函数\n    const obj = constructor.apply(_constructor, rest);\n    //如果构造函数执行结果是对象则返回执行结果\n    if (typeof obj === 'object') {\n        return obj;\n    } else {\n        return _constructor;\n    }\n}\nfunction Fun(name,sex) {\n  this.name = name\n  this.sex = sex\n}\nFun.prototype.getUserInfo = function() {\n  return `我的姓名${this.name},我的性别${this.sex}`\n}\n\nconst fun = myNew(Fun,'子君','男')\n// 我的姓名子君，我的性别男\nconsole.log(fun.getUserInfo())\n```\n\n### 题目五\n\n#### 题目介绍\n\n请说出以下代码输出内容\n\n```javascript\nconst a = {}\nconst b = Symbol('1')\nconst c = Symbol('1')\na[b] = '子君'\na[c] = '君子'\n\n// 我是子君还是君子呢\nconsole.log(a[b])\n\nconst d = {}\nconst e = {key: '1'}\nconst f = {key: '2'}\nd[e] = '子君'\nd[f] = '君子'\n\n// 我是子君还是君子呢\nconsole.log(d[e])\n```\n\n#### 答案\n\n```javascript\nconst a = {}\nconst b = Symbol('1')\nconst c = Symbol('1')\na[b] = '子君'\na[c] = '君子'\n\n// 输出子君\nconsole.log(a[b])\n\nconst d = {}\nconst e = {key: '1'}\nconst f = {key: '2'}\nd[e] = '子君'\nd[f] = '君子'\n\n// 输出君子\nconsole.log(d[e])\n```\n\n对于第一个输出，`Symbol()`函数会返回**「symbol」**类型的值，而`Symbol`函数传的参数仅仅是用于标识的，不会影响值的唯一性\n\n对于第二个输出， 因为`e`和`f`都是对象，而对象的`key`只能是数值或字符，所以会将对象转换为字符，对象的`toString`方法返回的是`[object Object]`, 所有输出的是君子\n\n#### 题目六\n\n#### 题目介绍\n\n请说出以下代码输出的内容\n\n```javascript\nconsole.log([] + [])\nconsole.log({} + [])\nconsole.log([] == ![])\nconsole.log(true + false)\n```\n\n#### 答案\n\n1. 第一行代码\n\n```\n// 输出 \"\" 空字符串\nconsole.log([] + [])\n```\n\n这行代码输出的是空字符串`\"\"`， 包装类型在运算的时候，会先调用`valueOf`方法，如果`valueOf`返回的还是包装类型，那么再调用`toString`方法\n\n```\n// 还是 数组\nconst val = [].valueOf()\n// 数组 toString 默认会将数组各项使用逗号 \",\" 隔开, 比如 [1,2,3].toSting 变成了\"1,2,3\",空数组 toString 就是空字符串\nconst val1 = val.toString() // val1 是空字符串\n```\n\n所以上面的代码相当于\n\n```\nconsole.log(\"\" + \"\")\n```\n\n1. 第二行代码\n\n   ```\n   // 输出 \"[object Object]\"\n   console.log({} + [])\n   ```\n\n   和第一题道理一样，对象 `{}`隐氏转换成了`[object Object]`,然后与`\"\"`相加\n\n2. 第三行代码\n\n   ```\n   // 输出 true\n   console.log([] == ![])\n   ```\n\n   对于`===`, 会严格比较两者的值，但是对于`==`就不一样了\n\n   所以对于上面的代码,看下面一步一步分析\n\n   ```\n   // 这个输出 false\n   console.log(![])\n   // 套用上面第三条 将 false 转换为 数值\n   // 这个输出 0\n   console.log(Number(false))\n   // 包装类型与 基本类型 == 先将包装类型通过 valueOf toString 转换为基本类型 \n   // 输出 \"\"\n   console.log([].toString())\n   // 套用第2条， 将空字符串转换为数值、\n   // 输出 0\n   console.log(Number(\"\"))\n   // 所以\n   console.log(0 == 0)\n   ```\n\n3. 1. 比如 `null == undefined`\n   2. 如果非`number`与`number`比较，会将其转换为`number`\n   3. 如果比较的双方中由一方是`boolean`,那么会先将`boolean`转换为`number`\n\n4. 第四行代码\n\n   ```\n   // 输出 1\n   console.log(true + false)\n   ```\n\n   两个基本类型相加，如果其中一方是字符，则将其他的转换为字符相加，否则将类型转换为`Number`,然后相加, `Number(true)` 是`1`, `Number(false)`是`0`, 所以结果是 `1`\n\n>本文中的所有题目首发于公众号【前端有的玩】，小编每天都会整理一道两道面试题，然后推送给所有的朋友，关注小编，每天带你去刷面试题，不想当咸鱼，想要换工作，还在犹豫什么，关注 === 大厂offer。\n\n #### 结语\n > 不要吹灭你的灵感和你的想象力; 不要成为你的模型的奴隶。 ——文森特・梵高", "user_name": "前端进击者", "description": "技术日新月异，我愿紧随不舍。个人公众号【前端有的玩】", "got_view_count": 313529, "category_name": "前端", "ctime": 1457483942}
{"tag_name": "Spring Boot", "concern_user_count": 26072, "user_id": "4107431172378887", "title": "自己动手编写一个Mybatis插件：Mybatis脱敏插件", "mark_content": "![](https://asset.felord.cn/blog/20200810155526.jpg)\n\n## 1. 前言\n\n在日常开发中，身份证号、手机号、卡号、客户号等个人信息都需要进行数据脱敏。否则容易造成个人隐私泄露，客户资料泄露，给不法分子可乘之机。但是数据脱敏不是把敏感信息隐藏起来，而是看起来像真的一样，实际上不能是真的。我以前的公司就因为不重视脱敏，一名员工在离职的时候通过后台的导出功能导出了核心的客户资料卖给了竞品，给公司造成了重大的损失。当然这里有数据管理的原因，但是脱敏仍旧是不可忽略的一环，脱敏可以从一定程度上保证数据的合规使用。下面就是一份经过脱敏的数据：\n\n![脱敏之后的数据](https://asset.felord.cn/blog/20200809212703.png)\n\n## 2. Mybatis 脱敏插件\n\n最近在研究**Mybatis**的插件，所以考虑能不能在**ORM**中搞一搞脱敏，所以就尝试了一下，这里分享一下思路。借此也分享一下**Mybatis**插件开发的思路。\n\n### 2.1 Mybatis 插件接口\n\n**Mybatis**中使用插件，需要实现接口`org.apache.ibatis.plugin.Interceptor`，如下所示：\n\n```java\npublic interface Interceptor {\n\n  Object intercept(Invocation invocation) throws Throwable;\n\n  default Object plugin(Object target) {\n    return Plugin.wrap(target, this);\n  }\n\n  default void setProperties(Properties properties) {\n    // NOP\n  }\n\n}\n```\n\n这里其实最核心的是`Object intercept(Invocation invocation)`方法，这是我们需要实现的方法。\n\n### 2.2 Invocation 对象\n\n那么核心方法中的`Invocation `是个什么概念呢？\n\n```java\npublic class Invocation {\n\n  private final Object target;\n  private final Method method;\n  private final Object[] args;\n\n  public Invocation(Object target, Method method, Object[] args) {\n    this.target = target;\n    this.method = method;\n    this.args = args;\n  }\n\n  public Object getTarget() {\n    return target;\n  }\n\n  public Method getMethod() {\n    return method;\n  }\n\n  public Object[] getArgs() {\n    return args;\n  }\n\n  public Object proceed() throws InvocationTargetException, IllegalAccessException {\n    return method.invoke(target, args);\n  }\n\n}\n```\n\n这个东西包含了四个概念：\n\n- **target** 拦截的对象\n- **method** 拦截**target**中的具体方法，也就是说**Mybatis**插件的粒度是精确到方法级别的。\n- **args**  拦截到的参数。\n- **proceed** 执行被拦截到的方法，你可以在执行的前后做一些事情。\n\n### 2.3 拦截签名\n\n既然我们知道了**Mybatis**插件的粒度是精确到方法级别的，那么疑问来了，插件如何知道轮到它工作了呢？\n\n所以**Mybatis**设计了签名机制来解决这个问题，通过在插件接口上使用注解`@Intercepts`标注来解决这个问题。\n\n```java\n@Intercepts(@Signature(type = ResultSetHandler.class,\n        method = \"handleResultSets\",\n        args = {Statement.class}))\n```\n\n就像上面一样，事实上就等于配置了一个`Invocation`。\n\n### 2.4 插件的作用域\n\n那么问题又来了，**Mybatis**插件能拦截哪些对象,或者说插件能在哪个生命周期阶段起作用呢？它可以拦截以下四大对象：\n\n- **Executor** 是**SQL**执行器，包含了组装参数，组装结果集到返回值以及执行**SQL**的过程，粒度比较粗。\n- **StatementHandler** 用来处理SQL的执行过程，我们可以在这里重写**SQL**非常常用。\n- **ParameterHandler** 用来处理传入**SQL**的参数，我们可以重写参数的处理规则。\n- **ResultSetHandler** 用于处理结果集，我们可以重写结果集的组装规则。\n\n你需要做的就是明确的你的业务需要在上面四个对象的哪个处理阶段拦截处理即可。\n\n### 2.5 MetaObject\n\n**Mybatis**提供了一个工具类`org.apache.ibatis.reflection.MetaObject`。它通过反射来读取和修改一些重要对象的属性。我们可以利用它来处理四大对象的一些属性，这是**Mybatis**插件开发的一个常用工具类。\n\n- **Object getValue(String name)** 根据名称获取对象的属性值，支持**OGNL**表达式。\n- **void setValue(String name, Object value)** 设置某个属性的值。\n- **Class<?> getSetterType(String name)** 获取**setter**方法的入参类型。\n- **Class<?> getGetterType(String name)** 获取**getter**方法的返回值类型。\n\n通常我们使用`SystemMetaObject.forObject(Object object)`来实例化`MetaObject`对象。你会在接下来的实战DEMO中看到我使用它。\n\n## 3. Mybatis 脱敏插件实战\n\n接下来我就把开头的脱敏需求实现一下。首先需要对脱敏字段进行标记并确定使用的脱敏策略。\n\n编写脱敏函数：\n\n```java\n/**\n * 具体策略的函数\n * @author felord.cn\n * @since 11:24\n **/\npublic interface Desensitizer  extends Function<String,String>  {\n\n}\n```\n\n编写脱敏策略枚举：\n\n```java\n/**\n * 脱敏策略.\n *\n * @author felord.cn\n * @since 11 :25\n */\npublic enum SensitiveStrategy {\n    /**\n     * Username sensitive strategy.\n     */\n    USERNAME(s -> s.replaceAll(\"(\\\\S)\\\\S(\\\\S*)\", \"$1*$2\")),\n    /**\n     * Id card sensitive type.\n     */\n    ID_CARD(s -> s.replaceAll(\"(\\\\d{4})\\\\d{10}(\\\\w{4})\", \"$1****$2\")),\n    /**\n     * Phone sensitive type.\n     */\n    PHONE(s -> s.replaceAll(\"(\\\\d{3})\\\\d{4}(\\\\d{4})\", \"$1****$2\")),\n\n    /**\n     * Address sensitive type.\n     */\n    ADDRESS(s -> s.replaceAll(\"(\\\\S{8})\\\\S{4}(\\\\S*)\\\\S{4}\", \"$1****$2****\"));\n\n\n    private final Desensitizer desensitizer;\n\n    SensitiveStrategy(Desensitizer desensitizer) {\n        this.desensitizer = desensitizer;\n    }\n\n    /**\n     * Gets desensitizer.\n     *\n     * @return the desensitizer\n     */\n    public Desensitizer getDesensitizer() {\n        return desensitizer;\n    }\n}\n```\n\n编写脱敏字段的标记注解：\n\n```java\n@Retention(RetentionPolicy.RUNTIME)\n@Target(ElementType.FIELD)\npublic @interface Sensitive {\n    SensitiveStrategy strategy();\n}\n```\n\n我们的返回对象中如果某个字段需要脱敏，只需要通过标记就可以了。例如下面这样：\n\n```java\n@Data\npublic class UserInfo {\n\n    private static final long serialVersionUID = -8938650956516110149L;\n    private Long userId;\n    @Sensitive(strategy = SensitiveStrategy.USERNAME)\n    private String name;\n    private Integer age;\n}\n```\n\n\n\n然后就是编写插件了，我可以确定的是需要拦截的是`ResultSetHandler`对象的`handleResultSets`方法，我们只需要实现插件接口`Interceptor`并添加签名就可以了。全部逻辑如下：\n\n```java\n@Slf4j\n@Intercepts(@Signature(type = ResultSetHandler.class,\n        method = \"handleResultSets\",\n        args = {Statement.class}))\npublic class SensitivePlugin implements Interceptor {\n    @SuppressWarnings(\"unchecked\")\n    @Override\n    public Object intercept(Invocation invocation) throws Throwable {\n        List<Object> records = (List<Object>) invocation.proceed();\n        // 对结果集脱敏\n        records.forEach(this::sensitive);\n        return records;\n    }\n\n\n    private void sensitive(Object source) {\n        // 拿到返回值类型\n        Class<?> sourceClass = source.getClass();\n        // 初始化返回值类型的 MetaObject\n        MetaObject metaObject = SystemMetaObject.forObject(source);\n        // 捕捉到属性上的标记注解 @Sensitive 并进行对应的脱敏处理\n        Stream.of(sourceClass.getDeclaredFields())\n                .filter(field -> field.isAnnotationPresent(Sensitive.class))\n                .forEach(field -> doSensitive(metaObject, field));\n    }\n\n\n    private void doSensitive(MetaObject metaObject, Field field) {\n        // 拿到属性名\n        String name = field.getName();\n        // 获取属性值\n        Object value = metaObject.getValue(name);\n        // 只有字符串类型才能脱敏  而且不能为null\n        if (String.class == metaObject.getGetterType(name) && value != null) {\n            Sensitive annotation = field.getAnnotation(Sensitive.class);\n            // 获取对应的脱敏策略 并进行脱敏\n            SensitiveStrategy type = annotation.strategy();\n            Object o = type.getDesensitizer().apply((String) value);\n            // 把脱敏后的值塞回去\n            metaObject.setValue(name, o);\n        }\n    }\n}\n```\n\n然后配置脱敏插件使之生效：\n\n```java\n@Bean\npublic SensitivePlugin sensitivePlugin(){\n    return new SensitivePlugin();\n}\n```\n\n操作查询获得结果 `UserInfo(userId=123123, name=李*龙, age=28)` ，成功将指定字段进行了脱敏。\n\n> 补充一句，其实脱敏也可以在**JSON**序列化的时候进行。\n\n## 4. 总结\n\n今天对编写**Mybatis**插件的一些要点进行了说明，同时根据说明实现了一个脱敏插件。但是请注意一定要熟悉四大对象的生命周期，否则自写插件可能会造成意想不到的结果。插件可以关注微信公众号：**码农小胖哥** 回复关键字 **sensitive** 进行获取。如果你觉得有用请无情的点赞、再看、转发。\n\n`关注公众号：Felordcn获取更多资讯`\n\n[个人博客：https://felord.cn](https://felord.cn)", "user_name": "码农小胖哥", "description": "关注公众号：码农小胖哥", "got_view_count": 163507, "category_name": "后端", "ctime": 1457483880}
{"tag_name": "TypeScript", "concern_user_count": 37742, "user_id": "782508012077678", "title": "走近MidwayJS：初识TS装饰器与IoC机制", "mark_content": "\n\n## 前言\n\n很惭愧在阿里实习将近三个月没有一点文章产出，同期入职的 [炽翎](https://juejin.im/user/3122268753634541) 和 [炬透](https://juejin.im/user/2365804756090381) 都产出了不少优秀的文章，如[不想痛失薪资普调和年终奖？试试自动化测试！（基础篇）](https://juejin.im/post/6844904194600599560)，不禁感慨优秀的人都是有共同点的：善于总结沉淀，而且文笔还好（这点太羡慕了）。入职即将满三个月，也就是说我三个多月没写过文章了。文笔拙劣，还请见谅。\n\n本篇文章是 [MidwayJS ](https://github.com/midwayjs/midway)的系列推广文章第一篇，原本我打算直接一篇搞定，做个MidwayJS开发后台应用的教程就好了。但是在提笔前询问过一些同学，发现即使是已经有工作经验的前端同学中也有一部分没有了解过TS装饰器相关的知识，对于IoC机制也知之甚少（虽然没学过Java的我同样只是一知半解），因此这篇文章会首先讲解**IoC机制（依赖注入）**与**TS装饰器**相关的知识，力求内容不枯燥，并使各位成功的对MidwayJS来电~\n\n\n\n## MidwayJS简介\n\n> MidwayJS目前已经升级到Midway-Serverless体系，这可能会给没接触过Serverless、只是想学习框架本身的你带来一些困扰。你可以先阅读其[框架本身文档](https://midwayjs.org/midway/)，来只体验框架本身作为后端应用的能力。\n\n你可能没有听过`Egg`，但你一定听过或者使用过`Koa`/`Express`，`Egg`基于`Koa`并在其能力上做了增强，奉行**【约定优于配置】**，同时它又能作为一款定制能力强的基础框架，来使得你能基于自己的技术架构封装出一套适合自己业务场景的框架。`MidwayJS`正是基于`Egg`，但在`Egg`的基础上做了一些较大的变动：\n\n- 更好的TS支持，可以说写MidwayJS比较舒服的一个地方就是它的**TypeScript支持**了，比如会作为服务的接口定义会单独存放于`interface`, 提供的能力强大的装饰器，与TypeORM这种TS支持好的框架协作起来更是愉悦。\n\n- IoC机制的路由，以我们下篇文章将要实现的接口为例：\n\n  ```typescript\n  @provide()\n  @controller('/user')\n  export class UserController {\n  \n    @get('/all')\n    async getUser(): Promise<void> {\n      // ...\n    }\n  \n    @get('/uid/:uid')\n    async findUserByUid(): Promise<void> {\n      // ...\n    }\n  \n    @post('/uid/:uid')\n    async updateUser(): Promise<void> {\n      // ...\n    }\n    \n    // ...\n  \n  }\n  ```\n\n  （Midway同时保留了Egg的路由能力，即`src/app/router.ts`的路由配置方式）\n\n  这里是否会让你想到`NestJS`？的确在路由这里二者的思想基本是相同的，但Midway的IoC机制底层基于 [Injection]([https://midwayjs.org/injection/guide.html#%E8%8E%B7%E5%8F%96-ioc-%E5%AE%B9%E5%99%A8](https://midwayjs.org/injection/guide.html#获取-ioc-容器))，同样是Midway团队的作品。并且，Midway的IoC机制也是`Midway-Serverless`能力的重要支持（这个我们下篇文章才会讲到）。\n\n- 生态复用，Egg与Koa的中间件大部分能在Midway应用中完美兼容,少部分暂不支持的也由官方团队在快速兼容。\n\n- 稳定支持，MidwayJS至今仍在快速发展迭代，同时也在阿里内部作为Serverless基建的重要成员而受到相当的重视，所以你不用担心它后续的维护情况。\n\n\n\n下面的部分里，我们会讲解这些东西：\n\n- **TS装饰器 基本语法、类型**\n- **Reflect 元编程**\n- **IoC机制与依赖注入（Dependence Injection）**\n- **实现简单的基于IoC的路由**\n- **常用依赖注入工具库**\n\n\n\n## TS 装饰器\n\n### TS装饰器的那些事儿\n首先我们需要知道，JS与TS中的装饰器不是一回事，JS中的装饰器目前依然停留在 [stage 2](https://github.com/tc39/proposal-decorators) 阶段，并且目前版本的草案与TS中的实现差异相当之大（TS是基于第一版，JS目前已经第三版了），所以二者最终的装饰器实现必然有非常大的差异。\n\n其次，装饰器不是TS所提供的特性（如类型、接口），而是TS实现的ECMAScript提案（就像类的私有成员一样）。TS实际上只会对**stage-3**以上的语言提供支持，比如TS3.7.5引入了可选链（[Optional chaining](https://github.com/tc39/proposal-optional-chaining)）与空值合并（[Nullish-Coalescing](https://github.com/tc39/proposal-nullish-coalescing)）。而当TS引入装饰器时（大约在15年左右），JS中的装饰器依然处于**stage-1**\n\n阶段。其原因是TS与Angular团队PY成功了，Ng团队不再维护 [AtScript]([atscript-playground](https://github.com/angular/atscript-playground))，而TS引入了注解语法（**Annotation**）及相关特性。\n\n但是并不需要担心，即使装饰器永远到达不了stage-3/4阶段，它也不会消失的。有相当多的框架都是装饰器的重度用户，如`Angular`、`Nest`、`Midway`等。对于装饰器的实现与编译结果会始终保留，就像`JSX`一样。如果你对它的历史与发展方向有兴趣，可以读一读 [是否应该在production里使用typescript的decorator？](https://www.zhihu.com/question/404724504)（贺师俊贺老的回答）\n\n\n\n为什么我们需要装饰器？在后面的例子中我们会体会到装饰器的强大与魅力，基于装饰器我们能够**快速优雅的复用逻辑**，**提供注释一般的解释说明效果**，以及**对业务代码进行能力增强**。同时我们本文的重点：**依赖注入**也可以通过装饰器来非常简洁的实现。现在我们可能暂时体会不到 **强大**、**简洁** 这些关键词，不急，安心读下去。我会尝试通过这篇文章让你对TS装饰器整体建立起一个认知，并在日常开发里也爱上使用装饰器。\n\n\n\n### 装饰器与注解\n\n> **由于我本身并没学习过Java以及Spring IoC，因此我的理解可能存在一些偏差，还请在评论区指出错误之处~**\n\n装饰器与注解实际上也有一定区别，由于并没有学过Java，这里就不与Java中的注解进行比较了。而只是说我所认为的二者差异：\n\n- **注解** 应该如同字面意义一样， 只是为某个被注解的对象提供元数据（`metadata`）的注入，本质上不能起到任何修改行为的操作，需要`scanner`去进行扫描获得元数据并基于其去执行操作，注解的元数据才有实际意义。\n- **装饰器** 没法添加元数据，只能基于已经由注解注入的元数据来执行操作，来对类、方法、属性、参数进行某种特定的操作。\n\n但实际上，TS中的装饰器通常是同时包含了这两种效能的，它可能消费元数据的同时也提供了元数据供别的装饰器消费。\n\n\n\n### 不同类型的装饰器及使用\n\n> 在开始前，你需要确保在`tsconfig.json`中设置了`experimentalDecorators`与`emitDecoratorMetadata`为true。\n\n首先要明确地是，TS中的装饰器实现本质是一个语法糖，它的本质是一个函数，如果调用形式为`@deco()`，那么这个函数应该再返回一个函数来实现调用。\n\n其次，你应该明白ES6中class的实质，如果不明白，推荐阅读我的这篇文章: [从Babel编译结果看ES6的Class实质](https://linbudu.top/posts/2020/03/25/babel-class.html)\n\n#### 类装饰器\n\n```ts\nfunction addProp(constructor: Function) {\n  constructor.prototype.job = 'fe';\n}\n\n@addProp\nclass P {\n  job: string;\n  constructor(public name: string) {}\n}\n\nlet p = new P('林不渡');\n\nconsole.log(p.job); // fe\n```\n\n我们发现，在以单纯装饰器方式`@addProp`调用时，不管用它来装饰哪个类，起到的作用都是相同的，因为其中要复用的逻辑是固定的。我们试试以`@addProp()`的方式来调用：\n\n```typescript\nfunction addProp(param: string): ClassDecorator {\n  return (constructor: Function) => {\n    constructor.prototype.job = param;\n  };\n}\n\n@addProp('fe+be')\nclass P {\n  job: string;\n  constructor(public name: string) {}\n}\n\nlet p = new P('林不渡');\n\nconsole.log(p.job); // fe+be\n```\n\n现在我们想要添加的属性值就可以由我们决定了, 实际上由于我们拿到了原型对象，还可以进行花式操作，能够解锁更多神秘姿势~\n\n\n\n#### 方法装饰器\n\n 方法装饰器的入参为 **类的原型对象**  **属性名** 以及**属性描述符(descriptor)**，其属性描述符包含`writable` `enumerable` `configurable` ，我们可以在这里去配置其相关信息。\n\n> 注意，对于静态成员来说，首个参数会是类的构造函数。而对于实例成员（比如下面的例子），则是类的原型对象\n\n```ts\nfunction addProps(): MethodDecorator {\n  return (target, propertyKey, descriptor) => {\n    console.log(target);\n    console.log(propertyKey);\n    console.log(JSON.stringify(descriptor));\n\n    descriptor.writable = false;\n  };\n}\n\nclass A {\n  @addProps()\n  originMethod() {\n    console.log(\"I'm Original!\");\n  }\n}\n\nconst a = new A();\n\na.originMethod = () => {\n  console.log(\"I'm Changed!\");\n};\n\na.originMethod();// I'm Changed!\n```\n\n你是否觉得有点想起来`Object.defineProperty()`？ 的确方法装饰器也是借助它来修改类和方法的属性的，你可以去[TypeScript Playground](https://www.typescriptlang.org/play)看看TS对上面代码的编译结果。\n\n\n\n#### 属性装饰器\n\n类似于方法装饰器，但它的入参少了属性描述符。原因则是目前没有方法在定义原型对象成员同时去描述一个实例的属性（创建描述符）。\n\n```typescript\nfunction addProps(): PropertyDecorator {\n  return (target, propertyKey) => {\n    console.log(target);\n    console.log(propertyKey);\n  };\n}\n\nclass A {\n  @addProps()\n  originProps: any;\n}\n```\n\n属性与方法装饰器有一个重要作用是注入与提取元数据，这点我们在后面会体现到。\n\n\n\n#### 参数装饰器\n\n参数装饰器的入参首要两位与属性装饰器相同，第三个参数则是参数在当前函数参数中的**索引**。\n\n```ts\nfunction paramDeco(params?: any): ParameterDecorator {\n  return (target, propertyKey, index) => {\n    console.log(target);\n    console.log(propertyKey);\n    console.log(index);\n    target.constructor.prototype.fromParamDeco = '呀呼！';\n  };\n}\n\nclass B {\n  someMethod(@paramDeco() param1: any, @paramDeco() param2: any) {\n    console.log(`${param1}  ${param2}`);\n  }\n}\n\nnew B().someMethod('啊哈', '林不渡！');\n// @ts-ignore\nconsole.log(B.prototype.fromParamDeco);\n\n```\n\n参数装饰器与属性装饰器都有个特别之处，他们都不能获取到描述符descriptor，因此也就不能去修改其参数/属性的行为。但是我们可以这么做：**给类原型添加某个属性，携带上与参数/属性/装饰器相关的元数据，并由下一个执行的装饰器来读取。**(装饰器的执行顺序请参见下一节)\n\n当然像例子中这样直接在原型上添加属性的方式是十分不推荐的，后面我们会使用ES7的`Reflect Metadata`来进行元数据的读/写。\n\n\n\n### 装饰器工厂\n\n假设现在我们同时需要四种装饰器，你会怎么做？定义四种装饰器然后分别使用吗？也行，但后续你看着这一堆装饰器可能会感觉有点头疼...，因此我们可以考虑接入工厂模式，使用一个装饰器工厂来为我们根据条件吐出不同的装饰器。\n\n\n\n首先我们准备好各个装饰器函数：\n\n（不建议把功能也写在装饰器工厂中，会造成耦合）\n\n```ts\n// @ts-nocheck\n\nfunction classDeco(): ClassDecorator {\n  return (target: Object) => {\n    console.log('Class Decorator Invoked');\n    console.log(target);\n  };\n}\n\nfunction propDeco(): PropertyDecorator {\n  return (target: Object, propertyKey: string) => {\n    console.log('Property Decorator Invoked');\n    console.log(propertyKey);\n  };\n}\n\nfunction methodDeco(): MethodDecorator {\n  return (\n    target: Object,\n    propertyKey: string,\n    descriptor: PropertyDescriptor\n  ) => {\n    console.log('Method Decorator Invoked');\n    console.log(propertyKey);\n  };\n}\n\nfunction paramDeco(): ParameterDecorator {\n  return (target: Object, propertyKey: string, index: number) => {\n    console.log('Param Decorator Invoked');\n    console.log(propertyKey);\n    console.log(index);\n  };\n}\n```\n\n \n\n接着，我们实现一个工厂函数来根据不同条件返回不同的装饰器：\n\n```typescript\nenum DecoratorType {\n  CLASS = 'CLASS',\n  METHOD = 'METHOD',\n  PROPERTY = 'PROPERTY',\n  PARAM = 'PARAM',\n}\n\ntype FactoryReturnType =\n  | ClassDecorator\n  | MethodDecorator\n  | PropertyDecorator\n  | ParameterDecorator;\n\nfunction decoFactory(type: DecoratorType, ...args: any[]): FactoryReturnType {\n  switch (type) {\n    case DecoratorType.CLASS:\n      return classDeco.apply(this, args);\n\n    case DecoratorType.METHOD:\n      return methodDeco.apply(this, args);\n\n    case DecoratorType.PROPERTY:\n      return propDeco.apply(this, args);\n\n    case DecoratorType.PARAM:\n      return paramDeco.apply(this, args);\n\n    default:\n      throw new Error('Invalid DecoratorType');\n  }\n}\n\n@decoFactory(DecoratorType.CLASS)\nclass C {\n  @decoFactory(DecoratorType.PROPERTY)\n  prop: any;\n\n  @decoFactory(DecoratorType.METHOD)\n  method(@decoFactory(DecoratorType.PARAM) param: string) {}\n}\n\nnew C().method();\n```\n\n（注意，这里在TS类型定义上似乎有些问题，所以需要带上顶部的`@ts-nocheck`，在后续解决了类型报错后，我会及时更新的TAT）\n\n\n\n### 多个装饰器声明\n\n> 装饰器求值顺序来自于TypeScript官方文档一节中的装饰器说明。\n\n 类中不同声明上的装饰器将按以下规定的顺序应用：\n\n 1. *参数装饰器*，然后依次是*方法装饰器*，*访问符装饰器*，或*属性装饰器*应用到每个实例成员。\n 2. *参数装饰器*，然后依次是*方法装饰器*，*访问符装饰器*，或*属性装饰器*应用到每个静态成员。\n 3. *参数装饰器*应用到构造函数。\n 4. *类装饰器*应用到类。\n\n\n\n注意这个顺序，后面我们能够实现元数据读写，也正是因为这个顺序。\n\n\n\n当存在多个装饰器来装饰同一个声明时，则会有以下的顺序：\n\n- 首先，由上至下依次对装饰器表达式求值，得到返回的真实函数（如果有的话）\n- 而后，求值的结果会由下至上依次调用\n\n（有点类似洋葱模型）\n\n\n\n```ts\nfunction foo() {\n    console.log(\"foo in\");\n    return function (target, propertyKey: string, descriptor: PropertyDescriptor) {\n        console.log(\"foo out\");\n    }\n}\n\nfunction bar() {\n    console.log(\"bar in\");\n    return function (target, propertyKey: string, descriptor: PropertyDescriptor) {\n        console.log(\"bar out\");\n    }\n}\n\nclass A {\n    @foo()\n    @bar()\n    method() {}\n}\n\n// foo in\n// bar in\n// bar out\n// foo out\n```\n\n\n\n## Reflect Metadata\n\n### 基本元数据读写\n\n`Reflect Metadata`是属于ES7的一个提案，其主要作用是在声明时去读写元数据。TS早在1.5+版本就已经支持反射元数据的使用，目前想要使用，我们还需要安装`reflect-metadata`与在`tsconfig.json`中启用`emitDecoratorMetadata`选项。\n\n\n\n你可以将元数据理解为用于描述数据的数据，如某个对象的键、键值、类型等等就可称之为该对象的元数据。我们先不用太在意元数据定义的位置，先做一个简单的阐述：\n\n*为类或类属性添加了元数据后，构造函数的原型（或是构造函数，根据静态成员还是实例成员决定）会具有`[[Metadata]]`属性，该属性内部包含一个**Map**结构，**键为属性键，值为元数据键值对**。*\n\n`reflect-metadata`提供了对Reflect对象的扩展，在引入后，我们可以直接从`Reflect`对象上获取扩展方法。\n\n> 文档见 [reflect-metadata](https://github.com/rbuckton/reflect-metadata)，但不用急着看，其API命令还是很语义化的\n\n```ts\nimport 'reflect-metadata';\n\n@Reflect.metadata('className', 'D')\nclass D {\n  @Reflect.metadata('methodName', 'hello')\n  public hello(): string {\n    return 'hello world';\n  }\n}\n\nconst d = new D();\nconsole.log(Reflect.getMetadata('className', D));\nconsole.log(Reflect.getMetadata('methodName', d));\n\n```\n\n可以看到，我们给类D与D内部的方法hello都注入了元数据，并通过`getMetadata(metadataKey, target)`这个方式取出了存放的元数据。\n\n> Reflect-metadata支持命令式(`Reflect.defineMetadata`)与声明式（上面的装饰器方式）的元数据定义\n\n\n\n我们注意到，注入在类上的元数据在取出时target为这个类D，而注入在方法上的元数据在取出时target则为实例d。原因其实我们实际上在上面的装饰器执行顺序提到了，这是由于**注入在方法、属性、参数上的元数据实际上是被添加在了实例对应的位置上，因此需要实例化才能取出。**\n\n\n\n### 内置元数据\n\nReflect允许程序去检视自身，基于这个效果，我们可以在装饰器运行时去检查其类型相关信息，如目标类型、目标参数的类型以及方法返回值的类型，这需要借助TS内置的**元数据metadataKey**来实现，以一个检查入参的例子为例：\n\n> 访问符装饰器的属性描述符会额外拥有`get`与`set`方法，其他与属性装饰器相同\n\n```typescript\nimport 'reflect-metadata';\n\nclass Point {\n  x: number;\n  y: number;\n}\n\nclass Line {\n  private _p0: Point;\n  private _p1: Point;\n\n  @validate\n  set p0(value: Point) {\n    this._p0 = value;\n  }\n  get p0() {\n    return this._p0;\n  }\n\n  @validate\n  set p1(value: Point) {\n    this._p1 = value;\n  }\n  get p1() {\n    return this._p1;\n  }\n}\n\nfunction validate<T>(\n  target: any,\n  propertyKey: string,\n  descriptor: TypedPropertyDescriptor<T>\n) {\n  let set = descriptor.set!;\n  descriptor.set = function (value: T) {\n    let type = Reflect.getMetadata('design:type', target, propertyKey);\n    if (!(value instanceof type)) {\n      throw new TypeError('Invalid type.');\n    }\n    set(value);\n  };\n}\n```\n\n> 这个例子来自于TypeScript官方文档，但实际上不能正常执行。因为在经过装饰器处理后，set方法的this将会丢失。但我猜想官方的用意只是展示`design:type`的用法。\n\n在这个例子中，我们基于`Reflect.getMetadata('design:type', target, propertyKey);`获取到了装饰器对应声明的属性类型，并确保在`setter`被调用时检查值类型。\n\n这里的 `design:type` 即是TS的内置元数据，你可以理解为TS在编译前还手动执行了`@Reflect.metadata(\"design:type\", Point)`。TS还内置了**`design:paramtypes`（获取目标参数类型）**与**`design:returntype`（获取方法返回值类型）**这两种元数据字段来提供帮助。但有一点需要注意，**即使对于基本类型，这些元数据也返回对应的包装类型，如`number` -> `[Function: Number]`**\n\n\n\n## IoC\n\n### IoC、依赖注入、容器\n\nIoC的全称为 **Inversion of Control**，意为**控制反转**，它是OOP中的一种原则（虽然不在n大设计模式中，但实际上IoC也属于一种设计模式），它可以很好的解耦代码。\n\n在不使用IoC的情况下，我们很容易写出来这样的代码：\n\n```typescript\nimport { A } from './modA';\nimport { B } from './modB';\n\nclass C {\n  constructor() {\n    this.a = new A();\n    this.b = new B();\n  }\n}\n```\n\n乍一看可能没什么，但实际上类C会强依赖于A、B，造成模块之间的耦合。要解决这个问题，我们可以这么做：用一个第三方容器来负责管理容器，当我们需要某个实例时，由这个容器来替我们实例化并交给我们实例。以`Injcetion`为例：\n\n```typescript\nimport { Container } from 'injection';\nimport { A } from './A';\nimport { B } from './B';\nconst container = new Container();\ncontainer.bind(A);\ncontainer.bind(B);\n\nclass C {\n  constructor() {\n    this.a = container.get('a');\n    this.b = container.get('b');\n  }\n}\n```\n\n现在A、B、C之间没有了耦合，甚至当某个类D需要使用C的实例时，我们也可以把C交给IoC容器。\n\n我们现在能够知道IoC容器大概的作用了：容器内部维护着一个对象池，管理着各个对象实例，当用户需要使用实例时，容器会自动将对象实例化交给用户。\n\n再举个栗子，当我们想要处对象时，会上Soul、Summer、陌陌...等等去一个个找，找哪种的与怎么找是由我自己决定的，这叫 **控制正转**。现在我觉得有点麻烦，直接把自己的介绍上传到世纪佳缘，如果有人看上我了，就会主动向我发起聊天，这叫 **控制反转**。\n\nDI的全称为**Dependency Injection**，即**依赖注入**。依赖注入是控制反转最常见的一种应用方式，就如它的名字一样，它的思路就是在对象创建时自动注入依赖对象。再以`Injection`的使用为例：\n\n```typescript\n// provide意为当前对象需要被绑定到容器中\n// inject意为去容器中取出对应的实例注入到当前属性中\n@provide()\nexport class UserService {\n \n  @inject()\n  userModel;\n\n  async getUser(userId) {\n    return await this.userModel.get(userId);\n  }\n}\n```\n\n我们不需要在构造函数中去手动`this.userModel = xxx`了，容器会自动帮我们做这一步。\n\n\n\n### 实例: 基于IoC的路由简易实现\n\n我们在最开始介绍了MidwayJS的路由机制，大概长这样：\n\n```typescript\n@provide()\n@controller('/user')\nexport class UserController {\n\n  @get('/all')\n  async getUser(): Promise<void> {\n    // ...\n  }\n\n  @get('/uid/:uid')\n  async findUserByUid(): Promise<void> {\n    // ...\n  }\n\n  @post('/uid/:uid')\n  async updateUser(): Promise<void> {\n    // ...\n  }\n}\n```\n\n（`@provide()`来自于底层的IoC支持`Injection`，Midway在应用启动时会去扫描被`@provide()`装饰的对象，并装载到容器中，这里不是重点，可以暂且跳过，我们主要关注如何**将装饰器路由解析成路由表**的形式）\n\n我们要解析的路由如下：\n\n```typescript\n@controller('/user')\nexport class UserController {\n  @get('/all')\n  async getAllUser(): Promise<void> {\n    // ...\n  }\n\n  @post('/update')\n  async updateUser(): Promise<void> {\n    // ...\n  }\n}\n```\n\n首先思考`controller`和`get`/`post`装饰器，我们需要使用这几个装饰器注入哪些信息：\n\n- **路径**\n- **方法（方法装饰器）**\n\n首先是对于整个类，我们需要将`path: \"/user\"`这个数据注入：\n\n```typescript\n// 工具常量枚举\nexport enum METADATA_MAP {\n  METHOD = 'method',\n  PATH = 'path',\n  GET = 'get',\n  POST = 'post',\n  MIDDLEWARE = 'middleware',\n}\n\nconst { METHOD, PATH, GET, POST } = METADATA_MAP;\n\nexport const controller = (path: string): ClassDecorator => {\n  return (target) => {\n    Reflect.defineMetadata(PATH, path, target);\n  };\n};\n```\n\n而后是方法装饰器，我们选择一个高阶函数（柯里化）去吐出各个方法的装饰器，而不是为每种方法定义一个。\n\n```typescript\n// 方法装饰器 保存方法与路径\nexport const methodDecoCreator = (method: string) => {\n  return (path: string): MethodDecorator => {\n    return (_target, _key, descriptor) => {\n      Reflect.defineMetadata(METHOD, method, descriptor.value!);\n      Reflect.defineMetadata(PATH, path, descriptor.value!);\n    };\n  };\n};\n\n// 首先确定方法，而后在使用时才去确定路径\nconst get = methodDecoCreator(GET);\nconst post = methodDecoCreator(POST);\n```\n\n接下来我们要做的事情就很简单了：\n\n- 拿到注入在类上元数据的根路径\n- 拿到每个方法上元数据的方法、路径\n- 拼接，生成路由表\n\n```typescript\nconst routeGenerator = (ins: Object) => {\n  const prototype = Object.getPrototypeOf(ins);\n\n  const rootPath = Reflect.getMetadata(PATH, prototype['constructor']);\n\n  const methods = Object.getOwnPropertyNames(prototype).filter(\n    (item) => item !== 'constructor'\n  );\n\n  const routeGroup = methods.map((methodName) => {\n    const methodBody = prototype[methodName];\n\n    const path = Reflect.getMetadata(PATH, methodBody);\n    const method = Reflect.getMetadata(METHOD, methodBody);\n    return {\n      path: `${rootPath}${path}`,\n      method,\n      methodName,\n      methodBody,\n    };\n  });\n  console.log(routeGroup);\n  return routeGroup;\n};\n```\n\n生成的结果大概是这样：\n\n```typescript\n[\n  {\n    path: '/user/all',\n    method: 'post',\n    methodName: 'getAllUser',\n    methodBody: [Function (anonymous)]\n  },\n  {\n    path: '/user/update',\n    method: 'get',\n    methodName: 'updateUser',\n    methodBody: [Function (anonymous)]\n  }\n]\n```\n\n基于这种思路，我们可以很容易的写一个使Koa支持IoC路由的工具。如果你有兴趣，不妨扩展一下。比如说路由还有可能长这样：\n\n```typescript\n@controller('/user', { middleware:[mw1, mw2, ...] })\nexport class UserController {\n  @get('/all', { middleware:[mw11, mw22, ...] })\n  async getAllUser(): Promise<void> {\n    // ...\n  }\n\n  @get('/:uid')\n    async getUser(): Promise<void> {\n      // ...\n    }\n\n  @post('/update')\n  async updateUser(): Promise<void> {\n    // ...\n  }\n}\n```\n\n新增了几个地方：\n\n- 全局中间件\n- 路由级别中间件\n- 路由传参\n\n要不要试试整活？\n\n\n\n这个例子是否属于IoC机制的体现可能会有争议，但我个人认为`Reflect Metadata`的设计本身就是IoC的体现。如果你有别的看法，欢迎在评论区告知我。\n\n\n\n### 依赖注入工具库\n\n我个人了解并使用过的TS依赖注入工具库包括：\n\n- [TypeDI](https://github.com/typestack/typedi)，TypeStack出品\n- [TSYringe](https://github.com/microsoft/tsyringe)，微软出品\n- [Injection](https://github.com/midwayjs/injection)，MidwayJS团队出品，是MidwayJS底层IoC的能力支持\n\n其中`TypeDI`也是我日常使用较多的一个，如果你使用基本的Koa开发项目，不妨试一试`TypeORM` + `TypeORM-TypeDI-Extensions `。我们再看看上面呈现过的`Injection`的例子：\n\n```typescript\n@provide()\nexport class UserService {\n \n  @inject()\n  userModel;\n\n  async getUser(userId) {\n    return await this.userModel.get(userId);\n  }\n}\n```\n\n实际上，一个依赖注入工具库必定会提供的就是 **从容器中获取实例** 与 **注入对象到容器中**的两个方法，如上面的`provide`与`inject`，TypeDI的`Service`与`Inject`。\n\n\n\n## 总结\n\n读完这篇文章，我想你应该对TypeScript中的装饰器与IoC机制有了大概的了解，如果你意犹未尽，不妨去看一下TypeScript对装饰器、反射元数据的编译结果，见[TypeScript Playground](https://www.typescriptlang.org/play)。或者，如果你想早点开始了解MidwayJS，在阅读[文档](https://midwayjs.org/midway/)的基础上，你也可以瞅瞅我写的这个简单的Demo：[Midway-Article-Demo](https://github.com/linbudu599/Midway-Article-Demo)，基于 `Midway` + `TypeORM` + `SQLite3`，但请注意仍处于雏形，许多Midway的强大能力尚未得到体现，所以不要以这个Demo判定Midway的能力，我会尽快完善这个Demo的。\n\n下一篇，我们会讲解Midway的基础能力，以及对Midway-Serverless：阿里巴巴淘系技术部面对Serverless交出的其中一份答卷的展望。本篇内容可能还是有些枯燥，下一篇我们就会进入欢乐的实战环节啦~\n\n\n\n", "user_name": "林不渡", "description": "前端", "got_view_count": 1956, "category_name": "前端", "ctime": 1457483942}
{"tag_name": "面试", "concern_user_count": 285352, "user_id": "1451011080727639", "title": "Java程序员面试必备：Volatile全方位解析", "mark_content": "### 前言\nvolatile是Java程序员必备的基础，也是面试官非常喜欢问的一个话题，本文跟大家一起开启vlatile学习之旅，如果有不正确的地方，也麻烦大家指出哈，一起相互学习~\n\n- 1.volatile的用法\n- 2.vlatile变量的作用\n- 3.现代计算机的内存模型（计算机模型，总线，MESI协议，嗅探技术）\n- 4.Java内存模型（JMM）\n- 5.并发编程的3个特性（原子性、可见性、有序性、happen-before、as-if-serial、指令重排）\n- 6.volatile的底层原理（如何保证可见性，如何保证指令重排，内存屏障）\n- 7.volatile的典型场景（状态标志，DCL单例模式）\n- 8.volatile常见面试题&&答案解析\n- 公众号：捡田螺的小男孩\n\n**github 地址**\n> https://github.com/whx123/JavaHome\n\n### 1.volatile的用法\nvolatile关键字是Java虚拟机提供的的**最轻量级的同步机制**，它作为一个修饰符出现，用来**修饰变量**，但是这里不包括局部变量哦。我们来看个demo吧，代码如下:\n```\n/**\n *  @Author 捡田螺的小男孩\n *  @Date 2020/08/02\n *  @Desc volatile的可见性探索\n */\npublic class VolatileTest  {\n\n    public static void main(String[] args) throws InterruptedException {\n        Task task = new Task();\n\n        Thread t1 = new Thread(task, \"线程t1\");\n        Thread t2 = new Thread(new Runnable() {\n            @Override\n            public void run() {\n                try {\n                    Thread.sleep(1000);\n                    System.out.println(\"开始通知线程停止\");\n                    task.stop = true; //修改stop变量值。\n                } catch (InterruptedException e) {\n                    e.printStackTrace();\n                }\n\n            }\n        }, \"线程t2\");\n        t1.start();  //开启线程t1\n        t2.start();  //开启线程t2\n        Thread.sleep(1000);\n    }\n}\n\nclass Task implements Runnable {\n    boolean stop = false;\n    int i = 0;\n\n    @Override\n    public void run() {\n        long s = System.currentTimeMillis();\n        while (!stop) {\n            i++;\n        }\n        System.out.println(\"线程退出\" + (System.currentTimeMillis() - s));\n    }\n}\n```\n**运行结果：**\n![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/057e2eec568a40fe9f47e05f3b47bdb7~tplv-k3u1fbpfcp-zoom-1.image)\n可以发现线程t2，虽然把stop设置为true了，但是线程t1对t2的**stop变量视而不可见**，因此，它一直在死循环running中。如果给变量stop加上volatile修饰，线程t1是可以停下来的,运行结果如下：\n```\nvolatile boolean stop = false;\n```\n![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/81326a66e9cc4350af71b0e9ff4dc304~tplv-k3u1fbpfcp-zoom-1.image)\n\n\n### 2. vlatile修饰变量的作用\n\n从以上例子，我们可以发现变量stop，加了vlatile修饰之后，线程t1对stop就可见了。其实，vlatile的作用就是：**保证变量对所有线程可见性**。当然，vlatile还有个作用就是，**禁止指令重排**，但是它**不保证原子性**。\n![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b5177218cf2b491da99d43392c7bd271~tplv-k3u1fbpfcp-zoom-1.image)\n\n所以当面试官问你**volatile的作用或者特性**，都可以这么回答：\n- 保证变量对所有线程可见性;\n- 禁止指令重排序\n- 不保证原子性\n\n### 3. 现代计算机的内存模型（计算机模型，MESI协议，嗅探技术，总线）\n为了更好理解volatile，先回顾一下计算机的内存模型与JMM（Java内存模型）吧~\n\n#### 计算机模型\n计算机执行程序时，指令是由CPU处理器执行的，而打交道的数据是在主内存当中的。\n\n由于计算机的存储设备与处理器的运算速度有几个数量级的差距，总不能每次CPU执行完指令，然后等主内存慢悠悠存取数据吧，\n所以现代计算机系统加入一层读写速度接近处理器运算速度的高速缓存（Cache），以作为来作为内存与处理器之间的缓冲。\n\n在多路处理器系统中，每个处理器都有自己的高速缓存，而它们共享同一主内存。**计算机抽象内存模型**如下：\n\n![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f995fb284a7241b9b95431e79a1c37b0~tplv-k3u1fbpfcp-zoom-1.image)\n\n- 程序执行时，把需要用到的数据，从主内存拷贝一份到高速缓存。\n- CPU处理器计算时，从它的高速缓存中读取，把计算完的数据写入高速缓存。\n- 当程序运算结束，把高速缓存的数据刷新会主内存。\n\n随着科学技术的发展，为了效率，高速缓存又衍生出一级缓存（L1），二级缓存（L2），甚至三级缓存(L3);\n![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/05fa9ff22d7f42ae82122bfc6c233bd9~tplv-k3u1fbpfcp-zoom-1.image)\n\n当多个处理器的运算任务都涉及同一块主内存区域，可能导致**缓存数据不一致**问题。如何解决这个问题呢？有两种方案\n\n> - 1、通过在总线加LOCK#锁的方式。\n> - 2、通过缓存一致性协议（Cache Coherence Protocol）\n\n#### 总线\n\n> 总线（Bus）是计算机各种功能部件之间传送信息的公共通信干线，它是由导线组成的传输线束， 按照计算机所传输的信息种类，计算机的总线可以划分为数据总线、地址总线和控制总线，分别用来传输数据、数据地址和控制信号。\n\nCPU和其他功能部件是通过总线通信的，如果在总线加LOCK#锁，那么在锁住总线期间，其他CPU是无法访问内存，这样一来，**效率就比较低了**。\n\n#### MESI协议\n为了解决一致性问题，还可以通过缓存一致性协议。即各个处理器访问缓存时都遵循一些协议，在读写时要根据协议来进行操作，这类协议有MSI、MESI（IllinoisProtocol）、MOSI、Synapse、Firefly及DragonProtocol等。比较著名的就是Intel的MESI（Modified Exclusive Shared Or Invalid）协议，它的核心思想是：\n\n >  当CPU写数据时，如果发现操作的变量是共享变量，即在其他CPU中也存在该变量的副本，会发出信号通知其他CPU将该变量的缓存行置为无效状态，因此当其他CPU需要读取这个变量时，发现自己缓存中缓存该变量的缓存行是无效的，那么它就会从内存重新读取。\n\nCPU中每个缓存行标记的4种状态（M、E、S、I）,也了解一下吧:\n\n| 缓存状态 | 描述 |\n|-----|-----|\n|  M，被修改（Modified) | 该缓存行只被该CPU缓存，与主存的值不同，会在它被其他CPU读取之前写入内存，并设置为Shared  | \n| E，独享的（Exclusive) | 该缓存行只被该CPU缓存，与主存的值相同，被其他CPU读取时置为Shared，被其他CPU写时置为Modified  | \n| S，共享的（Shared) | 该缓存行可能被多个CPU缓存，各个缓存中的数据与主存数据相同| \n| I，无效的（Invalid） | 该缓存行数据是无效，需要时需重新从主存载入 | \n\n\nMESI协议是如何实现的？如何保证当前处理器的内部缓存、主内存和其他处理器的缓存数据在总线上保持一致的？**多处理器总线嗅探**\n\n#### 嗅探技术\n> 在多处理器下，为了保证各个处理器的缓存是一致的，就会实现缓存缓存一致性协议，每个处理器通过嗅探在总线上传播的数据来检查自己的缓存值是不是过期了，如果处理器发现自己缓存行对应的内存地址被修改，就会将当前处理器的缓存行设置无效状态，当处理器对这个数据进行修改操作的时候，会重新从系统内存中把数据库读到处理器缓存中。\n\n### 4. Java内存模型（JMM）\n\n- Java虚拟机规范试图定义一种Java内存模型,来**屏蔽掉各种硬件和操作系统的内存访问差异**，以实现让Java程序在各种平台上都能达到一致的内存访问效果。\n- Java内存模型**类比**于计算机内存模型。\n- 为了更好的执行性能，java内存模型并没有限制执行引擎使用处理器的特定寄存器或缓存来和主内存打交道，也没有限制编译器进行调整代码顺序优化。所以Java内存模型**会存在缓存一致性问题和指令重排序问题的**。\n- Java内存模型规定所有的变量都是存在主内存当中（类似于计算机模型中的物理内存），每个线程都有自己的工作内存（类似于计算机模型的高速缓存）。这里的**变量**包括实例变量和静态变量，但是**不包括局部变量**，因为局部变量是线程私有的。\n- 线程的工作内存保存了被该线程使用的变量的主内存副本，**线程对变量的所有操作都必须在工作内存中进行**，而不能直接操作操作主内存。并且每个线程不能访问其他线程的工作内存。\n\n![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a6ca8c98a8cc42c998dd4fe3324ded79~tplv-k3u1fbpfcp-zoom-1.image)\n\n举个例子吧，假设i的初始值是0，执行以下语句：\n```\ni = i+1;\n```\n首先，执行线程t1从主内存中读取到i=0，到工作内存。然后在工作内存中，赋值i+1,工作内存就得到i=1，最后把结果写回主内存。因此，如果是单线程的话，该语句执行是没问题的。但是呢，线程t2的本地工作内存还没过期，那么它读到的数据就是脏数据了。如图：\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c0abe171336e4f89a58722a1569d64ce~tplv-k3u1fbpfcp-zoom-1.image)\n\nJava内存模型是围绕着如何在并发过程中如何处理**原子性、可见性和有序性**这3个特征来建立的，我们再来一起回顾一下~\n\n### 5.并发编程的3个特性（原子性、可见性、有序性）\n\n#### 原子性\n\n原子性，指操作是不可中断的，要么执行完成，要么不执行，基本数据类型的访问和读写都是具有原子性，当然（long和double的非原子性协定除外）。我们来看几个小例子：\n```\ni =666； // 语句1\ni = j;   // 语句2\ni = i+1;  //语句 3\ni++;   // 语句4\n```\n- 语句1操作显然是原子性的，将数值666赋值给i，即线程执行这个语句时，直接将数值666写入到工作内存中。\n- 语句2操作看起来也是原子性的，但是它实际上涉及两个操作，先去读j的值，再把j的值写入工作内存，两个操作分开都是原子操作，但是合起来就不满足原子性了。\n- 语句3读取i的值，加1，再写回主存，这个就不是原子性操作了。\n- 语句4 等同于语句3，也是非原子性操作。\n\n#### 可见性\n\n- 可见性就是指当一个线程修改了共享变量的值时，其他线程能够立即得知这个修改。\n- Java内存模型是通过在变量修改后将新值同步回主内存，在变量读取前从主内存刷新变量值这种依赖主内存作为传递媒介的方式来实现可见性的，无论是普通变量还是volatile变量都是如此。\n- volatile变量，保证新值能立即同步回主内存，以及每次使用前立即从主内存刷新，所以我们说volatile保证了多线程操作变量的可见性。\n- synchronized和Lock也能够保证可见性，线程在释放锁之前，会把共享变量值都刷回主存。final也可以实现可见性。\n\n \n#### 有序性\n\nJava虚拟机这样描述Java程序的有序性的：如果在本线程内观察，所有的操作都是有序的；如果在一个线程中，观察另一个线程，所有的操作都是无序的。\n\n后半句意思就是，在Java内存模型中，**允许编译器和处理器对指令进行重排序**，会影响到多线程并发执行的正确性；前半句意思就是**as-if-serial**的语义，即不管怎么重排序（编译器和处理器为了提高并行度），（单线程）程序的执行结果不会被改变。\n\n比如以下程序代码：\n```\ndouble pi  = 3.14;    //A\ndouble r   = 1.0;     //B\ndouble area = pi * r * r; //C\n```\n步骤C依赖于步骤A和B，因为指令重排的存在，程序执行顺讯可能是A->B->C,也可能是B->A->C,但是C不能在A或者B前面执行，这将违反as-if-serial语义。\n![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/87387195b86749ddbe1f36582a562988~tplv-k3u1fbpfcp-zoom-1.image)\n\n看段代码吧，假设程序先执行read方法，再执行add方法，结果一定是输出sum=2嘛？\n```\nbool flag = false;\nint b = 0;\n\npublic void read() {\n   b = 1;              //1\n   flag = true;        //2\n}\n\npublic void add() {\n   if (flag) {         //3\n       int sum =b+b;   //4\n       System.out.println(\"bb sum is\"+sum); \n   } \n}\n\n```\n\n如果是单线程，结果应该没问题，如果是多线程，线程t1对步骤1和2进行了**指令重排序**呢？结果sum就不是2了，而是0，如下图所示：\n![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/093c6e37453c462985bed78c4d239979~tplv-k3u1fbpfcp-zoom-1.image)\n\n这是为啥呢？**指令重排序**了解一下，指令重排是指在程序执行过程中,**为了提高性能**, **编译器和CPU可能会对指令进行重新排序**。CPU重排序包括指令并行重排序和内存系统重排序，重排序类型和重排序执行过程如下：\n\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d8a24934eab24bf9b80c402039371aa2~tplv-k3u1fbpfcp-zoom-1.image)\n\n实际上，可以给flag加上volatile关键字，来保证有序性。当然，也可以通过synchronized和Lock来保证有序性。synchronized和Lock保证某一时刻是只有一个线程执行同步代码，相当于是让线程顺序执行程序代码了，自然就保证了有序性。\n\n实际上Java内存模型的有序性并不是仅靠volatile、synchronized和Lock来保证有序性的。这是因为Java语言中，有一个先行发生原则（happens-before）：\n- **程序次序规则**：在一个线程内，按照控制流顺序，书写在前面的操作先行发生于书写在后面的操作。\n- **管程锁定规则**：一个unLock操作先行发生于后面对同一个锁额lock操作\n- **volatile变量规则**：对一个变量的写操作先行发生于后面对这个变量的读操作\n- **线程启动规则**：Thread对象的start()方法先行发生于此线程的每个一个动作\n- **线程终止规则**：线程中所有的操作都先行发生于线程的终止检测，我们可以通过Thread.join()方法结束、Thread.isAlive()的返回值手段检测到线程已经终止执行\n- **线程中断规则**：对线程interrupt()方法的调用先行发生于被中断线程的代码检测到中断事件的发生\n- **对象终结规则**：一个对象的初始化完成先行发生于他的finalize()方法的开始\n- **传递性**：如果操作A先行发生于操作B，而操作B又先行发生于操作C，则可以得出操作A先行发生于操作C\n\n根据happens-before的八大规则，我们回到刚的例子，一起分析一下。给flag加上volatile关键字，look look它是如何保证有序性的，\n```\nvolatile bool flag = false;\nint b = 0;\n\npublic void read() {\n   b = 1;              //1\n   flag = true;        //2\n}\n\npublic void add() {\n   if (flag) {         //3\n       int sum =b+b;   //4\n       System.out.println(\"bb sum is\"+sum); \n   } \n}\n```\n- 首先呢，flag加上volatile关键字，那就禁止了指令重排，也就是1 happens-before 2了\n- 根据**volatile变量规则**，2 happens-before 3\n- 由**程序次序规则**，得出 3 happens-before 4\n- 最后由**传递性**，得出1 happens-before 4，因此妥妥的输出sum=2啦~\n\n### 6.volatile底层原理\n\n以上讨论学习，我们知道volatile的语义就是保证变量对所有线程可见性以及禁止指令重排优化。那么，它的底层是如何保证可见性和禁止指令重排的呢？\n\n#### 图解volatile是如何保证可见性的？\n在这里，先看几个图吧，哈哈~\n\n假设flag变量的初始值false，现在有两条线程t1和t2要访问它，就可以简化为以下图：\n![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7ddbe230c8dc4501a77ffbe0587b5ba6~tplv-k3u1fbpfcp-zoom-1.image)\n\n如果线程t1执行以下代码语句，并且flag没有volatile修饰的话；t1刚修改完flag的值，还没来得及刷新到主内存，t2又跑过来读取了，很容易就数据flag不一致了，如下：\n\n```\nflag=true;\n```\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/cc065cf75803496aa1efafd6d68ba968~tplv-k3u1fbpfcp-zoom-1.image)\n\n如果flag变量是由volatile修饰的话，就不一样了，如果线程t1修改了flag值，volatile能保证修饰的flag变量后，可以**立即同步回主内存**。如图：\n\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/27e9e195810a4a71bdeb38dd128b27e4~tplv-k3u1fbpfcp-zoom-1.image)\n\n细心的朋友会发现，线程t2不还是flag旧的值吗，这不还有问题嘛？其实volatile还有一个保证，就是**每次使用前立即先从主内存刷新最新的值**，线程t1修改完后，线程t2的变量副本会过期了，如图：\n![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7e67dcdfe9d9412dab89961bf92b5b53~tplv-k3u1fbpfcp-zoom-1.image)\n\n显然，这里还不是底层，实际上volatile保证可见性和禁止指令重排都跟**内存屏障**有关，我们编译volatile相关代码看看~\n\n#### DCL单例模式（volatile）&编译对比\nDCL单例模式（Double Check Lock，双重检查锁）比较常用，它是需要volatile修饰的，所以就拿这段代码编译吧\n```\npublic class Singleton {  \n    private volatile static Singleton instance;  \n    private Singleton (){}  \n    public static Singleton getInstance() {  \n    if (instance == null) {  \n        synchronized (Singleton.class) {  \n        if (instance == null) {  \n            instance = new Singleton();  \n        }  \n        }  \n    }  \n    return instance;  \n    }  \n}  \n```\n编译这段代码后，观察有volatile关键字和没有volatile关键字时的instance所生成的汇编代码发现，有volatile关键字修饰时，会多出一个lock addl $0x0,(%esp)，即多出一个lock前缀指令\n```\n0x01a3de0f: mov    $0x3375cdb0,%esi   ;...beb0cd75 33  \n                                        ;   {oop('Singleton')}  \n0x01a3de14: mov    %eax,0x150(%esi)   ;...89865001 0000  \n0x01a3de1a: shr    $0x9,%esi          ;...c1ee09  \n0x01a3de1d: movb   $0x0,0x1104800(%esi)  ;...c6860048 100100  \n0x01a3de24: lock addl $0x0,(%esp)     ;...f0830424 00  \n                                        ;*putstatic instance  \n                                        ; - Singleton::getInstance@24 \n```\n lock指令相当于一个**内存屏障**，它保证以下这几点：\n > - 1.重排序时不能把后面的指令重排序到内存屏障之前的位置\n > - 2.将本处理器的缓存写入内存\n > - 3.如果是写入动作，会导致其他处理器中对应的缓存无效。\n\n显然，第2、3点不就是volatile保证可见性的体现嘛，第1点就是禁止指令重排列的体现。\n\n#### 内存屏障\n\n内存屏障四大分类：（Load 代表读取指令，Store代表写入指令）\n\n| 内存屏障类型 | 抽象场景| 描述|\n|-----|-----|-----|\n|LoadLoad屏障| Load1; LoadLoad; Load2|在Load2要读取的数据被访问前，保证Load1要读取的数据被读取完毕。|\n|StoreStore屏障|Store1; StoreStore; Store2|在Store2写入执行前，保证Store1的写入操作对其它处理器可见|\n|LoadStore屏障|Load1; LoadStore; Store2| 在Store2被写入前，保证Load1要读取的数据被读取完毕。|\n|StoreLoad屏障|Store1; StoreLoad; Load2|在Load2读取操作执行前，保证Store1的写入对所有处理器可见。|\n\n为了实现volatile的内存语义，Java内存模型采取以下的保守策略\n- 在每个volatile写操作的前面插入一个StoreStore屏障。\n- 在每个volatile写操作的后面插入一个StoreLoad屏障。\n- 在每个volatile读操作的前面插入一个LoadLoad屏障。\n- 在每个volatile读操作的后面插入一个LoadStore屏障。\n\n有些小伙伴，可能对这个还是有点疑惑，内存屏障这玩意太抽象了。我们照着代码看下吧：\n\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a3097b7467304540b6a552d897d46997~tplv-k3u1fbpfcp-zoom-1.image)\n内存屏障保证前面的指令先执行，所以这就保证了禁止了指令重排啦，同时内存屏障保证缓存写入内存和其他处理器缓存失效，这也就保证了可见性，哈哈~\n\n### 7.volatile的典型场景\n通常来说，使用volatile必须具备以下2个条件：\n- 1）对变量的写操作不依赖于当前值\n- 2）该变量没有包含在具有其他变量的不变式中\n\n实际上，volatile场景一般就是**状态标志**，以及**DCL单例模式**。\n\n#### 7.1 状态标志\n深入理解Java虚拟机，书中的例子：\n```\nMap configOptions;\nchar[] configText;\n// 此变量必须定义为 volatile\nvolatile boolean initialized = false;\n\n// 假设以下代码在线程 A 中运行\n// 模拟读取配置信息, 当读取完成后将 initialized 设置为 true 以告知其他线程配置可用\nconfigOptions = new HashMap();\nconfigText = readConfigFile(fileName);\nprocessConfigOptions(configText, configOptions);\ninitialized = true;\n      \n// 假设以下代码在线程 B 中运行\n// 等待 initialized 为 true, 代表线程 A 已经把配置信息初始化完成\nwhile(!initialized) {\n   sleep();\n}\n// 使用线程 A 中初始化好的配置信息\ndoSomethingWithConfig();\n```\n#### 7.2 DCL单例模式\n```\nclass Singleton{\n    private volatile static Singleton instance = null;\n     \n    private Singleton() {   \n    }\n     \n    public static Singleton getInstance() {\n        if(instance==null) {\n            synchronized (Singleton.class) {\n                if(instance==null)\n                    instance = new Singleton();\n            }\n        }\n        return instance;\n    }\n}\n\n```\n\n### 8. volatile相关经典面试题\n- 谈谈volatile的特性\n- volatile的内存语义  \n- 说说并发编程的3大特性\n- 什么是内存可见性，什么是指令重排序？\n- volatile是如何解决java并发中可见性的问题\n- volatile如何防止指令重排\n- volatile可以解决原子性嘛？为什么？\n- volatile底层的实现机制\n- volatile和synchronized的区别？\n\n#### 8.1 谈谈volatile的特性\n\n![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8e624231e978455ebec33c7380ffba0d~tplv-k3u1fbpfcp-zoom-1.image)\n\n#### 8.2  volatile的内存语义\n\n- 当写一个 volatile 变量时，JMM 会把该线程对应的本地内存中的共享变量值刷新到主内存。\n- 当读一个 volatile 变量时，JMM 会把该线程对应的本地内存置为无效。线程接下来将从主内存中读取共享变量。\n\n#### 8.3 说说并发编程的3大特性\n- 原子性\n- 可见性\n- 有序性\n\n#### 8.4 什么是内存可见性，什么是指令重排序？\n- 可见性就是指当一个线程修改了共享变量的值时，其他线程能够立即得知这个修改。\n- 指令重排是指JVM在编译Java代码的时候，或者CPU在执行JVM字节码的时候，对现有的指令顺序进行重新排序。\n\n#### 8.5 volatile是如何解决java并发中可见性的问题\n\n底层是通过内存屏障实现的哦，volatile能保证修饰的变量后，可以立即同步回主内存，每次使用前立即先从主内存刷新最新的值。\n\n#### 8.6 volatile如何防止指令重排\n\n也是内存屏障哦，跟面试官讲下Java内存的保守策略：\n- 在每个volatile写操作的前面插入一个StoreStore屏障。\n- 在每个volatile写操作的后面插入一个StoreLoad屏障。\n- 在每个volatile读操作的前面插入一个LoadLoad屏障。\n- 在每个volatile读操作的后面插入一个LoadStore屏障。\n\n再讲下volatile的语义哦，重排序时不能把内存屏障后面的指令重排序到内存屏障之前的位置\n\n#### 8.7 volatile可以解决原子性嘛？为什么？\n\n不可以，可以直接举i++那个例子，原子性需要synchronzied或者lock保证\n\n```\npublic class Test {\n    public volatile int race = 0;\n     \n    public void increase() {\n        race++;\n    }\n     \n    public static void main(String[] args) {\n        final Test test = new Test();\n        for(int i=0;i<10;i++){\n            new Thread(){\n                public void run() {\n                    for(int j=0;j<100;j++)\n                        test.increase();\n                };\n            }.start();\n        }\n        \n        //等待所有累加线程结束\n        while(Thread.activeCount()>1)  \n            Thread.yield();\n        System.out.println(test.race);\n    }\n}\n```\n\n #### 8.8 volatile底层的实现机制\n \n 可以看本文的第六小节，volatile底层原理哈，主要你要跟面试官讲述，volatile如何保证可见性和禁止指令重排，需要讲到内存屏障~\n \n #### 8.9 volatile和synchronized的区别？\n - volatile修饰的是变量，synchronized一般修饰代码块或者方法\n - volatile保证可见性、禁止指令重排，但是不保证原子性；synchronized可以保证原子性\n - volatile不会造成线程阻塞，synchronized可能会造成线程的阻塞，所以后面才有锁优化那么多故事~\n - 哈哈，你还有补充嘛~\n\n推荐之前写的一篇文章：\n[Synchronized解析——如果你愿意一层一层剥开我的心](https://juejin.im/post/6844903918653145102)\n\n\n### 公众号\n![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/07e9fd0521c244adab8556fee99a2011~tplv-k3u1fbpfcp-zoom-1.image)\n\n### 参考与感谢\n- <<深入理解Java虚拟机>>\n- [Java并发编程：volatile关键字解析](https://www.cnblogs.com/dolphin0520/p/3920373.html)\n- [面试官最爱的volatile关键字](https://juejin.im/post/6844903520760496141)\n- [ 面试官没想到一个Volatile，我都能跟他扯半小时](https://juejin.im/post/6844904149536997384)\n- [再有人问你Java内存模型是什么，就把这篇文章发给他。](http://47.103.216.138/archives/2550)\n- [【并发编程】MESI--CPU缓存一致性协议](https://www.cnblogs.com/z00377750/p/9180644.html)\n- [漫画：volatile对指令重排的影响 ](https://www.sohu.com/a/211287207_684445)\n- [volatile三大特性详解](https://www.jianshu.com/p/765e3abbe89a)\n\n", "user_name": "Jay_huaxiao", "description": "都怪这吉他，弹得太凄凉（个人公众号：捡田螺的小男孩）", "got_view_count": 190798, "category_name": "后端", "ctime": 1457483880}
{"tag_name": "React.js", "concern_user_count": 199177, "user_id": "3456520257288974", "title": "编写高质量可维护的代码：优化逻辑判断", "mark_content": "![](https://user-gold-cdn.xitu.io/2020/7/26/1738ae6bd8113663?w=1317&h=260&f=png&s=67242)\n\n> 这是第 <font size=3 color=\"red\">64</font> 篇不掺水的原创，想获取更多原创好文，请扫 👆 上方二维码关注我们吧~\n> 本文首发于政采云前端博客：[编写高质量可维护的代码：逻辑判断](https://www.zoo.team/article/logical-judgment)\n\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c2f595a79a3e43c8af7dd8d02cda28bd~tplv-k3u1fbpfcp-zoom-1.image)\n\n## 前言\n\nif else、switch case 是日常开发中最常见的条件判断语句，这种看似简单的语句，当遇到复杂的业务场景时，如果处理不善，就会出现大量的逻辑嵌套，可读性差并且难以扩展。\n\n\n\n编写高质量可维护的代码，我们先从最小处入手，一起来看看在前端开发过程中，可以从哪些方面来优化逻辑判断？  \n\n\n\n下面我们会分别从 JavaScript 语法和 React JSX 语法两个方面来分享一些优化的技巧。\n\n\n\n## JavaScript 语法篇 ##\n\n### 嵌套层级优化 ###\n\n```javascript\nfunction supply(fruit, quantity) {\n  const redFruits = ['apple', 'strawberry', 'cherry', 'cranberries'];\n  // 条件 1: 水果存在\n  if (fruit) {\n    // 条件 2: 属于红色水果\n    if (redFruits.includes(fruit)) {\n      console.log('红色水果');\n      // 条件 3: 水果数量大于 10 个\n      if (quantity > 10) {\n        console.log('数量大于 10 个');\n      }\n    }\n  } else {\n    throw new Error('没有水果啦!');\n  }\n}\n```\n\n\n\n分析上面的条件判断，存在三层 if 条件嵌套。\n\n\n\n如果提前 return 掉无效条件，将 if else的多重嵌套层次减少到一层，更容易理解和维护。\n\n\n\n```javascript\nfunction supply(fruit, quantity) {\n  const redFruits = ['apple', 'strawberry', 'cherry', 'cranberries'];\n  if (!fruit) throw new Error('没有水果啦'); // 条件 1: 当 fruit 无效时，提前处理错误\n  if (!redFruits.includes(fruit)) return; // 条件 2: 当不是红色水果时，提前 return\n  \n  console.log('红色水果');\n  \n  // 条件 3: 水果数量大于 10 个\n  if (quantity > 10) {\n    console.log('数量大于 10 个');\n  }\n}\n```\n\n\n\n### 多条件分支的优化处理 ###\n\n当需要枚举值处理不同的业务分支逻辑时， 第一反应是写下 if else ？我们来看一下： \n\n```javascript\nfunction pick(color) {\n  // 根据颜色选择水果\n  if(color === 'red') {\n      return ['apple', 'strawberry']; \n  } else if (color === 'yellow') {\n      return ['banana', 'pineapple'];\n  } else if (color === 'purple') {\n      return ['grape', 'plum'];\n  } else {\n      return [];\n  }\n}\n```\n\n\n\n在上面的实现中：\n\n- if else 分支太多\n- if else 更适合于条件区间判断，而 switch case 更适合于具体枚举值的分支判断\n\n使用 switch case 优化上面的代码后：\n\n```javascript\nfunction pick(color) {\n  // 根据颜色选择水果\n  switch (color) {\n    case 'red':\n      return ['apple', 'strawberry'];\n    case 'yellow':\n      return ['banana', 'pineapple'];\n    case 'purple':\n      return ['grape', 'plum'];\n    default:\n      return [];\n  }\n}\n```\n\n\n\nswitch case 优化之后的代码看上去格式整齐，思路很清晰，但还是很冗长。继续优化： \n\n- 借助 Object 的 { key: value } 结构，我们可以在 Object 中枚举所有的情况，然后将 key 作为索引，直接通过 Object.key  或者 Object[key] 来获取内容\n\n```javascript\nconst fruitColor = {\n  red: ['apple', 'strawberry'],\n  yellow: ['banana', 'pineapple'],\n  purple: ['grape', 'plum'],\n};\nfunction pick(color) {\n  return fruitColor[color] || [];\n}\n```\n\n- 使用 Map 数据结构，真正的 (key, value) 键值对结构 ； \n\n```javascript\nconst fruitColor = new Map()\n.set('red', ['apple', 'strawberry'])\n.set('yellow', ['banana', 'pineapple'])\n.set('purple', ['grape', 'plum']);\n\nfunction pick(color) {\n  return fruitColor.get(color) || [];\n}\n```\n\n\n\n优化之后，代码更简洁、更容易扩展。 \n\n\n\n为了更好的可读性，还可以通过更加语义化的方式定义对象，然后使用 Array.filter 达到同样的效果。\n\n\n\n```javascript\nconst fruits = [\n  { name: 'apple', color: 'red' }, \n  { name: 'strawberry', color: 'red' }, \n  { name: 'banana', color: 'yellow' }, \n  { name: 'pineapple', color: 'yellow' }, \n  { name: 'grape', color: 'purple' }, \n  { name: 'plum', color: 'purple' }\n];\n\nfunction pick(color) {\n  return fruits.filter(f => f.color === color);\n}\n```\n\n\n\n### 使用数组新特性简化逻辑判断 ###\n\n巧妙的利用 ES6 中提供的数组新特性，也可以让我们更轻松的处理逻辑判断。\n\n\n\n#### **多条件判断**\n\n编码时遇到多个判断条件时，本能的写下下面的代码（其实也是最能表达业务逻辑的面向过程编码）。 \n\n\n\n```javascript\nfunction judge(fruit) {\n  if (fruit === 'apple' || fruit === 'strawberry' || fruit === 'cherry' || fruit === 'cranberries' ) {\n    console.log('red');\n  }\n}\n```\n\n\n\n但是当 type 未来到 10 种甚至更多时， 我们只能继续添加 || 来维护代码么 ? \n\n试试 **Array.includes** ~\n\n\n\n```javascript\n// 将判断条件抽取成一个数组\nconst redFruits = ['apple', 'strawberry', 'cherry', 'cranberries'];\nfunction judge(fruit) {\n  if (redFruits.includes(fruit)) {\n      console.log('red');\n   }\n}\n\n```\n\n\n\n#### **判断数组中是否所有项都满足某条件**\n\n```javascript\nconst fruits = [\n  { name: 'apple', color: 'red' },\n  { name: 'banana', color: 'yellow' },\n  { name: 'grape', color: 'purple' }\n];\n\nfunction match() {\n  let isAllRed = true;\n\n  // 判断条件：所有的水果都必须是红色\n  for (let f of fruits) {\n    if (!isAllRed) break;\n    isAllRed = (f.color === 'red');\n  }\n\n  console.log(isAllRed); // false\n}\n\n```\n\n\n\n上面的实现中，主要是为了处理数组中的所有项都符合条件。\n\n使用 **Array.every** 可以很容的实现这个逻辑：\n\n\n\n```javascript\nconst fruits = [\n  { name: 'apple', color: 'red' },\n  { name: 'banana', color: 'yellow' },\n  { name: 'grape', color: 'purple' }\n];\n\nfunction match() {\n  // 条件：所有水果都必须是红色\n  const isAllRed = fruits.every(f => f.color === 'red');\n\n  console.log(isAllRed); // false\n}\n\n```\n\n\n\n#### **判断数组中是否有某一项满足条件**\n\n**Array.some** ，它主要处理的场景是判断数组中是否有一项满足条件。\n\n如果想知道是否有红色水果，可以直接使用 **Array.some** 方法：\n\n\n\n```javascript\nconst fruits = [\n  { name: 'apple', color: 'red' },\n  { name: 'banana', color: 'yellow' },\n  { name: 'grape', color: 'purple' }\n];\n\n// 条件：是否有红色水果 \nconst isAnyRed = fruits.some(f => f.color == 'red');\n\n```\n\n还有许多其他数组新特性，比如 Array.find、Array.slice、Array.findIndex、Array.reduce、Array.splice 等，在实际场景中可以根据需要选择使用。\n\n\n\n### **函数默认值**\n\n#### 使用默认参数\n\n```javascript\nconst buyFruit = (fruit,amount) => {\n if(!fruit){\n\treturn\n  }\n  amount = amount || 1;\n  console.log(amount)\n}\n\n```\n\n\n\n我们经常需要处理函数内部的一些参数默认值，上面的代码大家都不陌生，使用函数的默认参数，可以很好的帮助处理这种场景。\n\n\n\n```javascript\nconst buyFruit = (fruit,amount = 1) => {\n if(!fruit){\n\t\treturn\n  }\n  console.log(amount,'amount')\n}\n\n```\n\n\n我们可以通过 Babel 的转译来看一下默认参数是如何实现的。\n\n\n\n![](https://www.zoo.team/images/upload/upload_cf9531ce99d2eb9fe3d47feb21714304.png)\n\n\n\n从上面的转译结果可以发现，只有参数为 undefined 时才会使用默认参数。\n\n测试的执行结果如下：\n\n```js\nbuyFruit('apple','');  // amount\nbuyFruit('apple',null);  //null amount\nbuyFruit('apple');  //1 amount\n\n```\n\n所以使用默认参数的情况下，我们需要注意的是默认参数 `amount=1` 并不等同于 `amount || 1`。\n\n\n\n#### 使用解构与默认参数\n\n当函数参数是对象时，我们可以使用解构结合默认参数来简化逻辑。\n\nBefore:\n\n```javascript\nconst buyFruit = (fruit,amount) => {\n  fruit = fruit || {};\n  if(!fruit.name || !fruit.price){\n      return;\n  }\n  ...\n  amount = amount || 1;\n  console.log(amount)\n}\n\n```\n\nAfter:\n\n```javascript\nconst buyFruit = ({ name,price }={},amount) => {\n  if(!name || !prices){\n  \treturn;\n  }\n  console.log(amount)\n}\n\n```\n\n\n\n#### 复杂数据解构\n\n当处理比较简的对象时，解构与默认参数的配合是非常好的，但在一些复杂的场景中，我们面临的可能是更复杂的结构。\n\n```javascript\nconst oneComplexObj = {\n  firstLevel: {\n    secondLevel: [{\n      name: '',\n      price: '',\n    }],\n  },\n};\n```\n\n\n\n这个时候如果再通过解构去获取对象里的值。\n\n```javascript\nconst {\n  firstLevel: {\n    secondLevel: [{ name, price }] = [],\n  } = {},\n} = oneComplexObj;\n```\n\n\n\n可读性就会比较差，而且需要考虑多层解构的默认值以及数据异常情况。\n\n这种情况下，如果项目中使用 lodash 库，可以使用其中的 lodash/get 方法。\n\n\n\n```javascript\nimport lodashGet from 'lodash/get';\n\nconst { name,price } = lodashGet(oneComplexObj,'firstLevel.secondLevel[0]',{});\n\n```\n\n\n\n### 策略模式优化分支逻辑处理 ###\n\n策略模式：定义一系列的算法，把它们一个个封装起来， 并且使它们可相互替换。\n\n使用场景：策略模式属于对象行为模式，当遇到具有相同行为接口、行为内部不同逻辑实现的实例对象时，可以采用策略模式；或者是一组对象可以根据需要动态的选择几种行为中的某一种时，也可以采用策略模式；这里以第二种情况作为示例：\n\nBefore:\n\n```javascript\nconst TYPE = {\n  JUICE: 'juice',\n  SALAD: 'salad',\n  JAM: 'jam',\n};\nfunction enjoy({ type = TYPE.JUICE, fruits }) {\n  if (!fruits || !fruits.length) {\n    console.log('请先采购水果！');\n    return;\n  }\n  if (type === TYPE.JUICE) {\n    console.log('榨果汁中...');\n    return '果汁';\n  }\n  if (type === TYPE.SALAD) {\n    console.log('做沙拉中...');\n    return '拉沙';\n  }\n  if (type === TYPE.JAM) {\n    console.log('做果酱中...');\n    return '果酱';\n  }\n}\n\nenjoy({ type: 'juice', fruits });\n```\n\n使用思路：定义策略对象封装不同行为、提供策略选择接口，在不同的规则时调用相应的行为。\n\nAfter：\n\n```javascript\nconst TYPE = {\n  JUICE: 'juice',\n  SALAD: 'salad',\n  JAM: 'jam',\n};\n\nconst strategies = {\n  [TYPE.JUICE](fruits) {\n    console.log('榨果汁中...');\n    return '果汁';\n  },\n  [TYPE.SALAD](fruits) {\n    console.log('做沙拉中...');\n    return '沙拉';\n  },\n  [TYPE.JAM](fruits) {\n    console.log('做果酱中...');\n    return '果酱';\n  },\n};\n\nfunction enjoy({ type = TYPE.JUICE, fruits }) {\n  if (!type) {\n    console.log('请直接享用！');\n    return;\n  }\n  if (!fruits || !fruits.length) {\n    console.log('请先采购水果！');\n    return;\n  }\n  return strategies[type](fruits);\n}\n\nenjoy({ type: 'juice', fruits });\n```\n\n\n\n## 框架篇之 React JSX 逻辑判断优化 ##\n\nJSX 是一个看起来很像 XML 的 JavaScript 语法扩展。一般在 React 中使用 JSX 来描述界面信息，ReactDOM.render() 将 JSX 界面信息渲染到页面上。\n\n\n\n在 JSX 中支持 JavaScript 表达式，日常很常见的循环输出子组件、三元表达式判断、再复杂一些直接抽象出一个函数。\n\n\n\n在 JSX 中写这么多  JavaScript 表达式，整体代码看起来会有点儿杂乱。试着优化一下！\n\n\n\n### JSX-Control-Statements \n\n[JSX-Control-Statements](https://www.npmjs.com/package/jsx-control-statements) 是一个 Babel 插件，它扩展了 JSX 的能力，支持以标签的形式处理条件判断、循环。\n\n\n\n#### If 标签 ####\n\n<If> 标签内容只有在 condition 为 true 时才会渲染，等价于最简单的三元表达式。\n\nBefore: \n\n```javascript\n{ condition() ? 'Hello World!' : null }   \n\n```\n\n After:\n\n```javascript\n<If condition={ condition() }>Hello World!</If>   \n\n```\n\n注意：<Else /> 已被废弃，复杂的条件判断可以使用 <Choose> 标签。\n\n\n\n#### Choose 标签 ####\n\n<Choose> 标签下包括至少一个 <When> 标签、可选的 <Otherwise> 标签。\n\n<When> 标签内容只有在 condition 为 true 时才会渲染，相当于一个 if 条件判断分支。\n\n<Otherwise> 标签则相当于最后的 else 分支。\n\nBefore: \n\n```javascript\n{ test1 ? <span>IfBlock1</span> : test2 ? <span>IfBlock2</span> : <span>ElseBlock</span> }\n\n```\n\nAfter:\n\n```javascript\n<Choose>\n  <When condition={ test1 }>\n    <span>IfBlock1</span>\n  </When>\n  <When condition={ test2 }>\n    <span>IfBlock2</span>\n  </When>\n  <Otherwise>\n    <span>ElseBlock</span>\n  </Otherwise>\n</Choose>\n\n```\n\n\n\n#### For 标签 ####\n\n<For> 标签需要声明 of、each 属性。\n\nof 接收的是可以使用迭代器访问的对象。\n\neach 代表迭代器访问时的当前指向元素。\n\nBefore:\n\n```javascript\n{\n  (this.props.items || []).map(item => {\n      return <span key={ item.id }>{ item.title }</span>\n  })\n}\n\n```\n\nAfter:\n\n```javascript\n<For each=\"item\" of={ this.props.items }>\n   <span key={ item.id }>{ item.title }</span>\n</For>\n\n```\n\n注意：<For> 标签不能作为根元素。\n\n\n\n#### With 标签 ####\n\n<With> 标签提供变量传参的功能。\n\nBefore:\n\n```javascript\nrenderFoo = (foo) => {\n    return <span>{ foo }</span>;\n}\n\n// JSX 中表达式调用\n{\n    this.renderFoo(47)\n}\n\n```\n\nAfter:\n\n```javascript\n<With foo={ 47 }>\n  <span>{ foo }</span>\n</With>\n\n```\n\n\n\n使用这几种标签优化代码，可以减少  JSX 中存在的显式 JavaScript 表达式，使我们的代码看上去更简洁，但是这些标签封装的能力，在编译时需要转换为等价的 JavaScript 表达式。\n\n\n\n注意：具体 babel-plugin-jsx-control-statements 插件的使用见第三篇参考文章；Vue 框架已经通过指令的形式支持 v-if、v-else-if、v-else、v-show、slot 等。\n\n\n\n## 总结 \n\n以上我们总结了一些常见的逻辑判断优化技巧。当然，编写高质量可维护的代码，除了逻辑判断优化，还需要有清晰的注释、含义明确的变量命名、合理的代码结构拆分、逻辑分层解耦、以及更高层次的贴合业务的逻辑抽象等等，相信各位在这方面也有自己的一些心得，欢迎一起留言讨论~\n\n\n\n## 参考文献 \n\n\n* [5 Tips to Write Better Conditionals in JavaScript](<https://scotch.io/bar-talk/5-tips-to-write-better-conditionals-in-javascript>)\n* [stop-putting-so-many-if-statements-in-your-javascript](<https://medium.com/better-programming/stop-putting-so-many-if-statements-in-your-javascript-3b65aaa4b86b>)\n* [JSX Control Statements](<https://www.npmjs.com/package/jsx-control-statements>)\n\n## 推荐阅读\n[分分钟教会你搭建企业级的 npm 私有仓库](https://juejin.im/editor/posts/5eef64de518825658c1ad1f6)\n\n[一份值得收藏的 Git 异常处理清单](https://juejin.im/post/6844904182822993927)\n  \n## 招贤纳士\n政采云前端团队（ZooTeam），一个年轻富有激情和创造力的前端团队，隶属于政采云产品研发部，Base 在风景如画的杭州。团队现有 50 余个前端小伙伴，平均年龄 27 岁，近 3 成是全栈工程师，妥妥的青年风暴团。成员构成既有来自于阿里、网易的“老”兵，也有浙大、中科大、杭电等校的应届新人。团队在日常的业务对接之外，还在物料体系、工程平台、搭建平台、性能体验、云端应用、数据分析及可视化等方向进行技术探索和实战，推动并落地了一系列的内部技术产品，持续探索前端技术体系的新边界。\n\n如果你想改变一直被事折腾，希望开始能折腾事；如果你想改变一直被告诫需要多些想法，却无从破局；如果你想改变你有能力去做成那个结果，却不需要你；如果你想改变你想做成的事需要一个团队去支撑，但没你带人的位置；如果你想改变既定的节奏，将会是“ 5 年工作时间 3 年工作经验”；如果你想改变本来悟性不错，但总是有那一层窗户纸的模糊… 如果你相信相信的力量，相信平凡人能成就非凡事，相信能遇到更好的自己。如果你希望参与到随着业务腾飞的过程，亲手推动一个有着深入的业务理解、完善的技术体系、技术创造价值、影响力外溢的前端团队的成长历程，我觉得我们该聊聊。任何时间，等着你写点什么，发给 `ZooTeam@cai-inc.com`\n\n![](https://user-gold-cdn.xitu.io/2020/7/26/1738ae797b21cb74?w=1652&h=714&f=png&s=239198)", "user_name": "政采云前端团队", "description": "政采云前端 ZooTeam 团队，不掺水的原创。 团队站点：https://zoo.team", "got_view_count": 632079, "category_name": "前端", "ctime": 1457483942}
